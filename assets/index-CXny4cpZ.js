var Tw=Object.defineProperty;var Ew=(e,t,n)=>t in e?Tw(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var Zs=(e,t,n)=>Ew(e,typeof t!="symbol"?t+"":t,n);function $w(e,t){for(var n=0;n<t.length;n++){const s=t[n];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in e)){const a=Object.getOwnPropertyDescriptor(s,r);a&&Object.defineProperty(e,r,a.get?a:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const a of r)if(a.type==="childList")for(const o of a.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function n(r){const a={};return r.integrity&&(a.integrity=r.integrity),r.referrerPolicy&&(a.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?a.credentials="include":r.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function s(r){if(r.ep)return;r.ep=!0;const a=n(r);fetch(r.href,a)}})();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cw=1e-7,Ow=1e-4;class Dw{constructor(t,n){this.backend=t,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,n){this.dataIdsCount++,this.data.set(t,n)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class Kp{refCount(t){return _n("refCount")}incRef(t){return _n("incRef")}timerAvailable(){return!0}time(t){return _n("time")}read(t){return _n("read")}readSync(t){return _n("readSync")}readToGPU(t,n){return _n("readToGPU")}numDataIds(){return _n("numDataIds")}disposeData(t,n){return _n("disposeData")}write(t,n,s){return _n("write")}move(t,n,s,r,a){return _n("move")}createTensorFromGPUData(t,n,s){return _n("createTensorFromGPUData")}memory(){return _n("memory")}floatPrecision(){return _n("floatPrecision")}epsilon(){return this.floatPrecision()===32?Cw:Ow}dispose(){return _n("dispose")}}function _n(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ll(e,t,n){return Math.max(e,Math.min(t,n))}function Ya(e,t,n){const s=e[t];e[t]=e[n],e[n]=s}function D(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function Vn(e,t,n=""){D(Un(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function Ra(e){D(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function It(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function Aw(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==null&&t[n]!==null&&e[n]!==t[n])return!1;return!0}function Un(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function wo(e){return e%1===0}function xi(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Fw(e,t){let n=1,s=-1;for(let a=0;a<e.length;++a)if(e[a]>=0)n*=e[a];else if(e[a]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${a}`);s=a}else if(e[a]<0)throw Error(`Shapes can not be < 0. Found ${e[a]} at dim ${a}`);if(s===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const r=e.slice();return r[s]=t/n,r}function Ue(e,t){const n=t.length;return e=e==null?t.map((s,r)=>r):[].concat(e),D(e.every(s=>s>=-n&&s<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),D(e.every(s=>wo(s)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(s=>s<0?n+s:s)}function Rw(e,t){const n=[],s=[],r=t!=null&&Array.isArray(t)&&t.length===0,a=t==null||r?null:Ue(t,e).sort();let o=0;for(let i=0;i<e.length;++i){if(a!=null){if(a[o]===i&&e[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${e[i]}' is not 1`);(a[o]==null||a[o]>i)&&e[i]===1&&(n.push(e[i]),s.push(i)),a[o]<=i&&o++}e[i]!==1&&(n.push(e[i]),s.push(i))}return{newShape:n,keptDims:s}}function mn(e,t){return ze(e,t)}function ze(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function Pw(e,t){for(let n=0;n<e.length;n++){const s=e[n];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}function Mw(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function Vw(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function Wc(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function Lw(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function du(e){return typeof e=="string"||e instanceof String}function zw(e){return typeof e=="boolean"}function Bw(e){return typeof e=="number"}function Po(e){return Array.isArray(e)?Po(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":Bw(e)?"float32":du(e)?"string":zw(e)?"bool":"float32"}function jc(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Kt(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let s=t-3;s>=0;--s)n[s]=n[s+1]*e[s+1];return n}function Up(e,t,n,s=!1){const r=new Array;if(t.length===1){const a=t[0]*(s?2:1);for(let o=0;o<a;o++)r[o]=n[e+o]}else{const a=t[0],o=t.slice(1),i=o.reduce((u,c)=>u*c)*(s?2:1);for(let u=0;u<a;u++)r[u]=Up(e+u*i,o,n,s)}return r}function qn(e,t,n=!1){if(e.length===0)return t[0];const s=e.reduce((r,a)=>r*a)*(n?2:1);if(s===0)return[];if(s!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return Up(0,e,t,n)}function Ww(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function zl(e,t){const n=tn(e,t);for(let s=0;s<n.length;s++)n[s]=1;return n}function tn(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function Gp(e,t){const n=e.reduce((s,r)=>s*r,1);if(t==null||t==="float32")return qn(e,new Float32Array(n));if(t==="int32")return qn(e,new Int32Array(n));if(t==="bool")return qn(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Ln(e){e.forEach(t=>{D(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function ls(e,t,n){if(t===0)return 0;if(t===1)return e[0];let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=n[r]*e[r];return s}function Pa(e,t,n){if(t===0)return[];if(t===1)return[e];const s=new Array(t);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(e/n[r]),e-=s[r]*n[r];return s[s.length-1]=e,s}function Lr(e){return e&&e.then&&typeof e.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bd="tfjsflags";class jw{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=qw,this.populateURLFlags()}setPlatform(t,n){this.platform!=null&&(oe().getBool("IS_TEST")||oe().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=n}registerFlag(t,n,s){if(this.flagRegistry[t]={evaluationFn:n,setHook:s},this.urlFlags[t]!=null){const r=this.urlFlags[t];oe().getBool("IS_TEST")||oe().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${r}.`),this.set(t,r)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const n=this.evaluateFlag(t);if(Lr(n))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=n,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,n){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=n,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(n)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);bd in t&&t[bd].split(",").forEach(s=>{const[r,a]=s.split(":");this.urlFlags[r]=Kw(r,a)})}}function qw(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...s)=>(Hw(t,s[0],s[1]),s.join("="))),t}function Hw(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function Kw(e,t){const n=t.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:t}function oe(){return Xp}let Xp=null;function Uw(e){Xp=e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let xc;function Yp(){if(xc==null){let e;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");xc=e}return xc}function Gw(){const e=Yp();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function Bl(e,t){const n=Gw();if(n.has(e))return n.get(e);{const s=t();return n.set(e,s),n.get(e)}}const Jp="Abs",Wl="Acos",jl="Acosh",pu="Add",Zp="AddN",Qp="All",tm="Any",em="ArgMax",nm="ArgMin",ql="Asin",Hl="Asinh",Kl="Atan",Ul="Atanh",Gl="Atan2",sm="AvgPool",Xw="AvgPoolGrad",rm="AvgPool3D",Yw="AvgPool3DGrad",am="BatchMatMul",om="BatchToSpaceND",im="Bincount",Xl="BitwiseAnd",um="BroadcastArgs",Yl="Cast",Jl="Ceil",Zl="ClipByValue",cm="Complex",lm="ComplexAbs",fm="Concat",hm="Conv2D",dm="Conv2DBackpropFilter",pm="Conv2DBackpropInput",mm="Conv3D",Jw="Conv3DBackpropFilterV2",gm="Conv3DBackpropInputV2",Ql="Cos",tf="Cosh",ym="Cumprod",bm="Cumsum",wm="CropAndResize",vm="DenseBincount",km="DepthToSpace",xm="DepthwiseConv2dNative",Sm="DepthwiseConv2dNativeBackpropFilter",Im="DepthwiseConv2dNativeBackpropInput",Nm="Diag",_m="Dilation2D",wd="Dilation2DBackpropInput",vd="Dilation2DBackpropFilter",Zw="Draw",ef="RealDiv",Tm="Einsum",nf="Elu",Qw="EluGrad",sf="Erf",rf="Equal",af="Exp",Em="ExpandDims",of="Expm1",$m="FFT",Cm="Fill",Om="FlipLeftRight",uf="Floor",cf="FloorDiv",Dm="FusedBatchNorm",Am="GatherV2",Fm="GatherNd",lf="Greater",ff="GreaterEqual",hf="Identity",Rm="IFFT",Pm="Imag",df="IsFinite",pf="IsInf",mf="IsNan",Mm="LeakyRelu",gf="Less",yf="LessEqual",Vm="LinSpace",bf="Log",wf="Log1p",vf="LogicalAnd",kf="LogicalNot",xf="LogicalOr",Lm="LRN",tv="LRNGrad",zm="Max",Sf="Maximum",Bm="MaxPool",ev="MaxPoolGrad",Wm="MaxPool3D",nv="MaxPool3DGrad",jm="MaxPoolWithArgmax",qm="Mean",Hm="Min",If="Minimum",Km="MirrorPad",Nf="Mod",Um="Multinomial",_f="Multiply",Gm="Neg",Tf="NotEqual",Xm="NonMaxSuppressionV3",Ym="NonMaxSuppressionV4",Jm="NonMaxSuppressionV5",Zm="OnesLike",Qm="OneHot",tg="Pack",eg="PadV2",Ef="Pow",ng="Prelu",sg="Prod",rg="RaggedGather",ag="RaggedRange",og="RaggedTensorToTensor",ig="Range",ug="Real",$f="Reciprocal",Cf="Relu",cg="Reshape",lg="ResizeNearestNeighbor",sv="ResizeNearestNeighborGrad",fg="ResizeBilinear",rv="ResizeBilinearGrad",Of="Relu6",hg="Reverse",Df="Round",Af="Rsqrt",dg="ScatterNd",pg="TensorScatterUpdate",mg="SearchSorted",gg="Select",Ff="Selu",yg="Slice",Rf="Sin",Pf="Sinh",Mf="Sign",Vf="Sigmoid",Lf="Softplus",zf="Sqrt",bg="Sum",wg="SpaceToBatchND",vg="SplitV",kg="Softmax",xg="SparseFillEmptyRows",Sg="SparseReshape",Ig="SparseSegmentMean",Ng="SparseSegmentSum",_g="SparseToDense",Bf="SquaredDifference",av="Square",Wf="StaticRegexReplace",Tg="StridedSlice",Eg="StringNGrams",$g="StringSplit",Cg="StringToHashBucketFast",jf="Sub",qf="Tan",Hf="Tanh",Kf="Tile",Og="TopK",Dg="Transform",Si="Transpose",Ag="Unique",Fg="Unpack",Rg="UnsortedSegmentSum",Pg="ZerosLike",Uf="Step",kd="FromPixels",Mg="RotateWithOffset",qc="_FusedMatMul",Hc="FusedConv2D",Kc="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cr(...e){oe().getBool("IS_TEST")||oe().getBool("PROD")||console.warn(...e)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Li=Bl("kernelRegistry",()=>new Map),ov=Bl("gradRegistry",()=>new Map);function Uc(e,t){const n=Vg(e,t);return Li.get(n)}function xd(e){return ov.get(e)}function Sd(e){const t=Li.entries(),n=[];for(;;){const{done:s,value:r}=t.next();if(s)break;const[a,o]=r,[i]=a.split("_");i===e&&n.push(o)}return n}function iv(e){const{kernelName:t,backendName:n}=e,s=Vg(t,n);Li.has(s)&&Cr(`The kernel '${t}' for backend '${n}' is already registered`),Li.set(s,e)}function Vg(e,t){return`${t}_${e}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lg(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function uv(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function cv(e){if(Object.prototype.hasOwnProperty.call(e,"__esModule"))return e;var t=e.default;if(typeof t=="function"){var n=function s(){return this instanceof s?Reflect.construct(t,arguments,this.constructor):t.apply(this,arguments)};n.prototype=t.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(e).forEach(function(s){var r=Object.getOwnPropertyDescriptor(e,s);Object.defineProperty(n,s,r.get?r:{enumerable:!0,get:function(){return e[s]}})}),n}var Sc,Id;function lv(){if(Id)return Sc;Id=1,Sc=t;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function t(M,T,q){this.low=M|0,this.high=T|0,this.unsigned=!!q}t.prototype.__isLong__,Object.defineProperty(t.prototype,"__isLong__",{value:!0});function n(M){return(M&&M.__isLong__)===!0}t.isLong=n;var s={},r={};function a(M,T){var q,X,st;return T?(M>>>=0,(st=0<=M&&M<256)&&(X=r[M],X)?X:(q=i(M,(M|0)<0?-1:0,!0),st&&(r[M]=q),q)):(M|=0,(st=-128<=M&&M<128)&&(X=s[M],X)?X:(q=i(M,M<0?-1:0,!1),st&&(s[M]=q),q))}t.fromInt=a;function o(M,T){if(isNaN(M))return T?N:k;if(T){if(M<0)return N;if(M>=g)return R}else{if(M<=-b)return W;if(M+1>=b)return O}return M<0?o(-M,T).neg():i(M%m|0,M/m|0,T)}t.fromNumber=o;function i(M,T,q){return new t(M,T,q)}t.fromBits=i;var u=Math.pow;function c(M,T,q){if(M.length===0)throw Error("empty string");if(M==="NaN"||M==="Infinity"||M==="+Infinity"||M==="-Infinity")return k;if(typeof T=="number"?(q=T,T=!1):T=!!T,q=q||10,q<2||36<q)throw RangeError("radix");var X;if((X=M.indexOf("-"))>0)throw Error("interior hyphen");if(X===0)return c(M.substring(1),T,q).neg();for(var st=o(u(q,8)),et=k,nt=0;nt<M.length;nt+=8){var ot=Math.min(8,M.length-nt),tt=parseInt(M.substring(nt,nt+ot),q);if(ot<8){var ct=o(u(q,ot));et=et.mul(ct).add(o(tt))}else et=et.mul(st),et=et.add(o(tt))}return et.unsigned=T,et}t.fromString=c;function l(M,T){return typeof M=="number"?o(M,T):typeof M=="string"?c(M,T):i(M.low,M.high,typeof T=="boolean"?T:M.unsigned)}t.fromValue=l;var f=65536,d=1<<24,m=f*f,g=m*m,b=g/2,w=a(d),k=a(0);t.ZERO=k;var N=a(0,!0);t.UZERO=N;var _=a(1);t.ONE=_;var I=a(1,!0);t.UONE=I;var $=a(-1);t.NEG_ONE=$;var O=i(-1,2147483647,!1);t.MAX_VALUE=O;var R=i(-1,-1,!0);t.MAX_UNSIGNED_VALUE=R;var W=i(0,-2147483648,!1);t.MIN_VALUE=W;var P=t.prototype;return P.toInt=function(){return this.unsigned?this.low>>>0:this.low},P.toNumber=function(){return this.unsigned?(this.high>>>0)*m+(this.low>>>0):this.high*m+(this.low>>>0)},P.toString=function(T){if(T=T||10,T<2||36<T)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(W)){var q=o(T),X=this.div(q),st=X.mul(q).sub(this);return X.toString(T)+st.toInt().toString(T)}else return"-"+this.neg().toString(T);for(var et=o(u(T,6),this.unsigned),nt=this,ot="";;){var tt=nt.div(et),ct=nt.sub(tt.mul(et)).toInt()>>>0,ht=ct.toString(T);if(nt=tt,nt.isZero())return ht+ot;for(;ht.length<6;)ht="0"+ht;ot=""+ht+ot}},P.getHighBits=function(){return this.high},P.getHighBitsUnsigned=function(){return this.high>>>0},P.getLowBits=function(){return this.low},P.getLowBitsUnsigned=function(){return this.low>>>0},P.getNumBitsAbs=function(){if(this.isNegative())return this.eq(W)?64:this.neg().getNumBitsAbs();for(var T=this.high!=0?this.high:this.low,q=31;q>0&&(T&1<<q)==0;q--);return this.high!=0?q+33:q+1},P.isZero=function(){return this.high===0&&this.low===0},P.eqz=P.isZero,P.isNegative=function(){return!this.unsigned&&this.high<0},P.isPositive=function(){return this.unsigned||this.high>=0},P.isOdd=function(){return(this.low&1)===1},P.isEven=function(){return(this.low&1)===0},P.equals=function(T){return n(T)||(T=l(T)),this.unsigned!==T.unsigned&&this.high>>>31===1&&T.high>>>31===1?!1:this.high===T.high&&this.low===T.low},P.eq=P.equals,P.notEquals=function(T){return!this.eq(T)},P.neq=P.notEquals,P.ne=P.notEquals,P.lessThan=function(T){return this.comp(T)<0},P.lt=P.lessThan,P.lessThanOrEqual=function(T){return this.comp(T)<=0},P.lte=P.lessThanOrEqual,P.le=P.lessThanOrEqual,P.greaterThan=function(T){return this.comp(T)>0},P.gt=P.greaterThan,P.greaterThanOrEqual=function(T){return this.comp(T)>=0},P.gte=P.greaterThanOrEqual,P.ge=P.greaterThanOrEqual,P.compare=function(T){if(n(T)||(T=l(T)),this.eq(T))return 0;var q=this.isNegative(),X=T.isNegative();return q&&!X?-1:!q&&X?1:this.unsigned?T.high>>>0>this.high>>>0||T.high===this.high&&T.low>>>0>this.low>>>0?-1:1:this.sub(T).isNegative()?-1:1},P.comp=P.compare,P.negate=function(){return!this.unsigned&&this.eq(W)?W:this.not().add(_)},P.neg=P.negate,P.add=function(T){n(T)||(T=l(T));var q=this.high>>>16,X=this.high&65535,st=this.low>>>16,et=this.low&65535,nt=T.high>>>16,ot=T.high&65535,tt=T.low>>>16,ct=T.low&65535,ht=0,gt=0,wt=0,bt=0;return bt+=et+ct,wt+=bt>>>16,bt&=65535,wt+=st+tt,gt+=wt>>>16,wt&=65535,gt+=X+ot,ht+=gt>>>16,gt&=65535,ht+=q+nt,ht&=65535,i(wt<<16|bt,ht<<16|gt,this.unsigned)},P.subtract=function(T){return n(T)||(T=l(T)),this.add(T.neg())},P.sub=P.subtract,P.multiply=function(T){if(this.isZero())return k;if(n(T)||(T=l(T)),e){var q=e.mul(this.low,this.high,T.low,T.high);return i(q,e.get_high(),this.unsigned)}if(T.isZero())return k;if(this.eq(W))return T.isOdd()?W:k;if(T.eq(W))return this.isOdd()?W:k;if(this.isNegative())return T.isNegative()?this.neg().mul(T.neg()):this.neg().mul(T).neg();if(T.isNegative())return this.mul(T.neg()).neg();if(this.lt(w)&&T.lt(w))return o(this.toNumber()*T.toNumber(),this.unsigned);var X=this.high>>>16,st=this.high&65535,et=this.low>>>16,nt=this.low&65535,ot=T.high>>>16,tt=T.high&65535,ct=T.low>>>16,ht=T.low&65535,gt=0,wt=0,bt=0,Ct=0;return Ct+=nt*ht,bt+=Ct>>>16,Ct&=65535,bt+=et*ht,wt+=bt>>>16,bt&=65535,bt+=nt*ct,wt+=bt>>>16,bt&=65535,wt+=st*ht,gt+=wt>>>16,wt&=65535,wt+=et*ct,gt+=wt>>>16,wt&=65535,wt+=nt*tt,gt+=wt>>>16,wt&=65535,gt+=X*ht+st*ct+et*tt+nt*ot,gt&=65535,i(bt<<16|Ct,gt<<16|wt,this.unsigned)},P.mul=P.multiply,P.divide=function(T){if(n(T)||(T=l(T)),T.isZero())throw Error("division by zero");if(e){if(!this.unsigned&&this.high===-2147483648&&T.low===-1&&T.high===-1)return this;var q=(this.unsigned?e.div_u:e.div_s)(this.low,this.high,T.low,T.high);return i(q,e.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?N:k;var X,st,et;if(this.unsigned){if(T.unsigned||(T=T.toUnsigned()),T.gt(this))return N;if(T.gt(this.shru(1)))return I;et=N}else{if(this.eq(W)){if(T.eq(_)||T.eq($))return W;if(T.eq(W))return _;var nt=this.shr(1);return X=nt.div(T).shl(1),X.eq(k)?T.isNegative()?_:$:(st=this.sub(T.mul(X)),et=X.add(st.div(T)),et)}else if(T.eq(W))return this.unsigned?N:k;if(this.isNegative())return T.isNegative()?this.neg().div(T.neg()):this.neg().div(T).neg();if(T.isNegative())return this.div(T.neg()).neg();et=k}for(st=this;st.gte(T);){X=Math.max(1,Math.floor(st.toNumber()/T.toNumber()));for(var ot=Math.ceil(Math.log(X)/Math.LN2),tt=ot<=48?1:u(2,ot-48),ct=o(X),ht=ct.mul(T);ht.isNegative()||ht.gt(st);)X-=tt,ct=o(X,this.unsigned),ht=ct.mul(T);ct.isZero()&&(ct=_),et=et.add(ct),st=st.sub(ht)}return et},P.div=P.divide,P.modulo=function(T){if(n(T)||(T=l(T)),e){var q=(this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,T.low,T.high);return i(q,e.get_high(),this.unsigned)}return this.sub(this.div(T).mul(T))},P.mod=P.modulo,P.rem=P.modulo,P.not=function(){return i(~this.low,~this.high,this.unsigned)},P.and=function(T){return n(T)||(T=l(T)),i(this.low&T.low,this.high&T.high,this.unsigned)},P.or=function(T){return n(T)||(T=l(T)),i(this.low|T.low,this.high|T.high,this.unsigned)},P.xor=function(T){return n(T)||(T=l(T)),i(this.low^T.low,this.high^T.high,this.unsigned)},P.shiftLeft=function(T){return n(T)&&(T=T.toInt()),(T&=63)===0?this:T<32?i(this.low<<T,this.high<<T|this.low>>>32-T,this.unsigned):i(0,this.low<<T-32,this.unsigned)},P.shl=P.shiftLeft,P.shiftRight=function(T){return n(T)&&(T=T.toInt()),(T&=63)===0?this:T<32?i(this.low>>>T|this.high<<32-T,this.high>>T,this.unsigned):i(this.high>>T-32,this.high>=0?0:-1,this.unsigned)},P.shr=P.shiftRight,P.shiftRightUnsigned=function(T){if(n(T)&&(T=T.toInt()),T&=63,T===0)return this;var q=this.high;if(T<32){var X=this.low;return i(X>>>T|q<<32-T,q>>>T,this.unsigned)}else return T===32?i(q,0,this.unsigned):i(q>>>T-32,0,this.unsigned)},P.shru=P.shiftRightUnsigned,P.shr_u=P.shiftRightUnsigned,P.toSigned=function(){return this.unsigned?i(this.low,this.high,!1):this},P.toUnsigned=function(){return this.unsigned?this:i(this.low,this.high,!0)},P.toBytes=function(T){return T?this.toBytesLE():this.toBytesBE()},P.toBytesLE=function(){var T=this.high,q=this.low;return[q&255,q>>>8&255,q>>>16&255,q>>>24,T&255,T>>>8&255,T>>>16&255,T>>>24]},P.toBytesBE=function(){var T=this.high,q=this.low;return[T>>>24,T>>>16&255,T>>>8&255,T&255,q>>>24,q>>>16&255,q>>>8&255,q&255]},t.fromBytes=function(T,q,X){return X?t.fromBytesLE(T,q):t.fromBytesBE(T,q)},t.fromBytesLE=function(T,q){return new t(T[0]|T[1]<<8|T[2]<<16|T[3]<<24,T[4]|T[5]<<8|T[6]<<16|T[7]<<24,q)},t.fromBytesBE=function(T,q){return new t(T[4]<<24|T[5]<<16|T[6]<<8|T[7],T[0]<<24|T[1]<<16|T[2]<<8|T[3],q)},Sc}var zg=lv();const Bg=uv(zg),fv=$w({__proto__:null,default:Bg},[zg]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Or=Bg||fv;function mu(e){return Or.fromString(e,!0,16)}const Wg=mu("c3a5c85c97cb3127"),Er=mu("b492b66fbe98f273"),un=mu("9ae16a3b2f90404f");function Gc(e){return e.xor(e.shru(47))}function jg(e,t,n){const s=e.slice(t,t+n);return Or.fromBytes(Array.from(s),!0,!0)}function we(e,t){return jg(e,t,8)}function Nd(e,t){return jg(e,t,4)}function Ke(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function rr(e,t,n=mu("9ddfea08eb382d69")){let s=e.xor(t).mul(n);s=s.xor(s.shru(47));let r=t.xor(s).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function hv(e,t,n,s,r,a){r=r.add(e),a=Ke(a.add(r).add(s),21);const o=r;return r=r.add(t),r=r.add(n),a=a.add(Ke(r,44)),[r.add(s),a.add(o)]}function mi(e,t,n,s){return hv(we(e,t),we(e,t+8),we(e,t+16),we(e,t+24),n,s)}function dv(e,t=e.length){if(t>=8){const n=un.add(t*2),s=we(e,0).add(un),r=we(e,t-8),a=Ke(r,37).mul(n).add(s),o=Ke(s,25).add(r).mul(n);return rr(a,o,n)}if(t>=4){const n=un.add(t*2),s=Nd(e,0);return rr(s.shl(3).add(t),Nd(e,t-4),n)}if(t>0){const n=e[0],s=e[t>>1],r=e[t-1],a=n+(s<<8),o=t+(r<<2);return Gc(un.mul(a).xor(Wg.mul(o))).mul(un)}return un}function pv(e,t=e.length){const n=un.add(t*2),s=we(e,0).mul(Er),r=we(e,8),a=we(e,t-8).mul(n),o=we(e,t-16).mul(un);return rr(Ke(s.add(r),43).add(Ke(a,30)).add(o),s.add(Ke(r.add(un),18)).add(a),n)}function mv(e,t=e.length){const n=un.add(t*2),s=we(e,0).mul(un),r=we(e,8),a=we(e,t-8).mul(n),o=we(e,t-16).mul(un),i=Ke(s.add(r),43).add(Ke(a,30)).add(o),u=rr(i,s.add(Ke(r.add(un),18)).add(a),n),c=we(e,16).mul(n),l=we(e,24),f=i.add(we(e,t-32)).mul(n),d=u.add(we(e,t-24)).mul(n);return rr(Ke(c.add(l),43).add(Ke(f,30)).add(d),c.add(Ke(l.add(s),18)).add(f),n)}function gv(e,t=e.length){const n=Or.fromNumber(81,!0);if(t<=32)return t<=16?dv(e,t):pv(e,t);if(t<=64)return mv(e,t);let s=n,r=n.mul(Er).add(113),a=Gc(r.mul(un).add(113)).mul(un),o=[Or.UZERO,Or.UZERO],i=[Or.UZERO,Or.UZERO];s=s.mul(un).add(we(e,0));let u=0;const c=(t-1>>6)*64,l=c+(t-1&63)-63;do s=Ke(s.add(r).add(o[0]).add(we(e,u+8)),37).mul(Er),r=Ke(r.add(o[1]).add(we(e,u+48)),42).mul(Er),s=s.xor(i[1]),r=r.add(o[0]).add(we(e,u+40)),a=Ke(a.add(i[0]),33).mul(Er),o=mi(e,u,o[1].mul(Er),s.add(i[0])),i=mi(e,u+32,a.add(i[1]),r.add(we(e,u+16))),[a,s]=[s,a],u+=64;while(u!==c);const f=Er.add(a.and(255).shl(1));return u=l,i[0]=i[0].add(t-1&63),o[0]=o[0].add(i[0]),i[0]=i[0].add(o[0]),s=Ke(s.add(r).add(o[0]).add(we(e,u+8)),37).mul(f),r=Ke(r.add(o[1]).add(we(e,u+48)),42).mul(f),s=s.xor(i[1].mul(9)),r=r.add(o[0].mul(9).add(we(e,u+40))),a=Ke(a.add(i[0]),33).mul(f),o=mi(e,u,o[1].mul(f),s.add(i[0])),i=mi(e,u+32,a.add(i[1]),r.add(we(e,u+16))),[a,s]=[s,a],rr(rr(o[0],i[0],f).add(Gc(r).mul(Wg)).add(a),rr(o[1],i[1],f).add(s),f)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gf(e,t){return t==="string"?Pr(e):Xr([e],t)}function yv(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function Xr(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=ko(e)),oe().getBool("DEBUG")&&Pw(e,t),yv(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){const n=new Uint8Array(e.length);for(let s=0;s<n.length;++s)Math.round(e[s])!==0&&(n[s]=1);return n}else throw new Error(`Unknown data type ${t}`)}function Sa(){return oe().platform.now()}function Pr(e,t="utf-8"){return t=t||"utf-8",oe().platform.encode(e,t)}function vo(e,t="utf-8"){return t=t||"utf-8",oe().platform.decode(e,t)}function Gn(e){return oe().platform.isTypedArray!=null?oe().platform.isTypedArray(e):Lg(e)}function ko(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||Lr(e)||e==null||Gn(e)&&n)t.push(e);else if(Array.isArray(e)||Gn(e))for(let s=0;s<e.length;++s)ko(e[s],t,n);else{let s=-1;for(const r of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)ko(e[r],t,n)}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bv{constructor(t,n){this.backendTimer=t,this.logger=n,n==null&&(this.logger=new vv)}profileKernel(t,n,s){let r;const a=()=>{r=s()};let o;const i=Sa();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(a);else{a();for(const c of r)c.dataSync();o=Promise.resolve({kernelMs:Sa()-i})}if(oe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<r.length;c++){const l=r[c];l.data().then(f=>{wv(f,l.dtype,t)})}return{kernelName:t,outputs:r,inputs:n,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:n,outputs:s,timeMs:r,inputs:a,extraInfo:o}=t;s.forEach(i=>{Promise.all([i.data(),r,o]).then(u=>{this.logger.logKernelProfile(n,i,u[0],u[1],a,u[2])})})}}function wv(e,t,n){if(t!=="float32")return!1;for(let s=0;s<e.length;s++){const r=e[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class vv{logKernelProfile(t,n,s,r,a,o){const i=typeof r=="number"?xi(`${r}ms`,9):r.error,u=xi(t,25),c=n.rank,l=n.size,f=xi(n.shape.toString(),14);let d="";for(const m in a){const g=a[m];if(g!=null){const b=g.shape||n.shape,w=b.length;d+=`${m}: ${w}D ${w>0?b:""} `}}console.log(`%c${u}	%c${i}	%c${c}D ${f}	%c${l}	%c${d}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kv(e,t,n){const s={},r={};for(let u=0;u<t.length;u++)s[t[u].id]=!0;for(let u=0;u<e.length;u++){const c=e[u],l=c.inputs;for(const f in l){const d=l[f];let m=!1;for(let g=0;g<t.length;g++)if(s[d.id]){c.outputs.forEach(b=>s[b.id]=!0),m=!0,r[c.id]=!0;break}if(m)break}}const a={};a[n.id]=!0;const o={};for(let u=e.length-1;u>=0;u--){const c=e[u],l=c.inputs;for(let f=0;f<c.outputs.length;f++)if(a[c.outputs[f].id]){for(const d in l)a[l[d].id]=!0,o[c.id]=!0;break}}const i=[];for(let u=0;u<e.length;u++){const c=e[u];if(r[c.id]&&o[c.id]){const l={};for(const d in c.inputs){const m=c.inputs[d];s[m.id]&&(l[d]=m)}const f=Object.assign({},c);f.inputs=l,f.outputs=c.outputs,i.push(f)}}return i}function xv(e,t,n,s){for(let r=t.length-1;r>=0;r--){const a=t[r],o=[];if(a.outputs.forEach(u=>{const c=e[u.id];c!=null?o.push(c):o.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const i=a.gradient(o);for(const u in a.inputs){if(!(u in i))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(i)}.`);const c=n(()=>i[u]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${c.dtype}'`);const l=a.inputs[u];if(!Un(c.shape,l.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${u}' has shape '${c.shape}', which does not match the shape of the input '${l.shape}'`);if(e[l.id]==null)e[l.id]=c;else{const f=e[l.id];e[l.id]=s(f,c),f.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _d=20,Ja=3,Ic=7;function Sv(e,t,n,s){const r=Kt(t),a=Iv(e,t,n,r),o=t.length,i=Ii(e,t,n,r,a),u=["Tensor"];return s&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${o}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(i.map(c=>"    "+c).join(`
`)),u.join(`
`)}function Iv(e,t,n,s){const r=It(t),a=s[s.length-1],o=new Array(a).fill(0),i=t.length,u=n==="complex64"?so(e):e;if(i>1)for(let c=0;c<r/a;c++){const l=c*a;for(let f=0;f<a;f++)o[f]=Math.max(o[f],no(u[l+f],0,n).length)}return o}function no(e,t,n){let s;return Array.isArray(e)?s=`${parseFloat(e[0].toFixed(Ic))} + ${parseFloat(e[1].toFixed(Ic))}j`:du(e)?s=`'${e}'`:n==="bool"?s=qg(e):s=parseFloat(e.toFixed(Ic)).toString(),xi(s,t)}function qg(e){return e===0?"false":"true"}function Ii(e,t,n,s,r,a=!0){const o=n==="complex64"?2:1,i=t[0],u=t.length;if(u===0){if(n==="complex64"){const b=so(e);return[no(b[0],0,n)]}return n==="bool"?[qg(e[0])]:[e[0].toString()]}if(u===1){if(i>_d){const w=Ja*o;let k=Array.from(e.slice(0,w)),N=Array.from(e.slice((i-Ja)*o,i*o));return n==="complex64"&&(k=so(k),N=so(N)),["["+k.map((_,I)=>no(_,r[I],n)).join(", ")+", ..., "+N.map((_,I)=>no(_,r[i-Ja+I],n)).join(", ")+"]"]}return["["+(n==="complex64"?so(e):Array.from(e)).map((w,k)=>no(w,r[k],n)).join(", ")+"]"]}const c=t.slice(1),l=s.slice(1),f=s[0]*o,d=[];if(i>_d){for(let b=0;b<Ja;b++){const w=b*f,k=w+f;d.push(...Ii(e.slice(w,k),c,n,l,r,!1))}d.push("...");for(let b=i-Ja;b<i;b++){const w=b*f,k=w+f;d.push(...Ii(e.slice(w,k),c,n,l,r,b===i-1))}}else for(let b=0;b<i;b++){const w=b*f,k=w+f;d.push(...Ii(e.slice(w,k),c,n,l,r,b===i-1))}const m=u===2?",":"";d[0]="["+(i>0?d[0]+m:"");for(let b=1;b<d.length-1;b++)d[b]=" "+d[b]+m;let g=`,
`;for(let b=2;b<u;b++)g+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(a?"":g),d}function so(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class je{constructor(t,n,s){if(this.dtype=n,this.shape=t.slice(),this.size=It(t),s!=null){const r=s.length;D(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||ze(n,this.size),this.strides=Kt(t)}set(t,...n){n.length===0&&(n=[0]),D(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const s=this.locToIndex(n);this.values[s]=t}get(...t){t.length===0&&(t=[0]);let n=0;for(const r of t){if(r<0||r>=this.shape[n]){const a=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(a)}n++}let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=this.strides[r]*t[r];return this.values[s]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let n=t[t.length-1];for(let s=0;s<t.length-1;++s)n+=this.strides[s]*t[s];return n}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const n=new Array(this.shape.length);for(let s=0;s<n.length-1;++s)n[s]=Math.floor(t/this.strides[s]),t-=n[s]*this.strides[s];return n[n.length-1]=t,n}get rank(){return this.shape.length}toTensor(){return Xn().makeTensor(this.values,this.shape,this.dtype)}}let Xn=null,ua=null;function Nv(e){Xn=e}function _v(e){ua=e}class cn{constructor(t,n,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=n||"float32",this.size=It(t),this.strides=Kt(t),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return ua.buffer(this.shape,this.dtype,t)}bufferSync(){return ua.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return qn(this.shape,t,this.dtype==="complex64")}arraySync(){return qn(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=Xn().read(this.dataId);if(this.dtype==="string"){const n=await t;try{return n.map(s=>vo(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Xn().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Xn().readSync(this.dataId);if(this.dtype==="string")try{return t.map(n=>vo(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Xn().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Xn().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return ua.print(this,t)}clone(){return this.throwIfDisposed(),ua.clone(this)}toString(t=!1){const n=this.dataSync();return Sv(n,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),ua.cast(this,t)}variable(t=!0,n,s){return this.throwIfDisposed(),Xn().makeVariable(this,t,n,s)}}Object.defineProperty(cn,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function Hg(){return Bl("Tensor",()=>cn)}Hg();class zi extends cn{constructor(t,n,s,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=n,this.name=s}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Un(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Xn().disposeTensor(this),this.dataId=t.dataId,Xn().incRef(this,null)}dispose(){Xn().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(zi,Symbol.hasInstance,{value:e=>e instanceof cn&&e.assign!=null&&e.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Td;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(Td||(Td={}));var Xc;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(Xc||(Xc={}));var Yc;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(Yc||(Yc={}));var Jc;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(Jc||(Jc={}));var Zc;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(Zc||(Zc={}));const Tv={float32:Jc,int32:Xc,bool:Yc,complex64:Zc};function Ma(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return Tv[e][t]}function Kg(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function Ug(e){return typeof GPUBuffer<"u"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ae(e,t){if(e.dtype===t.dtype)return[e,t];const n=Ma(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Ev(e,t){D(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function Gg(e){const t=[];return Xg(e,t,new Set),t}function Xg(e,t,n){if(e==null)return;if(e instanceof cn){t.push(e);return}if(!$v(e))return;const s=e;for(const r in s){const a=s[r];n.has(a)||(n.add(a),Xg(a,t,n))}}function $v(e){return Array.isArray(e)||typeof e=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nc(e){return e.kernelName!=null}class Ed{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class Ia{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Ed}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const s=t[n];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,s=1){return t in this.registryFactory?(Cr(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:s},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:n,asyncInit:s}=this.initializeBackend(t);if(!(s?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new bv(this.backendInstance),!0}setupRegisteredKernels(){Sd(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){Sd(t).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[t])})}initializeBackend(t){const n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const s=n.factory();if(s&&!(s instanceof Kp)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,a=s.then(o=>r<this.pendingBackendInitId?!1:(this.registry[t]=o,this.pendingBackendInit=null,!0)).catch(o=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Cr(`Initialization of backend ${t} failed`),Cr(o.stack||o.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[t]=s,{success:!0,asyncInit:!1}}catch(s){return Cr(`Initialization of backend ${t} failed`),Cr(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const s=t[n],{success:r,asyncInit:a}=this.initializeBackend(s);if(a||r)return{name:s,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){const s=this.state.tensorInfo.get(n),r=s.backend,a=this.readSync(n),o=r.refCount(n);r.disposeData(n,!0),s.backend=t,t.move(n,a,s.shape,s.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let s=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=n(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(t,n,s){t();try{const r=s();return n(),r}catch(r){throw n(),r}}nextTensorId(){return Ia.nextTensorId++}nextVariableId(){return Ia.nextVariableId++}clone(t){const n=j.runKernel(hf,{x:t}),s={x:t},r=o=>({x:()=>{const i="float32",u={x:o},c={dtype:i};return j.runKernel(Yl,u,c)}}),a=[];return this.addTapeNode(this.state.activeScope.name,s,[n],r,a,{}),n}runKernel(t,n,s){if(this.backendName==null&&this.backend,!(Uc(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,s){const r=this.backend.numDataIds();let a=0;s.forEach(u=>{a+=u.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-n-a-o;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${t}'`)}runKernelFunc(t){let n,s=[];const r=this.isTapeOn(),a=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let u;const c=Nc(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Nc(t)){const{kernelName:g,inputs:b,attrs:w}=t;this.backendName==null&&this.backend;const k=Uc(g,this.backendName);D(k!=null,()=>`Cannot find registered kernel '${g}' for backend '${this.backendName}'`),i=()=>{const N=this.backend.numDataIds();u=k.kernelFunc({inputs:b,attrs:w,backend:this.backend});const _=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(g,N,_);const I=_.map($=>$.rank!=null?$:this.makeTensorFromTensorInfo($));if(r){const $=this.getTensorsForGradient(g,b,I);s=this.saveTensorsForBackwardMode($)}return I}}else{const{forwardFunc:g}=t,b=w=>{r&&(s=w.map(k=>this.keep(this.clone(k))))};i=()=>{const w=this.backend.numDataIds();u=this.tidy(()=>g(this.backend,b));const k=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,w,k),k}}const{inputs:l,attrs:f}=t,d=Nc(t)?null:t.backwardsFunc;let m;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=i():(m=this.profiler.profileKernel(c,l,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(m),n=m.outputs)}),r&&this.addTapeNode(c,l,n,d,s,f),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map(g=>l[g]!=null?l[g].shape:null),outputShapes:n.map(g=>g.shape),kernelTimeMs:m.timeMs,extraInfo:m.extraInfo}),Array.isArray(u)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(t,n,s){const r=xd(t);if(r!=null){const a=r.inputsToSave||[],o=r.outputsToSave||[];let i;r.saveAllInputs?(D(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(n).map(c=>n[c])):i=a.map(c=>n[c]);const u=s.filter((c,l)=>o[l]);return i.concat(u)}return[]}makeTensor(t,n,s,r){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let a=t;s==="string"&&du(t[0])&&(a=t.map(u=>Pr(u)));const o=r.write(a,n,s),i=new cn(n,s,o,this.nextTensorId());if(this.trackTensor(i,r),s==="string"){const u=this.state.tensorInfo.get(o),c=Lw(a);this.state.numBytes+=c-u.bytes,u.bytes=c}return i}makeTensorFromDataId(t,n,s,r){s=s||"float32";const a={dataId:t,shape:n,dtype:s};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(t,n){const{dataId:s,shape:r,dtype:a}=t,o=new cn(r,a,s,this.nextTensorId());return this.trackTensor(o,n),o}makeVariable(t,n=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==t.dtype&&(t=t.cast(r));const a=new zi(t,n,s,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let s=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(s=t.size*Wc(t.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:s})),t instanceof zi||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const s=t.size*Wc(t.dtype);this.state.numBytes-=s}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const n=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,s,r,a,o){const i={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:s,saved:a},u=xd(t);u!=null&&(r=u.gradFunc),r!=null&&(i.gradient=c=>(c=c.map((l,f)=>{if(l==null){const d=s[f],m=tn(d.size,d.dtype);return this.makeTensor(m,d.shape,d.dtype)}return l}),r(c.length>1?c:c[0],a,o))),this.state.activeTape.push(i)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){const n=Gg(t),s=new Set(n.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){const o=this.state.activeScope.track[a];!o.kept&&!s.has(o.id)&&o.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(a=>{!a.kept&&a.scopeId===r.id&&this.track(a)})}gradients(t,n,s,r=!1){if(D(n.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));D(a instanceof cn,()=>"The result y returned by f() must be a tensor.");const o=kv(this.state.activeTape,n,a);if(!r&&o.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const i={};i[a.id]=s??Cv(a.shape),xv(i,o,c=>this.tidy(c),Ov);const u=n.map(c=>i[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const l of c.saved)l.dispose()}),this.state.activeTape=null),{value:a,grads:u}})}customGrad(t){return D(jc(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{D(n.every(i=>i instanceof cn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};n.forEach((i,u)=>{r[u]=i});const a=(i,u)=>(s=t(...n,u),D(s.value instanceof cn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),D(jc(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),o=(i,u)=>{const c=s.gradFunc(i,u),l=Array.isArray(c)?c:[c];D(l.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),D(l.every(d=>d instanceof cn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const f={};return l.forEach((d,m)=>{f[m]=()=>d}),f};return this.runKernelFunc({forwardFunc:a,backwardsFunc:o,inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){const n=Sa(),s=await this.backend.time(t);return s.wallMs=Sa()-n,s}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Ed;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Ia.nextTensorId=0;Ia.nextVariableId=0;function Cv(e){const t=zl(It(e),"float32");return j.makeTensor(t,e,"float32")}function Yg(){const e=Yp();if(e._tfengine==null){const t=new jw(e);e._tfengine=new Ia(t)}return Uw(e._tfengine.ENV),Nv(()=>e._tfengine),e._tfengine}const j=Yg();function Ov(e,t){const n={a:e,b:t};return j.runKernel(pu,n)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dv(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const In=oe();In.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});In.registerFlag("IS_BROWSER",()=>Dv());In.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");In.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));In.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));In.registerFlag("PROD",()=>!1);In.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>In.getBool("DEBUG"));In.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);In.registerFlag("IS_TEST",()=>!1);In.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>In.getBool("DEBUG"));In.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);In.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);In.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dr(e,t){let n=e;if(Gn(e))return t==="string"?[]:[e.length];if(Kg(e)){const r=e.channels||"RGBA";return[e.height,e.width*r.length]}else if(Ug(e))return[e.buffer.size/(t==null?4:Wc(t))];if(!Array.isArray(e))return[];const s=[];for(;Array.isArray(n)||Gn(n)&&t!=="string";)s.push(n.length),n=n[0];return Array.isArray(e)&&oe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Jg(e,s,[]),s}function Jg(e,t,n){if(n=n||[],!Array.isArray(e)&&!Gn(e)){D(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}D(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),D(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);const s=t.slice(1);for(let r=0;r<e.length;++r)Jg(e[r],s,n.concat(r))}function $d(e,t,n,s){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${s}' must be ${e} tensor, but got ${t} tensor`)}}function C(e,t,n,s="numeric"){if(e instanceof Hg())return $d(s,e.dtype,t,n),e;let r=Po(e);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),$d(s,r,t,n),e==null||!Gn(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){const u=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${u}'`)}const a=dr(e,r);!Gn(e)&&!Array.isArray(e)&&(e=[e]);const i=r!=="string"?Xr(e,r):ko(e,[],!0);return j.makeTensor(i,a,r)}function Bi(e,t,n,s="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((a,o)=>C(a,`${t}[${o}]`,n,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zg="__op";function L(e){const t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const s=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+Zg;const r=(...a)=>{j.startScope(n);try{const o=s(...a);return Lr(o)&&console.error("Cannot return a Promise inside of tidy."),j.endScope(o),o}catch(o){throw j.endScope(null),o}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Av(e,t){const n=C(e,"real","complex"),s=C(t,"imag","complex");Vn(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:n,imag:s};return j.runKernel(cm,r)}const ur=L({complex_:Av});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pr(e,t,n,s){if(s==null)s=Po(e);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Ug(e)||Kg(e)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return j.backend.createTensorFromGPUData(e,t||n,s)}if(!Gn(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Ln(t);const r=It(t),a=It(n);D(r===a,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${a}`);for(let o=0;o<n.length;++o){const i=n[o],u=o===n.length-1?i!==It(t.slice(o)):!0;D(n[o]===t[o]||!u,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!Gn(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=s!=="string"?Xr(e,s):ko(e,[],!0),j.makeTensor(e,t,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fs(e,t,n){const s=dr(e,n);return pr(e,t,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zr={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Zn{static join(t){return new Zn(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(s=>Gn(s)?s.buffer:s),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let s=0;s<t.length;s++){const r=t[s];s!==t.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=n+r.byteLength;this.shards.push({buffer:r,start:n,end:a}),n=a}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),n=Math.min(this.byteLength,n),n<=t)return new ArrayBuffer(0);const s=this.findShardForByte(t);if(s===-1)throw new Error(`Could not find start shard for byte ${t}`);const r=n-t,a=new ArrayBuffer(r),o=new Uint8Array(a);let i=0;for(let u=s;u<this.shards.length;u++){const c=this.shards[u],f=t+i-c.start,d=i,g=Math.min(n,c.end)-c.start,b=new Uint8Array(c.buffer,f,g-f);if(o.set(b,d),i+=b.length,n<c.end)break}return a}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(r){return t<r.start?-1:t>=r.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=Fv(this.shards,n);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function Fv(e,t){let n=0,s=e.length;for(;n<=s;){const r=Math.floor((s-n)/2)+n,a=t(e[r]);if(a===0)return r;a<0?s=r:n=r+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cd(){return j}function de(e,t){return j.tidy(e,t)}function Sn(e){Gg(e).forEach(n=>n.dispose())}function cs(e){return j.keep(e)}function Od(e){return j.setBackend(e)}function Rv(){return j.ready()}function Pv(){return j.backendName}function Mv(e,t,n=1){return j.registerBackend(e,t,n)}function Vv(){return j.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cr=4;async function Lv(e,t){const n=[],s=[],r=Array.isArray(e)?e.map(o=>o.name):Object.keys(e);for(let o=0;o<r.length;++o){const i=r[o],u=Array.isArray(e)?e[o].tensor:e[i];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${u.dtype}`);const c={name:i,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const l=new Promise(async f=>{const d=await u.bytes(),m=d.reduce((w,k)=>w+k.length,0)+cr*d.length,g=new Uint8Array(m);let b=0;for(let w=0;w<d.length;w++){const k=d[w],N=new Uint8Array(new Uint32Array([k.length]).buffer);g.set(N,b),b+=cr,g.set(k,b),b+=k.length}f(g)});s.push(l)}else s.push(u.data());t!=null&&(c.group=t),n.push(c)}const a=await Promise.all(s);return{data:Wv(a),specs:n}}function Qg(e,t){const n=new Zn(e),s={};let r=0;for(const a of t){const o=zv(a,(i,u)=>n.slice(r+i,r+u));s[a.name]=ty(a,n.slice(r,r+o)),r+=o}return s}function zv(e,t){const n=It(e.shape);let s;if("quantization"in e){const r=e.quantization;s=zr[r.dtype]}else if(e.dtype==="string"){let r=0;for(let a=0;a<n;a++)r+=cr+new Uint32Array(t(r,r+cr))[0];return r}else s=zr[e.dtype];return n*s}async function Bv(e,t){const n=It(e.shape);let s;if("quantization"in e){const r=e.quantization;s=zr[r.dtype]}else if(e.dtype==="string"){let r=0;for(let a=0;a<n;a++)r+=cr+new Uint32Array(await t(r,r+cr))[0];return r}else s=zr[e.dtype];return n*s}function ty(e,t){const n=e.name,s=e.dtype,r=e.shape,a=It(r);let o,i=0;if("quantization"in e){const u=e.quantization;if(u.dtype==="uint8"||u.dtype==="uint16"){if(!("min"in u&&"scale"in u))throw new Error(`Weight ${e.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`)}else if(u.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${e.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${e.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const c=zr[u.dtype],l=u.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(s==="float32")if(u.dtype==="uint8"||u.dtype==="uint16"){o=new Float32Array(l.length);for(let f=0;f<l.length;f++){const d=l[f];o[f]=d*u.scale+u.min}}else if(u.dtype==="float16")o=Xv()(l);else throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);else if(s==="int32"){if(u.dtype!=="uint8"&&u.dtype!=="uint16")throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);o=new Int32Array(l.length);for(let f=0;f<l.length;f++){const d=l[f];o[f]=Math.round(d*u.scale+u.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${s}`);i+=a*c}else if(s==="string"){const u=It(e.shape);o=[];for(let c=0;c<u;c++){const l=new Uint32Array(t.slice(i,i+cr))[0];i+=cr;const f=new Uint8Array(t.slice(i,i+l));o.push(f),i+=l}}else{const u=zr[s];if(s==="float32")o=new Float32Array(t);else if(s==="int32")o=new Int32Array(t);else if(s==="bool")o=new Uint8Array(t);else if(s==="complex64"){o=new Float32Array(t);const c=new Float32Array(o.length/2),l=new Float32Array(o.length/2);for(let g=0;g<c.length;g++)c[g]=o[g*2],l[g]=o[g*2+1];const f=fs(c,r,"float32"),d=fs(l,r,"float32"),m=ur(f,d);return f.dispose(),d.dispose(),m}else throw new Error(`Unsupported dtype in weight '${n}': ${s}`);i+=a*u}return fs(o,r,s)}async function Dd(e,t,n){let s=new Uint8Array(t);for(;s.byteLength<n;){const{done:r,value:a}=await e.read();if(r&&a==null){const i=n-s.byteLength;throw new Error(`Reader is done but ${i} bytes are still expected`)}const o=new Uint8Array(s.length+a.byteLength);o.set(s,0),o.set(new Uint8Array(a),s.length),s=o}return s.buffer}async function ey(e,t){const n={},s=e.getReader();let r=new ArrayBuffer(0);for(const a of t){const o=await Bv(a,async(c,l)=>(r=await Dd(s,r,l),r.slice(c,l)));r=await Dd(s,r,o);const i=r.slice(0,o);r=r.slice(o);const u=ty(a,i);if(n[a.name]=u,Pv()==="webgpu"){const c=Vv();"uploadToGPU"in c&&It(u.shape)>=oe().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&c.uploadToGPU(u.dataId)}}return n}function Wv(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach(a=>{if(t+=a.byteLength,n.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});const s=new Uint8Array(t);let r=0;return n.forEach(a=>{s.set(new Uint8Array(a.buffer),r),r+=a.byteLength}),s.buffer}const Xf=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function Ad(e){return Xf?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function jv(e){if(Xf)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let s=0,r=t.length;s<r;s++)n+=String.fromCharCode(t[s]);return btoa(n)}function qv(e){if(Xf){const s=Buffer.from(e,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let s=0;s<t.length;++s)n.set([t.charCodeAt(s)],s);return n.buffer}function Hv(e){return Zn.join(e)}function Fd(e){const t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);const n=e.split(t);return n[n.length-1]}function ny(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function sy(e,t,n){const s={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(s.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=t,s.weightData=n}return e.signature!=null&&(s.signature=e.signature),e.userDefinedMetadata!=null&&(s.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(s.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(s.initializerSignature=e.initializerSignature),s}async function Yf(e,t){let n,s;return e.weightsManifest!=null&&([n,s]=await t(e.weightsManifest)),sy(e,n,s)}function Mo(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:Ad(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:Ad(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new Zn(e.weightData).byteLength}}function Qc(e){const t=[];for(const n of e)t.push(...n.weights);return t}function Kv(){const e=n=>{let s=n<<13,r=0;for(;(s&8388608)===0;)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function Uv(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function Gv(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function Xv(){const e=Kv(),t=Uv(),n=Gv();return s=>{const r=new ArrayBuffer(4*s.length),a=new Uint32Array(r);for(let o=0;o<s.length;o++){const i=s[o],u=e[n[i>>10]+(i&1023)]+t[i>>10];a[o]=u}return new Float32Array(r)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Oe{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Oe.instance==null&&(Oe.instance=new Oe),Oe.instance}static registerSaveRouter(t){Oe.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Oe.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Oe.getHandlers(t,"save")}static getLoadHandlers(t,n){return Oe.getHandlers(t,"load",n)}static getHandlers(t,n,s){const r=[];return(n==="load"?Oe.getInstance().loadRouters:Oe.getInstance().saveRouters).forEach(o=>{const i=o(t,s);i!==null&&r.push(i)}),r}}const Yv=e=>Oe.registerSaveRouter(e),Jv=e=>Oe.registerLoadRouter(e),Zv=e=>Oe.getSaveHandlers(e),Qv=(e,t)=>Oe.getLoadHandlers(e,t);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tl="tensorflowjs",el=1,Fr="models_store",sr="model_info_store";function ry(){if(!oe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function nl(e){const t=e.result;t.createObjectStore(Fr,{keyPath:"modelPath"}),t.createObjectStore(sr,{keyPath:"modelPath"})}class Br{constructor(t){if(this.indexedDB=ry(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,n){return new Promise((s,r)=>{const a=this.indexedDB.open(tl,el);a.onupgradeneeded=()=>nl(a),a.onsuccess=()=>{const o=a.result;if(n==null){const i=o.transaction(Fr,"readonly"),c=i.objectStore(Fr).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return o.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=l=>(o.close(),r(c.error)),i.oncomplete=()=>o.close()}else{n.weightData=Zn.join(n.weightData);const i=Mo(n),u=o.transaction(sr,"readwrite");let c=u.objectStore(sr),l;try{l=c.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(d){return r(d)}let f;l.onsuccess=()=>{f=o.transaction(Fr,"readwrite");const d=f.objectStore(Fr);let m;try{m=d.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:i})}catch(g){return r(g)}m.onsuccess=()=>s({modelArtifactsInfo:i}),m.onerror=g=>{c=u.objectStore(sr);const b=c.delete(this.modelPath);b.onsuccess=()=>(o.close(),r(m.error)),b.onerror=w=>(o.close(),r(m.error))}},l.onerror=d=>(o.close(),r(l.error)),u.oncomplete=()=>{f==null?o.close():f.oncomplete=()=>o.close()}}},a.onerror=o=>r(a.error)})}}Br.URL_SCHEME="indexeddb://";const ay=e=>oe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Br.URL_SCHEME)?t1(e.slice(Br.URL_SCHEME.length)):null;Oe.registerSaveRouter(ay);Oe.registerLoadRouter(ay);function t1(e){return new Br(e)}function e1(e){return e.startsWith(Br.URL_SCHEME)?e.slice(Br.URL_SCHEME.length):e}class n1{constructor(){this.indexedDB=ry()}async listModels(){return new Promise((t,n)=>{const s=this.indexedDB.open(tl,el);s.onupgradeneeded=()=>nl(s),s.onsuccess=()=>{const r=s.result,a=r.transaction(sr,"readonly"),i=a.objectStore(sr).getAll();i.onsuccess=()=>{const u={};for(const c of i.result)u[c.modelPath]=c.modelArtifactsInfo;t(u)},i.onerror=u=>(r.close(),n(i.error)),a.oncomplete=()=>r.close()},s.onerror=r=>n(s.error)})}async removeModel(t){return t=e1(t),new Promise((n,s)=>{const r=this.indexedDB.open(tl,el);r.onupgradeneeded=()=>nl(r),r.onsuccess=()=>{const a=r.result,o=a.transaction(sr,"readwrite"),i=o.objectStore(sr),u=i.get(t);let c;u.onsuccess=()=>{if(u.result==null)return a.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const l=i.delete(t),f=()=>{c=a.transaction(Fr,"readwrite");const m=c.objectStore(Fr).delete(t);m.onsuccess=()=>n(u.result.modelArtifactsInfo),m.onerror=g=>s(u.error)};l.onsuccess=f,l.onerror=d=>(f(),a.close(),s(u.error))}},u.onerror=l=>(a.close(),s(u.error)),o.oncomplete=()=>{c==null?a.close():c.oncomplete=()=>a.close()}},r.onerror=a=>s(r.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Es="/",ca="tensorflowjs_models",oy="info",s1="model_topology",r1="weight_specs",a1="weight_data",o1="model_metadata";function iy(e){return{info:[ca,e,oy].join(Es),topology:[ca,e,s1].join(Es),weightSpecs:[ca,e,r1].join(Es),weightData:[ca,e,a1].join(Es),modelMetadata:[ca,e,o1].join(Es)}}function uy(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function i1(e){const t=e.split(Es);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Es)}function u1(e){return e.startsWith(Wr.URL_SCHEME)?e.slice(Wr.URL_SCHEME.length):e}class Wr{constructor(t){if(!oe().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=iy(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(t.modelTopology),s=JSON.stringify(t.weightSpecs),r=Mo(t),a=Zn.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,jv(a));const o={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:r}}catch{throw uy(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){const i=JSON.parse(a);n.format=i.format,n.generatedBy=i.generatedBy,n.convertedBy=i.convertedBy,i.signature!=null&&(n.signature=i.signature),i.userDefinedMetadata!=null&&(n.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(n.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(n.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(n.trainingConfig=i.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=qv(o),n}}Wr.URL_SCHEME="localstorage://";const cy=e=>oe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Wr.URL_SCHEME)?c1(e.slice(Wr.URL_SCHEME.length)):null;Oe.registerSaveRouter(cy);Oe.registerLoadRouter(cy);function c1(e){return new Wr(e)}class l1{constructor(){D(oe().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),D(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},n=ca+Es,s=Es+oy;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);if(a.startsWith(n)&&a.endsWith(s)){const o=i1(a);t[o]=JSON.parse(this.LS.getItem(a))}}return t}async removeModel(t){t=u1(t);const n=iy(t);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(this.LS.getItem(n.info));return uy(n),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const da="://";class on{constructor(){this.managers={}}static getInstance(){return on.instance==null&&(on.instance=new on),on.instance}static registerManager(t,n){D(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(da)&&(t=t.slice(0,t.indexOf(da))),D(t.length>0,()=>"scheme must not be an empty string.");const s=on.getInstance();D(s.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),s.managers[t]=n}static getManager(t){const n=on.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(on.getInstance().managers)}}function Ni(e){if(e.indexOf(da)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${on.getSchemes().join(",")}`);return{scheme:e.split(da)[0],path:e.split(da)[1]}}async function ly(e,t,n=!1){D(e!==t,()=>`Old path and new path are the same: '${e}'`);const s=Oe.getLoadHandlers(e);D(s.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),D(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${e}.`);const r=s[0],a=Oe.getSaveHandlers(t);D(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),D(a.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${t}.`);const o=a[0],i=Ni(e).scheme,u=Ni(e).path,c=i===Ni(e).scheme,l=await r.load();n&&c&&await on.getManager(i).removeModel(u);const f=await o.save(l);return n&&!c&&await on.getManager(i).removeModel(u),f.modelArtifactsInfo}async function f1(){const e=on.getSchemes(),t={};for(const n of e){const s=await on.getManager(n).listModels();for(const r in s){const a=n+da+r;t[a]=s[r]}}return t}async function h1(e){const t=Ni(e);return on.getManager(t.scheme).removeModel(t.path)}async function d1(e,t){return ly(e,t,!1)}async function p1(e,t){return ly(e,t,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class m1{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,n){return fetch(t,n)}now(){return performance.now()}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,n){return new TextDecoder(n).decode(t)}setTimeoutCustom(t,n){if(typeof window>"u"||!oe().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,n);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return Lg(t)}}if(oe().get("IS_BROWSER")){oe().setPlatform("browser",new m1);try{on.registerManager(Wr.URL_SCHEME,new l1)}catch{}try{on.registerManager(Br.URL_SCHEME,new n1)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g1={importFetch:()=>require("node-fetch")};let _c;class y1{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,n){return oe().global.fetch!=null?oe().global.fetch(t,n):(_c==null&&(_c=g1.importFetch()),_c(t,n))}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(t)}decode(t,n){return t.length===0?"":new this.util.TextDecoder(n).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}oe().get("IS_NODE")&&!oe().get("IS_BROWSER")&&oe().setPlatform("node",new y1);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ce(e,t="float32",n){return t=t||"float32",Ln(e),new je(e,t,n)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b1(e,t){const n=C(e,"x","cast");if(!Mw(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:n},r={dtype:t};return j.runKernel(Yl,s,r)}const Pe=L({cast_:b1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w1(e){const n={x:C(e,"x","clone","string_or_numeric")};return j.runKernel(hf,n)}const ar=L({clone_:w1});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fy(e,t=!1){console.log(e.toString(t))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Yg();const v1={buffer:ce,cast:Pe,clone:ar,print:fy};_v(v1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k1(e,t){let n=C(e,"a","add"),s=C(t,"b","add");[n,s]=Ae(n,s);const r={a:n,b:s};return j.runKernel(pu,r)}const Jt=L({add_:k1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x1(e,t){let n=C(e,"a","floorDiv"),s=C(t,"b","floorDiv");[n,s]=Ae(n,s);const r={a:n,b:s};return j.runKernel(cf,r)}const hy=L({floorDiv_:x1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S1(e,t){let n=C(e,"a","div"),s=C(t,"b","div");if([n,s]=Ae(n,s),n.dtype==="int32"&&s.dtype==="int32")return hy(n,s);const r={a:n,b:s},a={};return j.runKernel(ef,r,a)}const ke=L({div_:S1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I1(e,t){let n=C(e,"a","mul"),s=C(t,"b","mul");[n,s]=Ae(n,s);const r={a:n,b:s};return j.runKernel(_f,r)}const Pt=L({mul_:I1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N1(e){const t=C(e,"x","abs");if(t.dtype==="complex64"){const n={x:t};return j.runKernel(lm,n)}else{const n={x:t};return j.runKernel(Jp,n)}}const Fn=L({abs_:N1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _1(e){const n={x:C(e,"x","acos")};return j.runKernel(Wl,n)}const T1=L({acos_:_1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E1(e){const n={x:C(e,"x","acosh")};return j.runKernel(jl,n)}const $1=L({acosh_:E1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C1(e){D(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),D(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);const t=e.map((r,a)=>C(r,`tensors${a}`,"addN")),n=t[0];t.forEach(r=>{if(r.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(r=>{if(!Un(r.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=t;return j.runKernel(Zp,s)}const O1=L({addN_:C1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D1(e,t=null,n=!1){const r={x:C(e,"x","all","bool")},a={axis:t,keepDims:n};return j.runKernel(Qp,r,a)}const A1=L({all_:D1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F1(e,t=null,n=!1){const r={x:C(e,"x","any","bool")},a={axis:t,keepDims:n};return j.runKernel(tm,r,a)}const R1=L({any_:F1});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P1(e,t=0){const s={x:C(e,"x","argMax")},r={axis:t};return j.runKernel(em,s,r)}const M1=L({argMax_:P1});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V1(e,t=0){const s={x:C(e,"x","argMin")},r={axis:t};return j.runKernel(nm,s,r)}const L1=L({argMin_:V1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z1(e){const n={x:C(e,"x","asin")};return j.runKernel(ql,n)}const B1=L({asin_:z1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W1(e){const n={x:C(e,"x","asinh")};return j.runKernel(Hl,n)}const j1=L({asinh_:W1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q1(e){const n={x:C(e,"x","atan")};return j.runKernel(Kl,n)}const H1=L({atan_:q1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K1(e,t){let n=C(e,"a","atan2"),s=C(t,"b","atan2");[n,s]=Ae(n,s);const r={a:n,b:s};return j.runKernel(Gl,r)}const U1=L({atan2_:K1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G1(e){const n={x:C(e,"x","atanh")};return j.runKernel(Ul,n)}const X1=L({atanh_:G1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jf(e,t,n,s,r="NHWC",a){const o=e[3],i=[...t,o],u=bu(r);return bs(e,i,n,a,s,null,null,u)}function Va(e,t,n,s,r,a,o="channelsLast"){const[i,u]=xo(t);let c;if(o==="channelsLast")c=[i,u,e[3],e[3]];else if(o==="channelsFirst")c=[i,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${o}`);return bs(e,c,n,s,r,a,!1,o)}function gu(e,t,n,s,r,a,o="NDHWC"){const[i,u,c]=sl(t);let l,f;if(o==="NDHWC")f="channelsLast",l=[i,u,c,e[4],e[4]];else if(o==="NCDHW")f="channelsFirst",l=[i,u,c,e[1],e[1]];else throw new Error(`Unknown dataFormat ${o}`);return yu(e,l,n,s,r,!1,f,a)}function bs(e,t,n,s,r,a,o=!1,i="channelsLast"){let[u,c,l,f]=[-1,-1,-1,-1];if(i==="channelsLast")[u,c,l,f]=e;else if(i==="channelsFirst")[u,f,c,l]=e;else throw new Error(`Unknown dataFormat ${i}`);const[d,m,,g]=t,[b,w]=xo(n),[k,N]=xo(s),_=pa(d,k),I=pa(m,N),{padInfo:$,outHeight:O,outWidth:R}=Z1(r,c,l,b,w,_,I,a,i),W=o?g*f:g;let P;return i==="channelsFirst"?P=[u,W,O,R]:i==="channelsLast"&&(P=[u,O,R,W]),{batchSize:u,dataFormat:i,inHeight:c,inWidth:l,inChannels:f,outHeight:O,outWidth:R,outChannels:W,padInfo:$,strideHeight:b,strideWidth:w,filterHeight:d,filterWidth:m,effectiveFilterHeight:_,effectiveFilterWidth:I,dilationHeight:k,dilationWidth:N,inShape:e,outShape:P,filterShape:t}}function yu(e,t,n,s,r,a=!1,o="channelsLast",i){let[u,c,l,f,d]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[u,c,l,f,d]=e;else if(o==="channelsFirst")[u,d,c,l,f]=e;else throw new Error(`Unknown dataFormat ${o}`);const[m,g,b,,w]=t,[k,N,_]=sl(n),[I,$,O]=sl(s),R=pa(m,I),W=pa(g,$),P=pa(b,O),{padInfo:M,outDepth:T,outHeight:q,outWidth:X}=Q1(r,c,l,f,k,N,_,R,W,P,i),st=a?w*d:w;let et;return o==="channelsFirst"?et=[u,st,T,q,X]:o==="channelsLast"&&(et=[u,T,q,X,st]),{batchSize:u,dataFormat:o,inDepth:c,inHeight:l,inWidth:f,inChannels:d,outDepth:T,outHeight:q,outWidth:X,outChannels:st,padInfo:M,strideDepth:k,strideHeight:N,strideWidth:_,filterDepth:m,filterHeight:g,filterWidth:b,effectiveFilterDepth:R,effectiveFilterHeight:W,effectiveFilterWidth:P,dilationDepth:I,dilationHeight:$,dilationWidth:O,inShape:e,outShape:et,filterShape:t}}function Y1(e,t,n,s,r){s==null&&(s=dy(e,t,n));const a=e[0],o=e[1],i=So((a-t+2*s)/n+1,r),u=So((o-t+2*s)/n+1,r);return[i,u]}function J1(e,t,n,s,r,a){r==null&&(r=dy(e,t[0],s[0]));const o=[0,0,0,n];for(let i=0;i<3;i++)e[i]+2*r>=t[i]&&(o[i]=So((e[i]-t[i]+2*r)/s[i]+1,a));return o}function dy(e,t,n,s=1){const r=pa(t,s);return Math.floor((e[0]*(n-1)-n+r)/2)}function xo(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function sl(e){return typeof e=="number"?[e,e,e]:e}function pa(e,t){return t<=1?e:e+(e-1)*(t-1)}function Z1(e,t,n,s,r,a,o,i,u){let c,l,f;if(typeof e=="number"){c={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};const m=Y1([t,n],a,s,e,i);l=m[0],f=m[1]}else if(e==="same"){l=Math.ceil(t/s),f=Math.ceil(n/r);const d=Math.max(0,(l-1)*s+a-t),m=Math.max(0,(f-1)*r+o-n),g=Math.floor(d/2),b=d-g,w=Math.floor(m/2),k=m-w;c={top:g,bottom:b,left:w,right:k,type:"SAME"}}else if(e==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},l=Math.ceil((t-a+1)/s),f=Math.ceil((n-o+1)/r);else if(typeof e=="object"){const d=u==="channelsLast"?e[1][0]:e[2][0],m=u==="channelsLast"?e[1][1]:e[2][1],g=u==="channelsLast"?e[2][0]:e[3][0],b=u==="channelsLast"?e[2][1]:e[3][1];c={top:d,bottom:m,left:g,right:b,type:d===0&&m===0&&g===0&&b===0?"VALID":"EXPLICIT"},l=So((t-a+d+m)/s+1,i),f=So((n-o+g+b)/r+1,i)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:c,outHeight:l,outWidth:f}}function Q1(e,t,n,s,r,a,o,i,u,c,l){let f,d,m,g;if(e==="valid"&&(e=0),typeof e=="number"){f={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};const w=J1([t,n,s,1],[i,u,c],1,[r,a,o],e,l);d=w[0],m=w[1],g=w[2]}else if(e==="same"){d=Math.ceil(t/r),m=Math.ceil(n/a),g=Math.ceil(s/o);const b=(d-1)*r+i-t,w=(m-1)*a+u-n,k=(g-1)*o+c-s,N=Math.floor(b/2),_=b-N,I=Math.floor(w/2),$=w-I,O=Math.floor(k/2),R=k-O;f={top:I,bottom:$,left:O,right:R,front:N,back:_,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:f,outDepth:d,outHeight:m,outWidth:g}}function So(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Wi(e){const[t,n,s]=xo(e);return t===1&&n===1&&s===1}function Qn(e,t){return Wi(e)||Wi(t)}function Na(e){return xo(e).every(t=>t>0)}function bu(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function ts(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")D(wo(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(s=>{s.forEach(r=>{D(wo(r),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${r}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tk(e,t){const s={x:C(e,"x","reshape","string_or_numeric")},r={shape:t};return j.runKernel(cg,s,r)}const mt=L({reshape_:tk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ek(e,t,n,s,r){const a=C(e,"x","avgPool","float32"),o=1;D(Qn(n,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);let i=a,u=!1;a.rank===3&&(u=!0,i=mt(a,[1,a.shape[0],a.shape[1],a.shape[2]])),D(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),ts("avgPool",s,r);const c={x:i},l={filterSize:t,strides:n,pad:s,dimRoundingMode:r};let f=j.runKernel(sm,c,l);return f=Pe(f,a.dtype),u?mt(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const py=L({avgPool_:ek});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nk(e,t,n,s,r,a="NDHWC"){const o=C(e,"x","avgPool3d","float32");let i=o,u=!1;o.rank===4&&(u=!0,i=mt(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),D(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),D(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),D(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),ts("avgPool3d",s,r);const c={x:i},l={filterSize:t,strides:n,pad:s,dimRoundingMode:r,dataFormat:a};let f=j.runKernel(rm,c,l);return f=Pe(f,i.dtype),u?mt(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const sk=L({avgPool3d_:nk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rk(e,t=0){D(e.length>=1,()=>"Pass at least one tensor to concat");const n=Bi(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),n.length===1)return ar(n[0]);const s=n,r={axis:t};return j.runKernel(fm,s,r)}const dn=L({concat_:rk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ak(e,t,n=!1,s=!1){let r=C(e,"a","matMul"),a=C(t,"b","matMul");[r,a]=Ae(r,a);const o={a:r,b:a},i={transposeA:n,transposeB:s};return j.runKernel(am,o,i)}const be=L({matMul_:ak});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ok(e){const n={x:C(e,"x","sigmoid","float32")};return j.runKernel(Vf,n)}const ma=L({sigmoid_:ok});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ik(e,t,n){const s=C(e,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},a={begin:t,size:n};return j.runKernel(yg,r,a)}const ve=L({slice_:ik});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uk(e){const n={x:C(e,"x","tanh","float32")};return j.runKernel(Hf,n)}const rl=L({tanh_:uk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ck(e,t,n,s,r,a){const o=C(e,"forgetBias","basicLSTMCell"),i=C(t,"lstmKernel","basicLSTMCell"),u=C(n,"lstmBias","basicLSTMCell"),c=C(s,"data","basicLSTMCell"),l=C(r,"c","basicLSTMCell"),f=C(a,"h","basicLSTMCell"),d=dn([c,f],1),m=be(d,i),g=Jt(m,u),b=g.shape[0],w=g.shape[1]/4,k=[b,w],N=ve(g,[0,0],k),_=ve(g,[0,w],k),I=ve(g,[0,w*2],k),$=ve(g,[0,w*3],k),O=Jt(Pt(ma(N),rl(_)),Pt(l,ma(Jt(o,I)))),R=Pt(rl(O),ma($));return[O,R]}const lk=L({basicLSTMCell_:ck});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fk(e,t,n){const s=C(e,"x","batchToSpaceND"),r=t.reduce((i,u)=>i*u);D(s.rank>=1+t.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`),D(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),D(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`);const a={x:s},o={blockShape:t,crops:n};return j.runKernel(om,a,o)}const my=L({batchToSpaceND_:fk});function hk(e){let t;return e.rank===0||e.rank===1?t=mt(e,[1,1,1,e.size]):e.rank===2?t=mt(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=mt(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dk(e,t,n,s,r,a){a==null&&(a=.001);const o=C(e,"x","batchNorm"),i=C(t,"mean","batchNorm"),u=C(n,"variance","batchNorm");let c;r!=null&&(c=C(r,"scale","batchNorm"));let l;s!=null&&(l=C(s,"offset","batchNorm")),D(i.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),D(l==null||i.rank===l.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),D(c==null||i.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:hk(o),scale:c,offset:l,mean:i,variance:u},m={varianceEpsilon:a},g=j.runKernel(Dm,d,m);return mt(g,o.shape)}const wu=L({batchNorm_:dk});function pk(e,t,n,s,r,a){const o=C(e,"x","batchNorm"),i=C(t,"mean","batchNorm"),u=C(n,"variance","batchNorm");let c;r!=null&&(c=C(r,"scale","batchNorm"));let l;return s!=null&&(l=C(s,"offset","batchNorm")),D(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),D(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),D(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&D(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),l!=null&&D(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${l.rank}.`),wu(o,i,u,l,c,a)}const mk=L({batchNorm2d_:pk});function gk(e,t,n,s,r,a){const o=C(e,"x","batchNorm"),i=C(t,"mean","batchNorm"),u=C(n,"variance","batchNorm");let c;r!=null&&(c=C(r,"scale","batchNorm"));let l;return s!=null&&(l=C(s,"offset","batchNorm")),D(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),D(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),D(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&D(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),l!=null&&D(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${l.rank}.`),wu(o,i,u,l,c,a)}const yk=L({batchNorm3d_:gk});function bk(e,t,n,s,r,a){const o=C(e,"x","batchNorm"),i=C(t,"mean","batchNorm"),u=C(n,"variance","batchNorm");let c;r!=null&&(c=C(r,"scale","batchNorm"));let l;return s!=null&&(l=C(s,"offset","batchNorm")),D(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),D(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),D(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&D(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),l!=null&&D(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${l.rank}.`),wu(o,i,u,l,c,a)}const wk=L({batchNorm4d_:bk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vk(e,t,n){const s=C(e,"x","bincount"),r=C(t,"weights","bincount");D(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),D(n>=0,()=>`size must be non-negative, but got ${n}.`),D(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const a={x:s,weights:r},o={size:n};return j.runKernel(im,a,o)}const gy=L({bincount_:vk});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kk(e,t){const n=C(e,"x","bitwiseAnd"),s=C(t,"y","bitwiseAnd");if(!Un(n.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${s.shape}`);if(n.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${s.dtype}`);const r={a:n,b:s};return j.runKernel(Xl,r)}const xk=L({bitwiseAnd_:kk});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sk(e,t){const n=C(e,"s0","broadcastArgs","int32"),s=C(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:n,s1:s};return j.runKernel(um,r)}const Ik=L({broadcastArgs_:Sk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nk(e,t){let n=C(e,"broadcastTo","x");const s=n.shape;if(Ln(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const c=n.shape.slice();for(;c.length<t.length;)c.unshift(1);n=mt(n,c)}const r=n.shape,a=Array.from(t);for(let c=t.length-1;c>=0;c--)if(r[c]===t[c])a[c]=1;else if(n.shape[c]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);if(a.map((c,l)=>c>1?l:-1).filter(c=>c>=0).length===0)return ar(n);const i={x:n},u={reps:a};return j.runKernel(Kf,i,u)}const io=L({broadcastTo_:Nk});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _k(e){const n={x:C(e,"x","ceil","float32")};return j.runKernel(Jl,n)}const Tk=L({ceil_:_k});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vo(e,t,n){Ln(e),n=n||Po(t);const s={shape:e,value:t,dtype:n};return j.runKernel(Cm,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ek(e,t,n){const s=C(e,"x","clipByValue");if(D(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return Vo(s.shape,t,s.dtype);const r={x:s},a={clipValueMin:t,clipValueMax:n};return j.runKernel(Zl,r,a)}const $k=L({clipByValue_:Ek});function Ck(e){return dn(e,0)}const Ok=L({concat1d_:Ck});function Dk(e,t){return dn(e,t)}const Ak=L({concat2d_:Dk});function Fk(e,t){return dn(e,t)}const Rk=L({concat3d_:Fk});function Pk(e,t){return dn(e,t)}const Mk=L({concat4d_:Pk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vk(e,t,n,s,r="NHWC",a=[1,1],o){const i=C(e,"x","conv2d","float32"),u=C(t,"filter","conv2d","float32");let c=i,l=!1;i.rank===3&&(l=!0,c=mt(i,[1,i.shape[0],i.shape[1],i.shape[2]])),D(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),D(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),ts("conv2d",s,o);const f=r==="NHWC"?c.shape[3]:c.shape[1];D(f===u.shape[2],()=>`Error in conv2d: depth of input (${f}) must match input depth for filter ${u.shape[2]}.`),D(Qn(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),D(Na(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),D(Na(n),()=>"Error in conv2D: Strides should be larger than 0.");const d={x:c,filter:u},m={strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:o},g=j.runKernel(hm,d,m);return l?mt(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const vu=L({conv2d_:Vk});function Lk(e,t,n,s,r="NWC",a=1,o){const i=C(e,"x","conv1d"),u=C(t,"filter","conv1d");let c=i,l=!1;i.rank===2&&(l=!0,c=mt(i,[1,i.shape[0],i.shape[1]])),D(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),D(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),ts("conv1d",s,o),D(c.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${u.shape[1]}.`),D(Qn(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),D(Na(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),D(Na(n),()=>"Error in conv1D: Stride should be larger than 0."),D(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const f=mt(u,[1,u.shape[0],u.shape[1],u.shape[2]]),d=mt(c,[c.shape[0],1,c.shape[1],c.shape[2]]),w=vu(d,f,[1,n],s,"NHWC",[1,a],o);return l?mt(w,[w.shape[2],w.shape[3]]):mt(w,[w.shape[0],w.shape[2],w.shape[3]])}const zk=L({conv1d_:Lk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bk(e,t,n,s,r,a="NHWC",o){D(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let i=e,u=t,c=!1;t.rank===3&&(c=!0,u=mt(t,[1,t.shape[0],t.shape[1],t.shape[2]]),i=[1,e[0],e[1],e[2]]),D(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),D(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),D(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const l=a==="NHWC"?i[3]:i[1],f=a==="NHWC"?u.shape[3]:u.shape[1];D(l===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[2]}.`),D(f===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${f}) must match output depth for filter ${n.shape[3]}.`),ts("conv2dDerInput",r,o);const d={dy:u,filter:n},m={strides:s,pad:r,dataFormat:a,dimRoundingMode:o,inputShape:i},g=j.runKernel(pm,d,m);return c?mt(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const yy=L({conv2DBackpropInput_:Bk});function Wk(e,t,n,s,r,a){const o=C(e,"x","conv2dTranspose"),i=C(t,"filter","conv2dTranspose");return yy(n,o,i,s,r,"NHWC",a)}const jk=L({conv2dTranspose_:Wk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qk(e,t,n,s,r="NDHWC",a=[1,1,1]){const o=C(e,"x","conv3d"),i=C(t,"filter","conv3d");let u=o,c=!1;o.rank===4&&(c=!0,u=mt(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),D(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),D(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),D(u.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${i.shape[3]}.`),D(Qn(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),D(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),D(Na(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),D(Na(n),()=>"Error in conv3D: Strides should be larger than 0.");const l={x:u,filter:i},f={strides:n,pad:s,dataFormat:r,dilations:a},d=j.runKernel(mm,l,f);return c?mt(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const Hk=L({conv3d_:qk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kk(e,t,n,s,r){D(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,o=t,i=!1;t.rank===4&&(i=!0,o=mt(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);const u=a[4],c=o.shape[4];D(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),D(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),D(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),D(u===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`),D(c===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`);const l={dy:o,filter:n},f={pad:r,strides:s,inputShape:a},d=j.runKernel(gm,l,f);return i?mt(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const Uk=L({conv3DBackpropInput_:Kk});function Gk(e,t,n,s,r){const a=C(e,"x","conv3dTranspose"),o=C(t,"filter","conv3dTranspose");return Uk(n,a,o,s,r)}const Xk=L({conv3dTranspose_:Gk});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yk(e){const n={x:C(e,"x","cos","float32")};return j.runKernel(Ql,n)}const Jk=L({cos_:Yk});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zk(e){const n={x:C(e,"x","cosh","float32")};return j.runKernel(tf,n)}const Qk=L({cosh_:Zk});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tx(e,t=0,n=!1,s=!1){const a={x:C(e,"x","cumprod")},o={axis:t,exclusive:n,reverse:s};return j.runKernel(ym,a,o)}const ex=L({cumprod_:tx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nx(e,t=0,n=!1,s=!1){const a={x:C(e,"x","cumsum")},o={axis:t,exclusive:n,reverse:s};return j.runKernel(bm,a,o)}const sx=L({cumsum_:nx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rx(e,t,n,s=!1){const r=C(e,"x","denseBincount"),a=C(t,"weights","denseBincount");D(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),D(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),D(n>=0,()=>`size must be non-negative, but got ${n}.`),D(a.size===r.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${a.shape}.`);const o={x:r,weights:a},i={size:n,binaryOutput:s};return j.runKernel(vm,o,i)}const ax=L({denseBincount_:rx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ox(e,t,n="NHWC"){const s=C(e,"x","depthToSpace","float32"),r=n==="NHWC"?s.shape[1]:s.shape[2],a=n==="NHWC"?s.shape[2]:s.shape[3],o=n==="NHWC"?s.shape[3]:s.shape[1];D(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),D(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${t}  for depthToSpace with input shape
    ${s.shape}`),D(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t} for depthToSpace with input shape
        ${s.shape}`),D(o%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${s.shape}`);const i={x:s},u={blockSize:t,dataFormat:n};return j.runKernel(km,i,u)}const ix=L({depthToSpace_:ox});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ux(e,t,n,s,r="NHWC",a=[1,1],o){const i=C(e,"x","depthwiseConv2d","float32"),u=C(t,"filter","depthwiseConv2d","float32");let c=i,l=!1;i.rank===3&&(l=!0,c=mt(i,[1,i.shape[0],i.shape[1],i.shape[2]])),D(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),D(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const f=r==="NHWC"?c.shape[3]:c.shape[1];D(f===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${f}) must match the inChannels dimension in filter ${u.shape[2]}.`),ts("depthwiseConv2d",s,o);const d={x:c,filter:u},m={strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:o},g=j.runKernel(xm,d,m);return l?mt(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const Zf=L({depthwiseConv2d_:ux});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cx(e){const n={x:C(e,"x","diag")};return j.runKernel(Nm,n)}const lx=L({diag_:cx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fx(e,t,n,s,r=[1,1],a="NHWC"){const o=C(e,"x","dilation2d"),i=C(t,"filter","dilation2d");D(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),D(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),D(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let u=o,c=!1;o.rank===3&&(u=mt(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0),D(u.shape[3]===i.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${i.shape[2]}`);const l={x:u,filter:i},f={strides:n,pad:s,dilations:r},d=j.runKernel(_m,l,f);return c?mt(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const hx=L({dilation2d_:fx});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ji(e,t){const n=e.length,s=[];for(let r=0;r<n;r++){const a=n-1-r,o=e[a]||1;(t[t.length-1-r]||1)>1&&o===1&&s.unshift(a)}return s}function dx(e,t){const n=[];for(let s=0;s<t.length;s++){const r=e[e.length-s-1],a=t.length-s-1,o=t[a];(r==null||r===1&&o>1)&&n.unshift(a)}return n}function Fe(e,t){const n=Math.max(e.length,t.length),s=new Array(n);for(let r=0;r<n;r++){let a=e[e.length-r-1];a==null&&(a=1);let o=t[t.length-r-1];if(o==null&&(o=1),a===1)s[n-r-1]=o;else if(o===1)s[n-r-1]=a;else if(a!==o){const i=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(i)}else s[n-r-1]=a}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function px(e,t){let n=C(e,"a","equal","string_or_numeric"),s=C(t,"b","equal","string_or_numeric");[n,s]=Ae(n,s),Fe(n.shape,s.shape);const r={a:n,b:s};return j.runKernel(rf,r)}const by=L({equal_:px});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mx(e,t,n){const s=C(t,"a","where"),r=C(n,"b","where"),a=C(e,"condition","where","bool"),o=Fe(Fe(a.shape,s.shape),r.shape),i=io(a,o),u=io(s,o),c=io(r,o),l={condition:i,t:u,e:c};return j.runKernel(gg,l)}const or=L({where_:mx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gx(e){const n={x:C(e,"x","zerosLike")};return j.runKernel(Pg,n)}const Mn=L({zerosLike_:gx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yx(e,t){let n=C(e,"a","div"),s=C(t,"b","div");[n,s]=Ae(n,s);const r=ke(n,s),a=Mn(r),o=by(s,a);return or(o,a,r)}const bx=L({divNoNan_:yx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wx(e,t){const n=C(e,"t1","dot"),s=C(t,"t2","dot");D((n.rank===1||n.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`);const r=n.rank===1?n.size:n.shape[1],a=s.rank===1?s.size:s.shape[0];if(D(r===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${a}.`),n.rank===1&&s.rank===1){const o=mt(n,[1,-1]),i=mt(s,[-1,1]),u=be(o,i);return mt(u,[])}else if(n.rank===1&&s.rank===2){const o=mt(n,[1,-1]),i=mt(s,[s.shape[0],s.shape[1]]),u=be(o,i);return mt(u,[u.size])}else if(n.rank===2&&s.rank===1){const o=mt(s,[-1,1]),i=be(n,o);return mt(i,[i.size])}else{const o=mt(s,[s.shape[0],s.shape[1]]);return be(n,o)}}const vx=L({dot_:wx});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kx(e,...t){const n=t.map((r,a)=>C(r,`tensors${a}`,"einsum")),s={equation:e};return j.runKernel(Tm,n,s)}const la=L({einsum_:kx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xx(e){const n={x:C(e,"x","elu","float32")};return j.runKernel(nf,n)}const wy=L({elu_:xx});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sx(e,t){const n=C(e,"x","ensureShape","string_or_numeric");if(!Aw(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}const Ix=L({ensureShape_:Sx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nx(e){let t=C(e,"x","erf");D(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Pe(t,"float32"));const n={x:t};return j.runKernel(sf,n)}const _x=L({erf_:Nx});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vy(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Tx(e,t,n){const s=e.length+t.length,r=[];let a=0,o=0;for(let i=0;i<s;i++)n.indexOf(i)===-1?r.push(e[a++]):r.push(t[o++]);return r}function zs(e,t){const n=[],s=e.length;for(let a=0;a<s;a++)t.indexOf(a)===-1&&n.push(e[a]);const r=t.map(a=>e[a]);return[n,r]}function es(e,t){const n=t.map(s=>1);return Tx(e,n,t)}function Yr(e,t,n){D(vy(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function ws(e,t){if(vy(e,t))return null;const n=[];for(let s=0;s<t;++s)e.indexOf(s)===-1&&n.push(s);return e.forEach(s=>n.push(s)),n}function ky(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function vs(e,t){const n=[];for(let s=t-e;s<t;++s)n.push(s);return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ex(e,t=null,n=!1){const r={x:C(e,"x","max")},a={reductionIndices:t,keepDims:n};return j.runKernel(zm,r,a)}const ga=L({max_:Ex});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $x(e,t=null,n=!1){const r={x:C(e,"x","min")},a={axis:t,keepDims:n};return j.runKernel(Hm,r,a)}const al=L({min_:$x});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cx(e,t){let n=C(e,"base","pow"),s=C(t,"exp","pow");[n,s]=Ae(n,s);const r={a:n,b:s};return j.runKernel(Ef,r)}const Io=L({pow_:Cx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fe(e,t){if((Gn(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&Gn(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return pr(e,[],[],t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ox(e){const n={x:C(e,"x","sqrt","float32")};return j.runKernel(zf,n)}const Fs=L({sqrt_:Ox});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dx(e){const t=C(e,"x","square"),n={};return j.runKernel("Square",{x:t},n)}const Yn=L({square_:Dx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ax(e,t=null,n=!1){let s=C(e,"x","sum");s.dtype==="bool"&&(s=Pe(s,"int32"));const r={x:s},a={axis:t,keepDims:n};return j.runKernel(bg,r,a)}const Ne=L({sum_:Ax});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fx(e,t="euclidean",n=null,s=!1){e=C(e,"x","norm");const r=xy(e,t,n);let a=r.shape;if(s){const o=Ue(n,e.shape);a=es(r.shape,o)}return mt(r,a)}function xy(e,t,n=null){if(e.rank===0)return Fn(e);if(e.rank!==1&&n===null)return xy(mt(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return Ne(Fn(e),n);if(t===1/0)return ga(Fn(e),n);if(t===-1/0)return al(Fn(e),n);if(t==="euclidean"||t===2)return Fs(Ne(Io(Fn(e),fe(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return ga(Ne(Fn(e),n[0]),n[1]-1);if(t===1/0)return ga(Ne(Fn(e),n[1]),n[0]);if(t===-1/0)return al(Ne(Fn(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return Fs(Ne(Yn(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const ku=L({norm_:Fx});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rx(e,t=null,n=!1){return ku(e,"euclidean",t,n)}const Px=L({euclideanNorm_:Rx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mx(e){const n={x:C(e,"x","exp")};return j.runKernel(af,n)}const jr=L({exp_:Mx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vx(e,t=0){const n=C(e,"x","expandDims","string_or_numeric");D(t<=n.rank,()=>"Axis must be <= rank of the tensor");const s={input:n},r={dim:t};return j.runKernel(Em,s,r)}const Ns=L({expandDims_:Vx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lx(e){const n={x:C(e,"x","expm1")};return j.runKernel(of,n)}const zx=L({expm1_:Lx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bx(e,t){const n=C(e,"x","tile","string_or_numeric");D(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);const s={x:n},r={reps:t};return j.runKernel(Kf,s,r)}const uo=L({tile_:Bx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wx(e,t,n,s="float32"){t==null&&(t=e);const r=ce([e,t],s),a=e<=t?e:t;for(let i=0;i<a;++i)r.set(1,i,i);const o=mt(r.toTensor(),[e,t]);if(n==null)return o;if(n.length===1)return uo(Ns(o,0),[n[0],1,1]);if(n.length===2)return uo(Ns(Ns(o,0),0),[n[0],n[1],1,1]);if(n.length===3)return uo(Ns(Ns(Ns(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const Sy=L({eye_:Wx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jx(e){const n={x:C(e,"x","floor","float32")};return j.runKernel(uf,n)}const Iy=L({floor_:jx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qx(e,t,n=0,s=0){const r=C(e,"x","gather"),a=C(t,"indices","gather","int32"),o={x:r,indices:a},i={axis:n,batchDims:s};return j.runKernel(Am,o,i)}const Ny=L({gather_:qx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hx(e,t){let n=C(e,"a","greater","string_or_numeric"),s=C(t,"b","greater","string_or_numeric");[n,s]=Ae(n,s),Fe(n.shape,s.shape);const r={a:n,b:s};return j.runKernel(lf,r)}const xu=L({greater_:Hx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kx(e,t){let n=C(e,"a","greaterEqual","string_or_numeric"),s=C(t,"b","greaterEqual","string_or_numeric");[n,s]=Ae(n,s),Fe(n.shape,s.shape);const r={a:n,b:s};return j.runKernel(ff,r)}const _y=L({greaterEqual_:Kx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ux(e){const n={input:C(e,"input","imag")};return j.runKernel(Pm,n)}const Su=L({imag_:Ux});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gx(e){const n={x:C(e,"x","isFinite")};return j.runKernel(df,n)}const Xx=L({isFinite_:Gx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yx(e){const n={x:C(e,"x","isInf")};return j.runKernel(pf,n)}const Jx=L({isInf_:Yx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zx(e){const n={x:C(e,"x","isNaN")};return j.runKernel(mf,n)}const Qx=L({isNaN_:Zx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tS(e,t=.2){const s={x:C(e,"x","leakyRelu")},r={alpha:t};return j.runKernel(Mm,s,r)}const Ty=L({leakyRelu_:tS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eS(e,t){let n=C(e,"a","less","string_or_numeric"),s=C(t,"b","less","string_or_numeric");[n,s]=Ae(n,s),Fe(n.shape,s.shape);const r={a:n,b:s};return j.runKernel(gf,r)}const ol=L({less_:eS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nS(e,t){let n=C(e,"a","lessEqual","string_or_numeric"),s=C(t,"b","lessEqual","string_or_numeric");[n,s]=Ae(n,s),Fe(n.shape,s.shape);const r={a:n,b:s};return j.runKernel(yf,r)}const Qf=L({lessEqual_:nS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sS(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const s={start:e,stop:t,num:n};return j.runKernel(Vm,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rS(e,t=5,n=1,s=1,r=.5){const a=C(e,"x","localResponseNormalization");D(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),D(wo(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=a,i=!1;a.rank===3&&(i=!0,o=mt(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const u={x:o},c={depthRadius:t,bias:n,alpha:s,beta:r},l=j.runKernel(Lm,u,c);return i?mt(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const aS=L({localResponseNormalization_:rS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oS(e){const n={x:C(e,"x","log","float32")};return j.runKernel(bf,n)}const No=L({log_:oS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iS(e){const n={x:C(e,"x","log1p")};return j.runKernel(wf,n)}const Ey=L({log1p_:iS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uS(e,t){D(jc(e),()=>"The f passed in variableGrads(f) must be a function"),D(t==null||Array.isArray(t)&&t.every(c=>c instanceof zi),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=t!=null;if(!n){t=[];for(const c in j.registeredVariables)t.push(j.registeredVariables[c])}const s=n?t.filter(c=>!c.trainable):null,r=t.length;t=t.filter(c=>c.trainable),D(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const a=!0,{value:o,grads:i}=j.gradients(e,t,null,a);D(i.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),D(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const u={};return t.forEach((c,l)=>{i[l]!=null&&(u[c.name]=i[l])}),s!=null&&s.forEach(c=>u[c.name]=null),{value:o,grads:u}}function Rs(e){return j.customGrad(e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cS(e){const n={x:C(e,"x","neg")};return j.runKernel(Gm,n)}const hs=L({neg_:cS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lS(e){const n={x:C(e,"x","softplus")};return j.runKernel(Lf,n)}const $y=L({softplus_:lS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fS(e){const t=C(e,"x","logSigmoid");return Rs(s=>({value:hs($y(hs(s))),gradFunc:o=>Pt(o,ma(hs(s)))}))(t)}const hS=L({logSigmoid_:fS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dS(e,t){let n=C(e,"a","sub"),s=C(t,"b","sub");[n,s]=Ae(n,s);const r={a:n,b:s};return j.runKernel(jf,r)}const ae=L({sub_:dS});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pS(e,t=-1){const n=C(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Rs((r,a)=>{const i=ga(r,t,!0),u=ae(r,i),c=ae(Pe(u,"float32"),No(Ne(jr(u),t,!0)));return a([c]),{value:c,gradFunc:(f,d)=>{const[m]=d,g=!0,b=jr(m);return ae(f,Pt(Ne(f,t,g),b))}}})(n)}const mS=L({logSoftmax_:pS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gS(e,t=null,n=!1){const s=C(e,"x","logSumExp"),r=Ue(t,s.shape),a=ga(s,r,!0),o=ae(s,a),i=jr(o),u=Ne(i,r),c=No(u),l=Jt(mt(a,c.shape),c);if(n){const f=es(l.shape,r);return mt(l,f)}return l}const Cy=L({logSumExp_:gS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yS(e,t){const n=C(e,"a","logicalAnd","bool"),s=C(t,"b","logicalAnd","bool");Fe(n.shape,s.shape);const r={a:n,b:s};return j.runKernel(vf,r)}const qi=L({logicalAnd_:yS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bS(e){const n={x:C(e,"x","logicalNot","bool")};return j.runKernel(kf,n)}const Oy=L({logicalNot_:bS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wS(e,t){const n=C(e,"a","logicalOr","bool"),s=C(t,"b","logicalOr","bool");Fe(n.shape,s.shape);const r={a:n,b:s};return j.runKernel(xf,r)}const Dy=L({logicalOr_:wS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vS(e,t){const n=C(e,"a","logicalXor","bool"),s=C(t,"b","logicalXor","bool");return Fe(n.shape,s.shape),qi(Dy(e,t),Oy(qi(e,t)))}const kS=L({logicalXor_:vS});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gi=2147483648;function xS(e,t,n="left"){const s=C(e,"sortedSequence","searchSorted"),r=C(t,"values","searchSorted"),a=s.shape[s.shape.length-1],o=r.shape[r.shape.length-1],i=mt(s,[-1,a]),u=mt(r,[-1,o]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(It(u.shape)>=gi)throw new Error(`values tensor size must less than ${gi}`);if(i.shape[1]>=gi)throw new Error(`trailing dim_size must less than ${gi} for int32 output type, was ${i.shape[1]}`);const c={sortedSequence:i,values:u},l={side:n};return j.runKernel(mg,c,l)}const th=L({searchSorted_:xS});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SS(e,t){return th(e,t,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IS(e,t,n,s,r){const a=C(e,"x","maxPool"),o=1;let i=a,u=!1;a.rank===3&&(u=!0,i=mt(a,[1,a.shape[0],a.shape[1],a.shape[2]])),D(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),D(Qn(n,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),ts("maxPool",s,r);const c={x:i},l={filterSize:t,strides:n,pad:s,dimRoundingMode:r},f=j.runKernel(Bm,c,l);return u?mt(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Ay=L({maxPool_:IS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NS(e,t=[1,1,1],n,s,r,a="NDHWC"){const o=C(e,"x","maxPool3d");let i=o,u=!1;o.rank===4&&(u=!0,i=mt(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),D(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),D(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),ts("maxPool3d",s,r);const c={x:i},l={filterSize:t,strides:n,pad:s,dimRoundingMode:r,dataFormat:a},f=j.runKernel(Wm,c,l);return u?mt(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const _S=L({maxPool3d_:NS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TS(e,t,n,s,r=!1){const o={x:C(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:s,includeBatchInIndex:r},u=j.runKernel(jm,o,i);return{result:u[0],indexes:u[1]}}const ES=L({maxPoolWithArgmax_:TS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $S(e,t){let n=C(e,"a","maximum"),s=C(t,"b","maximum");[n,s]=Ae(n,s),n.dtype==="bool"&&(n=Pe(n,"int32"),s=Pe(s,"int32")),Fe(n.shape,s.shape);const r={a:n,b:s};return j.runKernel(Sf,r)}const Fy=L({maximum_:$S});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CS(e,t=null,n=!1){const r={x:C(e,"x","mean")},a={axis:t,keepDims:n};return j.runKernel(qm,r,a)}const Hi=L({mean_:CS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _a(e,t="float32"){if(Ln(e),t==="complex64"){const s=_a(e,"float32"),r=_a(e,"float32");return ur(s,r)}const n=tn(It(e),t);return j.makeTensor(n,e,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rr(e,t="float32"){if(Ln(e),t==="complex64"){const s=Rr(e,"float32"),r=_a(e,"float32");return ur(s,r)}const n=zl(It(e),t);return j.makeTensor(n,e,t)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OS(e,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let s=C(e,"x","meshgrid",e instanceof cn?e.dtype:"float32");if(t===void 0)return[s];let r=C(t,"y","meshgrid",t instanceof cn?t.dtype:"float32");const a=It(s.shape),o=It(r.shape);return n==="xy"?(s=mt(s,[1,-1]),r=mt(r,[-1,1]),[be(Rr([o,1],s.dtype),s),be(r,Rr([1,a],r.dtype))]):(s=mt(s,[-1,1]),r=mt(r,[1,-1]),[be(s,Rr([1,o],s.dtype)),be(Rr([a,1],r.dtype),r)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DS(e,t){let n=C(e,"a","minimum"),s=C(t,"b","minimum");[n,s]=Ae(n,s),n.dtype==="bool"&&(n=Pe(n,"int32"),s=Pe(s,"int32")),Fe(n.shape,s.shape);const r={a:n,b:s};return j.runKernel(If,r)}const Ki=L({minimum_:DS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AS(e,t,n){D(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const s=C(e,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");D(t.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`);const r=n==="reflect"?1:0;for(let i=0;i<s.rank;i++)D(t[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),D(t[i][0]>=0&&t[i][0]<=s.shape[i]-r&&t[i][1]>=0&&t[i][1]<=s.shape[i]-r,()=>`Padding in dimension ${i} cannot be greater than or equal to ${s.shape[i]-r} or less than 0 for input of shape ${s.shape}`);const a={paddings:t,mode:n},o={x:s};return j.runKernel(Km,o,a)}const FS=L({mirrorPad_:AS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RS(e,t){let n=C(e,"a","mod"),s=C(t,"b","mod");[n,s]=Ae(n,s);const r={a:n,b:s};return j.runKernel(Nf,r)}const PS=L({mod_:RS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MS(e,t=null,n=!1){e=C(e,"x","moments");const s=Ue(t,e.shape),r=Hi(e,s,n);let a=r.shape;n||(a=es(r.shape,s));const o=Yn(ae(Pe(e,"float32"),mt(r,a))),i=Hi(o,s,n);return{mean:r,variance:i}}const VS=L({moments_:MS});function LS(e,t,n,s){const r=C(t,"data","multiRNNCell"),a=Bi(n,"c","multiRNNCell"),o=Bi(s,"h","multiRNNCell");let i=r;const u=[];for(let f=0;f<e.length;f++){const d=e[f](i,a[f],o[f]);u.push(d[0]),u.push(d[1]),i=d[1]}const c=[],l=[];for(let f=0;f<u.length;f+=2)c.push(u[f]),l.push(u[f+1]);return[c,l]}const zS=L({multiRNNCell_:LS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BS(e,t,n,s=!1){const r=C(e,"logits","multinomial"),a=r.size,o=r.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);n=n||Math.random();const u={logits:o===1?mt(r,[1,-1]):r},c={numSamples:t,seed:n,normalized:s},l=j.runKernel(Um,u,c);return o===1?mt(l,[l.size]):l}const WS=L({multinomial_:BS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jS(e,t){let n=C(e,"a","notEqual","string_or_numeric"),s=C(t,"b","notEqual","string_or_numeric");[n,s]=Ae(n,s),Fe(n.shape,s.shape);const r={a:n,b:s};return j.runKernel(Tf,r)}const Ry=L({notEqual_:jS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qS(e,t,n=1,s=0,r="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const o={indices:C(e,"indices","oneHot","int32")},i={dtype:r,depth:t,onValue:n,offValue:s};return j.runKernel(Qm,o,i)}const HS=L({oneHot_:qS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KS(e){const n={x:C(e,"x","onesLike")};return j.runKernel(Zm,n)}const US=L({onesLike_:KS});function GS(e,t){const n=C(e,"v1","outerProduct"),s=C(t,"v2","outerProduct");D(n.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${s.rank}.`);const r=mt(n,[-1,1]),a=mt(s,[1,-1]);return be(r,a)}const XS=L({outerProduct_:GS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YS(e,t,n=0){const s=C(e,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:t,constantValue:n},a={x:s};return j.runKernel(eg,a,r)}const Lo=L({pad_:YS});function JS(e,t,n=0){return D(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),Lo(e,[t],n)}const ZS=L({pad1d_:JS});function QS(e,t,n=0){return D(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Lo(e,t,n)}const tI=L({pad2d_:QS});function eI(e,t,n=0){return D(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Lo(e,t,n)}const nI=L({pad3d_:eI});function sI(e,t,n=0){return D(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Lo(e,t,n)}const rI=L({pad4d_:sI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aI(e,t,n){const s=C(e,"x","spaceToBatchND");D(s.rank>=1+t.length,()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`),D(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),D(s.shape.reduce((o,i,u)=>u>0&&u<=t.length?o&&(i+n[u-1][0]+n[u-1][1])%t[u-1]===0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);const r={x:s},a={blockShape:t,paddings:n};return j.runKernel(wg,r,a)}const Py=L({spaceToBatchND_:aI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oI(e,t,n,s,r,a,o){r==null&&(r=[1,1]),a==null&&(a=1),s===0&&(s="valid");const i=C(e,"x","maxPool");let u=i,c=!1;i.rank===3&&(c=!0,u=mt(i,[1,i.shape[0],i.shape[1],i.shape[2]])),D(Qn(a,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${r}'`);const l=Va(u.shape,t,a,r,s),f=[l.dilationHeight,l.dilationWidth];let d;s==="same"?d=uI([l.filterHeight,l.filterWidth],f):d=[[0,0],[0,0]];const m=f[0]===1&&f[1]===1,[g,b]=iI([l.inHeight,l.inWidth],f,d),w=m?s:"valid",k=m?u:Py(u,f,g),_=(n==="avg"?()=>py(k,t,a,w,o):()=>Ay(k,t,a,w,o))(),I=m?_:my(_,f,b);return c?mt(I,[I.shape[1],I.shape[2],I.shape[3]]):I}function iI(e,t,n){const s=n.map(l=>l[0]),r=n.map(l=>l[1]),a=e.concat(s,r),o=t.map((l,f)=>(l-a[f]%l)%l),i=r.map((l,f)=>l+o[f]),u=t.map((l,f)=>[s[f],i[f]]),c=t.map((l,f)=>[0,o[f]]);return[u,c]}function uI(e,t){const s=e.map((o,i)=>o+(o-1)*(t[i]-1)).map(o=>o-1),r=s.map(o=>Math.floor(o/2)),a=s.map((o,i)=>o-r[i]);return s.map((o,i)=>[r[i],a[i]])}const cI=L({pool_:oI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lI(e,t){const n=C(e,"x","prelu"),s=C(t,"alpha","prelu"),r={x:n,alpha:s};return j.runKernel(ng,r)}const My=L({prelu_:lI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fI(e,t=null,n=!1){let s=C(e,"x","prod");s.dtype==="bool"&&(s=Pe(s,"int32"));const r={x:s},a={axis:t,keepDims:n};return j.runKernel(sg,r,a)}const hI=L({prod_:fI});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dI(e,t,n,s){const r=e.map((l,f)=>C(l,`tensors${f}`,"raggedGather","int32")),a=C(t,"paramsDenseValues","raggedGather"),o=C(n,"indices","raggedGather","int32"),i={paramsNestedSplits:r,paramsDenseValues:a,indices:o},u={outputRaggedRank:s},c=j.runKernel(rg,i,u);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const pI=L({raggedGather_:dI});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mI(e,t,n){const s=C(e,"starts","raggedRange"),r=C(t,"limits","raggedRange",s.dtype),a=C(n,"deltas","raggedRange",s.dtype),o={starts:s,limits:r,deltas:a},i=j.runKernel(ag,o);return{rtNestedSplits:i[0],rtDenseValues:i[1]}}const gI=L({raggedRange_:mI});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yI(e,t,n,s,r){const a=C(e,"shape","raggedTensorToTensor","int32"),o=C(t,"values","raggedTensorToTensor"),i=C(n,"defaultValue","raggedTensorToTensor",o.dtype),u=s.map((f,d)=>C(f,`tensors${d}`,"raggedTensorToTensor","int32")),c={shape:a,values:o,defaultValue:i,rowPartitionTensors:u},l={rowPartitionTypes:r};return j.runKernel(og,c,l)}const bI=L({raggedTensorToTensor_:yI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wI(e,t,n){Ln(e);const s=It(e);let r=null;if(n==null||n==="float32")r=new Float32Array(s);else if(n==="int32")r=new Int32Array(s);else if(n==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${n}`);for(let a=0;a<s;a++)r[a]=t();return j.makeTensor(r,e,n)}const vI=L({rand_:wI});var _i={exports:{}},kI=_i.exports,Rd;function xI(){return Rd||(Rd=1,function(e){(function(t,n,s){function r(u){var c=this,l=i();c.next=function(){var f=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=f-(c.c=f|0)},c.c=1,c.s0=l(" "),c.s1=l(" "),c.s2=l(" "),c.s0-=l(u),c.s0<0&&(c.s0+=1),c.s1-=l(u),c.s1<0&&(c.s1+=1),c.s2-=l(u),c.s2<0&&(c.s2+=1),l=null}function a(u,c){return c.c=u.c,c.s0=u.s0,c.s1=u.s1,c.s2=u.s2,c}function o(u,c){var l=new r(u),f=c&&c.state,d=l.next;return d.int32=function(){return l.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,f&&(typeof f=="object"&&a(f,l),d.state=function(){return a(l,{})}),d}function i(){var u=4022871197,c=function(l){l=String(l);for(var f=0;f<l.length;f++){u+=l.charCodeAt(f);var d=.02519603282416938*u;u=d>>>0,d-=u,d*=u,u=d>>>0,d-=u,u+=d*4294967296}return(u>>>0)*23283064365386963e-26};return c}n&&n.exports?n.exports=o:this.alea=o})(kI,e)}(_i)),_i.exports}var Ti={exports:{}},SI=Ti.exports,Pd;function II(){return Pd||(Pd=1,function(e){(function(t,n,s){function r(i){var u=this,c="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var f=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^f^f>>>8},i===(i|0)?u.x=i:c+=i;for(var l=0;l<c.length+64;l++)u.x^=c.charCodeAt(l)|0,u.next()}function a(i,u){return u.x=i.x,u.y=i.y,u.z=i.z,u.w=i.w,u}function o(i,u){var c=new r(i),l=u&&u.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var d=c.next()>>>11,m=(c.next()>>>0)/4294967296,g=(d+m)/(1<<21);while(g===0);return g},f.int32=c.next,f.quick=f,l&&(typeof l=="object"&&a(l,c),f.state=function(){return a(c,{})}),f}n&&n.exports?n.exports=o:this.xor128=o})(SI,e)}(Ti)),Ti.exports}var Ei={exports:{}},NI=Ei.exports,Md;function _I(){return Md||(Md=1,function(e){(function(t,n,s){function r(i){var u=this,c="";u.next=function(){var f=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(f^f<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,i===(i|0)?u.x=i:c+=i;for(var l=0;l<c.length+64;l++)u.x^=c.charCodeAt(l)|0,l==c.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function a(i,u){return u.x=i.x,u.y=i.y,u.z=i.z,u.w=i.w,u.v=i.v,u.d=i.d,u}function o(i,u){var c=new r(i),l=u&&u.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var d=c.next()>>>11,m=(c.next()>>>0)/4294967296,g=(d+m)/(1<<21);while(g===0);return g},f.int32=c.next,f.quick=f,l&&(typeof l=="object"&&a(l,c),f.state=function(){return a(c,{})}),f}n&&n.exports?n.exports=o:this.xorwow=o})(NI,e)}(Ei)),Ei.exports}var $i={exports:{}},TI=$i.exports,Vd;function EI(){return Vd||(Vd=1,function(e){(function(t,n,s){function r(i){var u=this;u.next=function(){var l=u.x,f=u.i,d,m;return d=l[f],d^=d>>>7,m=d^d<<24,d=l[f+1&7],m^=d^d>>>10,d=l[f+3&7],m^=d^d>>>3,d=l[f+4&7],m^=d^d<<7,d=l[f+7&7],d=d^d<<13,m^=d^d<<9,l[f]=m,u.i=f+1&7,m};function c(l,f){var d,m=[];if(f===(f|0))m[0]=f;else for(f=""+f,d=0;d<f.length;++d)m[d&7]=m[d&7]<<15^f.charCodeAt(d)+m[d+1&7]<<13;for(;m.length<8;)m.push(0);for(d=0;d<8&&m[d]===0;++d);for(d==8?m[7]=-1:m[d],l.x=m,l.i=0,d=256;d>0;--d)l.next()}c(u,i)}function a(i,u){return u.x=i.x.slice(),u.i=i.i,u}function o(i,u){i==null&&(i=+new Date);var c=new r(i),l=u&&u.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var d=c.next()>>>11,m=(c.next()>>>0)/4294967296,g=(d+m)/(1<<21);while(g===0);return g},f.int32=c.next,f.quick=f,l&&(l.x&&a(l,c),f.state=function(){return a(c,{})}),f}n&&n.exports?n.exports=o:this.xorshift7=o})(TI,e)}($i)),$i.exports}var Ci={exports:{}},$I=Ci.exports,Ld;function CI(){return Ld||(Ld=1,function(e){(function(t,n,s){function r(i){var u=this;u.next=function(){var l=u.w,f=u.X,d=u.i,m,g;return u.w=l=l+1640531527|0,g=f[d+34&127],m=f[d=d+1&127],g^=g<<13,m^=m<<17,g^=g>>>15,m^=m>>>12,g=f[d]=g^m,u.i=d,g+(l^l>>>16)|0};function c(l,f){var d,m,g,b,w,k=[],N=128;for(f===(f|0)?(m=f,f=null):(f=f+"\0",m=0,N=Math.max(N,f.length)),g=0,b=-32;b<N;++b)f&&(m^=f.charCodeAt((b+32)%f.length)),b===0&&(w=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,b>=0&&(w=w+1640531527|0,d=k[b&127]^=m+w,g=d==0?g+1:0);for(g>=128&&(k[(f&&f.length||0)&127]=-1),g=127,b=4*128;b>0;--b)m=k[g+34&127],d=k[g=g+1&127],m^=m<<13,d^=d<<17,m^=m>>>15,d^=d>>>12,k[g]=m^d;l.w=w,l.X=k,l.i=g}c(u,i)}function a(i,u){return u.i=i.i,u.w=i.w,u.X=i.X.slice(),u}function o(i,u){i==null&&(i=+new Date);var c=new r(i),l=u&&u.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var d=c.next()>>>11,m=(c.next()>>>0)/4294967296,g=(d+m)/(1<<21);while(g===0);return g},f.int32=c.next,f.quick=f,l&&(l.X&&a(l,c),f.state=function(){return a(c,{})}),f}n&&n.exports?n.exports=o:this.xor4096=o})($I,e)}(Ci)),Ci.exports}var Oi={exports:{}},OI=Oi.exports,zd;function DI(){return zd||(zd=1,function(e){(function(t,n,s){function r(i){var u=this,c="";u.next=function(){var f=u.b,d=u.c,m=u.d,g=u.a;return f=f<<25^f>>>7^d,d=d-m|0,m=m<<24^m>>>8^g,g=g-f|0,u.b=f=f<<20^f>>>12^d,u.c=d=d-m|0,u.d=m<<16^d>>>16^g,u.a=g-f|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,i===Math.floor(i)?(u.a=i/4294967296|0,u.b=i|0):c+=i;for(var l=0;l<c.length+20;l++)u.b^=c.charCodeAt(l)|0,u.next()}function a(i,u){return u.a=i.a,u.b=i.b,u.c=i.c,u.d=i.d,u}function o(i,u){var c=new r(i),l=u&&u.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var d=c.next()>>>11,m=(c.next()>>>0)/4294967296,g=(d+m)/(1<<21);while(g===0);return g},f.int32=c.next,f.quick=f,l&&(typeof l=="object"&&a(l,c),f.state=function(){return a(c,{})}),f}n&&n.exports?n.exports=o:this.tychei=o})(OI,e)}(Oi)),Oi.exports}var Di={exports:{}};const AI={},FI=Object.freeze(Object.defineProperty({__proto__:null,default:AI},Symbol.toStringTag,{value:"Module"})),RI=cv(FI);var PI=Di.exports,Bd;function MI(){return Bd||(Bd=1,function(e){(function(t,n,s){var r=256,a=6,o=52,i="random",u=s.pow(r,a),c=s.pow(2,o),l=c*2,f=r-1,d;function m(I,$,O){var R=[];$=$==!0?{entropy:!0}:$||{};var W=k(w($.entropy?[I,_(n)]:I??N(),3),R),P=new g(R),M=function(){for(var T=P.g(a),q=u,X=0;T<c;)T=(T+X)*r,q*=r,X=P.g(1);for(;T>=l;)T/=2,q/=2,X>>>=1;return(T+X)/q};return M.int32=function(){return P.g(4)|0},M.quick=function(){return P.g(4)/4294967296},M.double=M,k(_(P.S),n),($.pass||O||function(T,q,X,st){return st&&(st.S&&b(st,P),T.state=function(){return b(P,{})}),X?(s[i]=T,q):T})(M,W,"global"in $?$.global:this==s,$.state)}function g(I){var $,O=I.length,R=this,W=0,P=R.i=R.j=0,M=R.S=[];for(O||(I=[O++]);W<r;)M[W]=W++;for(W=0;W<r;W++)M[W]=M[P=f&P+I[W%O]+($=M[W])],M[P]=$;(R.g=function(T){for(var q,X=0,st=R.i,et=R.j,nt=R.S;T--;)q=nt[st=f&st+1],X=X*r+nt[f&(nt[st]=nt[et=f&et+q])+(nt[et]=q)];return R.i=st,R.j=et,X})(r)}function b(I,$){return $.i=I.i,$.j=I.j,$.S=I.S.slice(),$}function w(I,$){var O=[],R=typeof I,W;if($&&R=="object")for(W in I)try{O.push(w(I[W],$-1))}catch{}return O.length?O:R=="string"?I:I+"\0"}function k(I,$){for(var O=I+"",R,W=0;W<O.length;)$[f&W]=f&(R^=$[f&W]*19)+O.charCodeAt(W++);return _($)}function N(){try{var I;return d&&(I=d.randomBytes)?I=I(r):(I=new Uint8Array(r),(t.crypto||t.msCrypto).getRandomValues(I)),_(I)}catch{var $=t.navigator,O=$&&$.plugins;return[+new Date,t,O,t.screen,_(n)]}}function _(I){return String.fromCharCode.apply(0,I)}if(k(s.random(),n),e.exports){e.exports=m;try{d=RI}catch{}}else s["seed"+i]=m})(typeof self<"u"?self:PI,[],Math)}(Di)),Di.exports}var Tc,Wd;function VI(){if(Wd)return Tc;Wd=1;var e=xI(),t=II(),n=_I(),s=EI(),r=CI(),a=DI(),o=MI();return o.alea=e,o.xor128=t,o.xorwow=n,o.xorshift7=s,o.xor4096=r,o.tychei=a,Tc=o,Tc}var Iu=VI();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eh{constructor(t,n,s,r,a){this.mean=t,this.stdDev=n,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=a||Math.random();this.random=Iu.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let t,n,s=!1;for(;!s;){let r,a,o;do r=2*this.random()-1,a=2*this.random()-1,o=r*r+a*a;while(o>=1||o===0);const i=Math.sqrt(-2*Math.log(o)/o);t=this.mean+this.stdDev*r*i,n=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(t))&&(s=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class LI{constructor(t,n,s,r){this.alpha=t,this.beta=1/n,this.dtype=s;const a=r||Math.random();this.randu=Iu.alea(a.toString()),this.randn=new eh(0,1,s,!1,this.randu()),t<1?this.d=t+2/3:this.d=t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,n,s,r,a,o;for(;;){do r=this.randn.nextValue(),o=1+this.c*r;while(o<=0);if(o*=o*o,t=r*r,n=1-.331*t*t,s=.5*t+this.d*(1-o+Math.log(o)),a=this.randu(),a<n||Math.log(a)<s)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(t){return this.dtype==="float32"?t:Math.round(t)}}class zI{constructor(t=0,n=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=n-t,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${n} <= 1 and dtype is not float`);this.random=Iu.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BI(e,t,n=1,s="float32",r){if(Ln(e),n==null&&(n=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const a=new LI(t,n,s,r),o=ce(e,s);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const WI=L({randomGamma_:BI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jI(e,t=0,n=1,s,r){if(Ln(e),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const a=new eh(t,n,s,!1,r),o=ce(e,s);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const Vy=L({randomNormal_:jI});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qI(e,t,n){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return Vy(e,0,1,t,n)}const HI=L({randomStandardNormal_:qI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KI(e,t=0,n=1,s="float32",r){Ln(e);const a=ce(e,s),o=new zI(t,n,null,r);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const nh=L({randomUniform_:KI});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UI(e,t,n,s){return nh(e,t,n,"int32",s)}const GI=L({randomUniformInt_:UI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _o(e,t,n=1,s="float32"){if(n===0)throw new Error("Cannot have a step of zero");const r={start:e,stop:t,step:n,dtype:s};return j.runKernel(ig,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XI(e){const n={input:C(e,"input","real")};return j.runKernel(ug,n)}const To=L({real_:XI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YI(e){const n={x:C(e,"x","reciprocal")};return j.runKernel($f,n)}const JI=L({reciprocal_:YI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZI(e){const n={x:C(e,"x","relu")};return j.runKernel(Cf,n)}const Nu=L({relu_:ZI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QI(e){const n={x:C(e,"x","relu6")};return j.runKernel(Of,n)}const Ly=L({relu6_:QI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tN(e,t){const s={x:C(e,"x","reverse")},r={dims:t};return j.runKernel(hg,s,r)}const qr=L({reverse_:tN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eN(e){const t=C(e,"x","reverse");return D(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),qr(t,0)}const nN=L({reverse1d_:eN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sN(e,t){const n=C(e,"x","reverse");return D(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),qr(n,t)}const rN=L({reverse2d_:sN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aN(e,t){const n=C(e,"x","reverse");return D(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),qr(n,t)}const oN=L({reverse3d_:aN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iN(e,t){const n=C(e,"x","reverse");return D(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),qr(n,t)}const uN=L({reverse4d_:iN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cN(e){const n={x:C(e,"x","round")};return j.runKernel(Df,n)}const zy=L({round_:cN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lN(e){const n={x:C(e,"x","rsqrt","float32")};return j.runKernel(Af,n)}const fN=L({rsqrt_:lN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hN(e){const n={x:C(e,"x","selu")};return j.runKernel(Ff,n)}const dN=L({selu_:hN});function pN(e,t,n,s,r,a=[1,1],o="NHWC"){const i=C(e,"x","separableConv2d"),u=C(t,"depthwiseFilter","separableConv2d"),c=C(n,"pointwiseFilter","separableConv2d");let l=i,f=!1;if(i.rank===3&&(f=!0,l=mt(i,[1,i.shape[0],i.shape[1],i.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");D(l.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${l.rank}.`),D(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),D(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),D(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),D(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const d=u.shape[2],m=u.shape[3];D(c.shape[2]===d*m,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*m}, but got ${c.shape[2]}.`);const g=Zf(l,u,s,r,o,a),w=vu(g,c,1,"valid",o);return f?mt(w,[w.shape[1],w.shape[2],w.shape[3]]):w}const mN=L({separableConv2d_:pN});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function gN(e,t){const n=C(e,"x","setdiff1d"),s=C(t,"y","setdiff1d");D(n.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${s.dtype}).`),D(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),D(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await n.data(),a=await s.data(),o=new Set(a);let i=0;for(let l=0;l<r.length;l++)o.has(r[l])||i++;const u=new je([i],n.dtype),c=new je([i],"int32");for(let l=0,f=0;l<r.length;l++)o.has(r[l])||(u.values[f]=r[l],c.values[f]=l,f++);return[u.toTensor(),c.toTensor()]}const yN=gN;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bN(e){const n={x:C(e,"x","sign")};return j.runKernel(Mf,n)}const wN=L({sign_:bN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vN(e){const n={x:C(e,"x","sin","float32")};return j.runKernel(Rf,n)}const kN=L({sin_:vN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xN(e){const n={x:C(e,"x","sinh")};return j.runKernel(Pf,n)}const SN=L({sinh_:xN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IN(e,t,n){const s=C(e,"x","slice1d");return D(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),ve(s,[t],[n])}const NN=L({slice1d_:IN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _N(e,t,n){const s=C(e,"x","slice2d");return D(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),ve(s,t,n)}const TN=L({slice2d_:_N});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EN(e,t,n){const s=C(e,"x","slice3d");return D(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),ve(s,t,n)}const $N=L({slice3d_:EN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CN(e,t,n){const s=C(e,"x","slice4d");return D(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),ve(s,t,n)}const ON=L({slice4d_:CN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DN(e,t=-1){const n=C(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const s={logits:n},r={dim:t};return j.runKernel(kg,s,r)}const AN=L({softmax_:DN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FN(e){D(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);const t={input:e};return j.runKernel($m,t)}const sh=L({fft_:FN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RN(e){D(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);const t={input:e};return j.runKernel(Rm,t)}const Ui=L({ifft_:RN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PN(e){const t=e.shape[e.shape.length-1],n=e.size/t;let s;if(t<=2){const r=mt(e,[n,t]);s=Ui(r)}else{const r=[n,2*(t-1)],a=mt(To(e),[n,t]),o=mt(Su(e),[n,t]),i=qr(ve(a,[0,1],[n,t-2]),1),u=Pt(qr(ve(o,[0,1],[n,t-2]),1),fe(-1)),c=dn([a,i],1),l=dn([o,u],1),f=mt(ur(c,l),[r[0],r[1]]);s=Ui(f)}if(s=To(s),e.rank===3&&e.shape[0]!==0){const r=s,a=e.shape[0];s=mt(s,[a,s.shape[0]/a,s.shape[1]]),r.dispose()}return s}const By=L({irfft_:PN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MN(e,t,n=0){const r={x:C(e,"x","split")},a={numOrSizeSplits:t,axis:n};return j.runKernel(vg,r,a)}const Eo=L({split_:MN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VN(e,t){D(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1];const s=e.size/n;let r;if(t!=null&&t<n){const g=e.shape.map(w=>0),b=e.shape.map(w=>w);b[e.shape.length-1]=t,r=ve(e,g,b),n=t}else if(t!=null&&t>n){const g=e.shape.map(b=>b);g[e.shape.length-1]=t-n,r=dn([e,_a(g)],e.shape.length-1),n=t}else r=e;const a=Mn(r),o=mt(ur(r,a),[s,n]),i=sh(o),u=Math.floor(n/2)+1,c=To(i),l=Su(i),f=Eo(c,[u,n-u],c.shape.length-1),d=Eo(l,[u,n-u],l.shape.length-1),m=r.shape.slice();return m[r.shape.length-1]=u,mt(ur(f[0],d[0]),m)}const rh=L({rfft_:VN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LN(e,t){let n=C(e,"a","squaredDifference"),s=C(t,"b","squaredDifference");[n,s]=Ae(n,s),Fe(n.shape,s.shape);const r={a:n,b:s},a={};return j.runKernel(Bf,r,a)}const Wy=L({squaredDifference_:LN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zN(e,t){const n=C(e,"x","squeeze","string_or_numeric");return mt(n,Rw(n.shape,t).newShape)}const ah=L({squeeze_:zN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BN(e,t=0){const n=Bi(e,"tensors","stack","string_or_numeric");D(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&D(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");const s=n,r={axis:t};return j.runKernel(tg,s,r)}const Ps=L({stack_:BN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WN(e,t=0){const s={x:C(e,"x","step")},r={alpha:t};return j.runKernel(Uf,s,r)}const jy=L({step_:WN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jN(e,t,n,s,r=0,a=0,o=0,i=0,u=0){const l={x:C(e,"x","stridedSlice","string_or_numeric")},f={begin:t,end:n,strides:s,beginMask:r,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};return j.runKernel(Tg,l,f)}const qN=L({stridedSlice_:jN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HN(e){const n={x:C(e,"x","tan","float32")};return j.runKernel(qf,n)}const KN=L({tan_:HN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jn(e,t){Ra(e);const n=dr(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return pr(e,null,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function co(e,t,n){if(Ra(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=dr(e,n);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return pr(e,t,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qy(e,t,n){if(Ra(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=dr(e,n);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return pr(e,t,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UN(e,t,n){if(Ra(e),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=dr(e,n);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return pr(e,t,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GN(e,t,n){if(Ra(e),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=dr(e,n);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return pr(e,t,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XN(e,t,n){if(Ra(e),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=dr(e,n);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||s,pr(e,t,s,n)}function YN(e,t,n){const s=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${s}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(a+` update.rank < ${r}. `);if(e.length<s+(n.rank-r))throw new Error(a+` Output shape length < ${s+(n.rank-r)}`);if(n.rank!==r+e.length-s)throw new Error(a+` update.rank != ${r+e.length-s}`);for(let o=0;o<r;++o)if(n.shape[o]!==t.shape[o])throw new Error(a+` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<n.rank-r;++o)if(n.shape[o+r]!==e[o+s])throw new Error(a+` updates.shape[${o+r}] (${n.shape[o+r]}) != shape[${o+r}] (${e[o+r]})`)}function Hy(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}YN(n,t,e)}function oh(e,t,n){const s=t.shape.length,r=s>1?t.shape[s-1]:1,a=n.length;let o=1;for(let f=r;f<a;++f)o*=n[f];const i=r<1?1:r,u=It(t.shape)/i,c=[...Kt(n.slice(0,r)),1],l=It(n);return{sliceRank:r,numUpdates:u,sliceSize:o,strides:c,outputSize:l}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JN(e,t,n){const s=C(e,"tensor","tensorScatterupdate"),r=C(t,"indices","tensorScatterupdate","int32"),a=C(n,"updates","tensorScatterupdate");if(Hy(a,r,s.shape),s.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${a.dtype}.`);const o={tensor:s,indices:r,updates:a},i={};return j.runKernel(pg,o,i)}const ZN=L({tensorScatterUpdate_:JN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QN(e,t=1,n=!0){const s=C(e,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);const a={x:s},o={k:t,sorted:n},[i,u]=j.runKernel(Og,a,o);return{values:i,indices:u}}const t_=L({topk_:QN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e_(e,t=0,n=1,s,r){if(Ln(e),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const a=new eh(t,n,s,!0,r),o=ce(e,s);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const n_=L({truncatedNormal_:e_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s_(e,t=0){const n=C(e,"x","unique","string_or_numeric");D(n.rank>0,()=>"The input tensor must be at least 1D");const s={x:n},r={axis:t},[a,o]=j.runKernel(Ag,s,r);return{values:a,indices:o}}const r_=L({unique_:s_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a_(e,t,n){const s=C(e,"x","unsortedSegmentSum"),r=C(t,"segmentIds","unsortedSegmentSum","int32");D(wo(n),()=>"numSegments must be of dtype int");const a={x:s,segmentIds:r},o={numSegments:n};return j.runKernel(Rg,a,o)}const o_=L({unsortedSegmentSum_:a_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i_(e,t=0){const n=C(e,"x","unstack","string_or_numeric");D(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);const s={value:n},r={axis:t};return j.runKernel(Fg,s,r)}const Jr=L({unstack_:i_});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u_(e,t){return th(e,t,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c_(e,t=!0,n,s){return j.makeVariable(e,t,n,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ky(e,t){const n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);const s=ce(e,"int32"),r=ce([n.length,e.length],"int32");for(let a=0;a<n.length;a++){const o=s.indexToLoc(n[a]),i=a*e.length;r.values.set(o,i)}return r.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function l_(e){const t=C(e,"condition","whereAsync","bool"),n=await t.data(),s=Ky(t.shape,n);return e!==t&&t.dispose(),s}const Uy=l_;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function f_(e,t,n){const s=C(e,"tensor","boolMask"),r=C(t,"mask","boolMask","bool"),a=n??0,o=r.rank,i=s.shape;D(o>0,()=>"mask cannot be scalar"),Vn(i.slice(a,a+o),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let b=a;b<a+o;b++)u*=i[b];const c=i.slice(0,a).concat([u],i.slice(a+o)),l=mt(s,c),f=mt(r,[-1]),d=await Uy(f),m=ah(d,[1]),g=Ny(l,m,a);return e!==s&&s.dispose(),t!==r&&r.dispose(),m.dispose(),l.dispose(),f.dispose(),d.dispose(),g}const h_=f_;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d_(e,t,n){const s=C(e,"x","transpose");if(t==null&&(t=s.shape.map((o,i)=>i).reverse()),D(s.rank===t.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${t}.`),t.forEach(o=>{D(o>=0&&o<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${t}`)}),s.rank<=1)return s.clone();const r={x:s},a={perm:t};return s.dtype==="complex64"?de(()=>{let o=To(s),i=Su(s);return o=j.runKernel(Si,{x:o},a),i=j.runKernel(Si,{x:i},a),n&&(i=hs(i)),ur(o,i)}):j.runKernel(Si,r,a)}const il=L({transpose_:d_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p_(e,t,n,s,r=!0){const a=C(e,"v","movingAverage"),o=C(t,"x","movingAverage"),i=C(n,"decay","movingAverage");Ev(a,o),D(Un(a.shape,o.shape),()=>"Shape mismatch in v and x");const u=fe(1),c=ae(u,i);let l=Pt(ae(o,a),c);if(r){D(s!=null,()=>"When using zeroDebias: true, step is required.");const f=C(s,"step","movingAverage");l=ke(l,ae(u,Io(i,f)))}return Jt(a,l)}const m_=L({movingAverage_:p_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g_(e,t,n){Ln(n);const s=C(e,"indices","scatterND","int32"),r=C(t,"updates","scatterND");Hy(r,s,n);const a={indices:s,updates:r},o={shape:n};return j.runKernel(dg,a,o)}const y_=L({scatterND_:g_});function b_(e,t,n,s){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const r=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const o=t.size;if(!(t.rank===0||t.rank===1&&o===r))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${r}]`);if(t.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w_(e,t,n,s=0){Ln(n);const r=C(e,"sparseIndices","sparseToDense","int32"),a=C(t,"sparseValues","sparseToDense","string_or_numeric"),o=C(s,"defaultValue","sparseToDense",a.dtype);b_(r,a,n,o);const i={sparseIndices:r,sparseValues:a,defaultValue:o},u={outputShape:n};return j.runKernel(_g,i,u)}const v_=L({sparseToDense_:w_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k_(e,t){const n=C(t,"indices","gatherND","int32"),r={params:C(e,"x","gatherND","string_or_numeric"),indices:n};return j.runKernel(Fm,r)}const x_=L({gatherND_:k_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S_(e,t){if(t==null)return e.shape.slice();if(Un(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let s=0;s<e.shape.length;s++)t[s]==null&&e.shape[s]!=null?n.push(e.shape[s]):n.push(t[s]);return n}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I_(e,t,n,s){const r=C(e,"x","dropout");if(D(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),D(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof cn?r.clone():r;const a=S_(r,n),o=1-t,i=ke(Iy(Jt(nh(a,0,1,"float32",s),o)),o);return Pt(r,i)}const N_=L({dropout_:I_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gy(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function ih(e,t,n){const s=1-e%2,r=new Float32Array(e);for(let a=0;a<e;++a){const o=2*Math.PI*a/(e+s-1);r[a]=t-n*Math.cos(o)}return jn(r,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function __(e,t,n=1){const s=C(e,"predictions","inTopK"),r=C(t,"targets","inTopK");D(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),D(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),Vn(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=s.shape[s.shape.length-1];D(n>0&&n<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`);const o=await s.data(),i=await r.data(),[u,c]=[o.length/a,a],l=mn("bool",u);for(let f=0;f<u;f++){const d=f*c,m=o.subarray(d,d+c),g=[];for(let b=0;b<m.length;b++)g.push({value:m[b],index:b});g.sort((b,w)=>w.value-b.value),l[f]=0;for(let b=0;b<n;b++)if(g[b].index===i[f]){l[f]=1;break}}return e!==s&&s.dispose(),t!==r&&r.dispose(),fs(l,r.shape,"bool")}const T_=__;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E_(e,t,n,s,r,a="NHWC",o){let i=e;e.rank===3&&(i=mt(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;u.rank===3&&(u=mt(t,[1,t.shape[0],t.shape[1],t.shape[2]])),D(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),D(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),D(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const c=a==="NHWC"?i.shape[3]:i.shape[1],l=a==="NHWC"?u.shape[3]:u.shape[1];D(c===n[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`),D(l===n[3],()=>`Error in conv2dDerFilter: depth of dy (${l}) must match output depth for filter (${n[3]}).`),ts("conv2dDerFilter",r,o);const f={x:i,dy:u},d={strides:s,pad:r,dataFormat:a,dimRoundingMode:o,filterShape:n};return j.runKernel(dm,f,d)}const $_=L({conv2DBackpropFilter_:E_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uh(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return Pt(e,jy(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function ch(e,t){let n=t;const s=dx(e.shape,t.shape);return s.length>0&&(n=Ne(n,s)),mt(n,e.shape)}function lh(e,t,n,s){if(t==="linear")return e;if(t==="relu")return Nu(e);if(t==="elu")return wy(e);if(t==="relu6")return Ly(e);if(t==="prelu")return My(e,n);if(t==="leakyrelu")return Ty(e,s);if(t==="sigmoid")return ma(e);throw new Error(`Unknown fused activation ${t}.`)}const fh=(e,t)=>!(e>0)||t==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C_({x:e,filter:t,strides:n,pad:s,dataFormat:r="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:l}){if(u=u||"linear",fh(j.state.gradientDepth,u)===!1){D(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let O=vu(e,t,n,s,r,a,o);return i!=null&&(O=Jt(O,i)),lh(O,u,c,l)}const f=C(e,"x","conv2d","float32"),d=C(t,"filter","conv2d","float32");let m=f,g=!1;f.rank===3&&(g=!0,m=mt(f,[1,f.shape[0],f.shape[1],f.shape[2]])),D(m.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${m.rank}.`),D(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),ts("fused conv2d",s,o);const b=r==="NHWC"?m.shape[3]:m.shape[1];D(d.shape[2]===b,()=>`Error in conv2d: depth of input (${b}) must match input depth for filter ${d.shape[2]}.`),D(Qn(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);const w=bs(m.shape,d.shape,n,a,s,o);let k;i!=null&&(k=C(i,"bias","fused conv2d"),[k]=Ae(k,f),r==="NHWC"?Fe(w.outShape,k.shape):(D(k.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${k.shape.length}.`),D(k.shape.length===0||k.shape[0]===w.outChannels||k.shape[0]===1,()=>`Error in fused conv2d: bias shape (${k.shape}) is not compatible with the number of output channels (${w.outChannels})`)));let N;if(c!=null){const O=c.shape;if(D(O.length<=1||O.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${O.length}.`),O.length===1)D(O[0]===1||O[0]===w.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${O}) is not compatible with the number of output channels (${w.outChannels}).`);else if(O.length===3)try{Fe(O,w.outShape)}catch{const W=`Error in fused conv2d: PReLU activation weights (${O}) is not compatible with the output shape of the conv2d (${w.outShape}).`;throw Error(W)}N=C(c,"prelu weights","fused conv2d")}const _=(O,R)=>{D(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[W,P,M,T]=R,q=uh(O,M,u);D(Wi(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const X=yy(P.shape,q,W,n,s),st=$_(P,q,W.shape,n,s),et=[X,st];if(T!=null){const nt=ch(T,q);et.push(nt)}return et},I={x:m,filter:d,bias:k,preluActivationWeights:N},$={strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:o,activation:u,leakyreluAlpha:l};return i==null?Rs((R,W,P)=>{let M=j.runKernel(Hc,I,$);return P([W,R,M]),g&&(M=mt(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:_}})(m,d):Rs((R,W,P,M)=>{let T=j.runKernel(Hc,I,$);return M([W,R,T,P]),g&&(T=mt(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:_}})(m,d,k)}const O_=L({fusedConv2d_:C_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D_(e,t,n,s,r,a=[1,1],o){let i=e;e.rank===3&&(i=mt(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;u.rank===3&&(u=mt(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={x:i,dy:u},l={strides:s,pad:r,dimRoundingMode:o,dilations:a,filterShape:n};return j.runKernel(Sm,c,l)}const A_=L({depthwiseConv2dNativeBackpropFilter_:D_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F_(e,t,n,s,r,a=[1,1],o){let i=t,u=!1;t.rank===3&&(u=!0,i=mt(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={dy:i,filter:n},l={strides:s,pad:r,dimRoundingMode:o,dilations:a,inputShape:e},f=j.runKernel(Im,c,l);return u?mt(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const R_=L({depthwiseConv2dNativeBackpropInput_:F_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P_({x:e,filter:t,strides:n,pad:s,dataFormat:r="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:l}){if(fh(j.state.gradientDepth,u)===!1){let $=Zf(e,t,n,s,r,a,o);return i!=null&&($=Jt($,i)),lh($,u,c,l)}const f=C(e,"x","depthwiseConv2d","float32"),d=C(t,"filter","depthwiseConv2d","float32");let m=f,g=!1;f.rank===3&&(g=!0,m=mt(f,[1,f.shape[0],f.shape[1],f.shape[2]])),D(m.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${m.rank}.`),D(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),D(m.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${m.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),a==null&&(a=[1,1]),D(Qn(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),ts("fused depthwiseConv2d",s,o);const b=bs(m.shape,d.shape,n,a,s,o,!0);let w;i!=null&&(w=C(i,"bias","fused conv2d"),[w]=Ae(w,f),Fe(b.outShape,w.shape));let k;c!=null&&(k=C(c,"prelu weights","fused depthwiseConv2d"));const N=($,O)=>{D(Wi(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[R,W,P,M]=O,T=uh($,P,u),q=R_(W.shape,T,R,n,s,a,o),X=A_(W,T,R.shape,n,s,a,o);if(M!=null){const st=ch(w,T);return[q,X,st]}return[q,X]},_={x:m,filter:d,bias:w,preluActivationWeights:k},I={strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:o,activation:u,leakyreluAlpha:l};return i==null?Rs((O,R,W)=>{let P=j.runKernel(Kc,_,I);return W([R,O,P]),g&&(P=mt(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:N}})(m,d):Rs((O,R,W,P)=>{let M=j.runKernel(Kc,_,I);return P([R,O,M,W]),g&&(M=mt(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:N}})(m,d,w)}const M_=L({fusedDepthwiseConv2d_:P_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V_({a:e,b:t,transposeA:n=!1,transposeB:s=!1,bias:r,activation:a="linear",preluActivationWeights:o,leakyreluAlpha:i=.2}){if(fh(j.state.gradientDepth,a)===!1){let T=be(e,t,n,s);return r!=null&&(T=Jt(T,r)),lh(T,a,o,i)}let u=C(e,"a","fused matMul"),c=C(t,"b","fused matMul");[u,c]=Ae(u,c);const l=n?u.shape[u.rank-2]:u.shape[u.rank-1],f=s?c.shape[c.rank-1]:c.shape[c.rank-2],d=n?u.shape[u.rank-1]:u.shape[u.rank-2],m=s?c.shape[c.rank-2]:c.shape[c.rank-1],g=u.shape.slice(0,-2),b=c.shape.slice(0,-2),w=It(g),k=It(b);D(l===f,()=>`Error in fused matMul: inner shapes (${l}) and (${f}) of Tensors with shapes ${u.shape} and ${c.shape} and transposeA=${n} and transposeB=${s} must match.`);const _=Fe(u.shape.slice(0,-2),c.shape.slice(0,-2)).concat([d,m]),I=n?mt(u,[w,l,d]):mt(u,[w,d,l]),$=s?mt(c,[k,m,f]):mt(c,[k,f,m]);let O;r!=null&&(O=C(r,"bias","fused matMul"),[O]=Ae(O,u),Fe(_,O.shape));let R;o!=null&&(R=C(o,"prelu weights","fused matMul"));const W=(T,q)=>{const[X,st,et,nt]=q,ot=uh(mt(T,et.shape),et,a);let tt,ct;if(!n&&!s?(tt=be(ot,st,!1,!0),ct=be(X,ot,!0,!1)):!n&&s?(tt=be(ot,st,!1,!1),ct=be(ot,X,!0,!1)):n&&!s?(tt=be(st,ot,!1,!0),ct=be(X,ot,!1,!1)):(tt=be(st,ot,!0,!0),ct=be(ot,X,!0,!0)),r!=null){const ht=ch(nt,ot);return[tt,ct,ht]}else return[tt,ct]},P={a:I,b:$,bias:O,preluActivationWeights:R},M={transposeA:n,transposeB:s,activation:a,leakyreluAlpha:i};return r==null?Rs((q,X,st)=>{const et=j.runKernel(qc,P,M);return st([q,X,et]),{value:mt(et,_),gradFunc:W}})(I,$):Rs((q,X,st,et)=>{const nt=j.runKernel(qc,P,M);return et([q,X,nt,st]),{value:mt(nt,_),gradFunc:W}})(I,$,O)}const L_=L({fusedMatMul_:V_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z_=Object.freeze(Object.defineProperty({__proto__:null,conv2d:O_,depthwiseConv2d:M_,matMul:L_},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B_(e){return ih(e,.54,.46)}const W_=L({hammingWindow_:B_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j_(e){return ih(e,.5,.5)}const Xy=L({hannWindow_:j_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q_(e,t,n,s=!1,r=0){let a=0;const o=[];for(;a+t<=e.size;)o.push(ve(e,a,t)),a+=n;if(s)for(;a<e.size;){const i=a+t-e.size,u=dn([ve(e,a,t-i),Vo([i],r)]);o.push(u),a+=n}return o.length===0?co([],[0,t]):mt(dn(o),[o.length,t])}const Yy=L({frame_:q_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H_(e,t,n,s,r=Xy){s==null&&(s=Gy(t));const a=Yy(e,t,n),o=Pt(a,r(t));return rh(o,s)}const K_=L({stft_:H_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U_(e,t,n,s,r="bilinear",a=0){const o=C(e,"image","cropAndResize"),i=C(t,"boxes","cropAndResize","float32"),u=C(n,"boxInd","cropAndResize","int32"),c=i.shape[0];D(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),D(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${i.shape}.`),D(u.rank===1&&u.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${i.shape}.`),D(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),D(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),D(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const l={image:o,boxes:i,boxInd:u},f={method:r,extrapolationValue:a,cropSize:s};return j.runKernel(wm,l,f)}const G_=L({cropAndResize_:U_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X_(e){const t=C(e,"image","flipLeftRight","float32");D(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const n={image:t};return j.runKernel(Om,n,{})}const Y_=L({flipLeftRight_:X_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J_(e){const t=C(e,"image","grayscaleToRGB"),n=t.rank-1,s=t.shape[n];D(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),D(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,uo(t,r)}const Z_=L({grayscaleToRGB_:J_});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q_(e){const t=C(e,"image","RGBToGrayscale"),n=t.rank-1,s=t.shape[n];D(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),D(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=t.dtype,a=Pe(t,"float32"),o=jn([.2989,.587,.114]);let i;switch(t.rank){case 2:i=la("ij,j->i",a,o);break;case 3:i=la("ijk,k->ij",a,o);break;case 4:i=la("ijkl,l->ijk",a,o);break;case 5:i=la("ijklm,m->ijkl",a,o);break;case 6:i=la("ijklmn,n->ijklm",a,o);break;default:throw new Error("Not a valid tensor rank.")}return i=Ns(i,-1),Pe(i,r)}const tT=L({rgbToGrayscale_:Q_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eT(e,t,n=0,s=.5){const r=C(e,"image","rotateWithOffset","float32");D(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const a={image:r},o={radians:t,fillValue:n,center:s};return j.runKernel(Mg,a,o)}const nT=L({rotateWithOffset_:eT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function La(e,t,n,s,r,a){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),a==null&&(a=0);const o=e.shape[0];return n=Math.min(n,o),D(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),D(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),D(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),D(t.rank===1,()=>"scores must be a 1D tensor"),D(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),D(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sT(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY){const a=C(e,"boxes","nonMaxSuppression","float32"),o=C(t,"scores","nonMaxSuppression","float32"),i=La(a,o,n,s,r);n=i.maxOutputSize,s=i.iouThreshold,r=i.scoreThreshold;const u={maxOutputSize:n,iouThreshold:s,scoreThreshold:r};return j.runKernel(Xm,{boxes:a,scores:o},u)}const rT=L({nonMaxSuppression_:sT});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aT(e,t,n){const s=oT(e,t,n),r=s<0?-(s+1):s;e.splice(r,0,t)}function oT(e,t,n){return uT(e,t,n||iT)}function iT(e,t){return e>t?1:e<t?-1:0}function uT(e,t,n){let s=0,r=e.length,a=0,o=!1;for(;s<r;){a=s+(r-s>>>1);const i=n(t,e[a]);i>0?s=a+1:(r=a,o=!i)}return o?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jy(e,t,n,s,r){return hh(e,t,n,s,r,0)}function Zy(e,t,n,s,r,a){return hh(e,t,n,s,r,0,!1,a,!0)}function Qy(e,t,n,s,r,a){return hh(e,t,n,s,r,a,!0)}function hh(e,t,n,s,r,a,o=!1,i=!1,u=!1){const c=[];for(let w=0;w<t.length;w++)t[w]>r&&c.push({score:t[w],boxIndex:w,suppressBeginIndex:0});c.sort(jd);const l=a>0?-.5/a:0,f=[],d=[];for(;f.length<n&&c.length>0;){const w=c.pop(),{score:k,boxIndex:N,suppressBeginIndex:_}=w;if(k<r)break;let I=!1;for(let $=f.length-1;$>=_;--$){const O=cT(e,N,f[$]);if(O>=s){I=!0;break}if(w.score=w.score*lT(s,l,O),w.score<=r)break}w.suppressBeginIndex=f.length,I||(w.score===k?(f.push(N),d.push(w.score)):w.score>r&&aT(c,w,jd))}const m=f.length,g=n-m;i&&g>0&&(f.push(...new Array(g).fill(0)),d.push(...new Array(g).fill(0)));const b={selectedIndices:f};return o&&(b.selectedScores=d),u&&(b.validOutputs=m),b}function cT(e,t,n){const s=e.subarray(t*4,t*4+4),r=e.subarray(n*4,n*4+4),a=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),i=Math.max(s[0],s[2]),u=Math.max(s[1],s[3]),c=Math.min(r[0],r[2]),l=Math.min(r[1],r[3]),f=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),m=(i-a)*(u-o),g=(f-c)*(d-l);if(m<=0||g<=0)return 0;const b=Math.max(a,c),w=Math.max(o,l),k=Math.min(i,f),N=Math.min(u,d),_=Math.max(k-b,0)*Math.max(N-w,0);return _/(m+g-_)}function lT(e,t,n){const s=Math.exp(t*n*n);return n<=e?s:0}function jd(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function fT(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY){const a=C(e,"boxes","nonMaxSuppressionAsync"),o=C(t,"scores","nonMaxSuppressionAsync"),i=La(a,o,n,s,r);n=i.maxOutputSize,s=i.iouThreshold,r=i.scoreThreshold;const u=await Promise.all([a.data(),o.data()]),c=u[0],l=u[1],{selectedIndices:f}=Jy(c,l,n,s,r);return a!==e&&a.dispose(),o!==t&&o.dispose(),jn(f,"int32")}const hT=fT;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dT(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,a=0){const o=C(e,"boxes","nonMaxSuppression"),i=C(t,"scores","nonMaxSuppression"),u=La(o,i,n,s,r,a);n=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,a=u.softNmsSigma;const c={boxes:o,scores:i},l={maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:a},f=j.runKernel(Jm,c,l);return{selectedIndices:f[0],selectedScores:f[1]}}const pT=L({nonMaxSuppressionWithScore_:dT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function mT(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,a=0){const o=C(e,"boxes","nonMaxSuppressionAsync"),i=C(t,"scores","nonMaxSuppressionAsync"),u=La(o,i,n,s,r,a);n=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,a=u.softNmsSigma;const c=await Promise.all([o.data(),i.data()]),l=c[0],f=c[1],{selectedIndices:d,selectedScores:m}=Qy(l,f,n,s,r,a);return o!==e&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:jn(d,"int32"),selectedScores:jn(m)}}const gT=mT;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yT(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,a=!1){const o=C(e,"boxes","nonMaxSuppression"),i=C(t,"scores","nonMaxSuppression"),u=La(o,i,n,s,r,null),c=u.maxOutputSize,l=u.iouThreshold,f=u.scoreThreshold,d={boxes:o,scores:i},m={maxOutputSize:c,iouThreshold:l,scoreThreshold:f,padToMaxOutputSize:a},g=j.runKernel(Ym,d,m);return{selectedIndices:g[0],validOutputs:g[1]}}const bT=L({nonMaxSuppressionPadded_:yT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function wT(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,a=!1){const o=C(e,"boxes","nonMaxSuppressionAsync"),i=C(t,"scores","nonMaxSuppressionAsync"),u=La(o,i,n,s,r,null),c=u.maxOutputSize,l=u.iouThreshold,f=u.scoreThreshold,[d,m]=await Promise.all([o.data(),i.data()]),{selectedIndices:g,validOutputs:b}=Zy(d,m,c,l,f,a);return o!==e&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:jn(g,"int32"),validOutputs:fe(b,"int32")}}const vT=wT;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kT(e,t,n=!1,s=!1){const r=C(e,"images","resizeBilinear");D(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),D(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),D(s===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=r,o=!1;r.rank===3&&(o=!0,a=mt(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const i={images:a},u={alignCorners:n,halfPixelCenters:s,size:t},c=j.runKernel(fg,i,u);return o?mt(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const xT=L({resizeBilinear_:kT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ST(e,t,n=!1,s=!1){const r=C(e,"images","resizeNearestNeighbor");D(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),D(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),D(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),D(s===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=r,o=!1;r.rank===3&&(o=!0,a=mt(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const i={images:a},u={alignCorners:n,halfPixelCenters:s,size:t},c=j.runKernel(lg,i,u);return o?mt(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const IT=L({resizeNearestNeighbor_:ST});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NT(e,t="binary",n=!1,s=.5){const r=C(e,"image","threshold"),a=.2989,o=.587,i=.114,u=r.shape[0]*r.shape[1];let c=Pt(jn([s]),255),l,f,d,m;if(D(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),D(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),D(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),D(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),r.shape[2]===3){[l,f,d]=Eo(r,[1,1,1],-1);const w=Pt(l,a),k=Pt(f,o),N=Pt(d,i);m=Jt(Jt(w,k),N)}else m=e;if(t==="otsu"){const w=gy(Pe(zy(m),"int32"),fs([]),256);c=_T(w,u)}const g=n?Qf(m,c):xu(m,c);return Pe(Pt(g,255),"int32")}function _T(e,t){let n=jn([-1]),s=jn([0]),r=jn([0]),a,o,i,u,c,l;for(let f=0;f<e.size-1;f++){a=ve(e,0,f+1),o=ve(e,f+1),c=ke(Ne(a),t),l=ke(Ne(o),t);const d=Ne(Pt(a,_o(0,a.size)));i=ke(d,Ne(a));const m=Vo(o.shape,a.size),g=Jt(_o(0,o.size),m),b=Pt(o,g);u=ke(Ne(b),Ne(o));const w=ae(i,u),k=ae(i,u),N=Pt(c,l);r=Pt(Pt(N,w),k);const _=xu(r,s);s=or(_,r,s),n=or(_,jn([f]),n)}return n}const TT=L({threshold_:NT});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ET(e,t,n="nearest",s="constant",r=0,a){const o=C(e,"image","transform","float32"),i=C(t,"transforms","transform","float32");D(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),D(i.rank===2&&(i.shape[0]===o.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),D(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const u={image:o,transforms:i},c={interpolation:n,fillMode:s,fillValue:r,outputShape:a};return j.runKernel(Dg,u,c)}const $T=L({transform_:ET});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CT(e,t,n){const s=C(e,"a","bandPart");D(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[a,o]=s.shape.slice(-2);let i,u;typeof t=="number"?(D(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),D(t<=a,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`),i=C(t<0?a:t,"numLower","bandPart")):(D(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),i=or(ol(t,0),a,Ki(t,a))),typeof n=="number"?(D(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),D(n<=o,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`),u=C(n<0?o:n,"numUpper","bandPart")):(D(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=or(ol(n,0),o,Ki(n,o)));const c=mt(_o(0,a,1,"int32"),[-1,1]),l=_o(0,o,1,"int32"),f=ae(c,l),d=qi(Qf(f,i),_y(f,hs(u))),m=_a([a,o],s.dtype);return mt(Ps(Jr(mt(s,[-1,a,o])).map(g=>or(d,g,m))),r)}const OT=L({bandPart_:CT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DT(e){let t;if(Array.isArray(e)){t=!1,D(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=e[0].shape[0];for(let a=1;a<e.length;++a)D(e[a].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[a].shape[0]} vs. ${r})`)}else t=!0,e=Eo(e,e.shape[0],0).map(r=>ah(r,[0]));D(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);const n=[],s=e;for(let r=0;r<e.length;++r)n.push(j.tidy(()=>{let a=s[r];if(r>0)for(let o=0;o<r;++o){const i=Pt(Ne(Pt(n[o],a)),n[o]);a=ae(a,i)}return ke(a,ku(a,"euclidean"))}));return t?Ps(n,0):n}const AT=L({gramSchmidt_:DT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FT(e,t=!1){if(D(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return qd(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce((u,c)=>u*c),s=Jr(mt(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],a=[];s.forEach(u=>{const[c,l]=qd(u,t);r.push(c),a.push(l)});const o=mt(Ps(r,0),e.shape),i=mt(Ps(a,0),e.shape);return[o,i]}}function qd(e,t=!1){return j.tidy(()=>{D(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);const n=e.shape[0],s=e.shape[1];let r=Sy(n),a=ar(e);const o=co([[1]],[1,1]);let i=ar(o);const u=n>=s?s:n;for(let c=0;c<u;++c){const l=a,f=i,d=r;[i,a,r]=j.tidy(()=>{const m=ve(a,[c,c],[n-c,1]),g=ku(m),b=ve(a,[c,c],[1,1]),w=or(xu(b,0),co([[-1]]),co([[1]])),k=ae(b,Pt(w,g)),N=ke(m,k);N.shape[0]===1?i=ar(o):i=dn([o,ve(N,[1,0],[N.shape[0]-1,N.shape[1]])],0);const _=hs(ke(be(w,k),g)),I=ve(a,[c,0],[n-c,s]),$=Pt(_,i),O=il(i);if(c===0)a=ae(I,be($,be(O,I)));else{const P=ae(I,be($,be(O,I)));a=dn([ve(a,[0,0],[c,s]),P],0)}const R=il($),W=ve(r,[0,c],[n,r.shape[1]-c]);if(c===0)r=ae(W,be(be(W,i),R));else{const P=ae(W,be(be(W,i),R));r=dn([ve(r,[0,0],[n,c]),P],1)}return[i,a,r]}),Sn([l,f,d])}return!t&&n>s&&(r=ve(r,[0,0],[n,s]),a=ve(a,[0,0],[s,s])),[r,a]})}const RT=L({qr_:FT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var kn;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(kn||(kn={}));function PT(e,t,n=kn.SUM_BY_NONZERO_WEIGHTS){const s=C(e,"losses","computeWeightedLoss");let r=null;t!=null&&(r=C(t,"weights","computeWeightedLoss"));const a=r==null?s:Pt(s,r);if(n===kn.NONE)return a;if(n===kn.SUM)return Ne(a);if(n===kn.MEAN){if(r==null)return Hi(a);{const o=s.size/r.size,i=ke(Ne(a),Ne(r));return o>1?ke(i,fe(o)):i}}if(n===kn.SUM_BY_NONZERO_WEIGHTS){if(r==null)return ke(Ne(a),fe(s.size));{const o=Pt(r,Rr(s.shape)),i=Pe(Ne(Ry(o,fe(0))),"float32");return ke(Ne(a),i)}}throw Error(`Unknown reduction: ${n}`)}const Bs=L({computeWeightedLoss_:PT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MT(e,t,n,s=kn.SUM_BY_NONZERO_WEIGHTS){const r=C(e,"labels","absoluteDifference"),a=C(t,"predictions","absoluteDifference");let o=null;n!=null&&(o=C(n,"weights","absoluteDifference")),Vn(r.shape,a.shape,"Error in absoluteDifference: ");const i=Fn(ae(r,a));return Bs(i,o,s)}const VT=L({absoluteDifference_:MT});function LT(e,t,n,s,r=kn.SUM_BY_NONZERO_WEIGHTS){const a=C(e,"labels","cosineDistance"),o=C(t,"predictions","cosineDistance");let i=null;s!=null&&(i=C(s,"weights","cosineDistance")),Vn(a.shape,o.shape,"Error in cosineDistance: ");const u=fe(1),c=ae(u,Ne(Pt(a,o),n,!0));return Bs(c,i,r)}const zT=L({cosineDistance_:LT});function BT(e,t,n,s=kn.SUM_BY_NONZERO_WEIGHTS){let r=C(e,"labels","hingeLoss");const a=C(t,"predictions","hingeLoss");let o=null;n!=null&&(o=C(n,"weights","hingeLoss")),Vn(r.shape,a.shape,"Error in hingeLoss: ");const i=fe(1);r=ae(Pt(fe(2),r),i);const u=Nu(ae(i,Pt(r,a)));return Bs(u,o,s)}const WT=L({hingeLoss_:BT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jT(e,t,n,s=1,r=kn.SUM_BY_NONZERO_WEIGHTS){const a=C(e,"labels","huberLoss"),o=C(t,"predictions","huberLoss");let i=null;n!=null&&(i=C(n,"weights","huberLoss")),Vn(a.shape,o.shape,"Error in huberLoss: ");const u=fe(s),c=Fn(ae(o,a)),l=Ki(c,u),f=ae(c,l),d=Jt(Pt(fe(.5),Yn(l)),Pt(u,f));return Bs(d,i,r)}const qT=L({huberLoss_:jT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HT(e,t,n,s=1e-7,r=kn.SUM_BY_NONZERO_WEIGHTS){const a=C(e,"labels","logLoss"),o=C(t,"predictions","logLoss");let i=null;n!=null&&(i=C(n,"weights","logLoss")),Vn(a.shape,o.shape,"Error in logLoss: ");const u=fe(1),c=fe(s),l=hs(Pt(a,No(Jt(o,c)))),f=Pt(ae(u,a),No(Jt(ae(u,o),c))),d=ae(l,f);return Bs(d,i,r)}const KT=L({logLoss_:HT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UT(e,t,n,s=kn.SUM_BY_NONZERO_WEIGHTS){const r=C(e,"labels","meanSquaredError"),a=C(t,"predictions","meanSquaredError");let o=null;n!=null&&(o=C(n,"weights","meanSquaredError")),Vn(r.shape,a.shape,"Error in meanSquaredError: ");const i=Wy(r,a);return Bs(i,o,s)}const GT=L({meanSquaredError_:UT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XT(e,t){const n=C(e,"labels","sigmoidCrossEntropyWithLogits"),s=C(t,"logits","sigmoidCrossEntropyWithLogits");Vn(n.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=Nu(s),a=Pt(s,n),o=Ey(jr(hs(Fn(s))));return Jt(ae(r,a),o)}function YT(e,t,n,s=0,r=kn.SUM_BY_NONZERO_WEIGHTS){let a=C(e,"multiClassLabels","sigmoidCrossEntropy");const o=C(t,"logits","sigmoidCrossEntropy");let i=null;if(n!=null&&(i=C(n,"weights","sigmoidCrossEntropy")),Vn(a.shape,o.shape,"Error in sigmoidCrossEntropy: "),s>0){const c=fe(s),l=fe(1),f=fe(.5);a=Jt(Pt(a,ae(l,c)),Pt(f,c))}const u=XT(a,o);return Bs(u,i,r)}const JT=L({sigmoidCrossEntropy_:YT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZT(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return Rs((r,a,o)=>{const u=Cy(a,[n],!0),c=ae(Pe(a,"float32"),u);o([r,c]);const l=hs(Pt(c,r));return{value:Ne(l,[n]),gradFunc:(m,g)=>{const[b,w]=g,k=es(m.shape,[n]);return[Pt(mt(m,k),ae(Pe(b,"float32"),jr(w))),Pt(mt(m,k),ae(jr(w),Pe(b,"float32")))]}}})(e,t)}function QT(e,t,n,s=0,r=kn.SUM_BY_NONZERO_WEIGHTS){let a=C(e,"onehotLabels","softmaxCrossEntropy");const o=C(t,"logits","softmaxCrossEntropy");let i=null;if(n!=null&&(i=C(n,"weights","softmaxCrossEntropy")),Vn(a.shape,o.shape,"Error in softmaxCrossEntropy: "),s>0){const c=fe(s),l=fe(1),f=fe(a.shape[1]);a=Jt(Pt(a,ae(l,c)),ke(c,f))}const u=ZT(a,o);return Bs(u,i,r)}const tE=L({softmaxCrossEntropy_:QT});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eE(e,t,n,s){const r=C(e,"indices","sparseFillEmptyRows","int32"),a=C(t,"values","sparseFillEmptyRows"),o=C(n,"denseShape","sparseFillEmptyRows","int32"),i=C(s,"defaultValue","sparseFillEmptyRows",a.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const u={indices:r,values:a,denseShape:o,defaultValue:i},c=j.runKernel(xg,u);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const nE=L({sparseFillEmptyRows_:eE});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sE(e,t,n){const s=C(e,"inputIndices","sparseReshape","int32"),r=C(t,"inputShape","sparseReshape","int32"),a=C(n,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const o={inputIndices:s,inputShape:r,newShape:a},i=j.runKernel(Sg,o);return{outputIndices:i[0],outputShape:i[1]}}const rE=L({sparseReshape_:sE});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aE(e,t,n){const s=C(e,"data","sparseSegmentMean"),r=C(t,"indices","sparseSegmentMean","int32"),a=C(n,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);const o={data:s,indices:r,segmentIds:a};return j.runKernel(Ig,o)}const oE=L({sparseSegmentMean_:aE});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iE(e,t,n){const s=C(e,"data","sparseSegmentSum"),r=C(t,"indices","sparseSegmentSum","int32"),a=C(n,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);const o={data:s,indices:r,segmentIds:a};return j.runKernel(Ng,o)}const uE=L({sparseSegmentSum_:iE});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cE(e,t,n,s,r,a,o,i){const u=C(e,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);const c=C(t,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const l={separator:n,nGramWidths:s,leftPad:r,rightPad:a,padWidth:o,preserveShortSequences:i},f={data:u,dataSplits:c},d=j.runKernel(Eg,f,l);return{nGrams:d[0],nGramsSplits:d[1]}}const lE=L({stringNGrams_:cE});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fE(e,t,n=!0){const s=C(e,"input","stringSplit","string"),r=C(t,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const a={skipEmpty:n},o={input:s,delimiter:r},i=j.runKernel($g,o,a);return{indices:i[0],values:i[1],shape:i[2]}}const hE=L({stringSplit_:fE});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dE(e,t){const n=C(e,"input","stringToHashBucketFast","string"),s={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const r={input:n};return j.runKernel(Cg,r,s)}const pE=L({stringToHashBucketFast_:dE});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mE(e,t,n,s=!0){const r=C(e,"input","staticRegexReplace","string"),a={pattern:t,rewrite:n,replaceGlobal:s};return j.runKernel(Wf,{x:r},a)}const gE=L({staticRegexReplace_:mE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yE={fft:sh,ifft:Ui,rfft:rh,irfft:By},bE={hammingWindow:W_,hannWindow:Xy,frame:Yy,stft:K_},wE={flipLeftRight:Y_,grayscaleToRGB:Z_,resizeNearestNeighbor:IT,resizeBilinear:xT,rgbToGrayscale:tT,rotateWithOffset:nT,cropAndResize:G_,nonMaxSuppression:rT,nonMaxSuppressionAsync:hT,nonMaxSuppressionWithScore:pT,nonMaxSuppressionWithScoreAsync:gT,nonMaxSuppressionPadded:bT,nonMaxSuppressionPaddedAsync:vT,threshold:TT,transform:$T},vE={bandPart:OT,gramSchmidt:AT,qr:RT},kE={absoluteDifference:VT,computeWeightedLoss:Bs,cosineDistance:zT,hingeLoss:WT,huberLoss:qT,logLoss:KT,meanSquaredError:GT,sigmoidCrossEntropy:JT,softmaxCrossEntropy:tE},xE={sparseFillEmptyRows:nE,sparseReshape:rE,sparseSegmentMean:oE,sparseSegmentSum:uE},SE={stringNGrams:lE,stringSplit:hE,stringToHashBucketFast:pE,staticRegexReplace:gE};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IE=new Map,NE=new Map;class _E{getClassName(){return this.constructor.className}static fromConfig(t,n){return new t(n)}}class Dr{constructor(){this.classNameMap={}}static getMap(){return Dr.instance==null&&(Dr.instance=new Dr),Dr.instance}static register(t){Dr.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function TE(e,t,n){D(e.className!=null,()=>"Class being registered does not have the static className property defined."),D(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),D(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof n>"u"&&(n=e.className);const s=n,r=t+">"+s;return Dr.register(e),IE.set(r,e),NE.set(e,r),e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zr extends _E{minimize(t,n=!1,s){const{value:r,grads:a}=this.computeGradients(t,s);if(s!=null){const o=s.map(i=>({name:i.name,tensor:a[i.name]}));this.applyGradients(o)}else this.applyGradients(a);return Sn(a),n?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,n){return uS(t,n)}dispose(){this.iterations_!=null&&Sn(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:fe(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(Zr,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EE extends Zr{static get className(){return"Adadelta"}constructor(t,n,s=null){super(),this.learningRate=t,this.rho=n,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=j.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const a=j.registeredVariables[s],o=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:de(()=>Mn(a).variable(o))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:de(()=>Mn(a).variable(o))});const i=Array.isArray(t)?t[r].tensor:t[s];if(i==null)return;const u=this.accumulatedGrads[r].variable,c=this.accumulatedUpdates[r].variable;de(()=>{const l=Jt(Pt(u,this.rho),Pt(Yn(i),1-this.rho)),f=Pt(ke(Fs(Jt(c,this.epsilon)),Fs(Jt(u,this.epsilon))),i),d=Jt(Pt(c,this.rho),Pt(Yn(f),1-this.rho));u.assign(l),c.assign(d);const m=Jt(Pt(f,-this.learningRate),a);a.assign(m)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Sn(this.accumulatedGrads.map(t=>t.variable)),Sn(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=t.length/2,s=!1;this.accumulatedGrads=t.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=t.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.rho,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $E extends Zr{static get className(){return"Adagrad"}constructor(t,n=.1){super(),this.learningRate=t,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const a=j.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:de(()=>Vo(a.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(t)?t[r].tensor:t[s];if(o==null)return;const i=this.accumulatedGrads[r].variable;de(()=>{const u=Jt(i,Yn(o));i.assign(u);const c=Jt(Pt(ke(o,Fs(Jt(u,j.backend.epsilon()))),-this.learningRate),a);a.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Sn(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=!1;this.accumulatedGrads=t.map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,n){return new t(n.learningRate,n.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CE extends Zr{static get className(){return"Adam"}constructor(t,n,s,r=null){super(),this.learningRate=t,this.beta1=n,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],de(()=>{this.accBeta1=fe(n).variable(),this.accBeta2=fe(s).variable()}),r==null&&(this.epsilon=j.backend.epsilon())}applyGradients(t){const n=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);de(()=>{const s=ae(1,this.accBeta1),r=ae(1,this.accBeta2);n.forEach((a,o)=>{const i=j.registeredVariables[a],u=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${a}/m`,variable:de(()=>Mn(i).variable(u))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${a}/v`,variable:de(()=>Mn(i).variable(u))});const c=Array.isArray(t)?t[o].tensor:t[a];if(c==null)return;const l=this.accumulatedFirstMoment[o].variable,f=this.accumulatedSecondMoment[o].variable,d=Jt(Pt(l,this.beta1),Pt(c,1-this.beta1)),m=Jt(Pt(f,this.beta2),Pt(Yn(c),1-this.beta2)),g=ke(d,s),b=ke(m,r);l.assign(d),f.assign(m);const w=Jt(Pt(ke(g,Jt(Fs(b),this.epsilon)),-this.learningRate),i);i.assign(w)}),this.accBeta1.assign(Pt(this.accBeta1,this.beta1)),this.accBeta2.assign(Pt(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Sn(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&Sn(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t),de(()=>{this.accBeta1.assign(Io(this.beta1,this.iterations_+1)),this.accBeta2.assign(Io(this.beta2,this.iterations_+1))});const n=t.length/2,s=!1;this.accumulatedFirstMoment=t.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=t.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OE extends Zr{static get className(){return"Adamax"}constructor(t,n,s,r=null,a=0){super(),this.learningRate=t,this.beta1=n,this.beta2=s,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],de(()=>{this.iteration=fe(0).variable(),this.accBeta1=fe(n).variable()}),r==null&&(this.epsilon=j.backend.epsilon())}applyGradients(t){const n=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);de(()=>{const s=ae(1,this.accBeta1),r=ke(-this.learningRate,Jt(Pt(this.iteration,this.decay),1));n.forEach((a,o)=>{const i=j.registeredVariables[a],u=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${a}/m`,variable:Mn(i).variable(u)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${a}/v`,variable:Mn(i).variable(u)});const c=Array.isArray(t)?t[o].tensor:t[a];if(c==null)return;const l=this.accumulatedFirstMoment[o].variable,f=this.accumulatedWeightedInfNorm[o].variable,d=Jt(Pt(l,this.beta1),Pt(c,1-this.beta1)),m=Pt(f,this.beta2),g=Fn(c),b=Fy(m,g);l.assign(d),f.assign(b);const w=Jt(Pt(ke(r,s),ke(d,Jt(b,this.epsilon))),i);i.assign(w)}),this.iteration.assign(Jt(this.iteration,1)),this.accBeta1.assign(Pt(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Sn(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&Sn(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tb extends Zr{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const a=Array.isArray(t)?t[r].tensor:t[s];if(a==null)return;const o=j.registeredVariables[s];de(()=>{const i=Jt(Pt(this.c,a),o);o.assign(i)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=cs(fe(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,n){return new t(n.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DE extends tb{static get className(){return"Momentum"}constructor(t,n,s=!1){super(t),this.learningRate=t,this.momentum=n,this.useNesterov=s,this.accumulations=[],this.m=fe(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const a=j.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:de(()=>Mn(a).variable(!1))});const o=this.accumulations[r].variable,i=Array.isArray(t)?t[r].tensor:t[s];i!=null&&de(()=>{let u;const c=Jt(Pt(this.m,o),i);this.useNesterov?u=Jt(Pt(this.c,Jt(i,Pt(c,this.m))),a):u=Jt(Pt(this.c,c),a),o.assign(c),a.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Sn(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=!1;this.accumulations=t.map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,n){return new t(n.learningRate,n.momentum,n.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AE extends Zr{static get className(){return"RMSProp"}constructor(t,n=.9,s=0,r=null,a=!1){if(super(),this.learningRate=t,this.decay=n,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,r==null&&(this.epsilon=j.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const a=j.registeredVariables[s],o=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:de(()=>Mn(a).variable(o))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:de(()=>Mn(a).variable(o))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:de(()=>Mn(a).variable(o))});const i=Array.isArray(t)?t[r].tensor:t[s];if(i==null)return;const u=this.accumulatedMeanSquares[r].variable,c=this.accumulatedMoments[r].variable;de(()=>{const l=Jt(Pt(u,this.decay),Pt(Yn(i),1-this.decay));if(this.centered){const f=this.accumulatedMeanGrads[r].variable,d=Jt(Pt(f,this.decay),Pt(i,1-this.decay)),m=ke(Pt(i,this.learningRate),Fs(ae(l,Jt(Yn(d),this.epsilon)))),g=Jt(Pt(c,this.momentum),m);u.assign(l),f.assign(d),c.assign(g);const b=ae(a,g);a.assign(b)}else{const f=Jt(Pt(u,this.decay),Pt(Yn(i),1-this.decay)),d=Jt(Pt(c,this.momentum),ke(Pt(i,this.learningRate),Fs(Jt(f,this.epsilon))));u.assign(f),c.assign(d);const m=ae(a,d);a.assign(m)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Sn(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Sn(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&Sn(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=this.centered?t.length/3:t.length/2,s=!1;this.accumulatedMeanSquares=t.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=t.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=t.slice(n*2,n*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,n){return new t(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FE=[EE,$E,CE,OE,DE,AE,tb];function RE(){for(const e of FE)TE(e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PE="model",ME=".json",VE=".weights.bin";function Hd(e){return new Promise(t=>setTimeout(t)).then(e)}class Hr{constructor(t){if(!oe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(Hr.URL_SCHEME)&&(t=t.slice(Hr.URL_SCHEME.length)),(t==null||t.length===0)&&(t=PE),this.modelJsonFileName=t+ME,this.weightDataFileName=t+VE}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=Zn.join(t.weightData),s=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],a=ny(t,r),o=window.URL.createObjectURL(new Blob([JSON.stringify(a)],{type:"application/json"})),i=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(i.download=this.modelJsonFileName,i.href=o,await Hd(()=>i.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){const u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=s,await Hd(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Mo(t)}}}}Hr.URL_SCHEME="downloads://";class LE{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise((t,n)=>{const s=new FileReader;s.onload=r=>{const a=JSON.parse(r.target.result),o=a.modelTopology;if(o==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(a.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:o});return}const u=Yf(a,c=>this.loadWeights(c));t(u)},s.onerror=r=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(t){const n=[],s=[];for(const o of t)n.push(...o.weights),s.push(...o.paths);const r=this.checkManifestAndWeightFiles(t),a=s.map(o=>this.loadWeightsFile(o,r[o]));return Promise.all(a).then(o=>[n,o])}loadWeightsFile(t,n){return new Promise((s,r)=>{const a=new FileReader;a.onload=o=>{const i=o.target.result;s(i)},a.onerror=o=>r(`Failed to weights data from file of path '${t}'.`),a.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(t){const n=[],s=this.weightsFiles.map(a=>Fd(a.name)),r={};for(const a of t)a.paths.forEach(o=>{const i=Fd(o);if(n.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(n.push(i),s.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);r[o]=this.weightsFiles[s.indexOf(i)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const zE=e=>oe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Hr.URL_SCHEME)?BE(e.slice(Hr.URL_SCHEME.length)):null;Oe.registerSaveRouter(zE);function BE(e="model"){return new Hr(e)}function WE(e){return new LE(e)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kd(e,t,n,s){o(e),n=n??0,s=s??1,i(n,s);let r=0;const a=u=>(u.then(c=>{const l=n+ ++r/e.length*(s-n);return t(l),c}),u);function o(u){D(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function i(u,c){D(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),D(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),D(c>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${c}`)}return Promise.all(e.map(a))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function eb(e,t){t==null&&(t={});const n=t.fetchFunc==null?oe().platform.fetch:t.fetchFunc,s=e.map(f=>n(f,t.requestInit,{isBinary:!0})),i=(t.onProgress==null?await Promise.all(s):await Kd(s,t.onProgress,0,.5)).map(f=>f.arrayBuffer());return t.onProgress==null?await Promise.all(i):await Kd(i,t.onProgress,.5,1)}function jE(e,t){var n;const s=t.fetchFunc==null?oe().platform.fetch:t.fetchFunc;let r=0,a;return(n=t.onProgress)===null||n===void 0||n.call(t,0),new ReadableStream({pull:async o=>{for(var i;r<e.length;){a||(a=(await s(e[r],t.requestInit,{isBinary:!0})).body.getReader());const{done:u,value:c}=await a.read();if(u){r++,a=void 0,(i=t.onProgress)===null||i===void 0||i.call(t,r/e.length);continue}o.enqueue(c);return}o.close()}})}async function qE(e,t="",n,s){return nb(o=>eb(o,{requestInit:s}))(e,t,n)}function nb(e){return async(t,n="",s)=>{const r=t.map(()=>!1),a={},o=s!=null?s.map(()=>!1):[],i=[];if(t.forEach((m,g)=>{let b=0;m.weights.forEach(w=>{const k="quantization"in w?w.quantization.dtype:w.dtype,N=zr[k]*It(w.shape),_=()=>{r[g]=!0,a[g]==null&&(a[g]=[]),a[g].push({manifestEntry:w,groupOffset:b,sizeBytes:N})};s!=null?s.forEach((I,$)=>{I===w.name&&(_(),o[$]=!0)}):_(),i.push(w.name),b+=N})}),!o.every(m=>m)){const m=s.filter((g,b)=>!o[b]);throw new Error(`Could not find weights in manifest with names: ${m.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}const u=r.reduce((m,g,b)=>(g&&m.push(b),m),[]),c=[];u.forEach(m=>{t[m].paths.forEach(g=>{const b=n+(n.endsWith("/")?"":"/")+g;c.push(b)})});const l=await e(c),f={};let d=0;return u.forEach(m=>{const g=t[m].paths.length,b=new Zn(l.slice(d,d+g));a[m].forEach(k=>{const N=b.slice(k.groupOffset,k.groupOffset+k.sizeBytes),_=Qg(N,[k.manifestEntry]);for(const I in _)f[I]=_[I]}),d+=g}),f}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HE="application/octet-stream",KE="application/json";class dh{constructor(t,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(D(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=oe().platform.fetch,D(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&D(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{},this.loadOptions=n}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],r=ny(t,s);if(n.body.append("model.json",new Blob([JSON.stringify(r)],{type:KE}),"model.json"),t.weightData!=null){const o=Zn.join(t.weightData);n.body.append("model.weights.bin",new Blob([o],{type:HE}),"model.weights.bin")}const a=await this.fetch(this.path,n);if(a.ok)return{modelArtifactsInfo:Mo(t),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async loadModelJSON(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await t.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const s=n.modelTopology,r=n.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return n}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const t=await this.loadModelJSON();return Yf(t,n=>this.loadWeights(n))}async loadStream(){const t=await this.loadModelJSON(),n=await this.getWeightUrls(t.weightsManifest),s=Qc(t.weightsManifest),r=()=>jE(n,this.loadOptions);return Object.assign(Object.assign({},t),{weightSpecs:s,getWeightStream:r})}async getWeightUrls(t){const n=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=UE(n),a=this.weightPathPrefix||s,o=[],i=[];for(const u of t)for(const c of u.paths)this.weightUrlConverter!=null?i.push(this.weightUrlConverter(c)):o.push(a+c+r);return this.weightUrlConverter&&o.push(...await Promise.all(i)),o}async loadWeights(t){const n=await this.getWeightUrls(t),s=Qc(t),r=await eb(n,this.loadOptions);return[s,r]}}dh.URL_SCHEME_REGEX=/^https?:\/\//;function UE(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),s=e.substring(0,t),r=n>t?e.substring(n):"";return[s+"/",r]}function ul(e){return e.match(dh.URL_SCHEME_REGEX)!=null}const sb=(e,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(s=>ul(s)):n=ul(e),n)return ph(e,t)}return null};Oe.registerSaveRouter(sb);Oe.registerLoadRouter(sb);function ph(e,t){return new dh(e,t)}function GE(e,t){return ph(e,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ec{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class rb{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class XE{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=n=>Promise.resolve(t.save(n)))}}function YE(e,t,n,s){const r=arguments;return new XE(ab(...r))}function ab(e,t,n,s){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new Ec(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ec({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ec({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:s}))}function JE(e){return new rb(e)}function ZE(e){return new rb(e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ob=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Zn,browserFiles:WE,browserHTTPRequest:GE,concatenateArrayBuffers:Hv,copyModel:d1,decodeWeights:Qg,decodeWeightsStream:ey,encodeWeights:Lv,fromMemory:YE,fromMemorySync:ab,getLoadHandlers:Qv,getModelArtifactsForJSON:Yf,getModelArtifactsForJSONSync:sy,getModelArtifactsInfoForJSON:Mo,getSaveHandlers:Zv,getWeightSpecs:Qc,http:ph,isHTTPScheme:ul,listModels:f1,loadWeights:qE,moveModel:p1,registerLoadRouter:Jv,registerSaveRouter:Yv,removeModel:h1,weightsLoaderFactory:nb,withSaveHandler:JE,withSaveHandlerSync:ZE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Nr;function QE(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,s=!1,r=!1,a=!1,o=!1,i=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&e instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)a=!0;else if(e.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&e instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(Uc(kd,j.backendName)!=null){const g={pixels:e},b={numChannels:t};return j.runKernel(kd,g,b)}const[c,l]=r?[e.videoWidth,e.videoHeight]:[e.width,e.height];let f;if(o)f=e.getContext("2d").getImageData(0,0,c,l).data;else if(s||n)f=e.data;else if(a||r||i){if(Nr==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Nr=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Nr=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Nr.canvas.width=c,Nr.canvas.height=l,Nr.drawImage(e,0,0,c,l),f=Nr.getImageData(0,0,c,l).data}let d;if(t===4)d=new Int32Array(f);else{const g=c*l;d=new Int32Array(g*t);for(let b=0;b<g;b++)for(let w=0;w<t;++w)d[b*t+w]=f[b*4+w]}return qy(d,[l,c,t],"int32")}const t2=L({fromPixels_:QE});function e2(e,t){const n=e.shape.length,s=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[s-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s-1]} vs. ${n}`);if(It(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const r=t.shape,a=r[r.length-1];let o=1;for(let f=0;f<r.length-1;++f)o*=r[f];const i=e.shape,u=r.slice();u.pop();let c=1;for(let f=a;f<n;++f)c*=i[f],u.push(i[f]);const l=[...Kt(e.shape).map(f=>f/c),1].slice(0,a);return[u,o,c,l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cl=-2,n2=-1;function s2(e,t,n){const s=e.shape.length;D(s===t.length,()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`),D(s===n.length,()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)D(t[r]+n[r]<=e.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${t[r]+n[r]}) would overflow input.shape[${r}] (${e.shape[r]})`)}function r2(e,t,n){const s=[];for(let r=0;r<e.length;r++)s[r]=Math.ceil((t[r]-e[r])/n[r]);return s}function a2(e,t,n){let s=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){s=r;break}for(let r=s+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function o2(e,t){let n=e.length>0?e[e.length-1]:1;for(let s=0;s<e.length-1;s++)n+=e[s]*t[s];return n}function i2(e,t,n){let s;const r=e.shape.length;typeof t=="number"?s=[t,...new Array(r-1).fill(0)]:t.length<r?s=t.concat(new Array(r-t.length).fill(0)):s=t.slice(),s.forEach(o=>{D(o!==-1,()=>"slice() does not support negative begin indexing.")});let a;return n==null?a=new Array(r).fill(-1):typeof n=="number"?a=[n,...new Array(r-1).fill(-1)]:n.length<r?a=n.concat(new Array(r-n.length).fill(-1)):a=n,a=a.map((o,i)=>o>=0?o:(D(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${i}.`),e.shape[i]-s[i])),[s,a]}function u2(e,t,n,s,r,a,o,i,u){let c;if(s==null?(c=new Array(t.length),c.fill(1)):c=s,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let l=!1;const f={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:c.slice(),beginMask:r,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};for(let _=0;_<f.dims;_++)l&&(1<<_&i)!==0&&f.numAddAxisAfterEllipsis++,1<<_&o&&(l=!0);l||(f.ellipsisMask|=1<<f.dims,f.dims++);const d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};c2(f,d);let m=!0,g=!0,b=!0;const w=[],k=[];for(let _=0;_<e.length;++_){if(d.strides[_]===0)throw Error(`strides[${_}] must be non-zero`);const I=!!(d.shrinkAxisMask&1<<_),$=e[_];if($===-1){w.push(I?1:-1);continue}const O=[d.beginMask&1<<_,d.endMask&1<<_],R=[d.strides[_]>0?0:-1,d.strides[_]>0?$:$-1];if(I&&d.strides[_]<=0)throw Error("only stride 1 allowed on non-range indexing.");b=b&&d.strides[_]===1;const W=!!(d.beginMask&1<<_&&d.endMask&1<<_);if(d.beginValid&&d.endValid){if(I){const q=d.begin[_]<0?$+d.begin[_]:d.begin[_];if(d.begin[_]=q,d.end[_]=d.begin[_]+1,q<0||q>=$)throw Error(`slice index ${d.begin[_]} of dimension ${_} out of bounds.`)}else d.begin[_]=Ud(d.begin[_],0,d.strides[_],$,O,R),d.end[_]=Ud(d.end[_],1,d.strides[_],$,O,R);const T=d.strides[_]===1&&d.begin[_]===0&&d.end[_]===$;m=m&&T,g=g&&(_===0&&d.strides[_]===1||T)}else m=m&&d.strides[_]===1&&W,g=g&&(_===0&&d.strides[_]===1||W);let P,M=!1;if(d.beginValid&&d.endValid?(P=d.end[_]-d.begin[_],M=!0):I?(P=1,M=!0):W&&$>=0&&(d.strides[_]<0?P=-$:P=$,M=!0),M){let T;P===0||P<0!=d.strides[_]<0?T=0:T=Math.trunc(P/d.strides[_])+(P%d.strides[_]!==0?1:0),w.push(T)}else w.push(-1)}for(let _=0;_<d.finalShapeGatherIndices.length;++_){const I=d.finalShapeGatherIndices[_];I>=0?k.push(w[I]):I===cl&&k.push(1)}return{finalShapeSparse:k.filter((_,I)=>d.finalShapeGatherIndices[I]!==cl),finalShape:k,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:d.begin,end:d.end,strides:d.strides}}function c2(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let s=0;s<e.dims;s++)if(1<<s&e.ellipsisMask){const r=Math.min(t.dims-(e.dims-s)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=s}else if(1<<s&e.newAxisMask)t.finalShapeGatherIndices.push(cl),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[s]),e.end!=null&&(t.end[n]=e.end[s]),t.strides[n]=e.strides[s],e.beginMask&1<<s&&(t.beginMask|=1<<n),e.endMask&1<<s&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<s?(t.finalShapeGatherIndices.push(n2),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(s)),t.inputShapeGatherIndicesSparse[n]=s,n++}}function Ud(e,t,n,s,r,a){if(r[t])return n>0?a[t]:a[t+1&1];{const o=e<0?s+e:e;return o<a[0]?a[0]:o>a[1]?a[1]:o}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l2(e,t){const n=e[0].length;e.forEach((r,a)=>{D(r.length===n,()=>`Error in concat${n}D: rank of tensors[${a}] must be the same as the rank of the rest (${n})`)}),D(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const s=e[0];e.forEach((r,a)=>{for(let o=0;o<n;o++)D(o===t||r[o]===s[o],()=>`Error in concat${n}D: Shape of tensors[${a}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${a}.`)})}function $c(e,t){const n=e[0].slice();for(let s=1;s<e.length;s++)n[t]+=e[s][t];return n}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var is;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(is||(is={}));function f2(e,t,n){let s=new Array;if(n==null&&t==null)return s;if(t==null)for(;s.length<e+n.length;)s.push(-1);else s=t.slice();if(n==null)return s;if(e+n.length!==s.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${s.length}`);for(let r=1;r<n.length;++r){const a=n[r],o=s[s.length-n.length+r],i=s[o];if(a>=0)if(i>=0){if(i!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${r+e}] = ${a} but shape[${r+e}] = ${i}`)}else s[o]=a}return s}function h2(e){const t={FIRST_DIM_SIZE:is.FIRST_DIM_SIZE,VALUE_ROWIDS:is.VALUE_ROWIDS,ROW_LENGTHS:is.ROW_LENGTHS,ROW_SPLITS:is.ROW_SPLITS,ROW_LIMITS:is.ROW_LIMITS,ROW_STARTS:is.ROW_STARTS},n=[];for(const s of e)if(s in t)n.push(t[s]);else break;return n}function d2(e){return e.length===0?0:e[0]===is.FIRST_DIM_SIZE?e.length-1:e.length}function p2(e,t){if(e==null||t==null)return;const n=e.length,s=t.length;if(n>=s)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(n,s-1);++r){const a=e[r],o=t[r+1];if(a>=0&&o>=0&&a!==1&&a!==o)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${r-e.length}] = ${a} but ragged tensor input.flatValues.shape[${r-e.length}] = ${o}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m2(e,t,n){const s=n*(typeof e=="number"?e:e[0]),r=t*(typeof e=="number"?e:e[1]);return[s,r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ib(e,t,n,s=!0){let r=[];if(s)r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);const a=t.length;for(let o=0;o<a;++o)r=r.concat([e[o+1]/t[o],t[o]]);r=r.concat(e.slice(a+1))}return r}function ub(e,t,n=!0){const s=[];if(n){s.push(t);for(let r=t+1;r<e;++r)r<=2*t?(s.push(r),s.push(r-(t+1))):s.push(r)}else{const r=[],a=[];for(let o=1;o<e;++o)o>=t*2+1||o%2===1?a.push(o):r.push(o);s.push(...r),s.push(0),s.push(...a)}return s}function cb(e,t,n,s=!0){const r=[];s?r.push(e[0]/n):r.push(e[0]*n);for(let a=1;a<e.length;++a)a<=t.length?s?r.push(t[a-1]*e[a]):r.push(e[a]/t[a-1]):r.push(e[a]);return r}function g2(e,t){const n=[0];for(let s=0;s<t;++s)n.push(e[s][0]);return n}function y2(e,t,n){const s=e.slice(0,1);for(let r=0;r<n;++r)s.push(e[r+1]-t[r][0]-t[r][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b2=1.7580993408473768,w2=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v2=.3275911,k2=.254829592,x2=-.284496736,S2=1.421413741,I2=-1.453152027,N2=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ta(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(e.length*2);for(let s=0;s<n.length;s+=2)n[s]=e[s/2],n[s+1]=t[s/2];return n}function _2(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let s=0;s<e.length;s+=2)t[s/2]=e[s],n[s/2]=e[s+1];return{real:t,imag:n}}function T2(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),s=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],s[Math.floor(r/4)]=e[r+1];return{real:n,imag:s}}function E2(e){const t=Math.floor(e.length/4),n=new Float32Array(t),s=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],s[Math.floor(r/4)]=e[r+1];return{real:n,imag:s}}function lb(e,t){const n=e[t*2],s=e[t*2+1];return{real:n,imag:s}}function $2(e,t,n,s){e[s*2]=t,e[s*2+1]=n}function C2(e,t){const n=new Float32Array(e/2),s=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){const a=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(a),s[r]=Math.sin(a)}return{real:n,imag:s}}function O2(e,t,n){const s=(n?2:-2)*Math.PI*(e/t),r=Math.cos(s),a=Math.sin(s);return{real:r,imag:a}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cc="->",D2=/->/g,Gd=",",Xd="...";function A2(e,t){e=e.replace(/\s/g,"");const n=(e.length-e.replace(D2,"").length)/Cc.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Cc}").`);const[s,r]=e.split(Cc);D(s.indexOf(Xd)===-1,()=>`The ellipsis notation ("${Xd}") is not supported yet.`);const a=s.split(Gd),o=a.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let d=0;d<r.length;++d){const m=r[d];if(!a.some(g=>g.indexOf(m)!==-1))throw new Error(`Output subscripts contain the label ${m} not present in the input subscripts.`);i.indexOf(m)===-1&&i.push(m)}for(let d=0;d<s.length;++d){const m=s[d];i.indexOf(m)===-1&&m!==Gd&&i.push(m)}const u=new Array(a.length);for(let d=0;d<o;++d){if(new Set(a[d].split("")).size!==a[d].length)throw new Error(`Found duplicate axes in input component ${a[d]}. Support for duplicate axes in input is not implemented yet.`);u[d]=[];for(let m=0;m<a[d].length;++m)u[d].push(i.indexOf(a[d][m]))}const c=i.length,l=r.length,f=[];for(let d=l;d<c;++d)f.push(d);return{allDims:i,summedDims:f,idDims:u}}function F2(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;const s=[];for(let r=0;r<e;++r)n[r]===-1&&s.push(r);return n=n.filter(r=>r!==-1),{permutationIndices:n,expandDims:s}}function R2(e,t,n){const s=new Array(e);for(let r=0;r<n.length;++r){const a=n[r].shape;for(let o=0;o<t[r].length;++o)s[t[r][o]]===void 0?s[t[r][o]]=a[o]:D(s[t[r][o]]===a[o],()=>`Expected dimension ${s[t[r][o]]} at axis ${o} of input shaped ${JSON.stringify(a)}, but got dimension ${a[o]}`)}}function P2(e,t){const n=e,s=[];let r=0;e.length===0&&n.push(-1),r=e.length+1;for(let o=0;o<r;++o)s.push([]);const a=[];for(let o=0;o<n.length;++o){const i=n[o],u=V2(t,i);for(const c of u)a.indexOf(c)===-1&&(s[o].push(c),a.push(c))}return{path:n,steps:s}}function M2(e){return e.every((t,n)=>t===n)}function V2(e,t){const n=[];for(let s=0;s<e.length;++s)(e[s].length===0||e[s].indexOf(t)!==-1||t===-1)&&n.push(s);return n}function L2(e,t,n=0){let s=[];if(typeof t=="number")D(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),s=new Array(t).fill(e.shape[n]/t);else{const r=t.reduce((o,i)=>(i===-1&&(o+=1),o),0);D(r<=1,()=>"There should be only one negative value in split array.");const a=t.indexOf(-1);if(a!==-1){const o=t.reduce((i,u)=>u>0?i+u:i);t[a]=e.shape[n]-o}D(e.shape[n]===t.reduce((o,i)=>o+i),()=>"The sum of sizes must match the size of the axis dimension."),s=t}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z2(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function B2(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function W2(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j2(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function q2(e,t){return`size ${e} must be non-negative, not ${t}`}function H2(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function K2(e,t){const n=It(e),s=It(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${e} outputShape= ${t}`}function U2(e,t){const n=It(e),s=It(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${s}. inputShape=${e} outputShape=${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yd(){return"segment ids must be >= 0"}function G2(){return"segment ids are not increasing"}function X2(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function Y2(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J2(e,t,n,s){const r=t.shape.length,a=e.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>a)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${a}).`);if(n<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${n}).`);for(let f=0;f<s;++f)if(e.shape[f]!==t.shape[f])throw new Error(`x.shape[${f}]: ${e.shape[f]} should be equal to indices.shape[${f}]: ${t.shape[f]}.`);const o=e.shape[n],i=[];let u=1,c=1,l=1;for(let f=0;f<s;++f)i.push(e.shape[f]),u*=e.shape[f];for(let f=s;f<n;f++)i.push(e.shape[f]),c*=e.shape[f];for(let f=s;f<r;f++)i.push(t.shape[f]);for(let f=n+1;f<a;f++)i.push(e.shape[f]),l*=e.shape[f];return{batchSize:u,sliceSize:l,outerSize:c,dimSize:o,outputShape:i}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $o(e){try{return e.map(t=>vo(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function Z2(e){return e.map(t=>Pr(t))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */RE();/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q2=oe();Q2.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Tn;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(Tn||(Tn={}));var Jd;(function(e){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(Jd||(Jd={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t$={};function fb(e){return t$[e]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v(e,t,n,s,r){const a=t.inputParams[e];if(a&&a.inputIndexStart!==void 0){const i=a.inputIndexStart,u=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?i+1:a.inputIndexEnd,c=i<0?t.inputNames.length+i:i;if(a.type==="tensor")return Ye(t.inputNames[c],n,s,r);if(a.type==="tensors"){const d=t.inputs.slice(i,u);return t.inputNames.slice(i,u).filter((g,b)=>{var w;return((w=d[b])===null||w===void 0?void 0:w.op)!=="NoOp"}).map(g=>Ye(g,n,s,r))}const l=Ye(t.inputNames[c],n,s,r),f=l.dataSync();return a.type==="number"?f[0]:qn(l.shape,f)}const o=t.attrParams[e];return o&&o.value}function Ye(e,t,n,s){const[r,a]=En(e,n);if(s!=null){const i=s.getHashTableHandleByName(r);if(i!=null)return i}const o=n.currentContextIds.find(i=>!!t[Gi(r,i)]);return o!==void 0?t[Gi(r,o)][a]:void 0}function Zd(e,t,n){return t[Gi(e,n.currentContextId)]}function _s(e,t){const[n,s,r]=En(e,t);return[Gi(n,t&&t.currentContextId),s,r]}function Gi(e,t){return t?`${e}-${t}`:e}function En(e,t){if(e==="")return["",0,void 0];const n=t!=null&&t.parseNodeNameCache!=null;if(n){const a=t.parseNodeNameCache.get(e);if(a!=null)return a}const s=e.split(":");let r;if(s.length===1)r=[e,0,void 0];else{const a=s[0],o=s.length===3?s[1]:void 0,i=Number(s[s.length-1]);r=[a,i,o]}return n&&t.parseNodeNameCache.set(e,r),r}function Ai(e,t,n){let s=v("pad",e,t,n);if(s==="explicit"){s=v("explicitPaddings",e,t,n);const r=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)r[a][0]=s[a*2],r[a][1]=s[a*2+1];return r}return s}function Ts(e){return e.kept?e:ar(e)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e$=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],n$=Object.freeze(Object.defineProperty({__proto__:null,json:e$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s$=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],r$=Object.freeze(Object.defineProperty({__proto__:null,json:s$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a$=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],o$=Object.freeze(Object.defineProperty({__proto__:null,json:a$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i$=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],u$=Object.freeze(Object.defineProperty({__proto__:null,json:i$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c$=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],l$=Object.freeze(Object.defineProperty({__proto__:null,json:c$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f$=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],h$=Object.freeze(Object.defineProperty({__proto__:null,json:f$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d$=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],p$=Object.freeze(Object.defineProperty({__proto__:null,json:d$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m$=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],g$=Object.freeze(Object.defineProperty({__proto__:null,json:m$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y$=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],b$=Object.freeze(Object.defineProperty({__proto__:null,json:y$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w$=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],v$=Object.freeze(Object.defineProperty({__proto__:null,json:w$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k$=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],x$=Object.freeze(Object.defineProperty({__proto__:null,json:k$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S$=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],I$=Object.freeze(Object.defineProperty({__proto__:null,json:S$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N$=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],_$=Object.freeze(Object.defineProperty({__proto__:null,json:N$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T$=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],E$=Object.freeze(Object.defineProperty({__proto__:null,json:T$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $$=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],C$=Object.freeze(Object.defineProperty({__proto__:null,json:$$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O$=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],D$=Object.freeze(Object.defineProperty({__proto__:null,json:O$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A$=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],F$=Object.freeze(Object.defineProperty({__proto__:null,json:A$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R$=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],P$=Object.freeze(Object.defineProperty({__proto__:null,json:R$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M$=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],V$=Object.freeze(Object.defineProperty({__proto__:null,json:M$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qd{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[n$,r$,o$,u$,l$,h$,p$,g$,b$,v$,x$,I$,_$,E$,C$,D$,F$,P$,V$],n=[].concat(...t.map(s=>s.json));this.opMappers=n.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(t,n={}){const s=t.node,r=[],a=[],o=[],i=s.reduce((b,w)=>(b[w.name]=this.mapNode(w),w.op.startsWith("Placeholder")?r.push(b[w.name]):w.op==="Const"?a.push(b[w.name]):(w.input==null||w.input.length===0)&&o.push(b[w.name]),b),{});let u=[];const c=[];let l={},f={};n!=null&&(l=this.mapSignatureEntries(n.inputs),f=this.mapSignatureEntries(n.outputs));const d=Object.keys(i);d.forEach(b=>{const w=i[b];w.inputNames.forEach((k,N)=>{const[_,,I]=_s(k),$=i[_];if($.outputs!=null){const O=$.outputs.indexOf(I);if(O!==-1){const R=`${_}:${O}`;w.inputNames[N]=R}}w.inputs.push($),$.children.push(w)})}),Object.keys(f).length===0?d.forEach(b=>{const w=i[b];w.children.length===0&&c.push(w)}):Object.keys(f).forEach(b=>{const[w]=_s(b),k=i[w];k!=null&&(k.signatureKey=f[b],c.push(k))}),Object.keys(l).length>0?Object.keys(l).forEach(b=>{const[w]=_s(b),k=i[w];k&&(k.signatureKey=l[b],u.push(k))}):u=r;let m={};t.library!=null&&t.library.function!=null&&(m=t.library.function.reduce((b,w)=>(b[w.signature.name]=this.mapFunction(w),b),{}));const g={nodes:i,inputs:u,outputs:c,weights:a,placeholders:r,signature:n,functions:m};return o.length>0&&(g.initNodes=o),g}mapSignatureEntries(t){return Object.keys(t||{}).reduce((n,s)=>(n[t[s].name]=s,n),{})}mapNode(t){const n=fb(t.op)||this.opMappers[t.op]||{};t.attr==null&&(t.attr={});const s={name:t.name,op:t.op,category:n.category,inputNames:(t.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:n.outputs};return n.inputs!=null&&(s.inputParams=n.inputs.reduce((r,a)=>(r[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},r),{})),n.attrs!=null&&(s.attrParams=n.attrs.reduce((r,a)=>{const o=a.type;let i;switch(a.type){case"string":i=ll(t.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=ll(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":i=yl(t.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=yl(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":i=hl(t.attr,a.tfName,a.defaultValue||0),i===void 0&&a.tfDeprecatedName&&(i=hl(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":i=gl(t.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=gl(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":i=fl(t.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=fl(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":i=wl(t.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=wl(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":i=ml(t.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=ml(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":i=bl(t.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=bl(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":i=dl(t.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=dl(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":i=pl(t.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=pl(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":i=tp(t.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=tp(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${t.op}`)}return r[a.name]={value:i,type:o},r},{})),s}mapFunction(t){const n=t.nodeDef,s=[],r=[];let a={};n!=null&&(a=n.reduce((f,d)=>(f[d.name]=this.mapNode(d),d.op==="Const"&&r.push(f[d.name]),f),{}));const o=[],i=[];t.signature.inputArg.forEach(f=>{const[d]=_s(f.name),m={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:mh(f.type),type:"dtype"}},children:[]};m.signatureKey=f.name,o.push(m),a[d]=m}),Object.keys(a).forEach(f=>{const d=a[f];d.inputNames.forEach((m,g)=>{const[b,,w]=_s(m),k=a[b];if(k.outputs!=null){const N=k.outputs.indexOf(w);if(N!==-1){const _=`${b}:${N}`;d.inputNames[g]=_}}d.inputs.push(k),k.children.push(d)})});const c=t.ret;t.signature.outputArg.forEach(f=>{const[d,m]=_s(c[f.name]),g=a[d];g!=null&&(g.defaultOutput=m,i.push(g))});const l=this.mapArgsToSignature(t);return{nodes:a,inputs:o,outputs:i,weights:r,placeholders:s,signature:l}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((n,s)=>(n[s.name]=this.mapArgToTensorInfo(s),n),{}),outputs:t.signature.outputArg.reduce((n,s)=>(n[s.name]=this.mapArgToTensorInfo(s,t.ret),n),{})}}mapArgToTensorInfo(t,n){let s=t.name;return n!=null&&(s=n[s]),{name:s,dtype:t.type}}}function L$(e){const t=oe().global;if(typeof t.atob<"u")return t.atob(e);if(typeof Buffer<"u")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function hb(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):L$(e);return t?n:n.toLowerCase()}function ll(e,t,n,s=!1){const r=e[t];return r!=null?hb(r.s,s):n}function fl(e,t,n){const s=e[t];return s?s.b:n}function hl(e,t,n){const s=e[t]||{},r=s.i!=null?s.i:s.f!=null?s.f:n;return typeof r=="number"?r:parseInt(r,10)}function mh(e){switch(typeof e=="string"&&(e=Tn[e]),e){case Tn.DT_FLOAT:case Tn.DT_HALF:return"float32";case Tn.DT_INT32:case Tn.DT_INT64:case Tn.DT_INT8:case Tn.DT_UINT8:return"int32";case Tn.DT_BOOL:return"bool";case Tn.DT_DOUBLE:return"float32";case Tn.DT_STRING:return"string";case Tn.DT_COMPLEX64:case Tn.DT_COMPLEX128:return"complex64";default:return null}}function tp(e,t,n){const s=e[t];return s&&s.func?s.func.name:n}function dl(e,t,n){const s=e[t];return s&&s.type?mh(s.type):n}function pl(e,t,n){const s=e[t];return s&&s.list&&s.list.type?s.list.type.map(r=>mh(r)):n}function db(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function ml(e,t,n){const s=e[t];return s&&s.shape?db(s.shape):n}function gl(e,t,n){const s=e[t];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):n}function yl(e,t,n,s=!1){const r=e[t];return r&&r.list&&r.list.s?r.list.s.map(a=>hb(a,s)):n}function bl(e,t,n){const s=e[t];return s&&s.list&&s.list.shape?s.list.shape.map(r=>db(r)):n}function wl(e,t,n){const s=e[t];return s&&s.list&&s.list.b?s.list.b:n}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class z${constructor(t,n,s){this.node=t,this.tensorMap=n,this.context=s,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(r=>this.getInput(r)),t.rawAttrs!=null&&(this.attrs=Object.keys(t.rawAttrs).reduce((r,a)=>(r[a]=this.getAttr(a),r),{}))}getInput(t){return Ye(t,this.tensorMap,this.context)}getAttr(t,n){const s=this.node.rawAttrs[t];if(s.tensor!=null)return Ye(t,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return hl(this.node.rawAttrs,t,n);if(s.s!=null)return ll(this.node.rawAttrs,t,n);if(s.b!=null)return fl(this.node.rawAttrs,t,n);if(s.shape!=null)return ml(this.node.rawAttrs,t,n);if(s.type!=null)return dl(this.node.rawAttrs,t,n);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return gl(this.node.rawAttrs,t,n);if(s.list.s!=null)return yl(this.node.rawAttrs,t,n);if(s.list.shape!=null)return bl(this.node.rawAttrs,t,n);if(s.list.b!=null)return wl(this.node.rawAttrs,t,n);if(s.list.type!=null)return pl(this.node.rawAttrs,t,n)}return n}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Je=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:Zg,abs:Fn,acos:T1,acosh:$1,add:Jt,addN:O1,all:A1,any:R1,argMax:M1,argMin:L1,asin:B1,asinh:j1,atan:H1,atan2:U1,atanh:X1,avgPool:py,avgPool3d:sk,basicLSTMCell:lk,batchNorm:wu,batchNorm2d:mk,batchNorm3d:yk,batchNorm4d:wk,batchToSpaceND:my,bincount:gy,bitwiseAnd:xk,booleanMaskAsync:h_,broadcastArgs:Ik,broadcastTo:io,buffer:ce,cast:Pe,ceil:Tk,clipByValue:$k,clone:ar,complex:ur,concat:dn,concat1d:Ok,concat2d:Ak,concat3d:Rk,concat4d:Mk,conv1d:zk,conv2d:vu,conv2dTranspose:jk,conv3d:Hk,conv3dTranspose:Xk,cos:Jk,cosh:Qk,cosineWindow:ih,cumprod:ex,cumsum:sx,denseBincount:ax,depthToSpace:ix,depthwiseConv2d:Zf,diag:lx,dilation2d:hx,div:ke,divNoNan:bx,dot:vx,dropout:N_,einsum:la,elu:wy,enclosingPowerOfTwo:Gy,ensureShape:Ix,equal:by,erf:_x,euclideanNorm:Px,exp:jr,expandDims:Ns,expm1:zx,eye:Sy,fft:sh,fill:Vo,floor:Iy,floorDiv:hy,fused:z_,gather:Ny,gatherND:x_,greater:xu,greaterEqual:_y,ifft:Ui,imag:Su,image:wE,inTopKAsync:T_,irfft:By,isFinite:Xx,isInf:Jx,isNaN:Qx,leakyRelu:Ty,less:ol,lessEqual:Qf,linalg:vE,linspace:sS,localResponseNormalization:aS,log:No,log1p:Ey,logSigmoid:hS,logSoftmax:mS,logSumExp:Cy,logicalAnd:qi,logicalNot:Oy,logicalOr:Dy,logicalXor:kS,losses:kE,lowerBound:SS,matMul:be,max:ga,maxPool:Ay,maxPool3d:_S,maxPoolWithArgmax:ES,maximum:Fy,mean:Hi,meshgrid:OS,min:al,minimum:Ki,mirrorPad:FS,mod:PS,moments:VS,movingAverage:m_,mul:Pt,multiRNNCell:zS,multinomial:WS,neg:hs,norm:ku,notEqual:Ry,oneHot:HS,ones:Rr,onesLike:US,op:L,outerProduct:XS,pad:Lo,pad1d:ZS,pad2d:tI,pad3d:nI,pad4d:rI,pool:cI,pow:Io,prelu:My,print:fy,prod:hI,raggedGather:pI,raggedRange:gI,raggedTensorToTensor:bI,rand:vI,randomGamma:WI,randomNormal:Vy,randomStandardNormal:HI,randomUniform:nh,randomUniformInt:GI,range:_o,real:To,reciprocal:JI,relu:Nu,relu6:Ly,reshape:mt,reverse:qr,reverse1d:nN,reverse2d:rN,reverse3d:oN,reverse4d:uN,rfft:rh,round:zy,rsqrt:fN,scalar:fe,scatterND:y_,searchSorted:th,selu:dN,separableConv2d:mN,setdiff1dAsync:yN,sigmoid:ma,sign:wN,signal:bE,sin:kN,sinh:SN,slice:ve,slice1d:NN,slice2d:TN,slice3d:$N,slice4d:ON,softmax:AN,softplus:$y,spaceToBatchND:Py,sparse:xE,sparseToDense:v_,spectral:yE,split:Eo,sqrt:Fs,square:Yn,squaredDifference:Wy,squeeze:ah,stack:Ps,step:jy,stridedSlice:qN,string:SE,sub:ae,sum:Ne,tan:KN,tanh:rl,tensor:fs,tensor1d:jn,tensor2d:co,tensor3d:qy,tensor4d:UN,tensor5d:GN,tensor6d:XN,tensorScatterUpdate:ZN,tile:uo,topk:t_,transpose:il,truncatedNormal:n_,unique:r_,unsortedSegmentSum:o_,unstack:Jr,upperBound:u_,variable:c_,where:or,whereAsync:Uy,zeros:_a,zerosLike:Mn},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B$=(e,t,n,s=Je)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(v("a",e,t,n),v("b",e,t,n))];case"AddN":return[s.addN(v("tensors",e,t,n))];case"FloorMod":case"Mod":return[s.mod(v("a",e,t,n),v("b",e,t,n))];case"Mul":return[s.mul(v("a",e,t,n),v("b",e,t,n))];case"RealDiv":case"Div":return[s.div(v("a",e,t,n),v("b",e,t,n))];case"DivNoNan":return[s.divNoNan(v("a",e,t,n),v("b",e,t,n))];case"FloorDiv":return[s.floorDiv(v("a",e,t,n),v("b",e,t,n))];case"Sub":return[s.sub(v("a",e,t,n),v("b",e,t,n))];case"Minimum":return[s.minimum(v("a",e,t,n),v("b",e,t,n))];case"Maximum":return[s.maximum(v("a",e,t,n),v("b",e,t,n))];case"Pow":return[s.pow(v("a",e,t,n),v("b",e,t,n))];case"SquaredDifference":return[s.squaredDifference(v("a",e,t,n),v("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W$=(e,t,n,s=Je)=>{switch(e.op){case"Abs":case"ComplexAbs":return[s.abs(v("x",e,t,n))];case"Acos":return[s.acos(v("x",e,t,n))];case"Acosh":return[s.acosh(v("x",e,t,n))];case"Asin":return[s.asin(v("x",e,t,n))];case"Asinh":return[s.asinh(v("x",e,t,n))];case"Atan":return[s.atan(v("x",e,t,n))];case"Atan2":return[s.atan2(v("x",e,t,n),v("y",e,t,n))];case"Atanh":return[s.atanh(v("x",e,t,n))];case"Ceil":return[s.ceil(v("x",e,t,n))];case"Complex":return[s.complex(v("real",e,t,n),v("imag",e,t,n))];case"Cos":return[s.cos(v("x",e,t,n))];case"Cosh":return[s.cosh(v("x",e,t,n))];case"Elu":return[s.elu(v("x",e,t,n))];case"Erf":return[s.erf(v("x",e,t,n))];case"Exp":return[s.exp(v("x",e,t,n))];case"Expm1":return[s.expm1(v("x",e,t,n))];case"Floor":return[s.floor(v("x",e,t,n))];case"Log":return[s.log(v("x",e,t,n))];case"Log1p":return[s.log1p(v("x",e,t,n))];case"Imag":return[s.imag(v("x",e,t,n))];case"Neg":return[s.neg(v("x",e,t,n))];case"Reciprocal":return[s.reciprocal(v("x",e,t,n))];case"Real":return[s.real(v("x",e,t,n))];case"Relu":return[s.relu(v("x",e,t,n))];case"Round":return[s.round(v("x",e,t,n))];case"Selu":return[s.selu(v("x",e,t,n))];case"Sigmoid":return[s.sigmoid(v("x",e,t,n))];case"Sin":return[s.sin(v("x",e,t,n))];case"Sign":return[s.sign(v("x",e,t,n))];case"Sinh":return[s.sinh(v("x",e,t,n))];case"Softplus":return[s.softplus(v("x",e,t,n))];case"Sqrt":return[s.sqrt(v("x",e,t,n))];case"Square":return[s.square(v("x",e,t,n))];case"Tanh":return[s.tanh(v("x",e,t,n))];case"Tan":return[s.tan(v("x",e,t,n))];case"ClipByValue":return[s.clipByValue(v("x",e,t,n),v("clipValueMin",e,t,n),v("clipValueMax",e,t,n))];case"Relu6":return[s.relu6(v("x",e,t,n))];case"Rsqrt":return[s.rsqrt(Ye(e.inputNames[0],t,n))];case"LeakyRelu":return[s.leakyRelu(v("x",e,t,n),v("alpha",e,t,n))];case"Prelu":return[s.prelu(v("x",e,t,n),v("alpha",e,t,n))];case"IsNan":return[s.isNaN(Ye(e.inputNames[0],t,n))];case"IsInf":return[s.isInf(Ye(e.inputNames[0],t,n))];case"IsFinite":return[s.isFinite(Ye(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wn(e,t,n=""){if(!(typeof e=="number"||typeof t=="number")){D(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let s=0;s<e.length;s++){const r=e[s],a=t[s];D(r<0||a<0||r===a,()=>n+` Shapes ${e} and ${t} must match`)}}}function ep(e){return!(typeof e=="number"||e.some(t=>t<0))}function Za(e,t,n){let s=vl(e,n);const r=!ep(s);if(r&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&t.forEach(a=>{s=vl(a.shape,s)}),!ep(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function vl(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let s=0;s<e.length;++s){const r=e[s],a=t[s];if(r>=0&&a>=0&&r!==a)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[s]=r>=0?r:a}return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class j${constructor(t,n,s,r,a,o,i){this.name=t,this.dtype=n,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=o,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=fe(0),cs(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const n=this.tensors[t];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(t){return t.map(n=>this.read(n))}write(t,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[t]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),Wn(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);s.tensor=n,cs(n),s.written=!0,this.tensors[t]=s}writeMany(t,n){if(t.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${n.length}.`);t.forEach((s,r)=>this.write(s,n[r]))}gather(t,n){if(n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(t)t=t.slice(0,this.size());else{t=[];for(let r=0;r<this.size();r++)t.push(r)}if(t.length===0)return fs([],[0].concat(this.elementShape));const s=this.readMany(t);return Wn(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),Ps(s,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(this.size()===0)return fs([],[0].concat(this.elementShape));const n=[];for(let r=0;r<this.size();r++)n.push(r);const s=this.readMany(n);return Wn(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),dn(s,0)}scatter(t,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);const s=Math.max(...t);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(t,Jr(n,0))}split(t,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let s=0;const r=t.map(u=>(s+=u,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const a=s===0?0:n.size/s,o=[];de(()=>{n=mt(n,[1,s,a]);for(let u=0;u<t.length;++u){const l=[0,u===0?0:r[u-1],0],f=[1,t[u],a];o[u]=mt(ve(n,l,f),this.elementShape)}return o});const i=[];for(let u=0;u<t.length;u++)i[u]=u;this.writeMany(i,o)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kr{get id(){return this.idTensor.id}constructor(t,n,s,r=-1){this.tensors=t,this.elementShape=n,this.elementDtype=s,t!=null&&t.forEach(a=>{if(s!==a.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${a.dtype}`);Wn(n,a.shape,"TensorList shape mismatch: "),cs(a)}),this.idTensor=fe(0),this.maxNumElements=r,cs(this.idTensor)}copy(){return new Kr([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,s=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);Wn(t,this.elementShape,"TensorList shape mismatch: ");const r=Za(this.elementShape,this.tensors,t);return de(()=>{const a=this.tensors.map(o=>mt(o,r));return Ps(a,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=Za(this.elementShape,this.tensors,t),r=this.tensors.pop();return r.kept=!1,Wn(r.shape,t,"TensorList shape mismatch: "),mt(r,s)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Wn(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");cs(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const n=new Kr([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let s=0;s<Math.min(this.tensors.length,t);++s)n.tensors[s]=this.tensors[s];return n}getItem(t,n,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);Wn(this.tensors[t].shape,n,"TensorList shape mismatch: ");const r=Za(this.elementShape,this.tensors,n);return mt(this.tensors[t],r)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Wn(this.elementShape,n.shape,"TensorList shape mismatch: "),cs(n),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=n}gather(t,n,s){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);Wn(this.elementShape,s,"TensorList shape mismatch: "),t=t.slice(0,this.size());const r=Za(this.elementShape,this.tensors,s);return t.length===0?fs([],[0].concat(r)):de(()=>{const a=t.map(o=>mt(this.tensors[o],r));return Ps(a,0)})}concat(t,n){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Wn(this.elementShape,n,"TensorList shape mismatch: ");const s=Za(this.elementShape,this.tensors,n);return this.size()===0?fs([],[0].concat(s)):de(()=>{const r=this.tensors.map(a=>mt(a,s));return dn(r,0)})}}function q$(e,t,n){const s=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);const r=e.shape.slice(1);Wn(r,t,"TensorList shape mismatch: ");const a=Jr(e);return new Kr(a,t,s)}function H$(e,t,n,s){return new Kr([],e,t,s)}function K$(e,t,n,s){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const r=Math.max(...t);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const a=new Kr([],n,e.dtype,s),o=Jr(e,0);return t.forEach((i,u)=>{a.setItem(i,o[u])}),a}function U$(e,t,n){let s=0;const r=t.map(l=>(s+=l,s));if(s!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${e.shape}`);const a=e.shape.slice(1),o=vl(a,n),i=s===0?0:e.size/s,u=de(()=>{const l=[];e=mt(e,[1,s,i]);for(let f=0;f<t.length;++f){const m=[0,f===0?0:r[f-1],0],g=[1,t[f],i];l[f]=mt(ve(e,m,g),o)}return e.dispose(),l}),c=new Kr([],n,e.dtype,t.length);for(let l=0;l<u.length;l++)c.setItem(l,u[l]);return c}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G$=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const s=v("thenBranch",e,t,n),r=v("elseBranch",e,t,n),a=v("cond",e,t,n),o=v("args",e,t,n);return(await a.data())[0]?n.functionMap[s].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const s=v("body",e,t,n),r=v("cond",e,t,n),a=v("args",e,t,n),o=await n.functionMap[r].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),i=a.map(l=>l.id);let u=await o[0].data();o.forEach(l=>{!l.kept&&i.indexOf(l.id)===-1&&l.dispose()});let c=a;for(;u[0];){const l=c;c=await n.functionMap[s].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);const f=c.map(m=>m.id);l.forEach(m=>{!m.kept&&i.indexOf(m.id)===-1&&f.indexOf(m.id)===-1&&m.dispose()});const d=await n.functionMap[r].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);u=await d[0].data(),d.forEach(m=>{!m.kept&&i.indexOf(m.id)===-1&&f.indexOf(m.id)===-1&&m.dispose()})}return c}case"LoopCond":{const s=v("pred",e,t,n);return[Ts(s)]}case"Switch":{const s=v("pred",e,t,n);let r=v("data",e,t,n);return r.kept||(r=Ts(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=e.inputNames.find(r=>Ye(r,t,n)!==void 0);if(s){const r=Ye(s,t,n);return[Ts(r)]}return}case"Enter":{const s=v("frameName",e,t,n),r=v("tensor",e,t,n);return n.enterFrame(s),[Ts(r)]}case"Exit":{const s=v("tensor",e,t,n);return n.exitFrame(),[Ts(s)]}case"NextIteration":{const s=v("tensor",e,t,n);return n.nextIteration(),[Ts(s)]}case"TensorArrayV3":{const s=v("size",e,t,n),r=v("dtype",e,t,n),a=v("elementShape",e,t,n),o=v("dynamicSize",e,t,n),i=v("clearAfterRead",e,t,n),u=v("identicalElementShapes",e,t,n),c=v("name",e,t,n),l=new j$(c,r,s,a,u,o,i);return n.addTensorArray(l),[l.idTensor,fe(1)]}case"TensorArrayWriteV3":{const s=v("tensorArrayId",e,t,n),r=v("index",e,t,n),a=v("tensor",e,t,n),o=n.getTensorArray(s.id);return o.write(r,a),[o.idTensor]}case"TensorArrayReadV3":{const s=v("tensorArrayId",e,t,n),r=v("index",e,t,n);return[n.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=v("tensorArrayId",e,t,n),r=v("indices",e,t,n),a=v("dtype",e,t,n);return[n.getTensorArray(s.id).gather(r,a)]}case"TensorArrayScatterV3":{const s=v("tensorArrayId",e,t,n),r=v("indices",e,t,n),a=v("tensor",e,t,n),o=n.getTensorArray(s.id);return o.scatter(r,a),[o.idTensor]}case"TensorArrayConcatV3":{const s=v("tensorArrayId",e,t,n),r=n.getTensorArray(s.id),a=v("dtype",e,t,n);return[r.concat(a)]}case"TensorArraySplitV3":{const s=v("tensorArrayId",e,t,n),r=v("tensor",e,t,n),a=v("lengths",e,t,n),o=n.getTensorArray(s.id);return o.split(a,r),[o.idTensor]}case"TensorArraySizeV3":{const s=v("tensorArrayId",e,t,n),r=n.getTensorArray(s.id);return[fe(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=v("tensorArrayId",e,t,n),r=n.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=v("tensorListId",e,t,n),r=v("index",e,t,n),a=v("tensor",e,t,n),o=n.getTensorList(s.id);return o.setItem(r,a),[o.idTensor]}case"TensorListGetItem":{const s=v("tensorListId",e,t,n),r=v("index",e,t,n),a=v("elementShape",e,t,n),o=v("elementDType",e,t,n);return[n.getTensorList(s.id).getItem(r,a,o)]}case"TensorListScatterV2":case"TensorListScatter":{const s=v("indices",e,t,n),r=v("tensor",e,t,n),a=v("elementShape",e,t,n),o=v("numElements",e,t,n),i=K$(r,s,a,o);return n.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=v("elementShape",e,t,n),r=v("elementDType",e,t,n);let a;e.op==="TensorListReserve"?a="numElements":a="maxNumElements";const o=v(a,e,t,n),i=e.op==="TensorListReserve"?-1:o,u=H$(s,r,o,i);return n.addTensorList(u),[u.idTensor]}case"TensorListGather":{const s=v("tensorListId",e,t,n),r=v("indices",e,t,n),a=v("elementShape",e,t,n),o=v("elementDType",e,t,n);return[n.getTensorList(s.id).gather(r,o,a)]}case"TensorListStack":{const s=v("tensorListId",e,t,n),r=v("elementShape",e,t,n),a=v("elementDType",e,t,n),o=v("numElements",e,t,n);return[n.getTensorList(s.id).stack(r,a,o)]}case"TensorListFromTensor":{const s=v("tensor",e,t,n),r=v("elementShape",e,t,n),a=v("elementDType",e,t,n),o=q$(s,r,a);return n.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=v("tensorListId",e,t,n),r=n.getTensorList(s.id),a=v("dtype",e,t,n),o=v("elementShape",e,t,n);return[r.concat(a,o)]}case"TensorListPushBack":{const s=v("tensorListId",e,t,n),r=v("tensor",e,t,n),a=n.getTensorList(s.id);return a.pushBack(r),[a.idTensor]}case"TensorListPopBack":{const s=v("tensorListId",e,t,n),r=v("elementShape",e,t,n),a=v("elementDType",e,t,n);return[n.getTensorList(s.id).popBack(r,a)]}case"TensorListSplit":{const s=v("tensor",e,t,n),r=v("elementShape",e,t,n),a=v("lengths",e,t,n),o=U$(s,a,r);return n.addTensorList(o),[o.idTensor]}case"TensorListLength":{const s=v("tensorListId",e,t,n),r=n.getTensorList(s.id);return[fe(r.size(),"int32")]}case"TensorListResize":{const s=v("tensorListId",e,t,n),r=v("size",e,t,n),o=n.getTensorList(s.id).resize(r);return n.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function np(e,t,n){const[s,r]=v("fusedOps",e,t,n),a=s==="biasadd",o=!a,i=r==="prelu",u=s==="fusedbatchnorm",c=v("numArgs",e,t,n);if(a){if(i&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&a&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const l=v("strides",e,t,n),f=Ai(e,t,n),d=v("dataFormat",e,t,n).toUpperCase(),m=v("dilations",e,t,n);let[g,b]=v("args",e,t,n);o&&(b=g,g=void 0);const w=v("leakyreluAlpha",e,t,n);return{stride:l,pad:f,dataFormat:d,dilations:m,biasArg:g,preluArg:b,activationFunc:r,leakyreluAlpha:w}}const X$=(e,t,n,s=Je)=>{switch(e.op){case"Conv1D":{const r=v("stride",e,t,n),a=v("pad",e,t,n),o=v("dataFormat",e,t,n).toUpperCase(),i=v("dilation",e,t,n);return[s.conv1d(v("x",e,t,n),v("filter",e,t,n),r,a,o,i)]}case"Conv2D":{const r=v("strides",e,t,n),a=Ai(e,t,n),o=v("dataFormat",e,t,n).toUpperCase(),i=v("dilations",e,t,n);return[s.conv2d(v("x",e,t,n),v("filter",e,t,n),[r[1],r[2]],a,o,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:r,pad:a,dataFormat:o,dilations:i,biasArg:u,preluArg:c,activationFunc:l,leakyreluAlpha:f}=np(e,t,n);return[s.fused.conv2d({x:v("x",e,t,n),filter:v("filter",e,t,n),strides:[r[1],r[2]],pad:a,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:l,preluActivationWeights:c,leakyreluAlpha:f})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:a,dataFormat:o,dilations:i,biasArg:u,preluArg:c,activationFunc:l,leakyreluAlpha:f}=np(e,t,n);return[s.fused.depthwiseConv2d({x:v("x",e,t,n),filter:v("filter",e,t,n),strides:[r[1],r[2]],pad:a,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:l,preluActivationWeights:c,leakyreluAlpha:f})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=v("outputShape",e,t,n),a=v("strides",e,t,n),o=Ai(e,t,n);return[s.conv2dTranspose(v("x",e,t,n),v("filter",e,t,n),r,[a[1],a[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=v("strides",e,t,n),a=Ai(e,t,n),o=v("dilations",e,t,n),i=v("dataFormat",e,t,n).toUpperCase();return[s.depthwiseConv2d(v("input",e,t,n),v("filter",e,t,n),[r[1],r[2]],a,i,[o[1],o[2]])]}case"Conv3D":{const r=v("strides",e,t,n),a=v("pad",e,t,n),o=v("dataFormat",e,t,n).toUpperCase(),i=v("dilations",e,t,n);return[s.conv3d(v("x",e,t,n),v("filter",e,t,n),[r[1],r[2],r[3]],a,o,[i[1],i[2],i[3]])]}case"AvgPool":{const r=v("strides",e,t,n),a=v("pad",e,t,n),o=v("kernelSize",e,t,n);return[s.avgPool(v("x",e,t,n),[o[1],o[2]],[r[1],r[2]],a)]}case"MaxPool":{const r=v("strides",e,t,n),a=v("pad",e,t,n),o=v("kernelSize",e,t,n);return[s.maxPool(v("x",e,t,n),[o[1],o[2]],[r[1],r[2]],a)]}case"MaxPoolWithArgmax":{const r=v("strides",e,t,n),a=v("pad",e,t,n),o=v("kernelSize",e,t,n),i=v("includeBatchInIndex",e,t,n),{result:u,indexes:c}=s.maxPoolWithArgmax(v("x",e,t,n),[o[1],o[2]],[r[1],r[2]],a,i);return[u,c]}case"AvgPool3D":{const r=v("strides",e,t,n),a=v("pad",e,t,n),o=v("kernelSize",e,t,n);return[s.avgPool3d(v("x",e,t,n),[o[1],o[2],o[3]],[r[1],r[2],r[3]],a)]}case"MaxPool3D":{const r=v("strides",e,t,n),a=v("pad",e,t,n),o=v("kernelSize",e,t,n);return[s.maxPool3d(v("x",e,t,n),[o[1],o[2],o[3]],[r[1],r[2],r[3]],a)]}case"Dilation2D":{const r=v("strides",e,t,n),a=v("pad",e,t,n),o=v("dilations",e,t,n),i=r[1],u=r[2],c=o[1],l=o[2];return[s.dilation2d(v("x",e,t,n),v("filter",e,t,n),[i,u],a,[c,l],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y$=(e,t,n,s=Je)=>{switch(e.op){case"Fill":{const r=v("shape",e,t,n),a=v("dtype",e,t,n),o=v("value",e,t,n);return[s.fill(r,o,a)]}case"LinSpace":{const r=v("start",e,t,n),a=v("stop",e,t,n),o=v("num",e,t,n);return[s.linspace(r,a,o)]}case"Multinomial":{const r=v("logits",e,t,n),a=v("numSamples",e,t,n),o=v("seed",e,t,n);return[s.multinomial(r,a,o)]}case"OneHot":{const r=v("indices",e,t,n),a=v("depth",e,t,n),o=v("onValue",e,t,n),i=v("offValue",e,t,n),u=v("dtype",e,t,n);return[s.oneHot(r,a,o,i,u)]}case"Ones":return[s.ones(v("shape",e,t,n),v("dtype",e,t,n))];case"OnesLike":return[s.onesLike(v("x",e,t,n))];case"RandomStandardNormal":return[s.randomStandardNormal(v("shape",e,t,n),v("dtype",e,t,n),v("seed",e,t,n))];case"RandomUniform":return[s.randomUniform(v("shape",e,t,n),v("minval",e,t,n),v("maxval",e,t,n),v("dtype",e,t,n))];case"RandomUniformInt":return[s.randomUniformInt(v("shape",e,t,n),v("minval",e,t,n),v("maxval",e,t,n),v("seed",e,t,n))];case"Range":{const r=v("start",e,t,n),a=v("stop",e,t,n),o=v("step",e,t,n);return[s.range(r,a,o,v("dtype",e,t,n))]}case"TruncatedNormal":{const r=v("shape",e,t,n),a=v("mean",e,t,n),o=v("stdDev",e,t,n),i=v("seed",e,t,n);return[s.truncatedNormal(r,a,o,v("dtype",e,t,n),i)]}case"Zeros":return[s.zeros(v("shape",e,t,n),v("dtype",e,t,n))];case"ZerosLike":return[s.zerosLike(v("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oc(e,t,n){const s=v("boxes",e,t,n),r=v("scores",e,t,n),a=v("maxOutputSize",e,t,n),o=v("iouThreshold",e,t,n),i=v("scoreThreshold",e,t,n),u=v("softNmsSigma",e,t,n);return{boxes:s,scores:r,maxOutputSize:a,iouThreshold:o,scoreThreshold:i,softNmsSigma:u}}const J$=async(e,t,n,s,r=Je)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:c,softNmsSigma:l}=Oc(e,t,n),f=await r.image.nonMaxSuppressionWithScoreAsync(a,o,i,u,c,l);return[f.selectedIndices,f.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:c}=Oc(e,t,n),l=v("padToMaxOutputSize",e,t,n),f=await r.image.nonMaxSuppressionPaddedAsync(a,o,i,u,c,l);return[f.selectedIndices,f.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:c}=Oc(e,t,n);return[await r.image.nonMaxSuppressionAsync(a,o,i,u,c)]}case"Where":{const a=r.cast(v("condition",e,t,n),"bool"),o=[await r.whereAsync(a)];return a.dispose(),o}case"ListDiff":return r.setdiff1dAsync(v("x",e,t,n),v("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z$=(e,t,n,s=Je)=>{switch(e.op){case"LowerBound":{const r=v("sortedSequence",e,t,n),a=v("values",e,t,n);return[s.lowerBound(r,a)]}case"TopKV2":{const r=v("x",e,t,n),a=v("k",e,t,n),o=v("sorted",e,t,n),i=s.topk(r,a,o);return[i.values,i.indices]}case"UpperBound":{const r=v("sortedSequence",e,t,n),a=v("values",e,t,n);return[s.upperBound(r,a)]}case"Unique":{const r=v("x",e,t,n),a=s.unique(r);return[a.values,a.indices]}case"UniqueV2":{const r=v("x",e,t,n),a=v("axis",e,t,n),o=s.unique(r,a);return[o.values,o.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q$=(e,t,n,s=Je)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const r=v("default",e,t,n);return[Ye(e.name,t,n)||r];case"Placeholder":return[Ye(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const l=v("x",e,t,n);return[Ts(l)]}case"IdentityN":return v("x",e,t,n).map(l=>Ts(l));case"Snapshot":const a=v("x",e,t,n);return[Ts(a)];case"Shape":return[s.tensor1d(v("x",e,t,n).shape,"int32")];case"ShapeN":return v("x",e,t,n).map(l=>s.tensor1d(l.shape));case"Size":return[s.scalar(v("x",e,t,n).size,"int32")];case"Rank":return[s.scalar(v("x",e,t,n).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const o=v("x",e,t,n),i=v("data",e,t,n),u=v("message",e,t,n),c=v("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let l=0;l<i.length;l++)console.log(Array.prototype.slice.call(i[l].dataSync()).slice(0,c));return[o];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tC{get id(){return this.handle.id}constructor(t,n){this.keyDType=t,this.valueDType=n,this.handle=fe(0),this.tensorMap=new Map,cs(this.handle)}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return fe(this.size(),"int32")}async import(t,n){this.checkKeyAndValueTensor(t,n);const s=await t.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),de(()=>{const r=Jr(n),a=s.length,o=r.length;D(a===o,()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${o} elements.`);for(let i=0;i<a;i++){const u=s[i],c=r[i];cs(c),this.tensorMap.set(u,c)}return this.handle})}async find(t,n){this.checkKeyAndValueTensor(t,n);const s=await t.data();return de(()=>{const r=[];for(let a=0;a<s.length;a++){const o=s[a],i=this.findWithDefault(o,n);r.push(i)}return Ps(r)})}findWithDefault(t,n){const s=this.tensorMap.get(t);return s??n}checkKeyAndValueTensor(t,n){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eC=async(e,t,n,s)=>{switch(e.op){case"HashTable":case"HashTableV2":{const r=s.getHashTableHandleByName(e.name);if(r!=null)return[r];{const a=v("keyDType",e,t,n),o=v("valueDType",e,t,n),i=new tC(a,o);return s.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=v("tableHandle",e,t,n,s),a=v("keys",e,t,n),o=v("values",e,t,n);return[await s.getHashTableById(r.id).import(a,o)]}case"LookupTableFind":case"LookupTableFindV2":{const r=v("tableHandle",e,t,n,s),a=v("keys",e,t,n),o=v("defaultValue",e,t,n);return[await s.getHashTableById(r.id).find(a,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=v("tableHandle",e,t,n,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nC=(e,t,n,s=Je)=>{switch(e.op){case"ResizeBilinear":{const r=v("images",e,t,n),a=v("size",e,t,n),o=v("alignCorners",e,t,n),i=v("halfPixelCenters",e,t,n);return[s.image.resizeBilinear(r,[a[0],a[1]],o,i)]}case"ResizeNearestNeighbor":{const r=v("images",e,t,n),a=v("size",e,t,n),o=v("alignCorners",e,t,n),i=v("halfPixelCenters",e,t,n);return[s.image.resizeNearestNeighbor(r,[a[0],a[1]],o,i)]}case"CropAndResize":{const r=v("image",e,t,n),a=v("boxes",e,t,n),o=v("boxInd",e,t,n),i=v("cropSize",e,t,n),u=v("method",e,t,n),c=v("extrapolationValue",e,t,n);return[s.image.cropAndResize(r,a,o,i,u,c)]}case"ImageProjectiveTransformV3":{const r=v("images",e,t,n),a=v("transforms",e,t,n),o=v("outputShape",e,t,n),i=v("fillValue",e,t,n),u=v("interpolation",e,t,n),c=v("fillMode",e,t,n);return[s.image.transform(r,a,u.toLowerCase(),c.toLowerCase(),i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sC=(e,t,n,s=Je)=>{switch(e.op){case"Equal":return[s.equal(v("a",e,t,n),v("b",e,t,n))];case"NotEqual":return[s.notEqual(v("a",e,t,n),v("b",e,t,n))];case"Greater":return[s.greater(v("a",e,t,n),v("b",e,t,n))];case"GreaterEqual":return[s.greaterEqual(v("a",e,t,n),v("b",e,t,n))];case"Less":return[s.less(v("a",e,t,n),v("b",e,t,n))];case"LessEqual":return[s.lessEqual(v("a",e,t,n),v("b",e,t,n))];case"LogicalAnd":return[s.logicalAnd(v("a",e,t,n),v("b",e,t,n))];case"LogicalNot":return[s.logicalNot(v("a",e,t,n))];case"LogicalOr":return[s.logicalOr(v("a",e,t,n),v("b",e,t,n))];case"Select":case"SelectV2":return[s.where(v("condition",e,t,n),v("a",e,t,n),v("b",e,t,n))];case"BitwiseAnd":return[s.bitwiseAnd(v("a",e,t,n),v("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rC=(e,t,n,s=Je)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(v("a",e,t,n),v("b",e,t,n),v("transposeA",e,t,n),v("transposeB",e,t,n))];case"Einsum":return[s.einsum(v("equation",e,t,n),...v("tensors",e,t,n))];case"Transpose":return[s.transpose(v("x",e,t,n),v("perm",e,t,n))];case"_FusedMatMul":const[r,a]=v("fusedOps",e,t,n),o=r==="biasadd",i=a==="prelu",u=v("numArgs",e,t,n),c=v("leakyreluAlpha",e,t,n);if(o){if(i&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[l,f]=v("args",e,t,n);return[s.fused.matMul({a:v("a",e,t,n),b:v("b",e,t,n),transposeA:v("transposeA",e,t,n),transposeB:v("transposeB",e,t,n),bias:l,activation:a,preluActivationWeights:f,leakyreluAlpha:c})];case"MatrixBandPart":return[s.linalg.bandPart(v("a",e,t,n),v("numLower",e,t,n),v("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aC=(e,t,n,s=Je)=>{switch(e.op){case"EuclideanNorm":return[s.euclideanNorm(v("x",e,t,n),v("axis",e,t,n),v("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(v("x",e,t,n),v("mean",e,t,n),v("variance",e,t,n),v("offset",e,t,n),v("scale",e,t,n),v("epsilon",e,t,n))];case"FusedBatchNormV3":return[s.batchNorm(v("x",e,t,n),v("mean",e,t,n),v("variance",e,t,n),v("offset",e,t,n),v("scale",e,t,n),v("epsilon",e,t,n))];case"LRN":return[s.localResponseNormalization(v("x",e,t,n),v("radius",e,t,n),v("bias",e,t,n),v("alpha",e,t,n),v("beta",e,t,n))];case"Softmax":return[s.softmax(v("x",e,t,n))];case"LogSoftmax":return[s.logSoftmax(v("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oC=(e,t,n,s=Je)=>{switch(e.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:a}=s.raggedGather(v("paramsNestedSplits",e,t,n),v("paramsDenseValues",e,t,n),v("indices",e,t,n),v("outputRaggedRank",e,t,n));return r.concat(a)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:a}=s.raggedRange(v("starts",e,t,n),v("limits",e,t,n),v("splits",e,t,n));return[r,a]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(v("shape",e,t,n),v("values",e,t,n),v("defaultValue",e,t,n),v("rowPartitionTensors",e,t,n),v("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iC=(e,t,n,s=Je)=>{switch(e.op){case"Max":{const i=v("axis",e,t,n),u=v("keepDims",e,t,n);return[s.max(v("x",e,t,n),i,u)]}case"Mean":{const i=v("axis",e,t,n),u=v("keepDims",e,t,n);return[s.mean(v("x",e,t,n),i,u)]}case"Min":{const i=v("axis",e,t,n),u=v("keepDims",e,t,n);return[s.min(v("x",e,t,n),i,u)]}case"Sum":{const i=v("axis",e,t,n),u=v("keepDims",e,t,n);return[s.sum(v("x",e,t,n),i,u)]}case"All":{const i=v("axis",e,t,n),u=v("keepDims",e,t,n);return[s.all(v("x",e,t,n),i,u)]}case"Any":{const i=v("axis",e,t,n),u=v("keepDims",e,t,n);return[s.any(v("x",e,t,n),i,u)]}case"ArgMax":{const i=v("axis",e,t,n);return[s.argMax(v("x",e,t,n),i)]}case"ArgMin":{const i=v("axis",e,t,n);return[s.argMin(v("x",e,t,n),i)]}case"Prod":{const i=v("axis",e,t,n),u=v("keepDims",e,t,n);return[s.prod(v("x",e,t,n),i,u)]}case"Cumprod":{const i=v("axis",e,t,n),u=v("exclusive",e,t,n),c=v("reverse",e,t,n);return[s.cumprod(v("x",e,t,n),i,u,c)]}case"Cumsum":{const i=v("axis",e,t,n),u=v("exclusive",e,t,n),c=v("reverse",e,t,n);return[s.cumsum(v("x",e,t,n),i,u,c)]}case"Bincount":const r=v("x",e,t,n),a=v("weights",e,t,n),o=v("size",e,t,n);return[s.bincount(r,a,o)];case"DenseBincount":{const i=v("x",e,t,n),u=v("weights",e,t,n),c=v("size",e,t,n),l=v("binaryOutput",e,t,n);return[s.denseBincount(i,u,c,l)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uC=(e,t,n,s=Je)=>{switch(e.op){case"ConcatV2":case"Concat":{const r=v("n",e,t,n),a=v("axis",e,t,n);let o=v("tensors",e,t,n);return o=o.slice(0,r),[s.concat(o,a)]}case"Gather":{const r=v("x",e,t,n),a=v("indices",e,t,n);return[s.gather(r,s.cast(a,"int32"),0)]}case"GatherV2":{const r=v("axis",e,t,n),a=v("batchDims",e,t,n),o=v("x",e,t,n),i=v("indices",e,t,n);return[s.gather(o,s.cast(i,"int32"),r,a)]}case"Reverse":{const r=v("dims",e,t,n),a=[];for(let i=0;i<r.length;i++)r[i]&&a.push(i);const o=v("x",e,t,n);return[s.reverse(o,a)]}case"ReverseV2":{const r=v("axis",e,t,n),a=v("x",e,t,n);return[s.reverse(a,r)]}case"Slice":{const r=v("begin",e,t,n),a=v("size",e,t,n);return[s.slice(v("x",e,t,n),r,a)]}case"StridedSlice":{const r=v("begin",e,t,n),a=v("end",e,t,n),o=v("strides",e,t,n),i=v("beginMask",e,t,n),u=v("endMask",e,t,n),c=v("ellipsisMask",e,t,n),l=v("newAxisMask",e,t,n),f=v("shrinkAxisMask",e,t,n),d=v("x",e,t,n);return[s.stridedSlice(d,r,a,o,i,u,c,l,f)]}case"Pack":return de(()=>{const r=v("axis",e,t,n),a=v("tensors",e,t,n),o=a[0].shape,i=s.squeeze(a[0]).shape,u=a.map(c=>{const l=Un(c.shape,o);if(!l&&!Un(s.squeeze(c).shape,i))throw new Error("the input tensors shape does not match");return l?c:s.reshape(c,o)});return[s.stack(u,r)]});case"Unpack":{const r=v("axis",e,t,n),a=v("tensor",e,t,n);return s.unstack(a,r)}case"Tile":{const r=v("reps",e,t,n);return[s.tile(v("x",e,t,n),r)]}case"Split":case"SplitV":{const r=v("axis",e,t,n),a=v("numOrSizeSplits",e,t,n),o=v("x",e,t,n);return s.split(o,a,r)}case"ScatterNd":{const r=v("indices",e,t,n),a=v("values",e,t,n),o=v("shape",e,t,n);return[s.scatterND(r,a,o)]}case"GatherNd":{const r=v("x",e,t,n),a=v("indices",e,t,n);return[s.gatherND(r,a)]}case"SparseToDense":{const r=v("sparseIndices",e,t,n),a=v("outputShape",e,t,n),o=v("sparseValues",e,t,n),i=v("defaultValue",e,t,n);return[s.sparseToDense(r,o,a,o.dtype===i.dtype?i:s.cast(i,o.dtype))]}case"TensorScatterUpdate":{const r=v("indices",e,t,n),a=v("values",e,t,n),o=v("tensor",e,t,n);return[s.tensorScatterUpdate(o,r,a)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cC=(e,t,n,s=Je)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:a,emptyRowIndicator:o,reverseIndexMap:i}=s.sparse.sparseFillEmptyRows(v("indices",e,t,n),v("values",e,t,n),v("denseShape",e,t,n),v("defaultValue",e,t,n));return[r,a,o,i]}case"SparseReshape":{const{outputIndices:r,outputShape:a}=s.sparse.sparseReshape(v("inputIndices",e,t,n),v("inputShape",e,t,n),v("newShape",e,t,n));return[r,a]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(v("data",e,t,n),v("indices",e,t,n),v("segmentIds",e,t,n))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(v("data",e,t,n),v("indices",e,t,n),v("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lC=(e,t,n,s=Je)=>{switch(e.op){case"FFT":return[s.fft(v("x",e,t,n))];case"IFFT":return[s.ifft(v("x",e,t,n))];case"RFFT":return[s.rfft(v("x",e,t,n))];case"IRFFT":return[s.irfft(v("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fC=(e,t,n,s=Je)=>{switch(e.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(v("input",e,t,n),v("pattern",e,t,n),v("rewrite",e,t,n),v("replaceGlobal",e,t,n))];case"StringNGrams":{const{nGrams:r,nGramsSplits:a}=s.string.stringNGrams(v("data",e,t,n),v("dataSplits",e,t,n),v("separator",e,t,n),v("nGramWidths",e,t,n),v("leftPad",e,t,n),v("rightPad",e,t,n),v("padWidth",e,t,n),v("preserveShortSequences",e,t,n));return[r,a]}case"StringSplit":{const{indices:r,values:a,shape:o}=s.string.stringSplit(v("input",e,t,n),v("delimiter",e,t,n),v("skipEmpty",e,t,n));return[r,a,o]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(v("input",e,t,n),v("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hC=(e,t,n,s=Je)=>{switch(e.op){case"Cast":return[s.cast(v("x",e,t,n),v("dtype",e,t,n))];case"ExpandDims":{const r=v("axis",e,t,n);return[s.expandDims(v("x",e,t,n),r)]}case"Squeeze":{const r=v("axis",e,t,n);return[s.squeeze(v("x",e,t,n),r)]}case"Reshape":return[s.reshape(v("x",e,t,n),v("shape",e,t,n))];case"EnsureShape":return[s.ensureShape(v("x",e,t,n),v("shape",e,t,n))];case"MirrorPad":return[s.mirrorPad(v("x",e,t,n),v("padding",e,t,n),v("mode",e,t,n))];case"PadV2":case"Pad":return[s.pad(v("x",e,t,n),v("padding",e,t,n),v("constantValue",e,t,n))];case"SpaceToBatchND":{const r=v("blockShape",e,t,n),a=v("paddings",e,t,n);return[s.spaceToBatchND(v("x",e,t,n),r,a)]}case"BatchToSpaceND":{const r=v("blockShape",e,t,n),a=v("crops",e,t,n);return[s.batchToSpaceND(v("x",e,t,n),r,a)]}case"DepthToSpace":{const r=v("blockSize",e,t,n),a=v("dataFormat",e,t,n).toUpperCase();return[s.depthToSpace(v("x",e,t,n),r,a)]}case"BroadcastTo":return[s.broadcastTo(v("x",e,t,n),v("shape",e,t,n))];case"BroadcastArgs":return[s.broadcastArgs(v("s0",e,t,n),v("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sp(e,t,n,s,r=de){const a=((o,i,u)=>{switch(o.category){case"arithmetic":return r(()=>B$(o,i,u));case"basic_math":return r(()=>W$(o,i,u));case"control":return G$(o,i,u);case"convolution":return r(()=>X$(o,i,u));case"creation":return r(()=>Y$(o,i,u));case"dynamic":return J$(o,i,u);case"evaluation":return r(()=>Z$(o,i,u));case"image":return r(()=>nC(o,i,u));case"graph":return r(()=>Q$(o,i,u));case"logical":return r(()=>sC(o,i,u));case"matrices":return r(()=>rC(o,i,u));case"normalization":return r(()=>aC(o,i,u));case"ragged":return r(()=>oC(o,i,u));case"reduction":return r(()=>iC(o,i,u));case"slice_join":return r(()=>uC(o,i,u));case"sparse":return r(()=>cC(o,i,u));case"spectral":return r(()=>lC(o,i,u));case"string":return r(()=>fC(o,i,u));case"transformation":return r(()=>hC(o,i,u));case"hash_table":return eC(o,i,u,s);case"custom":const c=fb(o.op);if(c&&c.customExecutor)return c.customExecutor(new z$(o,i,u));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return Lr(a)?a.then(o=>[].concat(o)):[].concat(a)}class rp{constructor(t={},n={},s={},r={},a){this.weightMap=t,this.tensorArrayMap=n,this.tensorListMap=s,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,n){return{id:t,frameName:n,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let n=0;n<this.contexts.length-1;n++){const s=this.contexts.slice(0,this.contexts.length-n);t.push(this.contextIdforContexts(s))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(t);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(t)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ap(e,t,n,s){const r=new Set,a=[];let o=null,i=null;const u=new Set,c=new Set(Object.keys(e).map(d=>En(d)[0]));s=s||[];const l=new Set(s.map(d=>En(d.name)[0])),f=[...t];for(;f.length>0;){const d=f.pop();if((Ar(d)||vC(d)||kC(d))&&o==null&&(o=d,i=o.children.map(m=>m.name).filter(m=>r.has(m))),r.add(d.name),n[d.name]==null&&!c.has(d.name)&&!l.has(d.name)){if(d.inputs.length===0){a.push(d.name);continue}d.inputs.forEach(m=>{u.has(m.name)||(u.add(m.name),f.push(m))})}}return{inputs:e,outputs:t,usedNodes:r,missingInputs:a,dynamicNode:o,syncInputs:i}}function dC(e,t){const{usedNodes:n,inputs:s}=t,r=Object.keys(s).map(w=>En(w)[0]).map(w=>e.nodes[w]),a=e.initNodes||[],o=w=>n.has(typeof w=="string"?w:w.name);function i(w){return[...new Map(w.map(k=>[k.name,k])).values()]}const u=i([...r,...e.weights,...a]).filter(o),c=i([...u,...Object.values(e.nodes)]).filter(o),l=new Map(c.map(w=>[w.name,w])),f={};for(const w of c){f[w.name]=f[w.name]||0;for(const k of w.children)o(k)||(f[k.name]=Number.POSITIVE_INFINITY),f[k.name]=(f[k.name]||0)+1}const d=Object.entries(f).filter(([,w])=>w===0).map(([w])=>w),m=[...d];for(;d.length>0;){const w=d.pop(),k=l.get(w);for(const N of k.children.filter(o))--f[N.name]===0&&(m.push(N.name),d.push(N.name))}const g=m.map(w=>l.get(w)),b=pC(g,u);return mC(b,u),b}function pC(e,t){const n=new Map(e.map(o=>[o.name,o])),s=t.map(o=>o.name),r=new Set(s);for(;s.length>0;){const o=s.pop(),i=n.get(o);for(const u of i.children)!n.has(u.name)||r.has(u.name)||(r.add(u.name),s.push(u.name))}return e.filter(o=>r.has(o.name))}class yi extends Error{constructor(t){super(`NodesExecutionOrderError: ${t}`)}}function mC(e,t){const n=new Map(e.map((i,u)=>[i.name,u])),s=new Set(t.map(i=>i.name)),r=i=>s.has(typeof i=="string"?i:i.name),a=new Set(e.map(i=>i.name)),o=i=>a.has(typeof i=="string"?i:i.name);for(const i of e){for(const u of i.children.filter(o)){if(!n.has(u.name))throw new yi(`Child ${u.name} of node ${i.name} is unreachable.`);if(n.get(i.name)>n.get(u.name))throw new yi(`Node ${i.name} is scheduled to run after its child ${u.name}.`)}if(!r(i))for(const u of i.inputs){if(!n.has(u.name))throw new yi(`Input ${u.name} of node ${i.name} is unreachable.`);if(n.get(u.name)>n.get(i.name))throw new yi(`Node ${i.name} is scheduled to run before its input ${u.name}.`)}}}function gC(e){const t=new Map(e.map((i,u)=>[i.name,u])),n=Number.MAX_SAFE_INTEGER,s=e.map((i,u)=>Ar(i)?n:u),r=i=>{const u=s[t.get(i.name)];return u??-1},a=e.map((i,u)=>i.children.map(r).reduce((c,l)=>Math.max(c,l),s[u])),o=new Map;for(let i=0;i<e.length;++i){const u=a[i];if(u===n)continue;const c=e[i],l=e[u];o.has(l.name)||o.set(l.name,[]),o.get(l.name).push(c)}return o}const yC=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),bC=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),wC=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Ar(e){return yC.has(e.op)}function vC(e){return bC.has(e.op)}function kC(e){return wC.has(e.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xi{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const n=Object.keys(t).map(s=>t[s].map(r=>r.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(s=>{this._functionExecutorMap[s]=new Xi(t.functions[s],this)})}getCompilationKey(t,n){const s=t.map(a=>a.name).sort(),r=n.map(a=>a.name).sort();return s.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(t,n){const s=ap(t,n,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:o}=s;if(a!=null)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(r.length>0){const c=n.map(f=>f.name),l=Object.keys(t);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${l}]. Missing the following inputs: [${r}]`)}const i=dC(this.graph,s),u=gC(i);return{orderedNodes:i,nodeLiveUntilMap:u}}cloneAndKeepTensor(t){if(t==null)return null;const n=t.clone();return cs(n),n}cloneTensorList(t){return t?t.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([n,s])=>[n,this.cloneTensorList(s)]))}execute(t,n){this.disposeIntermediateTensors(),t=this.mapInputs(t);const s=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);const r=s.map(d=>this.graph.nodes[En(d)[0]]),a=n.map(d=>En(d)[0]),o=new Set(a);let i=a.map(d=>this.graph.nodes[d]);i.length===0&&(i=this._outputs);const u=this.getCompilationKey(r,i);let c=this.compiledMap.get(u);c==null&&(c=this.compile(t,i),this.compiledMap.set(u,c));try{this.keepIntermediateTensors=oe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const l={},f={};return de(()=>{const d=new rp(this.weightMap,l,f,this.functionExecutorMap,this.parseNodeNameCache),m=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(k=>{const[N,_]=En(k,d),I=[];I[_]=t[k],m[N]=I,this.keepIntermediateTensors&&(this.clonedTensorsMap[N]=this.cloneTensorList(I))});const g=this.getFrozenTensorIds(m),{orderedNodes:b,nodeLiveUntilMap:w}=c;for(const k of b){if(m[k.name])continue;const N=sp(k,m,d,this._resourceManager);if(Lr(N))throw new Error(`The execution of the op '${k.op}' returned a promise. Please use model.executeAsync() instead.`);m[k.name]=N,this.keepIntermediateTensors&&(this.clonedTensorsMap[k.name]=this.cloneTensorList(N)),this.checkTensorForDisposalWithNodeLiveUntilInfo(k,m,d,g,o,w.get(k.name))}return this.parent==null&&d.dispose(g),n.map(k=>Ye(k,m,d))})}getFrozenTensorIds(t){const n=[].concat.apply([],Object.keys(t).map(s=>t[s]).map(s=>s.map(r=>r.id)));return new Set(n)}checkTensorForDisposal(t,n,s,r,a,o,i){if(!(Ar(n)||o.has(t))){for(const u of s[t])u!=null&&(i[u.id]=(i[u.id]||0)+n.children.length);for(const u of n.inputs){if(Ar(u))continue;const c=Zd(u.name,s,r);if(c!=null)for(const l of c){if(!l||l.kept||a.has(l.id))continue;const f=i[l.id];f===1?(l.dispose(),delete i[l.id]):f!=null&&i[l.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,n,s,r,a,o){function i(u){return Ar(u)||a.has(u.name)}if(!(Ar(t)||o==null))for(const u of o){if(i(u))continue;const c=Zd(u.name,n,s);for(const l of c)!l||l.kept||r.has(l.id)||l.dispose()}}async executeAsync(t,n){return this._executeAsync(t,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(const n of t)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,n,s=!1,r={},a={}){this.disposeIntermediateTensors(),s||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=oe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const o=new rp(this.weightMap,r,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const i=await this.executeWithControlFlow(t,o,n,s),u=n.map(d=>Ye(d,i,o)),c=u.map(d=>d.id),l=Object.keys(t).map(d=>t[d].id),f=new Set([...c,...l,...this.weightIds]);return Object.values(i).forEach(d=>{d.forEach(m=>{m&&!m.isDisposed&&!f.has(m.id)&&m.dispose()})}),this.parent==null&&o.dispose(f),u}async executeFunctionAsync(t,n,s){const r=t.reduce((a,o,i)=>(a[this.inputs[i].name]=o,a),{});return this._executeAsync(r,this.outputNodes,!0,n,s)}async executeWithControlFlow(t,n,s,r){const a=Object.keys(t),o=a.map(I=>this.graph.nodes[En(I)[0]]),i=s.map(I=>En(I)[0]),u=new Set(i);let c=i.map(I=>this.graph.nodes[I]);c.length===0&&(c=this._outputs);const{usedNodes:l,missingInputs:f,dynamicNode:d,syncInputs:m}=ap(t,c,this.weightMap,this._initNodes),g=[...o,...this.graph.weights,...this._initNodes||[]].map(I=>({node:I,contexts:n.currentContext})),b=Object.assign({},this.weightMap);Object.keys(t).forEach(I=>{const[$,O]=En(I),R=[];R[O]=t[I],b[$]=R});const w={},k=this.getFrozenTensorIds(b),N={};for(;g.length>0;){const I=this.processStack(o,g,n,b,N,k,u,w,l);await Promise.all(I)}d==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const _=c.filter(I=>!Ar(I)&&!Ye(I.name,b,n)).map(I=>I.name);if(_.length>0){let I="";throw d!=null&&(I=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${m}]`),new Error(`Cannot compute the outputs [${_}] from the provided inputs [${a}]. Consider providing the following inputs: [${f}]. ${I}`)}return b}processStack(t,n,s,r,a,o,i,u,c){const l=[];for(;n.length>0;){const f=n.pop();s.currentContext=f.contexts;let d="";if(f.node.op==="Enter"&&v("isConstant",f.node,r,s)&&([d]=_s(f.node.name,s)),r[f.node.name]==null){const m=sp(f.node,r,s,this._resourceManager);d||([d]=_s(f.node.name,s));const g=s.currentContext;Lr(m)?l.push(m.then(b=>(r[d]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(b)),s.currentContext=g,this.checkTensorForDisposal(d,f.node,r,s,o,i,u),this.processChildNodes(f.node,n,s,r,a,c),b))):(r[d]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(m)),this.checkTensorForDisposal(d,f.node,r,s,o,i,u),this.processChildNodes(f.node,n,s,r,a,c))}else this.processChildNodes(f.node,n,s,r,a,c)}return l}processChildNodes(t,n,s,r,a,o){t.children.forEach(i=>{const[u]=_s(i.name,s);a[u]||!o.has(i.name)||(i.op==="Merge"?i.inputNames.some(c=>!!Ye(c,r,s))&&(a[u]=!0,n.push({contexts:s.currentContext,node:i})):i.inputNames.every(c=>!!Ye(c,r,s))&&(a[u]=!0,n.push({contexts:s.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{const s=t[n],[r]=En(n),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){const o=a.attrParams.shape.value,i=o.length===s.shape.length&&s.shape.every((u,c)=>o[c]===-1||o[c]===u);D(i,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${o}], but was [${s.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&D(s.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(t){var n,s;const r={};for(const a in t){const o=(s=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||s===void 0?void 0:s[a];o!=null?r[o.name]=t[a]:r[a]=t[a]}return r}checkInputs(t){const n=Object.keys(t).filter(s=>{const[r]=En(s);return this.graph.nodes[r]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>{var s,r;const a=(r=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||r===void 0?void 0:r[n];return a!=null?a.name:n},{})}checkOutputs(t){t.forEach(n=>{const[s]=En(n);if(!this.graph.nodes[s])throw new Error(`The output '${n}' is not found in the graph`)})}}class xC{constructor(t={},n={}){this.hashTableNameToHandle=t,this.hashTableMap=n}addHashTable(t,n){this.hashTableNameToHandle[t]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SC="?tfjs-format=file",IC="model.json";class NC{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,n={},s=ob){this.modelUrl=t,this.loadOptions=n,this.version="n/a",this.io=s,n==null&&(this.loadOptions={}),this.resourceManager=new xC}findIOHandler(){const t=this.modelUrl;if(t.load!=null)this.handler=t;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const n=this.io.getLoadHandlers(t,this.loadOptions);if(n.length===0)n.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[t]}'`);this.handler=n[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return Lr(t)?t.then(n=>n.getWeightStream==null?this.loadSync(n):this.loadStreaming(n)):this.loadSync(t)}loadSync(t){const n=this.io.decodeWeights(t.weightData,t.weightSpecs);return this.loadWithWeightMap(t,n)}async loadStreaming(t){if(t.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const n=await ey(t.getWeightStream(),t.weightSpecs);return this.loadWithWeightMap(t,n)}loadWithWeightMap(t,n){this.artifacts=t;const s=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const a=this.artifacts.userDefinedMetadata;a.signature!=null&&(r=a.signature),a.structuredOutputKeys!=null&&(this.structuredOutputKeys=a.structuredOutputKeys)}if(this.signature=r,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new Xi(Qd.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(n),this.executor.resourceManager=this.resourceManager,t.modelInitializer!=null&&t.modelInitializer.node!=null){const a=Qd.Instance.transformGraph(t.modelInitializer);this.initializer=new Xi(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}async save(t,n){if(typeof t=="string"){const s=this.io.getSaveHandlers(t);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${t}'`);t=s[0]}if(t.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}addStructuredOutputNames(t){if(this.structuredOutputKeys){const n=t instanceof cn?[t]:t,s={};return n.forEach((r,a)=>s[this.structuredOutputKeys[a]]=r),s}return t}predict(t,n){const s=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(t,n){const s=await this.executeAsync(t,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(t){var n;if(!(t instanceof cn)&&!Array.isArray(t)){const a=(n=this.signature)===null||n===void 0?void 0:n.inputs;if(a!=null)for(const o in a){const i=a[o];i.resourceId!=null&&(t[o]=this.resourceIdToCapturedInput[i.resourceId])}return t}t=Array.isArray(t)?t:[t];const s=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${t.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((a,o)=>{var i,u,c;const l=(c=(u=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||u===void 0?void 0:u[o])===null||c===void 0?void 0:c.resourceId;return l!=null?a[o]=this.resourceIdToCapturedInput[l]:a[o]=t[r++],a},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const n=this.initializerSignature.outputs,s=Object.keys(n);for(let r=0;r<s.length;r++){const a=s[r],o=n[a];this.resourceIdToCapturedInput[o.resourceId]=t[r]}}}execute(t,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),n=this.normalizeOutputs(n);const s=this.executor.execute(t,n);return s.length>1?s:s[0]}async executeAsync(t,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),t=this.normalizeInputs(t),n=this.normalizeOutputs(n);const s=await this.executor.executeAsync(t,n);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((n,s)=>(n[s]=[t[s]],n),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Sn(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function _C(e,t={},n=ob){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof e=="string"&&(e=TC(e));const s=new NC(e,t,n);return await s.load(),s}function TC(e){return e.endsWith("/")||(e=e+"/"),`${e}${IC}${SC}`}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jt(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&D(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EC=Ky;class _u extends Kp{nextDataId(){return _u.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Dw(this,Cd())}write(t,n,s){this.firstUse&&(this.firstUse=!1,oe().get("IS_NODE")&&Cr(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:t,dtype:s,refCount:1}),r}makeTensorInfo(t,n,s){let r;if(n==="string"&&s!=null&&s.length>0&&du(s[0])){const a=s.map(o=>Pr(o));r=this.write(a,t,n)}else r=this.write(s,t,n);return{dataId:r,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){const n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){const n=this.data.get(t);n.refCount--}}move(t,n,s,r,a){this.data.set(t,{values:n,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:n,complexTensorInfos:s}=this.data.get(t);if(n==="complex64"){const r=this.readSync(s.real.dataId),a=this.readSync(s.imag.dataId);return Ta(r,a)}return Ww(this.data.get(t).values,n)}bufferSync(t){const n=this.readSync(t.dataId);if(t.dtype==="string")try{const s=n.map(r=>vo(r));return ce(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ce(t.shape,t.dtype,n)}makeOutput(t,n,s){return Cd().makeTensorFromTensorInfo(this.makeTensorInfo(n,s,t),this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(t);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const n=Sa();return t(),{kernelMs:Sa()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){jt([t],"where");const n=this.readSync(t.dataId);return EC(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}_u.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $C(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const CC=e=>{const{x:t}=e.inputs,n=e.backend;jt(t,"abs");let s=new Float32Array(It(t.shape));const r=n.data.get(t.dataId).values;return s=$C(r),n.makeOutput(s,t.shape,t.dtype)},OC={kernelName:Jp,backendName:"cpu",kernelFunc:CC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Me(e){return(t,n,s,r,a)=>{const o=Fe(t,n),i=o.length,u=Kt(o),c=It(o),l=mn(a,c),f=t.length,d=n.length,m=Kt(t),g=Kt(n),b=ji(t,o),w=ji(n,o);if(b.length+w.length===0)for(let k=0;k<l.length;++k)l[k]=e(s[k%s.length],r[k%r.length]);else for(let k=0;k<l.length;++k){const N=Pa(k,i,u),_=N.slice(-f);b.forEach(R=>_[R]=0);const I=ls(_,f,m),$=N.slice(-d);w.forEach(R=>$[R]=0);const O=ls($,d,g);l[k]=e(s[I],r[O])}return[l,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cn(e){const{inputs:t,backend:n}=e,{real:s,imag:r}=t,a=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,i=n.makeTensorInfo(s.shape,"complex64"),u=n.data.get(i.dataId);return u.complexTensorInfos={real:n.makeTensorInfo(s.shape,"float32",a),imag:n.makeTensorInfo(r.shape,"float32",o)},i}const DC={kernelName:cm,backendName:"cpu",kernelFunc:Cn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yi(e,t,n="float32"){if(n==="complex64"){const r=Yi(e,t,"float32"),a=Yi(e,t,"float32");return Cn({inputs:{real:r,imag:a},backend:e})}const s=tn(It(t),n);return e.makeTensorInfo(t,n,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ms(e){const{inputs:t,backend:n}=e,{x:s}=t;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const AC={kernelName:hf,backendName:"cpu",kernelFunc:ms};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ur(e){const{inputs:t,backend:n}=e,{input:s}=t,r=n.data.get(s.dataId).complexTensorInfos.real,a=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,a)}const FC={kernelName:ug,backendName:"cpu",kernelFunc:Ur};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RC(e,t,n,s){if(s==="int32"){const r=Int32Array.from(e);return[t,"int32",r]}if(s==="bool"){const r=Xr([0],n),[a,o]=Me((i,u)=>i!==u?1:0)(t,[],e,r,"bool");return[o,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${s}`)}function lr(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{dtype:a}=s;if(a==="complex64"){if(r.dtype==="complex64")return ms({inputs:{x:r},backend:n});const l=Yi(n,r.shape,r.dtype),f=lr({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),d=Cn({inputs:{real:f,imag:l},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(f),d}if(r.dtype==="complex64"){const l=Ur({inputs:{input:r},backend:n}),f=lr({inputs:{x:l},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(l),f}if(!Vw(r.dtype,a)){const l=ms({inputs:{x:r},backend:n});return{dataId:l.dataId,shape:l.shape,dtype:a}}const o=n.data.get(r.dataId).values,[i,u,c]=RC(o,r.shape,r.dtype,a);return n.makeTensorInfo(i,u,c)}const PC={kernelName:Yl,backendName:"cpu",kernelFunc:lr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qe(e,t,n,s){return n==null?({inputs:r,backend:a})=>{const{a:o,b:i}=r,u=a;jt([o,i],e);const c=u.data.get(o.dataId).values,l=u.data.get(i.dataId).values,f=o.dtype==="string"?$o(c):c,d=o.dtype==="string"?$o(l):l,m=s||o.dtype,[g,b]=t(o.shape,i.shape,f,d,m);return u.makeTensorInfo(b,m,g)}:({inputs:r,backend:a})=>{const{a:o,b:i}=r,u=a;if(o.dtype==="complex64"||i.dtype==="complex64"){const c=lr({inputs:{x:o},backend:u,attrs:{dtype:"complex64"}}),l=u.data.get(c.dataId),f=l.complexTensorInfos.real,d=l.complexTensorInfos.imag,m=u.data.get(f.dataId).values,g=u.data.get(d.dataId).values,b=lr({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),w=u.data.get(b.dataId),k=w.complexTensorInfos.real,N=w.complexTensorInfos.imag,_=u.data.get(k.dataId).values,I=u.data.get(N.dataId).values,[$,O,R]=n(o.shape,i.shape,m,g,_,I),W=u.makeTensorInfo(R,"float32",$),P=u.makeTensorInfo(R,"float32",O),M=Cn({inputs:{real:W,imag:P},backend:u});return u.disposeIntermediateTensorInfo(c),u.disposeIntermediateTensorInfo(b),u.disposeIntermediateTensorInfo(W),u.disposeIntermediateTensorInfo(P),M}else{const c=u.data.get(o.dataId).values,l=u.data.get(i.dataId).values,f=s||o.dtype,[d,m]=t(o.shape,i.shape,c,l,f);return u.makeTensorInfo(m,f,d)}}}function gh(e){return(t,n,s,r,a,o)=>{const i=Fe(t,n),u=It(i),c=i.length,l=Kt(i),f=mn("float32",u),d=mn("float32",u),m=ji(t,i),g=ji(n,i),b=Ta(s,r),w=Ta(a,o),k=t.length,N=Kt(t),_=n.length,I=Kt(n);if(m.length+g.length===0)for(let $=0;$<f.length;$++){const O=$%b.length,R=$%w.length,W=e(b[O*2],b[O*2+1],w[R*2],w[R*2+1]);f[$]=W.real,d[$]=W.imag}else for(let $=0;$<f.length;$++){const O=Pa($,c,l),R=O.slice(-k);m.forEach(q=>R[q]=0);const W=ls(R,k,N),P=O.slice(-_);g.forEach(q=>P[q]=0);const M=ls(P,_,I),T=e(b[W*2],b[W*2+1],w[M*2],w[M*2+1]);f[$]=T.real,d[$]=T.imag}return[f,d,i]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MC=Me((e,t)=>e+t),VC=gh((e,t,n,s)=>({real:e+n,imag:t+s})),Ea=qe(pu,MC,VC),LC={kernelName:pu,backendName:"cpu",kernelFunc:Ea};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pb(e,t,n,s,r){const a=It(s),o=tn(r,n);for(let i=0;i<e.length;i++){const u=e[i];if(u<0)throw new Error("Input x must be non-negative!");u>=r||(a>0?o[u]+=t[i]:o[u]+=1)}return o}function zC(e,t,n,s=!1){const r=e.shape[0],a=e.shape[1],o=ce([r,n],t.dtype);for(let i=0;i<r;i++)for(let u=0;u<a;u++){const c=e.get(i,u);if(c<0)throw new Error("Input x must be non-negative!");c>=n||(s?o.set(1,i,c):t.size>0?o.set(o.get(i,c)+t.get(i,u),i,c):o.set(o.get(i,c)+1,i,c))}return o}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BC=Me((e,t)=>e&t),WC=qe(Xl,BC),jC={kernelName:Xl,backendName:"cpu",kernelFunc:WC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mr(e){return(t,n,s)=>{const r=ze(n,t.length);for(let a=0;a<t.length;++a)r[a]=e(t[a],s);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ye(e,t,n){const s=mr(t);return gr(e,s,n)}function gr(e,t,n){return({inputs:s,attrs:r,backend:a})=>{const{x:o}=s;jt(o,e);const i=a,u=i.data.get(o.dataId).values;let c;if(o.dtype==="string"){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");c=$o(u)}else c=u;const l=n||o.dtype,f=t(c,l,r);return i.makeTensorInfo(o.shape,l,f)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qC=mr(e=>Math.ceil(e)),HC=gr(Jl,qC),KC={kernelName:Jl,backendName:"cpu",kernelFunc:HC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UC(e,t,n,s){const r=ze(n,It(t));if(s&&n!=="string"){let a=0;e.forEach(o=>{const i=It(o.shape);r.set(o.vals,a),a+=i})}else{let a=0;e.forEach(o=>{const i=n==="string"?$o(o.vals):o.vals;let u=0;for(let c=0;c<o.shape[0];++c){const l=c*t[1]+a;for(let f=0;f<o.shape[1];++f)r[l+f]=i[u++]}a+=o.shape[1]})}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GC=Me((e,t)=>e===t?1:0),mb=qe(rf,GC,null,"bool"),XC={kernelName:rf,backendName:"cpu",kernelFunc:mb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YC=mr(e=>Math.exp(e)),gb=gr(af,YC,"float32"),JC={kernelName:af,backendName:"cpu",kernelFunc:gb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZC=mr(e=>Math.expm1(e)),QC=gr(of,ZC),tO={kernelName:of,backendName:"cpu",kernelFunc:QC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eO=mr(e=>Math.floor(e)),nO=gr(uf,eO),sO={kernelName:uf,backendName:"cpu",kernelFunc:nO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rO=Me((e,t)=>Math.floor(e/t)),aO=qe(cf,rO,null,"int32"),oO={kernelName:cf,backendName:"cpu",kernelFunc:aO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iO(e,t,n,s,r,a,o,i,u){const c=ce([s,a],n);for(let l=0;l<s;l++){const f=[];let d=0;for(let m=0;m<r;m++){const g=e[l*r+m];d+=g*o[m],f.push(g)}if(d<0||d>=u/a)throw new Error(`Invalid indices: ${f} does not index into ${i}`);for(let m=0;m<a;m++)c.values[l*a+m]=t.get(...t.indexToLoc(d*a+m))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uO(e,t,n){const s=ce(n,e.dtype);for(let r=0;r<s.size;++r){const o=s.indexToLoc(r).slice(),i=o[0],u=o[2],c=t.locToIndex([i,u]);o[2]=t.values[c];const l=e.locToIndex(o);0<=l&&l<e.values.length&&(s.values[r]=e.values[l])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cO=Me((e,t)=>e>t?1:0),lO=qe(lf,cO,null,"bool"),fO={kernelName:lf,backendName:"cpu",kernelFunc:lO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hO=Me((e,t)=>e>=t?1:0),dO=qe(ff,hO,null,"bool"),pO={kernelName:ff,backendName:"cpu",kernelFunc:dO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mO=Me((e,t)=>e<t?1:0),gO=qe(gf,mO,null,"bool"),yO={kernelName:gf,backendName:"cpu",kernelFunc:gO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bO=Me((e,t)=>e<=t?1:0),wO=qe(yf,bO,null,"bool"),vO={kernelName:yf,backendName:"cpu",kernelFunc:wO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kO(e,t,n){const s=(t-e)/(n-1),r=tn(n,"float32");r[0]=e;for(let a=1;a<r.length;a++)r[a]=r[a-1]+s;return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xO=mr(e=>Math.log(e)),SO=gr(bf,xO),IO={kernelName:bf,backendName:"cpu",kernelFunc:SO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NO(e,t,n,s){const r=mn(s,It(n));for(let a=0;a<r.length;++a){const o=a*t;let i=e[o];for(let u=0;u<t;++u){const c=e[o+u];(Number.isNaN(c)||c>i)&&(i=c)}r[a]=i}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _O=Me((e,t)=>Math.max(e,t)),TO=qe(Sf,_O),EO={kernelName:Sf,backendName:"cpu",kernelFunc:TO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $O=Me((e,t)=>Math.min(e,t)),CO=qe(If,$O),OO={kernelName:If,backendName:"cpu",kernelFunc:CO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yb=Me((e,t)=>e*t),DO=gh((e,t,n,s)=>({real:e*n-t*s,imag:e*s+t*n})),Tu=qe(_f,yb,DO),AO={kernelName:_f,backendName:"cpu",kernelFunc:Tu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FO(e,t,n){const s=Gf(-1,n);return yb([],t,s,e,n)}function RO(e){const{inputs:t,backend:n}=e,{x:s}=t;jt(s,"neg");const r=n.data.get(s.dataId).values,[a,o]=FO(r,s.shape,s.dtype);return n.makeTensorInfo(o,s.dtype,a)}const PO={kernelName:Gm,backendName:"cpu",kernelFunc:RO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MO=Me((e,t)=>e!==t?1:0),VO=qe(Tf,MO,null,"bool"),LO={kernelName:Tf,backendName:"cpu",kernelFunc:VO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bb(e,t,n,s,r){const a=t.length,o=It(t),i=Kt(t),u=Kt(r),c=mn(n,It(r));for(let l=0;l<o;++l){const f=Pa(l,a,i),d=new Array(f.length);for(let g=0;g<d.length;g++)d[g]=f[s[g]];const m=ls(d,a,u);c[m]=e[l]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nn(e){const{inputs:t,attrs:n,backend:s}=e,{x:r}=t,{perm:a}=n;jt(r,"transpose");const o=r.shape.length,i=new Array(o);for(let f=0;f<i.length;f++)i[f]=r.shape[a[f]];const u=s.data.get(r.dataId).values,c=bb(u,r.shape,r.dtype,a,i);return{dataId:s.write(c,i,r.dtype),shape:i,dtype:r.dtype}}const zO={kernelName:Si,backendName:"cpu",kernelFunc:Nn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BO(e,t,n,s){const[r,a]=zs(e,s),o=Ma(t,"int32"),i=tn(It(r),o),u=It(a);for(let c=0;c<i.length;++c){const l=c*u;let f=1;for(let d=0;d<u;++d)f*=n[l+d];i[c]=f}return{outVals:i,outShape:r,outDtype:o}}function WO(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:o}=s;jt(r,"prod");const i=r.shape.length,u=Ue(a,r.shape),c=ws(u,i);let l=u,f=r;const d=[];c!=null&&(f=Nn({inputs:{x:r},backend:n,attrs:{perm:c}}),d.push(f),l=vs(l.length,i));const m=n.data.get(f.dataId).values,{outVals:g,outShape:b,outDtype:w}=BO(f.shape,f.dtype,m,l);let k=b;return o&&(k=es(b,u)),d.forEach(N=>n.disposeIntermediateTensorInfo(N)),n.makeTensorInfo(k,w,g)}const jO={kernelName:sg,backendName:"cpu",kernelFunc:WO};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qO(e,t,n){e.forEach((s,r)=>{if(s<0||s>=n){const a=Pa(r,t.length,Kt(t)).join(",");throw new Error(`indices[${a}] = ${s} is not in [0, ${n})`)}})}function HO(e,t){for(let n=0;n<e.length;++n){const s=e[n],r=n===e.length-1?t:e[n+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let a=1;a<s.length;++a)if(s[a-1]>s[a])throw new Error("Ragged splits must be sorted in ascending order")}}function KO(e,t,n,s){const r=[];let a=0;const o=t.length-1+n.length,i=new Array(o).fill(null).map(()=>[0]);HO(n,s);let u=1;for(let c=0;c<t.length-1;++c){u*=t[c];const l=t[c+1];for(let f=1;f<u+1;++f)i[c].push(f*l)}for(let c=0;c<e.length;++c){let l=e[c],f=e[c]+1;for(let d=0;d<n.length;++d){const m=n[d],g=d+t.length-1;if(g>=0){const b=i[g],w=b[b.length-1]-m[l];for(let k=l;k<f;++k)i[g].push(m[k+1]+w)}l=m[l],f=m[f]}f!==l&&(r.push([l,f]),a+=f-l)}return{outSplits:i,valueSlices:r,numValues:a}}function UO(e){const t=[];for(let n=0;n<e.length;++n){const s=e[n].length,r=ze("int32",s);t.push(r),e[n].forEach((a,o)=>r[o]=a)}return t}function op(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let s=t;s<e.length;s++)n[t-1]*=e[s];return n}function GO(e,t,n,s,r,a){const o=op(t,2)[1],i=op(a,2)[1];let u=0;for(const c of n)for(let l=c[0];l<c[1];++l){for(let f=0;f<s;++f)r[u*i+f]=e[l*o+f];++u}}function XO(e,t,n,s,r){const a=t.slice();a[0]=r;const o=ze(n,It(a)),i=e.length,u=i===0?0:i/t[0];return GO(e,t,s,u,o,a),[o,a]}function YO(e,t,n,s,r,a,o,i){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");const u=t[0][0]-1;if(qO(a,o,u),s.length===0)throw new Error("params.rank must be nonzero");const c=s[0],{outSplits:l,valueSlices:f,numValues:d}=KO(a,o,e,c),m=UO(l),g=XO(n,s,r,f,d);return[m,g[0],g[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ip=2147483647;function JO(e,t,n,s,r,a,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const i=t.length===0,u=r.length===0,c=o.length===0,l=[];i||l.push(t[0]),u||l.push(r[0]),c||l.push(o[0]);for(let w=1;w<l.length;++w)if(l[w]!==l[w-1])throw new Error("starts, limits, and deltas must have the same shape");const f=l.length===0?1:l[0],d=ze("int32",f+1);d[0]=0;for(let w=0;w<f;++w){const k=i?e[0]:e[w],N=u?s[0]:s[w],_=c?a[0]:a[w];if(_===0)throw new Error("Requires delta != 0");let I;if(_>0&&N<k||_<0&&N>k)I=0;else if(I=Math.ceil(Math.abs((N-k)/_)),I>ip)throw new Error(`Requires ((limit - start) / delta) <= ${ip}`);d[w+1]=d[w]+I}const m=d[f],g=ze(n,m);let b=0;for(let w=0;w<f;++w){const k=d[w+1]-d[w];let N=i?e[0]:e[w];const _=c?a[0]:a[w];for(let I=0;I<k;++I)g[b++]=N,N+=_}return[d,g]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Bn=is;class Ji{constructor(t,n,s,r,a,o,i,u,c,l){this.shape=t,this.shapeShape=n,this.values=s,this.valuesShape=r,this.valuesDType=a,this.defaultValue=o,this.defaultValueShape=i,this.rowPartitionValues=u,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=h2(l),this.raggedRank=d2(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Bn.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Bn.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Bn.VALUE_ROWIDS:return Ji.getMaxWidthValueRowID(n);case Bn.ROW_SPLITS:return Ji.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${Bn[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const n=t.length;if(n===0||n===1)return 0;let s=0;for(let r=0;r<n-1;++r){const a=t[r+1]-t[r];a>s&&(s=a)}return s}static getMaxWidthValueRowID(t){const n=t.length;if(n===0)return 0;let s=0,r=t[0],a=0;for(let o=1;o<n;++o){const i=t[o];i!==r&&(r=i,a=Math.max(o-s,a),s=o)}return Math.max(n-s,a)}tensorShapeFromTensor(t,n,s=!0){if(n.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return cp(t,s)}calculateOutputSize(t){const n=this.valuesShape,s=this.defaultValueShape;p2(s,n);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=f2(this.raggedRank,r,n);o[0]<0&&(o[0]=t);for(let i=1;i<=this.raggedRank;++i)o[i]<0&&(o[i]=this.getMaxWidth(i));return o}calculateFirstParentOutputIndex(t,n,s){const r=Math.min(t,s),a=[];let o=0;for(let i=0;i<r;++i,o+=n)a.push(o);for(let i=r;i<t;++i)a.push(-1);return D(a.length===t,()=>"Final length of result must be equal to firstDimension."),a}calculateOutputIndexRowSplit(t,n,s,r){const a=t.length,o=[];for(let i=0;i<a-1;++i){const u=t[i+1]-t[i];let c=Math.min(r,u),l=n[i];l===-1&&(c=0);for(let f=0;f<c;++f)o.push(l),l+=s;for(let f=0;f<u-c;++f)o.push(-1)}if(a>0&&o.length!==t[a-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(t,n,s,r){const a=t.length,o=[];if(a===0)return[];let i=0,u=t[0];if(u>=n.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${n.length}`);let c=n[u];o.push(c);for(let l=1;l<a;++l){const f=t[l];if(f===u)c>=0&&(++i,i<r?c+=s:c=-1);else{if(i=0,u=f,f>=n.length)throw new Error(`Got nextValueRowId=${f} which is not less than ${n.length}`);c=n[f]}o.push(c)}if(o.length!==t.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(t,n,s,r){const a=this.getRowPartitionTensor(t),o=this.getRowPartitionTypeByDimension(t);switch(o){case Bn.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,n,s,r);case Bn.ROW_SPLITS:if(a.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(a,n,s,r);default:throw new Error(`Unsupported partition type: ${Bn[o]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const n=this.rowPartitionTypes[0];switch(n){case Bn.FIRST_DIM_SIZE:return t[0];case Bn.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Bn.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Bn[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const n=this.getFirstDimensionSize(),s=this.calculateOutputSize(n),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let u=r.length-2;u>=0;--u)r[u]=r[u+1]*s[u+1];const a=cp(s,!1),o=ze(this.valuesDType,It(a));if(r[0]*s[0]>0){let u=this.calculateFirstParentOutputIndex(n,r[0],s[0]);for(let c=1;c<=this.raggedRank;++c)u=this.calculateOutputIndex(c-1,u,r[c],s[c]);this.setOutput(this.raggedRank,u,o,a)}return[a,o]}setOutput(t,n,s,r){if(s.length===0)return;const a=this.values,o=s;let i=r.slice();i=i.slice(t+1);const u=It(i),c=n.length;let l=this.defaultValue;if(l.length!==u&&l.length!==1){const g=this.defaultValueShape;de(()=>{const b=mt(l,g);l=io(b,i).dataSync()})}let f=0,d=0,m=0;for(let g=0;g<=c;++g){let b=g<c?n[g]:-1;if(b===m){++m;continue}if(d<m){const w=a.subarray(f*u),k=o.subarray(d*u),N=(m-d)*u;up(k,w,N)}if(g>=c){const w=s.length;b=Math.floor(w/u)}if(b>m)if(this.defaultValue.length===1)o.subarray(m*u,b*u).fill(this.defaultValue[0]),m=b;else for(;b>m;){const w=o.slice(m*u);up(w,l,u),++m}b<0?(f=g+1,d=m):(f=g,d=m,m=d+1)}}}function up(e,t,n){for(let s=0;s<n;s++)e[s]=t[s]}function cp(e,t){const n=[];for(let s of e){if(s<0){if(!t)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}n.push(s)}return n}function ZO(e,t,n,s,r,a,o,i,u,c){return new Ji(e,t,n,s,r,a,o,i,u,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QO(e,t,n,s){const r=e===t,a=e<t&&n<0,o=t<e&&n>1;if(r||a||o)return tn(0,s);const i=Math.abs(Math.ceil((t-e)/n)),u=tn(i,s);t<e&&n===1&&(n=-1),u[0]=e;for(let c=1;c<u.length;c++)u[c]=u[c-1]+n;return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tD=mr(e=>1/Math.sqrt(e)),eD=gr(Af,tD),nD={kernelName:Af,backendName:"cpu",kernelFunc:eD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ha(e,t,n,s,r,a,o,i,u,c){const l=[s/r,r],f=e.values,d=t.values;if(s===0)return ce(n,t.dtype);const m=u instanceof je?u:ce(l,t.dtype);typeof u=="string"||typeof u=="number"?m.values.fill(u):typeof u=="boolean"&&m.values.fill(+u);for(let g=0;g<a;g++){const b=[];let w=0;for(let k=0;k<o;k++){const N=f[g*o+k];b.push(N),w+=N*i[k]}if(w<0||w>=s/r)throw new Error(`Invalid indices: ${b} does not index into ${n}`);for(let k=0;k<r;k++)c?m.values[w*r+k]+=d[g*r+k]:m.values[w*r+k]=t.rank===0?d[0]:d[g*r+k]}return m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wb=ye(Vf,e=>1/(1+Math.exp(-e))),sD={kernelName:Vf,backendName:"cpu",kernelFunc:wb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rD(e,t,n,s,r){const a=a2(s,t,n),o=It(n),i=Kt(s);if(a){const f=o2(t,i);return r==="string"?e.slice(f,f+o):e.subarray(f,f+o)}const u=r==="string"?$o(e):e,c=ce(s,r,u),l=ce(n,r);for(let f=0;f<l.size;++f){const d=l.indexToLoc(f),m=d.map((g,b)=>g+t[b]);l.set(c.get(...m),...d)}return r==="string"?Z2(l.values):l.values}function Gr(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{begin:a,size:o}=s;jt(r,"slice");const[i,u]=i2(r,a,o);s2(r,i,u);const c=n.data.get(r.dataId).values,l=rD(c,i,u,r.shape,r.dtype);return n.makeTensorInfo(u,r.dtype,l)}const aD={kernelName:yg,backendName:"cpu",kernelFunc:Gr};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oD(e,t,n,s,r,a,o){const i=t[0],u=a[0],c=new Array(u),l=new Array(i),f=t[1];if(u===0){if(i!==0)throw new Error(z2(i));const w=ze(n,0),k=ze(r,0);return[w,[0,f],k,c,l]}let d=!0,m=0;const g=new Array(u).fill(0);for(let w=0;w<i;++w){const k=e[w*f];if(k<0)throw new Error(B2(w,k));if(k>=u)throw new Error(W2(w,k,u));++g[k],d=d&&k>=m,m=k}let b=!0;for(let w=0;w<u;++w){const k=g[w]===0;c[w]=k,b=b&&!k,g[w]=Math.max(g[w],1),w>0&&(g[w]+=g[w-1])}if(b&&d){const w=e,k=s;for(let N=0;N<i;++N)l[N]=N;return[w,[i,f],k,c,l]}else{const w=g[u-1],k=ze(n,w*f),N=ze(r,w),_=new Array(u).fill(0);for(let I=0;I<i;++I){const $=e[I*f],O=_[$],R=($===0?0:g[$-1])+O;_[$]++;for(let W=0;W<f;++W)k[R*f+W]=e[I*f+W];N[R]=s[I],l[I]=R}for(let I=0;I<u;++I)if(_[I]===0){const O=I===0?0:g[I-1];k[O*f+0]=I;for(let R=1;R<f;++R)k[O*f+R]=0;N[O]=o}return[k,[w,f],N,c,l]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iD(e,t,n,s,r){const a=It(s),o=t[0],i=r.length,u=[];let c=1,l=-1;for(let w=0;w<i;++w){const k=r[w];if(k===-1){if(l!==-1)throw new Error(j2(l,w));l=w,u.push(1)}else{if(k<0)throw new Error(q2(w,k));c*=k,u.push(k)}}if(l!==-1){if(c<=0)throw new Error(H2());const w=Math.trunc(a/c);if(c*w!==a)throw new Error(K2(s,u));u[l]=w}if(It(u)!==a)throw new Error(U2(s,u));const d=s.length,m=[];if(d>0){m[d-1]=1;for(let w=d-2;w>=0;--w)m[w]=m[w+1]*s[w+1]}const g=[];if(i>0){g[i-1]=1;for(let w=i-2;w>=0;--w)g[w]=g[w+1]*u[w+1]}const b=ze(n,o*i);for(let w=0;w<o;++w){let k=0;for(let N=0;N<d;++N)k+=e[w*d+N]*m[N];for(let N=0;N<i;++N)b[w*i+N]=Math.trunc(k/g[N]),k%=g[N]}return[b,[o,i],u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vb(e,t,n,s,r,a=!1,o=0){const i=s.length,u=[t[0],e.length/t[0]],c=u[1],f=i>0?r[i-1]+1:0;if(f<0)throw new Error(Yd());const d=t.slice();d[0]=f;const m=d.reduce((_,I)=>_*I,1),g=ze(n,m);if(i===0)return f>0&&g.fill(o),[g,d];if(f<=0)throw new Error(Yd());let b=0,w=1,k=0,N=r[b];for(;;){let _=0;if(w<i){if(_=r[w],N===_){++w;continue}if(N>=_)throw new Error(G2())}if(N<0||N>=f)throw new Error(X2(N,f));N>k&&g.fill(o,k*c,N*c);for(let I=b;I<w;++I){const $=s[I];if($<0||$>=u[0])throw new Error(Y2(I,s[I],u[0]));for(let O=0;O<c;O++)g[N*c+O]+=e[$*c+O]}if(a)for(let I=0;I<c;I++)g[N*c+I]/=w-b;if(b=w,++w,k=N+1,N=_,w>i)break}return k<f&&g.fill(o,k*c,f*c),[g,d]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uD=ye(zf,e=>Math.sqrt(e)),cD={kernelName:zf,backendName:"cpu",kernelFunc:uD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lD=Me((e,t)=>{const n=e-t;return n*n}),fD=qe(Bf,lD),hD={kernelName:Bf,backendName:"cpu",kernelFunc:fD};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dD=mr((e,t)=>{const{pattern:n,replaceGlobal:s,rewrite:r}=t;return e.replace(new RegExp(n,s?"g":""),r)}),pD=gr(Wf,dD),mD={kernelName:Wf,backendName:"cpu",kernelFunc:pD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gD(e,t,n,s){const r=ce(e,t.dtype);for(let a=0;a<r.size;a++){const o=r.indexToLoc(a),i=new Array(o.length);for(let u=0;u<i.length;u++)i[u]=o[u]*n[u]+s[u];r.set(t.get(...i),...o)}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yD{constructor(t,n,s,r,a,o){this.separator=Pr(t),this.nGramWidths=n,this.leftPad=Pr(s),this.rightPad=Pr(r),this.padWidth=a,this.preserveShort=o}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,n){const s=this.getPadWidth(n);return Math.max(0,t+2*s-n+1)}createNGrams(t,n,s,r,a,o){for(let i=0;i<a;++i){const u=this.getPadWidth(o),c=Math.max(0,u-i),l=Math.max(0,u-(a-(i+1))),f=o-(c+l),d=n+(c>0?0:i-u);let m=0;m+=c*this.leftPad.length;for(let N=0;N<f;++N)m+=t[d+N].length;m+=l*this.rightPad.length;const g=c+l+f-1;m+=g*this.separator.length,s[r+i]=new Uint8Array(m);const b=s[r+i];let w=0;const k=N=>N.forEach(_=>b[w++]=_);for(let N=0;N<c;++N)k(this.leftPad),k(this.separator);for(let N=0;N<f-1;++N)k(t[d+N]),k(this.separator);if(f>0){k(t[d+f-1]);for(let N=0;N<l;++N)k(this.separator),k(this.rightPad)}else{for(let N=0;N<l-1;++N)k(this.rightPad),k(this.separator);k(this.rightPad)}}}compute(t,n){const s=t.length,r=n.length;if(r>0){let u=n[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let c=1;c<r;++c){let l=n[c]>=u;if(l=l&&n[c]<=s,!l)throw new Error(`Invalid split value ${n[c]}, must be in [${u}, ${s}]`);u=n[c]}if(u!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${u}`)}const a=r-1,o=ze("int32",r);if(s===0||r===0){const u=new Array(s);for(let c=0;c<=a;++c)o[c]=0;return[u,o]}o[0]=0;for(let u=1;u<=a;++u){const c=n[u]-n[u-1];let l=0;this.nGramWidths.forEach(f=>{l+=this.getNumNGrams(c,f)}),this.preserveShort&&c>0&&l===0&&(l=1),o[u]=o[u-1]+l}const i=new Array(o[a]);for(let u=0;u<a;++u){const c=n[u];let l=o[u];if(this.nGramWidths.forEach(f=>{const d=n[u+1]-n[u],m=this.getNumNGrams(d,f);this.createNGrams(t,c,i,l,m,f),l+=m}),this.preserveShort&&l===o[u]){const f=n[u+1]-n[u];if(f===0)continue;const d=f+2*this.padWidth;this.createNGrams(t,c,i,l,1,d)}}return[i,o]}}function bD(e,t,n,s,r,a,o,i){return new yD(n,s,r,a,o,i).compute(e,t)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wD(e,t,n,s){if(!e.length)return;if(t.length===0){for(let a=0;a<e.length;++a)s.push(e.subarray(a,a+1));return}if(t.length===1){const a=t[0];let o=e.indexOf(a);for(;o!==-1;){const i=e.subarray(0,o);(!n||i.length!==0)&&s.push(i),e=e.subarray(o+1),o=e.indexOf(a)}(!n||e.length!==0)&&s.push(e);return}let r=0;for(let a=0;a<e.length+1;a++)if(a===e.length||t.indexOf(e[a])!==-1){const o=e.subarray(r,a);(!n||o.length!==0)&&s.push(o),r=a+1}}function vD(e,t,n){const s=e.length,r=[];let a=0,o=0;const i=new Array(s);for(let d=0;d<s;++d){const m=r.length;wD(e[d],t,n,r);const g=r.length-m;i[d]=g,a+=g,o=Math.max(o,g)}const u=ze("int32",a*2),c=new Array(a),l=[s,o];let f=0;for(let d=0;d<s;++d)for(let m=0;m<i[d];++m)u[f*2]=d,u[f*2+1]=m,c[f]=r[f],++f;return[u,c,l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kD(e,t){const n=ze("int32",e.length);for(let s=0;s<e.length;++s)n[s]=gv(e[s]).modulo(t).getLowBitsUnsigned();return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xD=Me((e,t)=>e-t),SD=gh((e,t,n,s)=>({real:e-n,imag:t-s})),yh=qe(jf,xD,SD),ID={kernelName:jf,backendName:"cpu",kernelFunc:yh};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ND(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const s=ce(n,e.dtype);for(let r=0;r<s.values.length;++r){const a=s.indexToLoc(r),o=new Array(e.rank);for(let u=0;u<o.length;u++)o[u]=a[u]%e.shape[u];const i=e.locToIndex(o);s.values[r]=e.values[i]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ro=(e,t)=>{const n=t.value-e.value;return n===0?e.index-t.index:n};function kb(e,t,n=0,s=e.length-1){for(;s>n;){if(s-n>600){const i=s-n+1,u=t-n+1,c=Math.log(i),l=.5*Math.exp(2*c/3),f=.5*Math.sqrt(c*l*(i-l)/i)*Math.sign(u-i/2),d=Math.max(n,Math.floor(t-u*l/i+f)),m=Math.min(s,Math.floor(t+(i-u)*l/i+f));kb(e,t,d,m)}const r=e[t];let a=n,o=s;for(Ya(e,n,t),ro(e[s],r)>0&&Ya(e,n,s);a<o;){for(Ya(e,a,o),a++,o--;ro(e[a],r)<0;)a=a+1;for(;ro(e[o],r)>0;)o=o-1}ro(e[n],r)===0?Ya(e,n,o):(o=o+1,Ya(e,o,s)),o<=t&&(n=o+1),t<=o&&(s=o-1)}}function _D(e,t,n,s,r){const a=t[t.length-1],[o,i]=[e.length/a,a],u=mn(n,o*s),c=mn("int32",o*s);for(let f=0;f<o;f++){const d=f*i,m=e.subarray(d,d+i);let g=new Array(m.length);m.forEach((N,_)=>g[_]={value:N,index:_}),s<g.length&&(kb(g,s),g=g.slice(0,s)),r&&g.sort(ro);const b=f*s,w=u.subarray(b,b+s),k=c.subarray(b,b+s);for(let N=0;N<s;N++)w[N]=g[N].value,k[N]=g[N].index}const l=t.slice();return l[l.length-1]=s,[ce(l,n,u),ce(l,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TD(e,t,n,s){const r=Ue(t,n)[0],a=[1,n[0],1];for(let g=0;g<r;g++)a[0]*=n[g];a[1]=n[r];for(let g=r+1;g<n.length;g++)a[2]*=n[g];const o=new Map,i=new Int32Array(n[r]),u=new je(a,s,e),c=[],l=a[0]===1&&a[2]===1;for(let g=0;g<n[r];g++){let b;if(l)b=e[g].toString();else{const k=[];for(let N=0;N<a[0];N++)for(let _=0;_<a[2];_++)k.push(u.get(N,g,_));b=k.join(",")}const w=o.get(b);if(w!=null)i[g]=w;else{const k=o.size;o.set(b,k),i[g]=k,c.push(g)}}const f=a.slice();f[1]=o.size;const d=new je(f,s);c.forEach((g,b)=>{for(let w=0;w<a[0];w++)for(let k=0;k<a[2];k++)d.set(u.get(w,g,k),w,b,k)});const m=n.slice();return m[r]=f[1],{outputValues:d.values,outputShape:m,indices:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Mv("cpu",()=>new _u,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xb=ye(nf,e=>e>=0?e:Math.exp(e)-1),ED={kernelName:nf,backendName:"cpu",kernelFunc:xb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sb(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{alpha:a}=s;jt([r],"leakyRelu");const o=It(r.shape),i=n.data.get(r.dataId).values,u=mn("float32",o);for(let c=0;c<i.length;c++)u[c]=i[c]<0?a*i[c]:i[c];return n.makeTensorInfo(r.shape,"float32",u)}const $D={kernelName:Mm,backendName:"cpu",kernelFunc:Sb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CD=Me((e,t)=>e<0?t*e:e);function Ib(e){const{inputs:t,backend:n}=e,{x:s,alpha:r}=t;jt([s,r],"prelu");const a=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,[i,u]=CD(s.shape,r.shape,a,o,"float32");return n.makeTensorInfo(u,"float32",i)}const OD={kernelName:ng,backendName:"cpu",kernelFunc:Ib};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nb=ye(Cf,e=>Math.max(0,e)),DD={kernelName:Cf,backendName:"cpu",kernelFunc:Nb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _b=ye(Of,e=>Math.min(Math.max(0,e),6)),AD={kernelName:Of,backendName:"cpu",kernelFunc:_b};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zi(e,t,n,s,r){if(n==="linear")return ms({inputs:{x:t},backend:e});if(n==="relu")return Nb({inputs:{x:t},backend:e});if(n==="elu")return xb({inputs:{x:t},backend:e});if(n==="relu6")return _b({inputs:{x:t},backend:e});if(n==="prelu")return Ib({inputs:{x:t,alpha:s},backend:e});if(n==="leakyrelu")return Sb({inputs:{x:t},backend:e,attrs:{alpha:r}});if(n==="sigmoid")return wb({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{shape:a}=s,o=It(r.shape),i=Fw(a,o),u=It(i);D(o===u,()=>`The new shape (${i}) has ${u} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),n.incRef(r.dataId);const c=n.data.get(r.dataId);if(c.complexTensorInfos!=null){const l=c.complexTensorInfos.real,f=c.complexTensorInfos.imag;l.shape=i,f.shape=i}return{dataId:r.dataId,shape:i,dtype:r.dtype}}const FD={kernelName:cg,backendName:"cpu",kernelFunc:xe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tb(e){const{inputs:t,backend:n,attrs:s}=e,{a:r,b:a}=t,{transposeA:o,transposeB:i}=s;jt([r,a],"matMul");const u=r.shape.length,c=a.shape.length,l=o?r.shape[u-2]:r.shape[u-1],f=i?a.shape[c-1]:a.shape[c-2],d=o?r.shape[u-1]:r.shape[u-2],m=i?a.shape[c-2]:a.shape[c-1],g=r.shape.slice(0,-2),b=a.shape.slice(0,-2),w=It(g),k=It(b),_=Fe(r.shape.slice(0,-2),a.shape.slice(0,-2)).concat([d,m]);D(l===f,()=>`Error in matMul: inner shapes (${l}) and (${f}) of Tensors with shapes ${r.shape} and ${a.shape} and transposeA=${o} and transposeB=${i} must match.`);const I=o?[w,l,d]:[w,d,l],$=i?[k,m,f]:[k,f,m],O=xe({inputs:{x:r},backend:n,attrs:{shape:I}}),R=xe({inputs:{x:a},backend:n,attrs:{shape:$}}),W=o?O.shape[1]:O.shape[2],P=o?O.shape[2]:O.shape[1],M=i?R.shape[1]:R.shape[2],T=Math.max(w,k),q=n.data.get(O.dataId).values,X=n.data.get(R.dataId).values,st=Kt(O.shape),et=Kt(R.shape),[nt,ot,tt]=o?[st[0],1,st[1]]:[st[0],st[1],1],[ct,ht,gt]=i?[1,et[1],et[0]]:[et[1],1,et[0]],wt=P*M,bt=ce([T,P,M],O.dtype),Ct=bt.values,Et=n.blockSize;for(let Ft=0;Ft<T;Ft++){const Bt=Ft%w,Ht=Ft%k;for(let vt=0;vt<P;vt+=Et){const Ut=Math.min(vt+Et,P);for(let Zt=0;Zt<M;Zt+=Et){const F=Math.min(Zt+Et,M);for(let z=0;z<W;z+=Et){const at=Math.min(z+Et,W);for(let ft=vt;ft<Ut;ft++)for(let lt=Zt;lt<F;lt++){let dt=0;for(let xt=z;xt<at;xt++){const Tt=q[Bt*nt+ft*ot+xt*tt],kt=X[xt*ct+lt*ht+Ht*gt];dt+=Tt*kt}Ct[Ft*wt+(ft*M+lt)]+=dt}}}}}return n.disposeIntermediateTensorInfo(O),n.disposeIntermediateTensorInfo(R),n.makeTensorInfo(_,bt.dtype,bt.values)}const RD={kernelName:am,backendName:"cpu",kernelFunc:Tb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PD(e){const{inputs:t,backend:n,attrs:s}=e,{a:r,b:a,bias:o,preluActivationWeights:i}=t,{transposeA:u,transposeB:c,activation:l,leakyreluAlpha:f}=s;let d,m,g;const b=[];d=Tb({inputs:{a:r,b:a},attrs:{transposeA:u,transposeB:c},backend:n}),o&&(m=Ea({inputs:{a:d,b:o},backend:n}),b.push(d),d=m),l&&(g=Zi(n,d,l,i,f),b.push(d),d=g);for(const k of b)n.disposeIntermediateTensorInfo(k);return d}const MD={kernelName:qc,backendName:"cpu",kernelFunc:PD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VD=ye(Wl,e=>Math.acos(e)),LD={kernelName:Wl,backendName:"cpu",kernelFunc:VD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zD=ye(jl,e=>Math.acosh(e)),BD={kernelName:jl,backendName:"cpu",kernelFunc:zD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WD(e){const{inputs:t,backend:n}=e,s=t;jt(t,"addN");const r=s.map(i=>n.data.get(i.dataId).values),a=ce(s[0].shape,s[0].dtype),o=a.values;for(let i=0;i<s.length;i++){const u=r[i];for(let c=0;c<o.length;c++)o[c]+=u[c]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}const jD={kernelName:Zp,backendName:"cpu",kernelFunc:WD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qD(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:o}=s;jt(r,"all");const i=Ue(a,r.shape);let u=i;const c=ws(u,r.shape.length);let l=r;c!=null&&(l=Nn({inputs:{x:r},backend:n,attrs:{perm:c}}),u=vs(u.length,r.shape.length)),Yr("all",u,l.shape.length);const[f,d]=zs(l.shape,u),m=It(d),g=tn(It(f),l.dtype),b=n.data.get(l.dataId).values;for(let k=0;k<g.length;++k){const N=k*m;let _=b[N];for(let I=0;I<m;++I){const $=b[N+I];_=_&&$}g[k]=_}c!=null&&n.disposeIntermediateTensorInfo(l);const w=n.makeTensorInfo(f,l.dtype,g);if(o){const k=es(f,i),N=xe({inputs:{x:w},backend:n,attrs:{shape:k}});return n.disposeIntermediateTensorInfo(w),N}return w}const HD={kernelName:Qp,backendName:"cpu",kernelFunc:qD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KD(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:o}=s;jt(r,"any");const i=Ue(a,r.shape);let u=i;const c=ws(u,r.shape.length);let l=r;c!=null&&(l=Nn({inputs:{x:r},backend:n,attrs:{perm:c}}),u=vs(u.length,r.shape.length)),Yr("any",u,l.shape.length);const[f,d]=zs(l.shape,u),m=It(d),g=tn(It(f),l.dtype),b=n.data.get(l.dataId).values;for(let k=0;k<g.length;++k){const N=k*m;let _=b[N];for(let I=0;I<m;++I){const $=b[N+I];_=_||$}g[k]=_}c!=null&&n.disposeIntermediateTensorInfo(l);const w=n.makeTensorInfo(f,l.dtype,g);if(o){const k=es(f,i),N=xe({inputs:{x:w},backend:n,attrs:{shape:k}});return n.disposeIntermediateTensorInfo(w),N}return w}const UD={kernelName:tm,backendName:"cpu",kernelFunc:KD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GD(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a}=s;jt(r,"argMax");let o=Ue(a,r.shape);const i=ws(o,r.shape.length);let u=r;const c=[];i!=null&&(u=Nn({inputs:{x:r},backend:n,attrs:{perm:i}}),c.push(u),o=vs(o.length,u.shape.length)),o=[o[0]],Yr("argMax",o,u.shape.length);const[l,f]=zs(u.shape,o),d=It(l),m=tn(d,"int32"),g=It(f),b=n.data.get(u.dataId).values;for(let w=0;w<m.length;++w){const k=w*g;let N=b[k],_=0;for(let I=0;I<g;++I){const $=b[k+I];$>N&&(N=$,_=I)}m[w]=_}return c.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.makeTensorInfo(l,"int32",m)}const XD={kernelName:em,backendName:"cpu",kernelFunc:GD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YD(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a}=s;jt(r,"argMin");let o=Ue(a,r.shape);const i=ws(o,r.shape.length);let u=r;const c=[];i!=null&&(u=Nn({inputs:{x:r},backend:n,attrs:{perm:i}}),c.push(u),o=vs(o.length,u.shape.length)),o=[o[0]],Yr("argMin",o,u.shape.length);const[l,f]=zs(u.shape,o),d=It(l),m=tn(d,"int32"),g=It(f),b=n.data.get(u.dataId).values;for(let w=0;w<m.length;++w){const k=w*g;let N=b[k],_=0;for(let I=0;I<g;++I){const $=b[k+I];$<N&&(N=$,_=I)}m[w]=_}return c.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.makeTensorInfo(l,"int32",m)}const JD={kernelName:nm,backendName:"cpu",kernelFunc:YD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZD=ye(ql,e=>Math.asin(e)),QD={kernelName:ql,backendName:"cpu",kernelFunc:ZD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tA=ye(Hl,e=>Math.asinh(e)),eA={kernelName:Hl,backendName:"cpu",kernelFunc:tA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nA=ye(Kl,e=>Math.atan(e)),sA={kernelName:Kl,backendName:"cpu",kernelFunc:nA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rA=Me((e,t)=>Math.atan2(e,t)),aA=qe(Gl,rA),oA={kernelName:Gl,backendName:"cpu",kernelFunc:aA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iA=ye(Ul,e=>Math.atanh(e)),uA={kernelName:Ul,backendName:"cpu",kernelFunc:iA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bh(e,t,n,s,r,a){const o=r.strideHeight,i=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,l=r.effectiveFilterHeight,f=r.effectiveFilterWidth,d=r.padInfo.top,m=r.padInfo.left,g=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,b=ce(r.outShape,n),w=b.values,k=r.outShape[1]*r.outShape[2]*r.outShape[3],N=r.outShape[2]*r.outShape[3],_=r.outShape[3];for(let I=0;I<r.batchSize;++I){const $=I*k,O=I*s[0];for(let R=0;R<r.inChannels;++R)for(let W=0;W<r.outHeight;++W){const P=W*o-d,M=Math.max(0,P),T=Math.min(r.inHeight,l+P),q=$+W*N;for(let X=0;X<r.outWidth;++X){const st=X*i-m,et=Math.max(0,st),nt=Math.min(r.inWidth,f+st);let ot=g,tt=0,ct=0;for(let gt=M;gt<T;gt+=u){const wt=O+gt*s[1];for(let bt=et;bt<nt;bt+=c){const Ct=wt+bt*s[2],Et=e[Ct+R];a==="max"&&Et>ot?ot=Et:a==="avg"&&(tt+=Et,ct++)}if(isNaN(ot))break}const ht=q+X*_+R;w[ht]=a==="avg"?tt/ct:ot}}}return b}function Eb(e,t,n,s,r=!1,a=!1){const o=ce(s.outShape,"int32"),i=s.strideHeight,u=s.strideWidth,c=s.dilationHeight,l=s.dilationWidth,f=s.effectiveFilterHeight,d=s.effectiveFilterWidth,m=s.padInfo.top,g=s.padInfo.left,b=ce(t,n,e);for(let w=0;w<s.batchSize;++w)for(let k=0;k<s.inChannels;++k)for(let N=0;N<s.outHeight;++N){const _=N*i-m;let I=_;for(;I<0;)I+=c;const $=Math.min(s.inHeight,f+_);for(let O=0;O<s.outWidth;++O){const R=O*u-g;let W=R;for(;W<0;)W+=l;const P=Math.min(s.inWidth,d+R);let M=Number.NEGATIVE_INFINITY,T=-1;for(let q=I;q<$;q+=c){const X=q-_;for(let st=W;st<P;st+=l){const et=st-R,nt=b.get(w,q,st,k);nt>M&&(M=nt,r?T=a?((w*s.inHeight+q)*s.inWidth+st)*s.inChannels+k:(q*s.inWidth+st)*s.inChannels+k:T=X*d+et)}}o.set(T,w,N,O,k)}}return o}function $b(e,t,n,s,r,a){const o=r.strideDepth,i=r.strideHeight,u=r.strideWidth,c=r.dilationDepth,l=r.dilationHeight,f=r.dilationWidth,d=r.effectiveFilterDepth,m=r.effectiveFilterHeight,g=r.effectiveFilterWidth,b=r.padInfo.front,w=r.padInfo.top,k=r.padInfo.left,N=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,_=ce(r.outShape,n),I=_.values,$=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],O=r.outShape[2]*r.outShape[3]*r.outShape[4],R=r.outShape[3]*r.outShape[4],W=r.outShape[4];for(let P=0;P<r.batchSize;++P){const M=P*$,T=P*s[0];for(let q=0;q<r.inChannels;++q)for(let X=0;X<r.outDepth;++X){const st=X*o-b;let et=st;for(;et<0;)et+=c;const nt=Math.min(r.inDepth,d+st),ot=M+X*O;for(let tt=0;tt<r.outHeight;++tt){const ct=tt*i-w;let ht=ct;for(;ht<0;)ht+=l;const gt=Math.min(r.inHeight,m+ct),wt=ot+tt*R;for(let bt=0;bt<r.outWidth;++bt){const Ct=bt*u-k;let Et=Ct;for(;Et<0;)Et+=f;const Ft=Math.min(r.inWidth,g+Ct),Bt=wt+bt*W;let Ht=N,vt=0,Ut=0;for(let F=et;F<nt;F+=c){const z=T+F*s[1];for(let at=ht;at<gt;at+=l){const ft=z+at*s[2];for(let lt=Et;lt<Ft;lt+=f){const dt=ft+lt*s[3],xt=e[dt+q];if(a==="max"&&xt>Ht?Ht=xt:a==="avg"&&(vt+=xt,Ut++),isNaN(Ht))break}if(isNaN(Ht))break}if(isNaN(Ht))break}const Zt=Bt+q;I[Zt]=a==="avg"?vt/Math.max(Ut,1):Ht}}}}return _}function cA(e,t){const n=ce(t.outShape,"int32"),s=t.strideDepth,r=t.strideHeight,a=t.strideWidth,o=t.dilationDepth,i=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterDepth,l=t.effectiveFilterHeight,f=t.effectiveFilterWidth,d=t.padInfo.front,m=t.padInfo.top,g=t.padInfo.left;for(let b=0;b<t.batchSize;++b)for(let w=0;w<t.inChannels;++w)for(let k=0;k<t.outDepth;++k){const N=k*s-d;let _=N;for(;_<0;)_+=o;const I=Math.min(t.inDepth,c+N);for(let $=0;$<t.outHeight;++$){const O=$*r-m;let R=O;for(;R<0;)R+=i;const W=Math.min(t.inHeight,l+O);for(let P=0;P<t.outWidth;++P){const M=P*a-g;let T=M;for(;T<0;)T+=u;const q=Math.min(t.inWidth,f+M);let X=Number.NEGATIVE_INFINITY,st=-1;for(let et=_;et<I;et+=o){const nt=et-N;for(let ot=R;ot<W;ot+=i){const tt=ot-O;for(let ct=T;ct<q;ct+=u){const ht=ct-M,gt=e.get(b,et,ot,ct,w);gt>=X&&(X=gt,st=nt*l*f+tt*l+ht)}}}n.set(st,b,k,$,P,w)}}}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lA(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t;jt(r,"avgPool");const{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=s,c=1;D(Qn(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const l=Va(r.shape,a,o,c,i,u);let f;if(l.filterWidth===1&&l.filterHeight===1&&Un(l.inShape,l.outShape))f=ms({inputs:{x:r},backend:n});else{const d=n.data.get(r.dataId).values,m=Kt(r.shape),g=bh(d,r.shape,r.dtype,m,l,"avg");f=n.makeTensorInfo(l.outShape,r.dtype,g.values)}return f}const fA={kernelName:sm,backendName:"cpu",kernelFunc:lA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hA(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:u,dataFormat:c}=s;jt(r,"avgPool3d");const l=gu(r.shape,a,o,1,i,u,c),f=n.data.get(r.dataId).values,d=$b(f,r.shape,r.dtype,Kt(r.shape),l,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}const dA={kernelName:rm,backendName:"cpu",kernelFunc:hA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pA(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:a}=t,{filterSize:o,strides:i,pad:u,dimRoundingMode:c}=s;jt([r,a],"avgPool3DGrad");const l=gu(a.shape,o,i,1,u,c),f=l.strideDepth,d=l.strideHeight,m=l.strideWidth,g=l.filterDepth,b=l.filterHeight,w=l.filterWidth,k=l.dilationDepth,N=l.dilationHeight,_=l.dilationWidth,I=l.effectiveFilterDepth,$=l.effectiveFilterHeight,O=l.effectiveFilterWidth,R=I-1-l.padInfo.front,W=O-1-l.padInfo.left,P=$-1-l.padInfo.top,M=ce(a.shape,"float32"),T=1/(g*b*w),q=n.bufferSync(r);for(let X=0;X<l.batchSize;++X)for(let st=0;st<l.inChannels;++st)for(let et=0;et<l.inDepth;++et)for(let nt=0;nt<l.inHeight;++nt)for(let ot=0;ot<l.inWidth;++ot){const tt=et-R,ct=nt-P,ht=ot-W;let gt=0;for(let wt=0;wt<I;wt+=k){const bt=(tt+wt)/f;if(!(bt<0||bt>=l.outDepth||Math.floor(bt)!==bt))for(let Ct=0;Ct<$;Ct+=N){const Et=(ct+Ct)/d;if(!(Et<0||Et>=l.outHeight||Math.floor(Et)!==Et))for(let Ft=0;Ft<O;Ft+=_){const Bt=(ht+Ft)/m;if(Bt<0||Bt>=l.outWidth||Math.floor(Bt)!==Bt)continue;const Ht=q.get(X,bt,Et,Bt,st);gt+=Ht}}}M.set(gt*T,X,et,nt,ot,st)}return n.makeTensorInfo(M.shape,M.dtype,M.values)}const mA={kernelName:Yw,backendName:"cpu",kernelFunc:pA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gA(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:a}=t,o=a;jt([r,a],"avgPoolGrad");const{filterSize:i,strides:u,pad:c}=s,l=Va(o.shape,i,u,1,c),f=l.strideHeight,d=l.strideWidth,m=l.filterHeight,g=l.filterWidth,b=l.dilationHeight,w=l.dilationWidth,k=l.effectiveFilterHeight,N=l.effectiveFilterWidth,_=N-1-l.padInfo.left,I=k-1-l.padInfo.top,$=ce(o.shape,"float32"),O=1/(m*g),R=n.data.get(r.dataId).values,W=ce(r.shape,"float32",R);for(let P=0;P<l.batchSize;++P)for(let M=0;M<l.inChannels;++M)for(let T=0;T<l.inHeight;++T)for(let q=0;q<l.inWidth;++q){const X=T-I,st=q-_;let et=0;for(let nt=0;nt<k;nt+=b){const ot=(X+nt)/f;if(!(ot<0||ot>=l.outHeight||Math.floor(ot)!==ot))for(let tt=0;tt<N;tt+=w){const ct=(st+tt)/d;if(ct<0||ct>=l.outWidth||Math.floor(ct)!==ct)continue;const ht=W.get(P,ot,ct,M);et+=ht}}$.set(et*O,P,T,q,M)}return n.makeTensorInfo($.shape,$.dtype,$.values)}const yA={kernelName:Xw,backendName:"cpu",kernelFunc:gA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bA(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,scale:a,offset:o,mean:i,variance:u}=t;D(i.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),D(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),D(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),jt([r,i,u,a,o],"batchNorm");let{varianceEpsilon:c}=s;c==null&&(c=.001);const l=n.data.get(r.dataId).values,f=n.data.get(i.dataId).values,d=n.data.get(u.dataId).values,m=a?n.data.get(a.dataId).values:new Float32Array([1]),g=o?n.data.get(o.dataId).values:new Float32Array([0]),b=new Float32Array(l.length),w=g.length,k=m.length,N=d.length,_=f.length;let I=0,$=0,O=0,R=0;for(let W=0;W<l.length;++W)b[W]=g[I++]+(l[W]-f[$++])*m[O++]/Math.sqrt(d[R++]+c),I>=w&&(I=0),$>=_&&($=0),O>=k&&(O=0),R>=N&&(R=0);return n.makeTensorInfo(r.shape,r.dtype,b)}const wA={kernelName:Dm,backendName:"cpu",kernelFunc:bA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vA(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockShape:a,crops:o}=s;jt([r],"batchToSpaceND");const i=a.reduce((k,N)=>k*N),u=ib(r.shape,a,i),c=ub(u.length,a.length),l=cb(r.shape,a,i),f=g2(o,a.length),d=y2(l,o,a.length),m=xe({inputs:{x:r},backend:n,attrs:{shape:u}}),g=Nn({inputs:{x:m},backend:n,attrs:{perm:c}}),b=xe({inputs:{x:g},backend:n,attrs:{shape:l}}),w=Gr({inputs:{x:b},backend:n,attrs:{begin:f,size:d}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),w}const kA={kernelName:om,backendName:"cpu",kernelFunc:vA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xA(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,weights:a}=t,{size:o}=s,i=n.data.get(r.dataId).values,u=n.data.get(a.dataId).values,c=pb(i,u,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,c)}const SA={kernelName:im,backendName:"cpu",kernelFunc:xA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IA(e){const{inputs:t,backend:n}=e,{s0:s,s1:r}=t,a=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,i=Fe(Array.from(a),Array.from(o));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}const NA={kernelName:um,backendName:"cpu",kernelFunc:IA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _A=ye(Zl,(e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),TA={kernelName:Zl,backendName:"cpu",kernelFunc:_A};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EA=e=>{const{x:t}=e.inputs,n=e.backend,s=new Float32Array(It(t.shape)),r=n.data.get(t.dataId),a=r.complexTensorInfos.real,o=r.complexTensorInfos.imag,i=n.data.get(a.dataId).values,u=n.data.get(o.dataId).values;for(let c=0;c<i.length;c++){const l=i[c],f=u[c];s[c]=Math.hypot(l,f)}return n.makeOutput(s,t.shape,"float32")},$A={kernelName:lm,backendName:"cpu",kernelFunc:EA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $a(e){const{inputs:t,backend:n}=e,{input:s}=t,r=n.data.get(s.dataId).complexTensorInfos.imag,a=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,a)}const CA={kernelName:Pm,backendName:"cpu",kernelFunc:$a};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ca(e){const{inputs:t,backend:n,attrs:s}=e,{axis:r}=s,a=Ue(r,t[0].shape)[0],o=t.map(b=>b.shape);l2(o,a);let i=$c(t.map(b=>b.shape),a);if(It(i)===0)return n.makeTensorInfo(i,t[0].dtype,[]);const u=t.filter(b=>It(b.shape)>0);if(u.length===1)return ms({inputs:{x:u[0]},backend:n});if(u[0].dtype==="complex64"){const b=u.map(I=>Ur({inputs:{input:I},backend:n})),w=u.map(I=>$a({inputs:{input:I},backend:n})),k=Ca({inputs:b,backend:n,attrs:{axis:a}}),N=Ca({inputs:w,backend:n,attrs:{axis:a}}),_=Cn({inputs:{real:k,imag:N},backend:n});return b.forEach(I=>n.disposeIntermediateTensorInfo(I)),w.forEach(I=>n.disposeIntermediateTensorInfo(I)),n.disposeIntermediateTensorInfo(k),n.disposeIntermediateTensorInfo(N),_}const c=u.map(b=>{const k=[-1,It(b.shape.slice(a))];return xe({inputs:{x:b},backend:n,attrs:{shape:k}})}),l=c.map(b=>({vals:n.data.get(b.dataId).values,shape:b.shape}));i=$c(c.map(b=>b.shape),1);const f=c[0].shape[0]===1,d=UC(l,i,t[0].dtype,f),m=$c(u.map(b=>b.shape),a),g=n.makeTensorInfo(m,t[0].dtype,d);return c.forEach(b=>n.disposeIntermediateTensorInfo(b)),g}const OA={kernelName:fm,backendName:"cpu",kernelFunc:Ca};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cb(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a}=t,{strides:o,pad:i,dataFormat:u,dilations:c,dimRoundingMode:l}=s;jt([r,a],"conv2d");const f=bu(u),d=bs(r.shape,a.shape,o,c,i,l,!1,f),m=d.filterHeight,g=d.filterWidth,b=d.dilationHeight,w=d.dilationWidth,k=d.padInfo.left,N=d.padInfo.top,_=d.dataFormat==="channelsLast",I=new je(d.outShape,r.dtype),$=Kt(r.shape),O=Kt(a.shape),R=$[0],W=_?$[1]:$[2],P=_?$[2]:1,M=_?1:$[1],T=I.strides[0],q=_?I.strides[1]:I.strides[2],X=_?I.strides[2]:1,st=_?1:I.strides[1],et=n.data.get(r.dataId).values,nt=n.data.get(a.dataId).values,ot=I.values;for(let tt=0;tt<d.batchSize;++tt){const ct=tt*R,ht=tt*T;for(let gt=0;gt<d.outHeight;++gt){const wt=ht+gt*q,bt=gt*d.strideHeight-N;for(let Ct=0;Ct<m;++Ct){const Et=bt+Ct*b;if(Et<0||Et>=d.inHeight)continue;const Ft=Ct*O[0],Bt=ct+Et*W;for(let Ht=0;Ht<d.outWidth;++Ht){const vt=wt+Ht*X,Ut=Ht*d.strideWidth-k;for(let Zt=0;Zt<g;++Zt){const F=Ut+Zt*w;if(F<0||F>=d.inWidth)continue;const z=Ft+Zt*O[1],at=Bt+F*P;let ft=z;for(let lt=0;lt<d.inChannels;++lt){const dt=et[at+lt*M];for(let xt=0;xt<d.outChannels;++xt)ot[vt+xt*st]+=dt*nt[ft+xt];ft+=d.outChannels}}}}}}return n.makeTensorInfo(I.shape,I.dtype,ot)}const DA={kernelName:hm,backendName:"cpu",kernelFunc:Cb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AA(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:a}=t,{strides:o,pad:i,dataFormat:u,dimRoundingMode:c,filterShape:l}=s;jt([r,a],"conv2dBackpropFilter");const f=bu(u),d=bs(r.shape,l,o,1,i,c,!1,f),{strideHeight:m,strideWidth:g,filterHeight:b,filterWidth:w}=d,k=d.dataFormat==="channelsLast",N=new je(d.filterShape,"float32"),_=d.padInfo.left,I=d.padInfo.top,$=n.data.get(r.dataId).values,O=n.data.get(a.dataId).values,R=new je(r.shape,r.dtype,$),W=new je(a.shape,a.dtype,O);for(let P=0;P<b;++P){const M=Math.max(0,Math.ceil((I-P)/m)),T=Math.min(d.outHeight,(d.inHeight+I-P)/m);for(let q=0;q<w;++q){const X=Math.max(0,Math.ceil((_-q)/g)),st=Math.min(d.outWidth,(d.inWidth+_-q)/g);for(let et=0;et<d.inChannels;++et)for(let nt=0;nt<d.outChannels;++nt){let ot=0;for(let tt=0;tt<d.batchSize;++tt)for(let ct=M;ct<T;++ct){const ht=P+ct*m-I;for(let gt=X;gt<st;++gt){const wt=q+gt*g-_;k?ot+=R.get(tt,ht,wt,et)*W.get(tt,ct,gt,nt):ot+=R.get(tt,et,ht,wt)*W.get(tt,nt,ct,gt)}}N.set(ot,P,q,et,nt)}}}return n.makeTensorInfo(N.shape,N.dtype,N.values)}const FA={kernelName:dm,backendName:"cpu",kernelFunc:AA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RA(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:a}=t,{inputShape:o,strides:i,pad:u,dataFormat:c,dimRoundingMode:l}=s;jt([r,a],"conv2dBackpropInput");const f=Kt(a.shape),d=Kt(r.shape);let m=bu(c);const g=bs(o,a.shape,i,1,u,l,!1,m),b=new je(g.inShape,"float32"),w=b.values,k=n.data.get(r.dataId).values,N=n.data.get(a.dataId).values,[_,I,$]=f,{batchSize:O,filterHeight:R,filterWidth:W,inChannels:P,inHeight:M,inWidth:T,outChannels:q,outHeight:X,outWidth:st,strideHeight:et,strideWidth:nt}=g;m=g.dataFormat;const ot=R-1-g.padInfo.top,tt=W-1-g.padInfo.left,ct=m==="channelsLast",ht=b.strides[0],gt=ct?b.strides[1]:b.strides[2],wt=ct?b.strides[2]:1,bt=ct?1:b.strides[1],Ct=d[0],Et=ct?d[1]:d[2],Ft=ct?d[2]:1,Bt=ct?1:d[1];for(let Ht=0;Ht<O;++Ht)for(let vt=0;vt<P;++vt)for(let Ut=0;Ut<M;++Ut){const Zt=Ut-ot,F=Math.max(0,Math.ceil(Zt/et)),z=Math.min(X,(R+Zt)/et);for(let at=0;at<T;++at){const ft=at-tt,lt=Math.max(0,Math.ceil(ft/nt)),dt=Math.min(st,(W+ft)/nt);let xt=0;for(let kt=F;kt<z;++kt){const yt=kt*et-Zt;for(let Vt=lt;Vt<dt;++Vt){const $t=Vt*nt-ft,Lt=Ct*Ht+Et*kt+Ft*Vt,qt=_*(R-1-yt)+I*(W-1-$t)+$*vt;for(let Gt=0;Gt<q;++Gt){const Qt=k[Lt+Bt*Gt],ne=N[qt+Gt];xt+=Qt*ne}}}const Tt=ht*Ht+gt*Ut+wt*at+bt*vt;w[Tt]=xt}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}const PA={kernelName:pm,backendName:"cpu",kernelFunc:RA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MA(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a}=t,{strides:o,pad:i,dilations:u}=s;jt([r,a],"conv3d");const c=yu(r.shape,a.shape,o,u,i),{filterDepth:l,filterHeight:f,filterWidth:d,dilationDepth:m,dilationHeight:g,dilationWidth:b,padInfo:w}=c,k=w.front,N=w.left,_=w.top,I=new je(c.outShape,r.dtype),$=n.data.get(r.dataId).values,O=n.data.get(a.dataId).values,R=I.values,W=Kt(r.shape),P=Kt(a.shape);for(let M=0;M<c.batchSize;++M){const T=M*W[0],q=M*I.strides[0];for(let X=0;X<c.outDepth;++X){const st=q+X*I.strides[1],et=X*c.strideDepth-k;for(let nt=0;nt<l;++nt){const ot=et+nt*m;if(ot<0||ot>=c.inDepth)continue;const tt=nt*P[0],ct=T+ot*W[1];for(let ht=0;ht<c.outHeight;++ht){const gt=st+ht*I.strides[2],wt=ht*c.strideHeight-_;for(let bt=0;bt<f;++bt){const Ct=wt+bt*g;if(Ct<0||Ct>=c.inHeight)continue;const Et=tt+bt*P[1],Ft=ct+Ct*W[2];for(let Bt=0;Bt<c.outWidth;++Bt){const Ht=gt+Bt*c.outChannels,vt=Bt*c.strideWidth-N;for(let Ut=0;Ut<d;++Ut){const Zt=vt+Ut*b;if(Zt<0||Zt>=c.inWidth)continue;const F=Et+Ut*P[2],z=Ft+Zt*c.inChannels;let at=F;for(let ft=0;ft<c.inChannels;++ft){const lt=$[z+ft];for(let dt=0;dt<c.outChannels;++dt)R[Ht+dt]+=lt*O[at+dt];at+=c.outChannels}}}}}}}}return n.makeTensorInfo(I.shape,I.dtype,I.values)}const VA={kernelName:mm,backendName:"cpu",kernelFunc:MA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LA(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:a}=t,{strides:o,pad:i,filterShape:u}=s;jt([r,a],"conv3dBackpropFilterV2");const c=Kt(r.shape),l=Kt(a.shape),f=yu(r.shape,u,o,1,i),d=f.strideDepth,m=f.strideHeight,g=f.strideWidth,b=f.filterDepth,w=f.filterHeight,k=f.filterWidth,N=new je(f.filterShape,"float32"),_=N.values,[I,$,O,R]=N.strides,W=n.data.get(a.dataId).values,[P,M,T,q]=l,X=n.data.get(r.dataId).values,[st,et,nt,ot]=c,tt=f.padInfo.front,ct=f.padInfo.left,ht=f.padInfo.top;for(let gt=0;gt<b;++gt){const wt=Math.max(0,Math.ceil((tt-gt)/d)),bt=Math.min(f.outDepth,(f.inDepth+tt-gt)/d),Ct=gt*I;for(let Et=0;Et<w;++Et){const Ft=Math.max(0,Math.ceil((ht-Et)/m)),Bt=Math.min(f.outHeight,(f.inHeight+ht-Et)/m),Ht=Et*$+Ct;for(let vt=0;vt<k;++vt){const Ut=Math.max(0,Math.ceil((ct-vt)/g)),Zt=Math.min(f.outWidth,(f.inWidth+ct-vt)/g),F=vt*O+Ht;for(let z=0;z<f.inChannels;++z){const at=z*R+F;for(let ft=0;ft<f.outChannels;++ft){let lt=0;for(let dt=0;dt<f.batchSize;++dt){const xt=dt*st,Tt=dt*P;for(let kt=wt;kt<bt;++kt){const Vt=(gt+kt*d-tt)*et+xt,$t=kt*M+Tt;for(let Lt=Ft;Lt<Bt;++Lt){const Gt=(Et+Lt*m-ht)*nt+Vt,Qt=Lt*T+$t;for(let ne=Ut;ne<Zt;++ne){const Re=(vt+ne*g-ct)*ot+Gt,He=ne*q+Qt;lt+=X[Re+z]*W[He+ft]}}}}_[at+ft]=lt}}}}}return n.makeTensorInfo(N.shape,N.dtype,N.values)}const zA={kernelName:Jw,backendName:"cpu",kernelFunc:LA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BA(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:a}=t,{pad:o,strides:i,inputShape:u}=s;jt([r],"conv3dBackpropInputV2");const c=Kt(r.shape),l=Kt(a.shape),f=yu(u,a.shape,i,1,o),d=new je(f.inShape,"float32"),m=d.values,[g,b,w,k]=d.strides,N=n.data.get(r.dataId).values,[_,I,$,O]=c,R=n.data.get(a.dataId).values,[W,P,M,T]=l,{batchSize:q,filterDepth:X,filterHeight:st,filterWidth:et,inChannels:nt,inDepth:ot,inHeight:tt,inWidth:ct,outChannels:ht,outDepth:gt,outHeight:wt,outWidth:bt,strideDepth:Ct,strideHeight:Et,strideWidth:Ft}=f,Bt=X-1-f.padInfo.front,Ht=st-1-f.padInfo.top,vt=et-1-f.padInfo.left;for(let Ut=0;Ut<q;++Ut)for(let Zt=0;Zt<nt;++Zt)for(let F=0;F<ot;++F){const z=F-Bt,at=Math.max(0,Math.ceil(z/Ct)),ft=Math.min(gt,(X+z)/Ct);for(let lt=0;lt<tt;++lt){const dt=lt-Ht,xt=Math.max(0,Math.ceil(dt/Et)),Tt=Math.min(wt,(st+dt)/Et);for(let kt=0;kt<ct;++kt){const yt=kt-vt,Vt=Math.max(0,Math.ceil(yt/Ft)),$t=Math.min(bt,(et+yt)/Ft);let Lt=0;for(let qt=at;qt<ft;++qt){const Gt=qt*Ct-z;for(let Qt=xt;Qt<Tt;++Qt){const ne=Qt*Et-dt;for(let _e=Vt;_e<$t;++_e){const Re=_e*Ft-yt,He=_*Ut+I*qt+$*Qt+O*_e,We=W*(X-1-Gt)+P*(st-1-ne)+M*(et-1-Re)+T*Zt;for(let gn=0;gn<ht;++gn){const qs=N[He+gn],$e=R[We+gn];Lt+=qs*$e}}}}m[g*Ut+b*F+w*lt+k*kt+Zt]=Lt}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}const WA={kernelName:gm,backendName:"cpu",kernelFunc:BA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jA=ye(Ql,e=>Math.cos(e)),qA={kernelName:Ql,backendName:"cpu",kernelFunc:jA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HA=ye(tf,e=>Math.cosh(e)),KA={kernelName:tf,backendName:"cpu",kernelFunc:HA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UA(e){const{inputs:t,backend:n,attrs:s}=e,{image:r,boxes:a,boxInd:o}=t,{cropSize:i,method:u,extrapolationValue:c}=s,[l,f,d,m]=r.shape,g=a.shape[0],[b,w]=i,k=ce([g,b,w,m],"float32"),N=n.data.get(a.dataId).values,_=n.data.get(o.dataId).values,I=n.data.get(r.dataId).values,$=Kt(r.shape),O=Kt(k.shape);for(let R=0;R<g;R++){const W=R*4,P=N[W],M=N[W+1],T=N[W+2],q=N[W+3],X=_[R];if(X>=l)continue;const st=b>1?(T-P)*(f-1)/(b-1):0,et=w>1?(q-M)*(d-1)/(w-1):0;for(let nt=0;nt<b;nt++){const ot=b>1?P*(f-1)+nt*st:.5*(P+T)*(f-1);if(ot<0||ot>f-1){for(let tt=0;tt<w;tt++)for(let ct=0;ct<m;ct++){const ht=ct+tt*O[2]+nt*O[1]+R*O[0];k.values[ht]=c}continue}if(u==="bilinear"){const tt=Math.floor(ot),ct=Math.ceil(ot),ht=ot-tt;for(let gt=0;gt<w;gt++){const wt=w>1?M*(d-1)+gt*et:.5*(M+q)*(d-1);if(wt<0||wt>d-1){for(let Ft=0;Ft<m;Ft++){const Bt=Ft+gt*O[2]+nt*O[1]+R*O[0];k.values[Bt]=c}continue}const bt=Math.floor(wt),Ct=Math.ceil(wt),Et=wt-bt;for(let Ft=0;Ft<m;Ft++){let Bt=Ft+bt*$[2]+tt*$[1]+X*$[0];const Ht=I[Bt];Bt=Ft+Ct*$[2]+tt*$[1]+X*$[0];const vt=I[Bt];Bt=Ft+bt*$[2]+ct*$[1]+X*$[0];const Ut=I[Bt];Bt=Ft+Ct*$[2]+ct*$[1]+X*$[0];const Zt=I[Bt],F=Ht+(vt-Ht)*Et,z=Ut+(Zt-Ut)*Et;Bt=Ft+gt*O[2]+nt*O[1]+R*O[0],k.values[Bt]=F+(z-F)*ht}}}else for(let tt=0;tt<w;++tt){const ct=w>1?M*(d-1)+tt*et:.5*(M+q)*(d-1);if(ct<0||ct>d-1){for(let wt=0;wt<m;wt++){const bt=wt+tt*O[2]+nt*O[1]+R*O[0];k.values[bt]=c}continue}const ht=Math.round(ct),gt=Math.round(ot);for(let wt=0;wt<m;wt++){const bt=wt+ht*$[2]+gt*$[1]+X*$[0],Ct=wt+tt*O[2]+nt*O[1]+R*O[0];k.values[Ct]=I[bt]}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const GA={kernelName:wm,backendName:"cpu",kernelFunc:UA};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XA(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,exclusive:o,reverse:i}=s;jt(r,"cumprod");const u=ws([a],r.shape.length);let c=r;u!=null&&(c=Nn({inputs:{x:r},backend:n,attrs:{perm:u}}));const l=vs(1,r.shape.length)[0];if(l!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${l}`);const f=Ma(c.dtype,"int32"),d=zl(It(c.shape),f),m=n.data.get(c.dataId).values,g=c.shape[c.shape.length-1],b=i?(k,N)=>k+g-N-1:(k,N)=>k+N;for(let k=0;k<m.length;k+=g)for(let N=0;N<g;N++){const _=b(k,N);if(N===0)d[_]=o?1:m[_];else{const I=b(k,N-1);d[_]=o?m[I]*d[I]:m[_]*d[I]}}const w=n.makeTensorInfo(c.shape,f,d);if(u!=null){const k=ky(u),N=Nn({inputs:{x:w},backend:n,attrs:{perm:k}});return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(c),N}return w}const YA={kernelName:ym,backendName:"cpu",kernelFunc:XA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JA(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,exclusive:o,reverse:i}=s;jt(r,"cumsum");const u=ws([a],r.shape.length);let c=r;u!=null&&(c=Nn({inputs:{x:r},backend:n,attrs:{perm:u}}));const l=vs(1,r.shape.length)[0];if(l!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${l}`);const f=Ma(c.dtype,"int32"),d=tn(It(c.shape),f),m=n.data.get(c.dataId).values,g=c.shape[c.shape.length-1],b=i?(k,N)=>k+g-N-1:(k,N)=>k+N;for(let k=0;k<m.length;k+=g)for(let N=0;N<g;N++){const _=b(k,N);if(N===0)d[_]=o?0:m[_];else{const I=b(k,N-1);d[_]=o?m[I]+d[I]:m[_]+d[I]}}const w=n.makeTensorInfo(c.shape,f,d);if(u!=null){const k=ky(u),N=Nn({inputs:{x:w},backend:n,attrs:{perm:k}});return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(c),N}return w}const ZA={kernelName:bm,backendName:"cpu",kernelFunc:JA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QA(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,weights:a}=t,{size:o,binaryOutput:i}=s;if(r.shape.length===1){const u=n.data.get(r.dataId).values,c=n.data.get(a.dataId).values,l=pb(u,c,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,l)}else if(r.shape.length===2){const u=n.bufferSync(r),c=n.bufferSync(a),l=zC(u,c,o,i);return n.makeTensorInfo(l.shape,a.dtype,l.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const tF={kernelName:vm,backendName:"cpu",kernelFunc:QA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eF(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockSize:a,dataFormat:o}=s;D(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const i=r.shape[0],u=r.shape[1],c=r.shape[2],l=r.shape[3],f=u*a,d=c*a,m=l/(a*a),g=n.data.get(r.dataId).values,b=new Float32Array(i*f*d*m);let w=0;for(let k=0;k<i;++k)for(let N=0;N<f;++N){const _=Math.floor(N/a),I=N%a;for(let $=0;$<d;++$){const O=Math.floor($/a),R=$%a,W=(I*a+R)*m;for(let P=0;P<m;++P){const T=P+W+l*(O+c*(_+u*k));b[w++]=g[T]}}}return n.makeTensorInfo([i,f,d,m],r.dtype,b)}const nF={kernelName:km,backendName:"cpu",kernelFunc:eF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ob(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a}=t,{strides:o,pad:i,dilations:u,dimRoundingMode:c}=s;jt([r,a],"depthwiseConv2DNative");const l=Kt(r.shape),f=Kt(a.shape);let d=u;d==null&&(d=[1,1]),D(Qn(o,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const m=bs(r.shape,a.shape,o,d,i,c,!0),{filterHeight:g,filterWidth:b,dilationHeight:w,dilationWidth:k,padInfo:N}=m,_=N.left,I=N.top,$=m.outChannels/m.inChannels,O=new je(m.outShape,r.dtype),R=n.data.get(r.dataId).values,W=n.data.get(a.dataId).values,P=O.values;for(let M=0;M<m.batchSize;++M){const T=M*l[0],q=M*O.strides[0];for(let X=0;X<m.outHeight;++X){const st=q+X*O.strides[1],et=X*m.strideHeight-I;for(let nt=0;nt<g;++nt){const ot=et+nt*w;if(ot<0||ot>=m.inHeight)continue;const tt=nt*f[0],ct=T+ot*l[1];for(let ht=0;ht<m.outWidth;++ht){const gt=st+ht*O.strides[2],wt=ht*m.strideWidth-_;for(let bt=0;bt<b;++bt){const Ct=wt+bt*k;if(Ct<0||Ct>=m.inWidth)continue;const Et=tt+bt*f[1],Ft=ct+Ct*m.inChannels;let Bt=gt,Ht=Et;for(let vt=0;vt<m.inChannels;++vt){const Ut=R[Ft+vt];for(let Zt=0;Zt<$;++Zt)P[Bt+Zt]+=Ut*W[Ht+Zt];Bt+=$,Ht+=$}}}}}}return n.makeTensorInfo(O.shape,O.dtype,O.values)}const sF={kernelName:xm,backendName:"cpu",kernelFunc:Ob};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rF(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:a}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:c,filterShape:l}=s;jt([r,a],"depthwiseConv2dNativeBackpropFilter");const f=bs(r.shape,l,o,i,u,c,!0),{strideHeight:d,strideWidth:m,filterHeight:g,filterWidth:b}=f,w=new je(f.filterShape,"float32"),k=f.padInfo.left,N=f.padInfo.top,_=f.outChannels/f.inChannels,I=n.data.get(r.dataId).values,$=new je(r.shape,r.dtype,I),O=n.data.get(a.dataId).values,R=new je(a.shape,a.dtype,O);for(let W=0;W<g;++W){const P=Math.max(0,Math.ceil((N-W)/d)),M=Math.min(f.outHeight,(f.inHeight+N-W)/d);for(let T=0;T<b;++T){const q=Math.max(0,Math.ceil((k-T)/m)),X=Math.min(f.outWidth,(f.inWidth+k-T)/m);for(let st=0;st<f.outChannels;++st){const et=Math.trunc(st/_),nt=st%_;let ot=0;for(let tt=0;tt<f.batchSize;++tt)for(let ct=P;ct<M;++ct){const ht=W+ct*d-N;for(let gt=q;gt<X;++gt){const wt=T+gt*m-k;ot+=$.get(tt,ht,wt,et)*R.get(tt,ct,gt,st)}}w.set(ot,W,T,et,nt)}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}const aF={kernelName:Sm,backendName:"cpu",kernelFunc:rF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oF(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:a}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:c,inputShape:l}=s;jt([r,a],"depthwiseConv2DNativeBackpropInput");const f=Kt(r.shape),d=Kt(a.shape),m=bs(l,a.shape,o,i,u,c,!0),g=new je(m.inShape,"float32"),b=g.values,[w,k,N]=g.strides,_=n.data.get(r.dataId).values,[I,$,O]=f,R=n.data.get(a.dataId).values,[W,P,M]=d,{batchSize:T,filterHeight:q,filterWidth:X,inChannels:st,inHeight:et,inWidth:nt,outChannels:ot,outHeight:tt,outWidth:ct,strideHeight:ht,strideWidth:gt}=m,wt=q-1-m.padInfo.top,bt=X-1-m.padInfo.left,Ct=ot/st;for(let Et=0;Et<T;++Et)for(let Ft=0;Ft<st;++Ft)for(let Bt=0;Bt<et;++Bt){const Ht=Bt-wt,vt=Math.max(0,Math.ceil(Ht/ht)),Ut=Math.min(tt,(q+Ht)/ht);for(let Zt=0;Zt<nt;++Zt){const F=Zt-bt,z=Math.max(0,Math.ceil(F/gt)),at=Math.min(ct,(X+F)/gt);let ft=0;for(let lt=vt;lt<Ut;++lt){const dt=lt*ht-Ht;for(let xt=z;xt<at;++xt){const Tt=xt*gt-F,kt=I*Et+$*lt+O*xt,yt=W*(q-1-dt)+P*(X-1-Tt)+M*Ft;for(let Vt=0;Vt<Ct;++Vt){const $t=Ft*Ct+Vt,Lt=_[kt+$t],qt=R[yt+Vt];ft+=Lt*qt}}}b[w*Et+k*Bt+N*Zt+Ft]=ft}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}const iF={kernelName:Im,backendName:"cpu",kernelFunc:oF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uF(e){const{inputs:t,backend:n}=e,{x:s}=t,r=It(s.shape),a=n.data.get(s.dataId).values,o=ce([r,r],s.dtype),i=o.values;for(let c=0;c<a.length;c++)i[c*r+c]=a[c];const u=[...s.shape,...s.shape];return n.makeTensorInfo(u,o.dtype,o.values)}const cF={kernelName:Nm,backendName:"cpu",kernelFunc:uF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lF={kernelName:_m,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:r}=e,{strides:a,pad:o,dilations:i}=n,u=t,c=u.data.get(s.dataId).values,l=s.shape.length,f=u.data.get(r.dataId).values,d=r.shape.length,{batchSize:m,inHeight:g,inWidth:b,inChannels:w,outHeight:k,outWidth:N,padInfo:_,strideHeight:I,strideWidth:$,filterHeight:O,filterWidth:R,dilationHeight:W,dilationWidth:P,outShape:M}=Jf(s.shape,r.shape,a,o,"NHWC",i),T=It(M),q=M.length,X=ze(s.dtype,T);for(let et=0;et<m;++et)for(let nt=0;nt<k;++nt){const ot=nt*I-_.top;for(let tt=0;tt<N;++tt){const ct=tt*$-_.left;for(let ht=0;ht<w;++ht){let gt=Number.MIN_SAFE_INTEGER;for(let bt=0;bt<O;++bt){const Ct=ot+bt*W;if(Ct>=0&&Ct<g)for(let Et=0;Et<R;++Et){const Ft=ct+Et*P;if(Ft>=0&&Ft<b){const Bt=ls([et,Ct,Ft,ht],l,Kt(s.shape)),Ht=ls([bt,Et,ht],d,Kt(r.shape)),vt=c[Bt]+f[Ht];vt>gt&&(gt=vt)}}}const wt=ls([et,nt,tt,ht],q,Kt(M));X[wt]=gt}}}return{dataId:u.write(Xr(X,s.dtype),M,s.dtype),shape:M,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fF={kernelName:vd,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:r,dy:a}=e,{strides:o,pad:i,dilations:u}=n,c=t,l=qn(s.shape,c.data.get(s.dataId).values),f=qn(r.shape,c.data.get(r.dataId).values),{batchSize:d,inHeight:m,inWidth:g,inChannels:b,outHeight:w,outWidth:k,padInfo:N,strideHeight:_,strideWidth:I,filterHeight:$,filterWidth:O,dilationHeight:R,dilationWidth:W,outShape:P}=Jf(s.shape,r.shape,o,i,"NHWC",u);D(a.rank===P.length,()=>`Error in ${vd}, dy must have the same rank as output ${P.length}, but got ${a.rank}`);const M=qn(P,c.data.get(a.dataId).values),T=Gp(r.shape,r.dtype);for(let X=0;X<d;++X)for(let st=0;st<w;++st){const et=st*_-N.top;for(let nt=0;nt<k;++nt){const ot=nt*I-N.left;for(let tt=0;tt<b;++tt){let ct=Number.MIN_SAFE_INTEGER,ht=0,gt=0;for(let wt=0;wt<$;++wt){const bt=et+wt*R;if(bt>=0&&bt<m)for(let Ct=0;Ct<O;++Ct){const Et=ot+Ct*W;if(Et>=0&&Et<g){const Ft=l[X][bt][Et][tt]+f[wt][Ct][tt];Ft>ct&&(ct=Ft,ht=wt,gt=Ct)}}}T[ht][gt][tt]+=M[X][st][nt][tt]}}}return{dataId:c.write(Xr(T,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hF={kernelName:wd,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:r,dy:a}=e,{strides:o,pad:i,dilations:u}=n,c=t,l=qn(s.shape,c.data.get(s.dataId).values),f=qn(r.shape,c.data.get(r.dataId).values),{batchSize:d,inHeight:m,inWidth:g,inChannels:b,outHeight:w,outWidth:k,padInfo:N,strideHeight:_,strideWidth:I,filterHeight:$,filterWidth:O,dilationHeight:R,dilationWidth:W,outShape:P}=Jf(s.shape,r.shape,o,i,"NHWC",u);D(a.rank===P.length,()=>`Error in ${wd}, dy must have the same rank as output ${P.length}, but got ${a.rank}`);const M=qn(P,c.data.get(a.dataId).values),T=Gp(s.shape,s.dtype);for(let X=0;X<d;++X)for(let st=0;st<w;++st){const et=st*_-N.top;for(let nt=0;nt<k;++nt){const ot=nt*I-N.left;for(let tt=0;tt<b;++tt){let ct=Number.MIN_SAFE_INTEGER,ht=et<0?0:et,gt=ot<0?0:ot;for(let wt=0;wt<$;++wt){const bt=et+wt*R;if(bt>=0&&bt<m)for(let Ct=0;Ct<O;++Ct){const Et=ot+Ct*W;if(Et>=0&&Et<g){const Ft=l[X][bt][Et][tt]+f[wt][Ct][tt];Ft>ct&&(ct=Ft,ht=bt,gt=Et)}}}T[X][ht][gt][tt]+=M[X][st][nt][tt]}}}return{dataId:c.write(Xr(T,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dF(e){const{inputs:t,backend:n,attrs:s}=e,{image:r}=t,{canvas:a,options:o}=s,{contextOptions:i,imageOptions:u}=o||{},c=(u==null?void 0:u.alpha)||1,l=(i==null?void 0:i.contextType)||"2d";if(l!=="2d")throw new Error(`Context type ${i.contextType} is not supported by the CPU backend.`);const f=a.getContext(l,(i==null?void 0:i.contextAttributes)||{});if(f==null)throw new Error(`Could not get the context with ${l} type.`);const[d,m]=r.shape.slice(0,2),g=r.shape.length===2?1:r.shape[2],b=n.data.get(r.dataId).values,w=r.dtype==="float32"?255:1,k=new Uint8ClampedArray(m*d*4);for(let _=0;_<d*m;++_){const I=[0,0,0,255*c];for(let O=0;O<g;O++){const R=b[_*g+O];if(r.dtype==="float32"){if(R<0||R>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${R}.`)}else if(r.dtype==="int32"&&(R<0||R>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${R}.`);g===1?(I[0]=R*w,I[1]=R*w,I[2]=R*w):I[O]=R*w}const $=_*4;k[$+0]=Math.round(I[0]),k[$+1]=Math.round(I[1]),k[$+2]=Math.round(I[2]),k[$+3]=Math.round(I[3])}a.width=m,a.height=d;const N=new ImageData(k,m,d);return f.putImageData(N,0,0),r}const pF={kernelName:Zw,backendName:"cpu",kernelFunc:dF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zo(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:o}=s;jt(r,"sum");let i;r.dtype==="bool"?i=lr({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):i=ms({inputs:{x:r},backend:n});const u=i.shape.length,c=Ue(a,i.shape),l=ws(c,u);let f=c,d=i;l!=null&&(d=Nn({inputs:{x:i},backend:n,attrs:{perm:l}}),f=vs(f.length,u)),Yr("sum",f,d.shape.length);const[m,g]=zs(d.shape,f),b=Ma(d.dtype,"int32");let w=Yi(n,m,b);const k=It(g),N=n.data.get(w.dataId).values,_=n.data.get(d.dataId).values;for(let I=0;I<N.length;++I){const $=I*k;let O=0;for(let R=0;R<k;++R)O+=_[$+R];N[I]=O}if(o){const I=es(w.shape,c),$=w;w=xe({inputs:{x:w},backend:n,attrs:{shape:I}}),n.disposeIntermediateTensorInfo($)}return n.disposeIntermediateTensorInfo(i),l!=null&&n.disposeIntermediateTensorInfo(d),w}const mF={kernelName:bg,backendName:"cpu",kernelFunc:zo};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gF(e){const{inputs:t,backend:n,attrs:s}=e,{equation:r}=s,a=t,{allDims:o,summedDims:i,idDims:u}=A2(r,a.length);R2(o.length,u,a);const{path:c,steps:l}=P2(i,u),f=l.length;let d=null,m=o.length;const g=[];for(let b=0;b<f;++b){for(const w of l[b]){const{permutationIndices:k,expandDims:N}=F2(m,u[w]);let _;M2(k)?_=a[w]:(_=Nn({inputs:{x:a[w]},backend:n,attrs:{perm:k}}),g.push(_));const I=_.shape.slice();for(let $=0;$<N.length;++$)I.splice(N[$],0,1);Un(_.shape,I)||(_=xe({inputs:{x:_},backend:n,attrs:{shape:I}}),g.push(_)),d===null?d=_:(d=Tu({inputs:{a:_,b:d},backend:n}),g.push(d))}b<f-1&&(c[b]>=0&&(d=zo({inputs:{x:d},backend:n,attrs:{axis:c[b]-(o.length-m),keepDims:!1}}),g.push(d)),m--)}for(const b of g)b!==d&&n.disposeIntermediateTensorInfo(b);return d}const yF={kernelName:Tm,backendName:"cpu",kernelFunc:gF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bF(e){const{inputs:t,backend:n}=e,{dy:s,y:r}=t;jt([s,r],"eluGrad");const a=new Float32Array(It(r.shape)),o=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values;for(let u=0;u<o.length;++u){const c=o[u];c>=0?a[u]=i[u]:a[u]=i[u]*(c+1)}return n.makeTensorInfo(r.shape,"float32",a)}const wF={kernelName:Qw,backendName:"cpu",kernelFunc:bF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vF=v2,kF=k2,xF=x2,SF=S2,IF=I2,NF=N2,_F=ye(sf,e=>{const t=Math.sign(e),n=Math.abs(e),s=1/(1+vF*n);return t*(1-((((NF*s+IF)*s+SF)*s+xF)*s+kF)*s*Math.exp(-n*n))}),TF={kernelName:sf,backendName:"cpu",kernelFunc:_F};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qi(e){const{inputs:t,backend:n,attrs:s}=e,{input:r}=t,{dim:a}=s,o=r.shape.length,i=r.shape.slice();let u=a;return a<0&&(D(-(o+1)<=a,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+a+1),i.splice(u,0,1),xe({inputs:{x:r},backend:n,attrs:{shape:i}})}const EF={kernelName:Em,backendName:"cpu",kernelFunc:Qi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $F=Me((e,t)=>e/t),wh=qe(ef,$F),kl={kernelName:ef,backendName:"cpu",kernelFunc:wh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Db(e,t,n){const s=e.shape,r=s[0],a=s[1],o=n.data.get(e.dataId),i=o.complexTensorInfos.real,u=o.complexTensorInfos.imag,c=[r,a],l=It(c),f=mn("float32",l),d=mn("float32",l);for(let w=0;w<r;w++){const k=Gr({inputs:{x:i},backend:n,attrs:{begin:[w,0],size:[1,a]}}),N=Gr({inputs:{x:u},backend:n,attrs:{begin:[w,0],size:[1,a]}}),_=Cn({inputs:{real:k,imag:N},backend:n}),{real:I,imag:$}=CF(_,t,n),O=Ta(I,$);for(let R=0;R<a;R++){const W=lb(O,R);f[w*a+R]=W.real,d[w*a+R]=W.imag}n.disposeIntermediateTensorInfo(k),n.disposeIntermediateTensorInfo(N),n.disposeIntermediateTensorInfo(_)}const m=n.makeTensorInfo(c,"float32",f),g=n.makeTensorInfo(c,"float32",d),b=Cn({inputs:{real:m,imag:g},backend:n});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),b}function CF(e,t,n){const s=It(e.shape),r=n.data.get(e.dataId),a=n.data.get(r.complexTensorInfos.real.dataId).values,o=n.data.get(r.complexTensorInfos.imag.dataId).values;if(OF(s)){const i=xl(a,o,s,t,n),u=[e.shape[0],e.shape[1]];if(t){const c=n.makeTensorInfo(u,"float32",i.real),l=n.makeTensorInfo(u,"float32",i.imag),f=n.makeTensorInfo([],"float32",Gf(s,"float32")),d=ms({inputs:{x:f},backend:n}),m=kl.kernelFunc({inputs:{a:c,b:f},backend:n}),g=kl.kernelFunc({inputs:{a:l,b:d},backend:n}),b=n.data.get(m.dataId).values,w=n.data.get(g.dataId).values;return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),{real:b,imag:w}}return i}else{const i=Ta(a,o),u=DF(i,s,t);return _2(u)}}function OF(e){return(e&e-1)===0}function xl(e,t,n,s,r){if(n===1)return{real:e,imag:t};const a=Ta(e,t),o=n/2,i=T2(a),u=i.real,c=i.imag,l=[u.length],f=r.makeTensorInfo(l,"float32",u),d=r.makeTensorInfo(l,"float32",c),m=Cn({inputs:{real:f,imag:d},backend:r}),g=E2(a),b=g.real,w=g.imag,k=[b.length],N=r.makeTensorInfo(k,"float32",b),_=r.makeTensorInfo(k,"float32",w),I=Cn({inputs:{real:N,imag:_},backend:r}),$=xl(u,c,o,s,r),O=$.real,R=$.imag,W=[O.length],P=r.makeTensorInfo(W,"float32",O),M=r.makeTensorInfo(W,"float32",R),T=Cn({inputs:{real:P,imag:M},backend:r}),q=xl(b,w,o,s,r),X=q.real,st=q.imag,et=[X.length],nt=r.makeTensorInfo(et,"float32",X),ot=r.makeTensorInfo(et,"float32",st),tt=Cn({inputs:{real:nt,imag:ot},backend:r}),ct=C2(n,s),ht=[ct.real.length],gt=r.makeTensorInfo(ht,"float32",ct.real),wt=r.makeTensorInfo(ht,"float32",ct.imag),bt=Cn({inputs:{real:gt,imag:wt},backend:r}),Ct=Tu({inputs:{a:bt,b:tt},backend:r}),Et=Ea({inputs:{a:T,b:Ct},backend:r}),Ft=yh({inputs:{a:T,b:Ct},backend:r}),Bt=Ur({inputs:{input:Et},backend:r}),Ht=Ur({inputs:{input:Ft},backend:r}),vt=$a({inputs:{input:Et},backend:r}),Ut=$a({inputs:{input:Ft},backend:r}),Zt=Ca({inputs:[Bt,Ht],backend:r,attrs:{axis:0}}),F=Ca({inputs:[vt,Ut],backend:r,attrs:{axis:0}}),z=r.data.get(Zt.dataId).values,at=r.data.get(F.dataId).values;return r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(I),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(M),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(nt),r.disposeIntermediateTensorInfo(ot),r.disposeIntermediateTensorInfo(tt),r.disposeIntermediateTensorInfo(gt),r.disposeIntermediateTensorInfo(wt),r.disposeIntermediateTensorInfo(bt),r.disposeIntermediateTensorInfo(Ct),r.disposeIntermediateTensorInfo(Et),r.disposeIntermediateTensorInfo(Ft),r.disposeIntermediateTensorInfo(Bt),r.disposeIntermediateTensorInfo(vt),r.disposeIntermediateTensorInfo(Ht),r.disposeIntermediateTensorInfo(Ut),r.disposeIntermediateTensorInfo(Zt),r.disposeIntermediateTensorInfo(F),{real:z,imag:at}}function DF(e,t,n){const s=new Float32Array(t*2);for(let r=0;r<t;r++){let a=0,o=0;for(let i=0;i<t;i++){const u=O2(r*i,t,n),c=lb(e,i);a+=c.real*u.real-c.imag*u.imag,o+=c.real*u.imag+c.imag*u.real}n&&(a/=t,o/=t),$2(s,a,o,r)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AF(e){const{inputs:t,backend:n}=e,{input:s}=t,r=It(s.shape),a=s.shape[s.shape.length-1],o=r/a,i=xe({inputs:{x:s},backend:n,attrs:{shape:[o,a]}}),u=Db(i,!1,n),c=xe({inputs:{x:u},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),c}const FF={kernelName:$m,backendName:"cpu",kernelFunc:AF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vh(e){const{backend:t,attrs:n}=e,{shape:s,value:r,dtype:a}=n,o=a||Po(r),i=ze(o,It(s));return PF(i,r,o),t.makeTensorInfo(s,o,i)}const RF={kernelName:Cm,backendName:"cpu",kernelFunc:vh};function PF(e,t,n){e.fill(t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MF={kernelName:Om,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:s}=e,r=n,a=mn(s.dtype,It(s.shape)),[o,i,u,c]=s.shape,l=r.data.get(s.dataId).values;for(let d=0;d<o;d++){const m=d*u*i*c;for(let g=0;g<i;g++){const b=g*(u*c);for(let w=0;w<u;w++){const k=w*c;for(let N=0;N<c;N++){const _=Math.round(u-w-1),I=m+b+k+N;let $=l[I];if(_>=0&&_<u){const O=_*c,R=m+b+O+N;$=l[R]}a[I]=$}}}}return{dataId:r.write(a,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VF(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a,bias:o,preluActivationWeights:i}=t,{strides:u,pad:c,dataFormat:l,dilations:f,dimRoundingMode:d,activation:m,leakyreluAlpha:g}=s;let b=Cb({inputs:{x:r,filter:a},backend:n,attrs:{strides:u,pad:c,dataFormat:l,dilations:f,dimRoundingMode:d}});if(o){const w=b;if(l==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const k=xe({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});b=Ea({inputs:{a:b,b:k},backend:n}),n.disposeIntermediateTensorInfo(k)}else b=Ea({inputs:{a:b,b:o},backend:n});n.disposeIntermediateTensorInfo(w)}if(m){const w=b;if(l==="NCHW"&&m==="prelu"&&i.shape.length===1&&i.shape[0]!==1){const k=xe({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});b=Zi(n,b,m,k,g),n.disposeIntermediateTensorInfo(k)}else b=Zi(n,b,m,i,g);n.disposeIntermediateTensorInfo(w)}return b}const LF={kernelName:Hc,backendName:"cpu",kernelFunc:VF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zF(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a,bias:o,preluActivationWeights:i}=t,{strides:u,pad:c,dataFormat:l,dilations:f,dimRoundingMode:d,activation:m,leakyreluAlpha:g}=s;let b=Ob({inputs:{x:r,filter:a},backend:n,attrs:{strides:u,pad:c,dataFormat:l,dilations:f,dimRoundingMode:d}});if(o){const w=b;b=Ea({inputs:{a:b,b:o},backend:n}),n.disposeIntermediateTensorInfo(w)}if(m){const w=b;b=Zi(n,b,m,i,g),n.disposeIntermediateTensorInfo(w)}return b}const BF={kernelName:Kc,backendName:"cpu",kernelFunc:zF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WF(e){const{inputs:t,backend:n}=e,{params:s,indices:r}=t,a=It(s.shape),o=r.shape,i=o[o.length-1],[u,c,l,f]=e2(s,r);if(c===0)return n.makeTensorInfo(u,s.dtype,[]);const d=n.data.get(r.dataId).values,m=n.bufferSync(s),g=iO(d,m,s.dtype,c,i,l,f,s.shape,a);return n.makeTensorInfo(u,s.dtype,g.values)}const jF={kernelName:Fm,backendName:"cpu",kernelFunc:WF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qF(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,indices:a}=t,{axis:o,batchDims:i}=s;jt([r,a],"gatherV2");const u=Ue(o,r.shape)[0],c=n.data.get(a.dataId).values,l=r.shape[u];for(let I=0;I<c.length;++I){const $=c[I];D($<=l-1&&$>=0,()=>`GatherV2: the index value ${$} is not in [0, ${l-1}]`)}let f=i;i==null&&(f=0);const d=It(a.shape),m=J2(r,a,u,f),g=xe({inputs:{x:r},backend:n,attrs:{shape:[m.batchSize,m.outerSize,m.dimSize,m.sliceSize]}}),b=xe({inputs:{x:a},backend:n,attrs:{shape:[m.batchSize,d/m.batchSize]}}),w=[m.batchSize,m.outerSize,d/m.batchSize,m.sliceSize],k=n.bufferSync(b),N=n.bufferSync(g),_=uO(N,k,w);return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),n.makeTensorInfo(m.outputShape,_.dtype,_.values)}const HF={kernelName:Am,backendName:"cpu",kernelFunc:qF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KF(e){const{inputs:t,backend:n}=e,{input:s}=t,r=It(s.shape),a=s.shape[s.shape.length-1],o=r/a,i=xe({inputs:{x:s},backend:n,attrs:{shape:[o,a]}}),u=Db(i,!0,n),c=xe({inputs:{x:u},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),c}const UF={kernelName:Rm,backendName:"cpu",kernelFunc:KF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GF=ye(df,e=>Number.isFinite(e)?1:0,"bool"),XF={kernelName:df,backendName:"cpu",kernelFunc:GF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YF=ye(pf,e=>Math.abs(e)===1/0?1:0,"bool"),JF={kernelName:pf,backendName:"cpu",kernelFunc:YF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZF=ye(mf,e=>Number.isNaN(e)?1:0,"bool"),QF={kernelName:mf,backendName:"cpu",kernelFunc:ZF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t3(e){const{backend:t,attrs:n}=e,{start:s,stop:r,num:a}=n,o=kO(s,r,a);return t.makeTensorInfo([o.length],"float32",o)}const e3={kernelName:Vm,backendName:"cpu",kernelFunc:t3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n3=ye(wf,e=>Math.log1p(e)),s3={kernelName:wf,backendName:"cpu",kernelFunc:n3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r3=Me((e,t)=>e&&t),a3=qe(vf,r3,null,"bool"),o3={kernelName:vf,backendName:"cpu",kernelFunc:a3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i3=ye(kf,e=>e?0:1,"bool"),u3={kernelName:kf,backendName:"cpu",kernelFunc:i3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c3=Me((e,t)=>e||t),l3=qe(xf,c3,null,"bool"),f3={kernelName:xf,backendName:"cpu",kernelFunc:l3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h3(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{depthRadius:a,bias:o,alpha:i,beta:u}=s;jt(r,"LRN");const c=r.shape[3],l=c-1,f=n.data.get(r.dataId).values,d=It(r.shape),m=new Float32Array(d);function g(b){const w=b%c;let k=b-w+Math.max(0,w-a);const N=b-w+Math.min(w+a,l);let _=0;for(;k<=N;k++){const I=f[k];_+=I*I}return _}for(let b=0;b<d;b++){const w=g(b),k=f[b]*Math.pow(o+i*w,-u);m[b]=k}return n.makeTensorInfo(r.shape,r.dtype,m)}const d3={kernelName:Lm,backendName:"cpu",kernelFunc:h3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p3(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,y:a,dy:o}=t,{depthRadius:i,bias:u,alpha:c,beta:l}=s;jt(o,"LRNGrad");const f=It(o.shape),d=o.shape[3],m=n.data.get(o.dataId).values,g=n.data.get(r.dataId).values,b=n.data.get(a.dataId).values,w=new Float32Array(f),k=f;for(let N=0;N<k;N++){const _=N%d,I=N-_+Math.max(0,_-i),$=N-_+Math.min(d,_+i+1);let O=0;for(let R=I;R<$;R++)O+=Math.pow(g[R],2);O=c*O+u;for(let R=I;R<$;R++){let W=-2*c*l*g[R]*b[N]/O;N===R&&(W+=Math.pow(O,-l)),W*=m[N],w[R]+=W}}return n.makeTensorInfo(o.shape,r.dtype,w)}const m3={kernelName:tv,backendName:"cpu",kernelFunc:p3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ab(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{reductionIndices:a,keepDims:o}=s,i=n;let u=r.shape;const c=u.length,l=Ue(a,u);let f=l;const d=ws(f,c);let m=i.data.get(r.dataId).values;if(d!=null){const I=new Array(c);for(let $=0;$<I.length;$++)I[$]=u[d[$]];m=bb(m,u,r.dtype,d,I),f=vs(f.length,c),u=I}jt(r,"max"),Yr("max",f,c);const[g,b]=zs(u,f),w=It(b),k=NO(m,w,g,r.dtype),N=i.write(k,g,r.dtype);let _=g;return o&&(_=es(g,l)),{dataId:N,shape:_,dtype:r.dtype}}const g3={kernelName:zm,backendName:"cpu",kernelFunc:Ab};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y3(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t;jt(r,"maxPool");const{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=s,c=1;D(Qn(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const l=Va(r.shape,a,o,c,i,u);let f;if(l.filterWidth===1&&l.filterHeight===1&&Un(l.inShape,l.outShape))f=ms({inputs:{x:r},backend:n});else{const d=n.data.get(r.dataId).values,m=Kt(r.shape),g=bh(d,r.shape,r.dtype,m,l,"max");f=n.makeTensorInfo(l.outShape,r.dtype,g.values)}return f}const b3={kernelName:Bm,backendName:"cpu",kernelFunc:y3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w3(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:u,dataFormat:c}=s;jt(r,"maxPool3d");const l=gu(r.shape,a,o,1,i,u,c),f=n.data.get(r.dataId).values,d=$b(f,r.shape,r.dtype,Kt(r.shape),l,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}const v3={kernelName:Wm,backendName:"cpu",kernelFunc:w3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k3(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:a}=t,{filterSize:o,strides:i,pad:u,dimRoundingMode:c}=s;jt([r,a],"maxPool3DGrad");const l=gu(a.shape,o,i,1,u,c),f=n.bufferSync(a),d=cA(f,l),m=l.strideDepth,g=l.strideHeight,b=l.strideWidth,w=l.dilationDepth,k=l.dilationHeight,N=l.dilationWidth,_=l.effectiveFilterDepth,I=l.effectiveFilterHeight,$=l.effectiveFilterWidth,O=_-1-l.padInfo.front,R=$-1-l.padInfo.left,W=I-1-l.padInfo.top,P=ce(a.shape,"float32"),M=n.bufferSync(r);for(let T=0;T<l.batchSize;++T)for(let q=0;q<l.inChannels;++q)for(let X=0;X<l.inDepth;++X)for(let st=0;st<l.inHeight;++st)for(let et=0;et<l.inWidth;++et){const nt=X-O,ot=st-W,tt=et-R;let ct=0;for(let ht=0;ht<_;ht+=w){const gt=(nt+ht)/m;if(!(gt<0||gt>=l.outDepth||Math.floor(gt)!==gt))for(let wt=0;wt<I;wt+=k){const bt=(ot+wt)/g;if(!(bt<0||bt>=l.outHeight||Math.floor(bt)!==bt))for(let Ct=0;Ct<$;Ct+=N){const Et=(tt+Ct)/b;if(Et<0||Et>=l.outWidth||Math.floor(Et)!==Et)continue;const Ft=_*I*$-1-d.get(T,gt,bt,Et,q),Bt=ht*I*$+wt*$+Ct,Ht=Ft===Bt?1:0;if(Ht===0)continue;const vt=M.get(T,gt,bt,Et,q);ct+=vt*Ht}}}P.set(ct,T,X,st,et,q)}return n.makeTensorInfo(P.shape,P.dtype,P.values)}const x3={kernelName:nv,backendName:"cpu",kernelFunc:k3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S3(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:a,output:o}=t,i=a;jt([a,o],"maxPoolGrad");const{filterSize:u,strides:c,pad:l,dimRoundingMode:f}=s,d=Va(i.shape,u,c,1,l,f),m=n.data.get(i.dataId).values,g=ce(d.outShape,i.dtype,Eb(m,i.shape,i.dtype,d).values),b=d.strideHeight,w=d.strideWidth,k=d.dilationHeight,N=d.dilationWidth,_=d.effectiveFilterHeight,I=d.effectiveFilterWidth,$=I-1-d.padInfo.left,O=_-1-d.padInfo.top,R=ce(i.shape,"float32"),W=n.data.get(r.dataId).values,P=ce(r.shape,"float32",W);for(let M=0;M<d.batchSize;++M)for(let T=0;T<d.inChannels;++T)for(let q=0;q<d.inHeight;++q)for(let X=0;X<d.inWidth;++X){const st=q-O,et=X-$;let nt=0;for(let ot=0;ot<_;ot+=k){const tt=(st+ot)/b;if(!(tt<0||tt>=d.outHeight||Math.floor(tt)!==tt))for(let ct=0;ct<I;ct+=N){const ht=(et+ct)/w;if(ht<0||ht>=d.outWidth||Math.floor(ht)!==ht)continue;const gt=_*I-1-g.get(M,tt,ht,T),wt=ot*I+ct,bt=gt===wt?1:0;if(bt===0)continue;const Ct=P.get(M,tt,ht,T);nt+=Ct*bt}}R.set(nt,M,q,X,T)}return n.makeTensorInfo(R.shape,R.dtype,R.values)}const I3={kernelName:ev,backendName:"cpu",kernelFunc:S3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N3(e,t,n,s,r){const a=Kt(t),o=bh(e,t,n,a,r,"max"),i=Eb(e,t,n,r,!0,s);return[o.values,i.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _3={kernelName:jm,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:s}=e,{filterSize:r,strides:a,pad:o,includeBatchInIndex:i}=t,u=n;jt(s,"MaxPoolWithArgmax");const c=u.data.get(s.dataId).values,l=Va(s.shape,r,a,[1,1],o),[f,d]=N3(c,s.shape,s.dtype,i,l),m=u.write(f,l.outShape,s.dtype),g=u.write(d,l.outShape,s.dtype);return[{dataId:m,shape:l.outShape,dtype:s.dtype},{dataId:g,shape:l.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T3(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:o}=s,i=Ue(a,r.shape),c=zs(r.shape,i)[1],l=It(c),f=[],d=n.makeTensorInfo([],"float32",new Float32Array([l]));f.push(d);const m=lr({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});f.push(m);const g=wh({inputs:{a:m,b:d},backend:n});f.push(g);const b=zo({inputs:{x:g},backend:n,attrs:{axis:a,keepDims:o}});return f.forEach(w=>n.disposeIntermediateTensorInfo(w)),b}const E3={kernelName:qm,backendName:"cpu",kernelFunc:T3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $3(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:o}=s;jt(r,"min");const i=Ue(a,r.shape);let u=i;const c=ws(u,r.shape.length);let l=r;c!=null&&(l=Nn({inputs:{x:r},backend:n,attrs:{perm:c}}),u=vs(u.length,r.shape.length)),Yr("min",u,l.shape.length);const[f,d]=zs(l.shape,u),m=It(d),g=tn(It(f),l.dtype),b=n.data.get(l.dataId).values;for(let k=0;k<g.length;++k){const N=k*m;let _=b[N];for(let I=0;I<m;++I){const $=b[N+I];(Number.isNaN($)||$<_)&&(_=$)}g[k]=_}c!=null&&n.disposeIntermediateTensorInfo(l);const w=n.makeTensorInfo(f,l.dtype,g);if(o){const k=es(f,i),N=xe({inputs:{x:w},backend:n,attrs:{shape:k}});return n.disposeIntermediateTensorInfo(w),N}return w}const C3={kernelName:Hm,backendName:"cpu",kernelFunc:$3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O3(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{paddings:a,mode:o}=s;jt(r,"mirrorPad");const i=a.map((_,I)=>_[0]+r.shape[I]+_[1]),u=a.map(_=>_[0]),c=a.map((_,I)=>_[0]+r.shape[I]),l=o==="reflect"?0:1,f=n.data.get(r.dataId).values,d=r.shape.length,m=Kt(r.shape),g=It(i),b=i.length,w=Kt(i),k=mn(r.dtype,g);for(let _=0;_<g;_++){let I=Pa(_,b,w);for(let O=0;O<b;O++)I[O]<u[O]?I[O]=u[O]*2-I[O]-l:I[O]>=c[O]&&(I[O]=(c[O]-1)*2-I[O]+l);I=I.map((O,R)=>O-u[R]);const $=ls(I,d,m);k[_]=f[$]}return{dataId:n.write(k,i,r.dtype),shape:i,dtype:r.dtype}}const D3={kernelName:Km,backendName:"cpu",kernelFunc:O3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A3=Me((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),F3=qe(Nf,A3),R3={kernelName:Nf,backendName:"cpu",kernelFunc:F3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fb(e){const{inputs:t,backend:n,attrs:s}=e,{logits:r}=t,{dim:a}=s,o=r.shape.length;let i=a;if(i===-1&&(i=o-1),i!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${i}`);const u=Ue([i],r.shape),c=Ab({inputs:{x:r},backend:n,attrs:{reductionIndices:u,keepDims:!1}}),l=es(c.shape,u),f=xe({inputs:{x:c},backend:n,attrs:{shape:l}}),d=yh({inputs:{a:r,b:f},backend:n}),m=gb({inputs:{x:d},backend:n}),g=zo({inputs:{x:m},backend:n,attrs:{axis:u,keepDims:!1}}),b=xe({inputs:{x:g},backend:n,attrs:{shape:l}}),w=wh({inputs:{a:m,b},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),w}const P3={kernelName:kg,backendName:"cpu",kernelFunc:Fb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M3(e){const{inputs:t,backend:n,attrs:s}=e,{logits:r}=t,{numSamples:a,seed:o,normalized:i}=s;jt(r,"multinomial");const u=i?r:Fb({inputs:{logits:r},backend:n,attrs:{dim:-1}}),c=u.shape[0],l=u.shape[1],f=n.data.get(u.dataId).values,d=[c,a],m=tn(It(d),"int32");for(let g=0;g<c;++g){const b=g*l,w=new Float32Array(l-1);w[0]=f[b];for(let _=1;_<w.length;++_)w[_]=w[_-1]+f[b+_];const k=Iu.alea(o.toString()),N=g*a;for(let _=0;_<a;++_){const I=k();m[N+_]=w.length;for(let $=0;$<w.length;$++)if(I<w[$]){m[N+_]=$;break}}}return i||n.disposeIntermediateTensorInfo(u),n.makeTensorInfo(d,"int32",m)}const V3={kernelName:Um,backendName:"cpu",kernelFunc:M3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L3=Jy;function z3(e){const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u}=s;jt(r,"NonMaxSuppression");const c=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,{selectedIndices:f}=L3(c,l,o,i,u);return n.makeTensorInfo([f.length],"int32",new Int32Array(f))}const B3={kernelName:Xm,backendName:"cpu",kernelFunc:z3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W3=Zy;function j3(e){const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:c}=s;jt(r,"NonMaxSuppressionPadded");const l=n.data.get(r.dataId).values,f=n.data.get(a.dataId).values,{selectedIndices:d,validOutputs:m}=W3(l,f,o,i,u,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([m]))]}const q3={kernelName:Ym,backendName:"cpu",kernelFunc:j3};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H3=Qy;function K3(e){const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,softNmsSigma:c}=s;jt(r,"NonMaxSuppressionWithScore");const l=n.data.get(r.dataId).values,f=n.data.get(a.dataId).values,d=o,m=i,g=u,b=c,{selectedIndices:w,selectedScores:k}=H3(l,f,d,m,g,b);return[n.makeTensorInfo([w.length],"int32",new Int32Array(w)),n.makeTensorInfo([k.length],"float32",new Float32Array(k))]}const U3={kernelName:Jm,backendName:"cpu",kernelFunc:K3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G3(e){const{inputs:t,backend:n,attrs:s}=e,{indices:r}=t,{dtype:a,depth:o,onValue:i,offValue:u}=s;jt(r,"oneHot");const c=It(r.shape),l=new Float32Array(c*o);l.fill(u);const f=n.data.get(r.dataId).values;for(let d=0;d<c;++d)f[d]>=0&&f[d]<o&&(l[d*o+f[d]]=i);return n.makeTensorInfo([...r.shape,o],a,l)}const X3={kernelName:Qm,backendName:"cpu",kernelFunc:G3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tu(e){const{inputs:t,backend:n}=e,{x:s}=t;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=Ur({inputs:{input:s},backend:n}),a=tu({inputs:{x:r},backend:n}),o=$a({inputs:{input:s},backend:n}),i=tu({inputs:{x:o},backend:n}),u=Cn({inputs:{real:a,imag:i},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),u}else return vh({backend:n,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const Y3={kernelName:Pg,backendName:"cpu",kernelFunc:tu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rb(e){const{inputs:t,backend:n}=e,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=Ur({inputs:{input:s},backend:n}),a=Rb({inputs:{x:r},backend:n}),o=$a({inputs:{input:s},backend:n}),i=tu({inputs:{x:o},backend:n}),u=Cn({inputs:{real:a,imag:i},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),u}else return vh({backend:n,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const J3={kernelName:Zm,backendName:"cpu",kernelFunc:Rb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pb(e){const{inputs:t,backend:n,attrs:s}=e,{axis:r}=s;if(t.length===1)return Qi({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const a=t[0].shape,o=t[0].dtype;t.forEach(l=>{Vn(a,l.shape,"All tensors passed to stack must have matching shapes"),D(o===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=[],u=t.map(l=>{const f=Qi({inputs:{input:l},backend:n,attrs:{dim:r}});return i.push(f),f}),c=Ca({inputs:u,backend:n,attrs:{axis:r}});return i.forEach(l=>n.disposeIntermediateTensorInfo(l)),c}const Z3={kernelName:tg,backendName:"cpu",kernelFunc:Pb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q3(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{paddings:a,constantValue:o}=s;jt(r,"pad");const i=a.map((N,_)=>N[0]+r.shape[_]+N[1]),u=a.map(N=>N[0]),c=n.data.get(r.dataId).values,l=It(r.shape),f=r.shape.length,d=Kt(r.shape),m=It(i),g=i.length,b=Kt(i),w=mn(r.dtype,m);o!==0&&w.fill(o);for(let N=0;N<l;N++){const I=Pa(N,f,d).map((O,R)=>O+u[R]),$=ls(I,g,b);w[$]=c[N]}return{dataId:n.write(w,i,r.dtype),shape:i,dtype:r.dtype}}const Mb={kernelName:eg,backendName:"cpu",kernelFunc:Q3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tR=Me((e,t)=>Math.pow(e,t)),eR=qe(Ef,tR),nR={kernelName:Ef,backendName:"cpu",kernelFunc:eR};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sR(e){const{inputs:t,backend:n,attrs:s}=e,{paramsNestedSplits:r,paramsDenseValues:a,indices:o}=t,{outputRaggedRank:i}=s,u=r.map(k=>n.data.get(k.dataId).values),c=r.map(k=>k.shape),l=n.data.get(a.dataId).values,f=n.data.get(o.dataId).values,[d,m,g]=YO(u,c,l,a.shape,a.dtype,f,o.shape),b=d.map(k=>n.makeTensorInfo([k.length],"int32",k)),w=n.makeTensorInfo(g,a.dtype,m);return b.concat([w])}const rR={kernelName:rg,backendName:"cpu",kernelFunc:sR};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aR(e){const{inputs:t,backend:n}=e,{starts:s,limits:r,deltas:a}=t,o=n.data.get(s.dataId).values,i=n.data.get(r.dataId).values,u=n.data.get(a.dataId).values,[c,l]=JO(o,s.shape,s.dtype,i,r.shape,u,a.shape),f=n.makeTensorInfo([c.length],"int32",c),d=n.makeTensorInfo([l.length],s.dtype,l);return[f,d]}const oR={kernelName:ag,backendName:"cpu",kernelFunc:aR};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iR(e){const{inputs:t,backend:n,attrs:s}=e,{shape:r,values:a,defaultValue:o,rowPartitionTensors:i}=t,{rowPartitionTypes:u}=s,c=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,f=n.data.get(o.dataId).values,d=i.map(w=>n.data.get(w.dataId).values),m=i.map(w=>w.shape),[g,b]=ZO(c,r.shape,l,a.shape,a.dtype,f,o.shape,d,m,u);return n.makeTensorInfo(g,a.dtype,b)}const uR={kernelName:og,backendName:"cpu",kernelFunc:iR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cR(e){const{backend:t,attrs:n}=e,{start:s,stop:r,dtype:a,step:o}=n,i=QO(s,r,o,a);return t.makeTensorInfo([i.length],a,i)}const lR={kernelName:ig,backendName:"cpu",kernelFunc:cR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fR=ye($f,e=>1/e),hR={kernelName:$f,backendName:"cpu",kernelFunc:fR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dR(e){const{inputs:t,backend:n,attrs:s}=e,{images:r}=t,{alignCorners:a,halfPixelCenters:o,size:i}=s;jt(r,"resizeBilinear");const u=Kt(r.shape),[c,l]=i,[f,d,m,g]=r.shape,b=n.data.get(r.dataId).values,w=new Float32Array(It([f,c,l,g])),k=[a&&c>1?d-1:d,a&&l>1?m-1:m],N=[a&&c>1?c-1:c,a&&l>1?l-1:l];let _=0;const I=k[0]/N[0],$=k[1]/N[1];for(let O=0;O<f;O++)for(let R=0;R<c;R++){let W;o?W=I*(R+.5)-.5:W=I*R;const P=Math.max(0,Math.floor(W)),M=W-P,T=Math.min(d-1,Math.ceil(W)),q=O*u[0]+P*u[1],X=O*u[0]+T*u[1];for(let st=0;st<l;st++){let et;o?et=$*(st+.5)-.5:et=$*st;const nt=Math.max(0,Math.floor(et)),ot=et-nt,tt=Math.min(m-1,Math.ceil(et)),ct=q+nt*u[2],ht=X+nt*u[2],gt=q+tt*u[2],wt=X+tt*u[2];for(let bt=0;bt<g;bt++){const Ct=b[ct+bt],Et=b[ht+bt],Ft=b[gt+bt],Bt=b[wt+bt],Ht=Ct+(Ft-Ct)*ot,vt=Et+(Bt-Et)*ot,Ut=Ht+(vt-Ht)*M;w[_++]=Ut}}}return n.makeTensorInfo([f,c,l,g],"float32",w)}const pR={kernelName:fg,backendName:"cpu",kernelFunc:dR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mR(e){const{inputs:t,backend:n,attrs:s}=e,{images:r,dy:a}=t,{alignCorners:o}=s;jt([a,r],"resizeBilinearGrad");const i=Kt(r.shape),[u,c,l,f]=r.shape,[,d,m]=a.shape,g=new Float32Array(u*c*l*f),b=[o&&d>1?c-1:c,o&&m>1?l-1:l],w=[o&&d>1?d-1:d,o&&m>1?m-1:m],k=b[0]/w[0],N=b[1]/w[1],_=n.data.get(a.dataId).values;let I=0;for(let $=0;$<u;$++){const O=$*i[0];for(let R=0;R<d;R++){const W=R*k,P=Math.floor(W),M=Math.min(Math.ceil(W),c-1),T=O+P*i[1],q=O+M*i[1],X=W-P,st=1-X;for(let et=0;et<m;et++){const nt=et*N,ot=Math.floor(nt),tt=Math.min(Math.ceil(nt),l-1),ct=nt-ot,ht=1-ct,gt=T+ot*i[2],wt=T+tt*i[2],bt=q+ot*i[2],Ct=q+tt*i[2],Et=st*ht,Ft=st*ct,Bt=X*ht,Ht=X*ct;for(let vt=0;vt<f;vt++){const Ut=_[I++];g[gt+vt]+=Ut*Et,g[wt+vt]+=Ut*Ft,g[bt+vt]+=Ut*Bt,g[Ct+vt]+=Ut*Ht}}}}return n.makeTensorInfo([u,l,c,f],"float32",g)}const gR={kernelName:rv,backendName:"cpu",kernelFunc:mR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yR(e){const{inputs:t,backend:n,attrs:s}=e,{images:r}=t,{alignCorners:a,halfPixelCenters:o,size:i}=s;jt(r,"resizeNearestNeighbor");const u=Kt(r.shape),[c,l]=i,[f,d,m,g]=r.shape,b=n.data.get(r.dataId).values,w=new Float32Array(f*c*l*g),k=[a&&c>1?d-1:d,a&&l>1?m-1:m],N=[a&&c>1?c-1:c,a&&l>1?l-1:l],_=k[0]/N[0],I=k[1]/N[1];let $=0;for(let O=0;O<f;O++){const R=O*u[0];for(let W=0;W<c;W++){const P=o?_*(W+.5):_*W;let M=Math.min(d-1,a?Math.round(P):Math.floor(P));o&&(M=Math.max(0,M));const T=R+M*u[1];for(let q=0;q<l;q++){const X=o?I*(q+.5):I*q;let st=Math.min(m-1,a?Math.round(X):Math.floor(X));o&&(st=Math.max(0,st));const et=T+st*u[2];for(let nt=0;nt<g;nt++){const ot=b[et+nt];w[$++]=ot}}}}return n.makeTensorInfo([f,c,l,g],r.dtype,w)}const bR={kernelName:lg,backendName:"cpu",kernelFunc:yR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wR(e){const{inputs:t,backend:n,attrs:s}=e,{images:r,dy:a}=t,{alignCorners:o}=s;jt([a,r],"resizeNearestNeighborGrad");const i=Kt(r.shape),u=Kt(a.shape),[c,l,f,d]=r.shape,[,m,g]=a.shape,b=new Float32Array(c*l*f*d),w=n.data.get(a.dataId).values,k=[o&&m>1?l-1:l,o&&g>1?f-1:f],N=[o&&m>1?m-1:m,o&&g>1?g-1:g],_=k[0]/N[0],I=k[1]/N[1],$=1/_,O=1/I,R=Math.ceil($)*2+2,W=Math.ceil(O)*2+2;for(let P=0;P<c;P++){const M=P*i[0];for(let T=0;T<l;T++){const q=M+T*i[1],X=Math.floor(T*$),st=Math.floor(X-R/2);for(let et=0;et<f;et++){const nt=q+et*i[2],ot=Math.floor(et*O),tt=Math.floor(ot-W/2);for(let ct=0;ct<d;ct++){let ht=0;for(let gt=0;gt<R;gt++){const wt=gt+st;if(wt<0||wt>=m)continue;const bt=M+wt*u[1],Ct=wt*_,Et=Math.min(l-1,o?Math.round(Ct):Math.floor(Ct));if(T===Et)for(let Ft=0;Ft<W;Ft++){const Bt=Ft+tt;if(Bt<0||Bt>=g)continue;const Ht=bt+Bt*u[2],vt=Bt*I,Ut=Math.min(f-1,o?Math.round(vt):Math.floor(vt));et===Ut&&(ht+=w[Ht+ct])}}b[nt+ct]=ht}}}}return n.makeTensorInfo(r.shape,r.dtype,b)}const vR={kernelName:sv,backendName:"cpu",kernelFunc:wR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kR(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{dims:a}=s;jt(r,"reverse");const o=r.shape.length,i=Ue(a,r.shape);if(o===0)return ms({inputs:{x:r},backend:n});const u=new je(r.shape,r.dtype),c=n.bufferSync(r);for(let l=0;l<u.size;l++){const f=u.indexToLoc(l),d=f.slice();i.forEach(m=>d[m]=r.shape[m]-1-d[m]),u.set(c.get(...d),...f)}return n.makeTensorInfo(u.shape,u.dtype,u.values)}const xR={kernelName:hg,backendName:"cpu",kernelFunc:kR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SR={kernelName:Mg,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:s}=e,{radians:r,fillValue:a,center:o}=t,i=n,u=mn(s.dtype,It(s.shape)),[c,l,f,d]=s.shape,[m,g]=m2(o,l,f),b=255,w=Math.sin(r),k=Math.cos(r),N=i.data.get(s.dataId).values;for(let I=0;I<c;I++){const $=I*f*l*d;for(let O=0;O<l;O++){const R=O*(f*d);for(let W=0;W<f;W++){const P=W*d;for(let M=0;M<d;M++){const T=[c,O,W,M],q=T[2],X=T[1];let st=(q-m)*k-(X-g)*w,et=(q-m)*w+(X-g)*k;st=Math.round(st+m),et=Math.round(et+g);let nt=a;if(typeof a!="number"&&(M===3?nt=b:nt=a[M]),st>=0&&st<f&&et>=0&&et<l){const tt=et*(f*d),ct=st*d,ht=$+tt+ct+M;nt=N[ht]}const ot=$+R+P+M;u[ot]=nt}}}}return{dataId:i.write(u,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IR=ye(Df,e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),NR={kernelName:Df,backendName:"cpu",kernelFunc:IR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _R(e){const{inputs:t,backend:n,attrs:s}=e,{indices:r,updates:a}=t,{shape:o}=s,{sliceRank:i,numUpdates:u,sliceSize:c,strides:l,outputSize:f}=oh(a,r,o),d=!0,m=n.bufferSync(r),g=n.bufferSync(a),b=ha(m,g,o,f,c,u,i,l,0,d);return n.makeTensorInfo(o,b.dtype,b.values)}const TR={kernelName:dg,backendName:"cpu",kernelFunc:_R};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ER(e,t){let n=0,s=e.length,r=0;for(;n<s;)r=Math.floor((n+s)/2),e[r]<t?n=r+1:s=r;return s}function $R(e,t){let n=0,s=e.length,r=0;for(;n<s;)r=Math.floor((n+s)/2),e[r]<=t?n=r+1:s=r;return s}function CR(e,t,n,s,r,a){const o=ze("int32",n*r);for(let i=0;i<n;++i){const u=e.slice(i*s,(i+1)*s),c=i*r;for(let l=0;l<r;++l)o[c+l]=a==="left"?ER(u,t[l+c]):$R(u,t[l+c])}return o}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OR(e){const{inputs:t,backend:n,attrs:s}=e,{sortedSequence:r,values:a}=t,{side:o}=s,i=n.data.get(r.dataId).values,u=n.data.get(a.dataId).values,c=CR(i,u,r.shape[0],r.shape[1],a.shape[1],o);return n.makeTensorInfo(a.shape,"int32",c)}const DR={kernelName:mg,backendName:"cpu",kernelFunc:OR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AR(e){const{inputs:t,backend:n}=e,{condition:s,t:r,e:a}=t;jt([s,r,a],"select");const o=s.shape.length,i=n.data.get(s.dataId).values,u=n.data.get(r.dataId).values,c=n.data.get(a.dataId).values,l=Ma(r.dtype,a.dtype),f=tn(It(r.shape),l);let d=0;const m=o===0||o>1||r.shape.length===1?1:It(r.shape.slice(1));for(let g=0;g<i.length;g++)for(let b=0;b<m;b++)i[g]===1?f[d++]=u[g]:f[d++]=c[g];return n.makeTensorInfo(r.shape,l,f)}const FR={kernelName:gg,backendName:"cpu",kernelFunc:AR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RR=b2,PR=w2,MR=ye(Ff,e=>e>=0?PR*e:RR*(Math.exp(e)-1)),VR={kernelName:Ff,backendName:"cpu",kernelFunc:MR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LR=ye(Mf,e=>e<0?-1:e>0?1:0),zR={kernelName:Mf,backendName:"cpu",kernelFunc:LR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BR=ye(Rf,e=>Math.sin(e)),WR={kernelName:Rf,backendName:"cpu",kernelFunc:BR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jR=ye(Pf,e=>Math.sinh(e)),qR={kernelName:Pf,backendName:"cpu",kernelFunc:jR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HR=11920928955078125e-23,lp=Math.log(HR)+2,KR=ye(Lf,e=>{const t=e>-lp,n=e<lp,s=Math.exp(e);let r;return n?r=s:t?r=e:r=Math.log(1+s),r}),UR={kernelName:Lf,backendName:"cpu",kernelFunc:KR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GR(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockShape:a,paddings:o}=s;jt([r],"spaceToBatchND");const i=It(a),u=[[0,0]];u.push(...o);for(let O=1+a.length;O<r.shape.length;++O)u.push([0,0]);const c=Mb.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:u,constantValue:0}}),l=ib(c.shape,a,i,!1),f=ub(l.length,a.length,!1),d=cb(c.shape,a,i,!1),b=xe({inputs:{x:c},backend:n,attrs:{shape:l}}),N=Nn({inputs:{x:b},backend:n,attrs:{perm:f}}),$=xe({inputs:{x:N},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(N),$}const XR={kernelName:wg,backendName:"cpu",kernelFunc:GR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YR(e){const{inputs:t,backend:n}=e,{indices:s,values:r,denseShape:a,defaultValue:o}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${a.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const i=n.data.get(s.dataId).values,u=n.data.get(r.dataId).values,c=n.data.get(a.dataId).values,l=n.data.get(o.dataId).values[0],[f,d,m,g,b]=oD(i,s.shape,s.dtype,u,r.dtype,c,l);return[n.makeTensorInfo(d,s.dtype,f),n.makeTensorInfo([d[0]],r.dtype,m),n.makeTensorInfo([g.length],"bool",new Uint8Array(g.map(w=>Number(w)))),n.makeTensorInfo([b.length],s.dtype,new Int32Array(b))]}const JR={kernelName:xg,backendName:"cpu",kernelFunc:YR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZR(e){const{inputs:t,backend:n}=e,{inputIndices:s,inputShape:r,newShape:a}=t;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const o=Array.from(n.data.get(r.dataId).values),i=n.data.get(s.dataId).values,u=Array.from(n.data.get(a.dataId).values),[c,l,f]=iD(i,s.shape,s.dtype,o,u);return[n.makeTensorInfo(l,s.dtype,c),n.makeTensorInfo([f.length],a.dtype,new Int32Array(f))]}const QR={kernelName:Sg,backendName:"cpu",kernelFunc:ZR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tP(e){const{inputs:t,backend:n}=e,{data:s,indices:r,segmentIds:a}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${a.shape}`);if(r.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(s.dataId).values,i=n.data.get(r.dataId).values,u=n.data.get(a.dataId).values,[c,l]=vb(o,s.shape,s.dtype,i,u,!0);return n.makeTensorInfo(l,s.dtype,c)}const eP={kernelName:Ig,backendName:"cpu",kernelFunc:tP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nP(e){const{inputs:t,backend:n}=e,{data:s,indices:r,segmentIds:a}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${a.shape}`);if(r.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(s.dataId).values,i=n.data.get(r.dataId).values,u=n.data.get(a.dataId).values,[c,l]=vb(o,s.shape,s.dtype,i,u);return n.makeTensorInfo(l,s.dtype,c)}const sP={kernelName:Ng,backendName:"cpu",kernelFunc:nP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rP(e){const{inputs:t,backend:n,attrs:s}=e,{sparseIndices:r,sparseValues:a,defaultValue:o}=t,{outputShape:i}=s,{sliceRank:u,numUpdates:c,sliceSize:l,strides:f,outputSize:d}=oh(a,r,i),m=!1,g=n.bufferSync(r);let b;switch(a.dtype){case"bool":{const w=n.bufferSync(a),k=!!n.data.get(o.dataId).values[0];b=ha(g,w,i,d,l,c,u,f,k,m);break}case"float32":{const w=n.bufferSync(a),k=n.data.get(o.dataId).values[0];b=ha(g,w,i,d,l,c,u,f,k,m);break}case"int32":{const w=n.bufferSync(a),k=n.data.get(o.dataId).values[0];b=ha(g,w,i,d,l,c,u,f,k,m);break}case"string":{const w=n.bufferSync(a),k=vo(n.data.get(o.dataId).values[0]);b=ha(g,w,i,d,l,c,u,f,k,m);break}default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(i,b.dtype,b.values)}const aP={kernelName:_g,backendName:"cpu",kernelFunc:rP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oP(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{numOrSizeSplits:a,axis:o}=s,i=Ue(o,r.shape)[0],u=L2(r,a,i),c=new Array(r.shape.length).fill(0),l=r.shape.slice();return u.map(f=>{const d=[...l];d[i]=f;const m=Gr({inputs:{x:r},backend:n,attrs:{begin:c,size:d}});return c[i]+=f,m})}const iP={kernelName:vg,backendName:"cpu",kernelFunc:oP};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uP={kernelName:av,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,s=t;jt(n,"square");const r=s.data.get(n.dataId).values,a=new Float32Array(r.length);for(let i=0;i<r.length;++i){const u=r[i];a[i]=u*u}return{dataId:s.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cP=ye(Uf,(e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),lP={kernelName:Uf,backendName:"cpu",kernelFunc:cP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fP(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{begin:a,end:o,strides:i,beginMask:u,endMask:c,ellipsisMask:l,newAxisMask:f,shrinkAxisMask:d}=s;jt(r,"stridedSlice");const{finalShapeSparse:m,finalShape:g,isIdentity:b,sliceDim0:w,isSimpleSlice:k,begin:N,end:_,strides:I}=u2(r.shape,a,o,i,u,c,l,f,d);let $;if(b)$=xe({inputs:{x:r},backend:n,attrs:{shape:g}});else if(w||k){D(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const O=r2(N,_,I),R=Gr({inputs:{x:r},backend:n,attrs:{begin:N,size:O}});$=xe({inputs:{x:R},backend:n,attrs:{shape:g}}),n.disposeIntermediateTensorInfo(R)}else{const O=n.bufferSync(r),R=gD(m,O,I,N);$=n.makeTensorInfo(g,R.dtype,R.values)}return $}const hP={kernelName:Tg,backendName:"cpu",kernelFunc:fP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dP(e){const{inputs:t,backend:n,attrs:s}=e,{separator:r,nGramWidths:a,leftPad:o,rightPad:i,padWidth:u,preserveShortSequences:c}=s,{data:l,dataSplits:f}=t,d=n.data.get(l.dataId).values,m=n.data.get(f.dataId).values,[g,b]=bD(d,m,r,a,o,i,u,c);return[n.makeTensorInfo([g.length],"string",g),n.makeTensorInfo(f.shape,"int32",b)]}const pP={kernelName:Eg,backendName:"cpu",kernelFunc:dP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mP(e){const{inputs:t,backend:n,attrs:s}=e,{skipEmpty:r}=s,{input:a,delimiter:o}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const i=n.data.get(a.dataId).values,u=n.data.get(o.dataId).values[0],[c,l,f]=vD(i,u,r),d=l.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",l),n.makeTensorInfo([2],"int32",new Int32Array(f))]}const gP={kernelName:$g,backendName:"cpu",kernelFunc:mP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yP(e){const{inputs:t,backend:n,attrs:s}=e,{numBuckets:r}=s,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=n.data.get(a.dataId).values,i=kD(o,r);return n.makeTensorInfo(a.shape,"int32",i)}const bP={kernelName:Cg,backendName:"cpu",kernelFunc:yP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wP=ye(qf,e=>Math.tan(e)),vP={kernelName:qf,backendName:"cpu",kernelFunc:wP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kP=ye(Hf,e=>Math.tanh(e)),xP={kernelName:Hf,backendName:"cpu",kernelFunc:kP};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SP(e){const{inputs:t,backend:n}=e,{tensor:s,indices:r,updates:a}=t,{sliceRank:o,numUpdates:i,sliceSize:u,strides:c,outputSize:l}=oh(a,r,s.shape),f=!1,d=n.bufferSync(r),m=n.bufferSync(a),g=n.bufferSync(s),b=ha(d,m,s.shape,l,u,i,o,c,g,f);return n.makeTensorInfo(s.shape,b.dtype,b.values)}const IP={kernelName:pg,backendName:"cpu",kernelFunc:SP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NP(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{reps:a}=s;jt(r,"tile");const o=ND(n.bufferSync(r),a);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const _P={kernelName:Kf,backendName:"cpu",kernelFunc:NP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TP(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{k:a,sorted:o}=s;jt(r,"topk");const i=n.data.get(r.dataId).values,[u,c]=_D(i,r.shape,r.dtype,a,o);return[n.makeTensorInfo(u.shape,u.dtype,u.values),n.makeTensorInfo(c.shape,c.dtype,c.values)]}const EP={kernelName:Og,backendName:"cpu",kernelFunc:TP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $P(e){const{inputs:t,attrs:n,backend:s}=e,{image:r,transforms:a}=t,{interpolation:o,fillMode:i,fillValue:u,outputShape:c}=n,[l,f,d,m]=r.shape,[g,b]=c??[f,d],w=[l,g,b,m],k=Kt(r.shape),N=k[0],_=k[1],I=k[2],$=Kt(w),O=$[0],R=$[1],W=$[2],P=mn(r.dtype,It(w));P.fill(u);const M=s.data.get(r.dataId).values,T=s.data.get(a.dataId).values;for(let X=0;X<l;++X){const st=a.shape[0]===1?T:T.subarray(X*8,X*8+8);for(let et=0;et<g;++et)for(let nt=0;nt<b;++nt)for(let ot=0;ot<m;++ot){let tt;const ct=st[6]*nt+st[7]*et+1;if(ct===0)continue;const ht=(st[0]*nt+st[1]*et+st[2])/ct,gt=(st[3]*nt+st[4]*et+st[5])/ct,wt=fp(ht,d,i),bt=fp(gt,f,i);switch(o){case"nearest":tt=RP(M,f,d,N,_,I,X,bt,wt,ot,u);break;case"bilinear":tt=PP(M,f,d,N,_,I,X,bt,wt,ot,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const Ct=X*O+et*R+nt*W+ot;P[Ct]=tt}return s.makeTensorInfo(w,r.dtype,P)}return{dataId:s.write(P,w,r.dtype),shape:r.shape,dtype:r.dtype}}const CP={kernelName:Dg,backendName:"cpu",kernelFunc:$P};function fp(e,t,n){switch(n){case"reflect":return OP(e,t);case"wrap":return DP(e,t);case"nearest":return FP(e,t);case"constant":default:return AP(e)}}function OP(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const s=2*t;n<s&&(n=s*Math.trunc(-n/s)+n),n=n<-t?n+s:-n-1}else if(n>t-1)if(t<=1)n=0;else{const s=2*t;n-=s*Math.trunc(n/s),n>=t&&(n=s-n-1)}return Ll(0,n,t-1)}function DP(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const s=t-1;n+=t*(Math.trunc(-n/s)+1)}else if(n>t-1)if(t<=1)n=0;else{const s=t-1;n-=t*Math.trunc(n/s)}return Ll(0,n,t-1)}function AP(e,t){return e}function FP(e,t){return Ll(0,e,t-1)}function ao(e,t,n,s,r,a,o,i,u,c,l){const f=o*s+i*r+u*a+c;return 0<=i&&i<t&&0<=u&&u<n?e[f]:l}function RP(e,t,n,s,r,a,o,i,u,c,l){const f=Math.round(i),d=Math.round(u);return ao(e,t,n,s,r,a,o,f,d,c,l)}function PP(e,t,n,s,r,a,o,i,u,c,l){const f=Math.floor(i),d=Math.floor(u),m=f+1,g=d+1,b=(g-u)*ao(e,t,n,s,r,a,o,f,d,c,l)+(u-d)*ao(e,t,n,s,r,a,o,f,g,c,l),w=(g-u)*ao(e,t,n,s,r,a,o,m,d,c,l)+(u-d)*ao(e,t,n,s,r,a,o,m,g,c,l);return(m-i)*b+(i-f)*w}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MP(e){const{inputs:t,attrs:n,backend:s}=e,{axis:r}=n,{x:a}=t;jt(a,"unique");const o=s.data.get(a.dataId).values,{outputValues:i,outputShape:u,indices:c}=TD(o,r,a.shape,a.dtype);return[s.makeTensorInfo(u,a.dtype,i),s.makeTensorInfo([c.length],"int32",c)]}const VP={kernelName:Ag,backendName:"cpu",kernelFunc:MP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LP(e){const{inputs:t,backend:n,attrs:s}=e,{value:r}=t;let{axis:a}=s;a<0&&(a+=r.shape.length);const o=r.shape.length,i=r.shape[a],u=new Array(o-1);let c=0;for(let m=0;m<o;m++)m!==a&&(u[c++]=r.shape[m]);const l=new Array(o).fill(0),f=r.shape.slice();f[a]=1;const d=new Array(i);for(let m=0;m<d.length;m++){l[a]=m;const g=Gr({inputs:{x:r},backend:n,attrs:{begin:l,size:f}});d[m]=xe({inputs:{x:g},backend:n,attrs:{shape:u}}),n.disposeIntermediateTensorInfo(g)}return d}const zP={kernelName:Fg,backendName:"cpu",kernelFunc:LP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BP(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,segmentIds:a}=t,{numSegments:o}=s;jt(r,"unsortedSegmentSum");const i=r.shape.length,u=a.shape.length,c=[],l=[],f=i-u;let d=a;for(let g=0;g<f;++g){const b=Qi({inputs:{input:d},backend:n,attrs:{dim:g+1}});d=b,l.push(b)}for(let g=0;g<o;++g){const b=Gf(g,"int32"),w=n.makeTensorInfo([],"int32",b),k=mb({inputs:{a:w,b:d},backend:n}),N=lr({inputs:{x:k},backend:n,attrs:{dtype:"float32"}}),_=Tu({inputs:{a:N,b:r},backend:n}),I=zo({inputs:{x:_},backend:n,attrs:{axis:0,keepDims:!1}});c.push(I),l.push(w),l.push(k),l.push(N),l.push(_),l.push(I)}const m=Pb({inputs:c,backend:n,attrs:{axis:0}});return l.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}const WP={kernelName:Rg,backendName:"cpu",kernelFunc:BP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jP=[MD,OC,LD,BD,LC,jD,HD,UD,XD,JD,QD,eA,sA,oA,uA,fA,dA,mA,yA,RD,wA,kA,SA,jC,NA,PC,KC,TA,DC,$A,OA,DA,FA,PA,VA,zA,WA,qA,KA,GA,YA,ZA,tF,nF,sF,aF,iF,cF,lF,fF,hF,pF,yF,ED,wF,XC,TF,JC,EF,tO,FF,RF,MF,sO,oO,LF,BF,jF,HF,fO,pO,AC,UF,CA,XF,JF,QF,$D,yO,vO,e3,IO,s3,o3,u3,f3,d3,m3,g3,EO,b3,v3,x3,I3,_3,E3,C3,OO,D3,R3,V3,AO,PO,B3,q3,U3,LO,X3,J3,Z3,Mb,nR,OD,jO,rR,oR,uR,lR,FC,kl,hR,DD,AD,FD,pR,gR,bR,vR,xR,SR,NR,nD,TR,DR,FR,VR,sD,zR,WR,qR,aD,P3,UR,XR,JR,QR,eP,sP,aP,iP,cD,uP,hD,mD,lP,hP,pP,gP,bP,ID,mF,vP,xP,IP,_P,EP,CP,zO,VP,zP,WP,Y3];for(const e of jP)iv(e);var qP=class{constructor(e){Zs(this,"model");Zs(this,"dict",[]);Zs(this,"canvas");Zs(this,"ctx");Zs(this,"modelPath");Zs(this,"dictPath");Zs(this,"backend");this.modelPath=e.modelPath,this.dictPath=e.dictPath,this.backend=e.backend||"cpu",this.canvas=document.createElement("canvas"),this.canvas.width=this.canvas.height=64,this.ctx=this.canvas.getContext("2d",{willReadFrequently:!0})}async initialize(e){const t=await fetch(this.dictPath).then(n=>n.text());return this.dict=t.split(`
`),this.model=await _C(this.modelPath,{streamWeights:!0,onProgress:e==null?void 0:e.onProgress}),this.backend==="webgl"?(await Od("webgl"),await Rv(),await this.recognize([10,10,0,20,20,1])):await Od("cpu"),!0}async recognize(e){if(!this.model)throw new Error("Model not initialized");const{canvas:t,ctx:n,model:s,dict:r}=this;n.fillStyle="white",n.fillRect(0,0,t.width,t.height);const a=e.length/3,o=Array.from({length:a},(k,N)=>({x:e[3*N],y:e[3*N+1],isEnd:e[3*N+2]===1}));let i=1/0,u=1/0,c=-1/0,l=-1/0;for(const{x:k,y:N}of o)k<i&&(i=k),k>c&&(c=k),N<u&&(u=N),N>l&&(l=N);const f=c-i||1,d=l-u||1,m=(i+c)/2,g=(u+l)/2,b=Math.min(t.width*.9/f,t.height*.9/d);n.strokeStyle="black",n.lineWidth=2,n.lineCap="round",n.lineJoin="round";let w=null;for(const k of o){const N=t.width/2+(k.x-m)*b,_=t.height/2+(k.y-g)*b;w&&!w.isEnd?(n.beginPath(),n.moveTo(t.width/2+(w.x-m)*b,t.height/2+(w.y-g)*b),n.lineTo(N,_),n.stroke()):(n.beginPath(),n.moveTo(N,_)),w=k}return de(()=>{const k=t2(t,3),N=Pe(k,"float32"),_=ke(N,255),I=Ns(_,0),$=s.predict(I).dataSync();return Array.from($.keys()).sort((R,W)=>$[W]-$[R]).slice(0,10).map(R=>R<r.length?r[R]:"").filter(Boolean)})}async close(){var e;(e=this.model)==null||e.dispose(),this.model=void 0}};/**
* @vue/shared v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function kh(e){const t=Object.create(null);for(const n of e.split(","))t[n]=1;return n=>n in t}const pe={},ya=[],ds=()=>{},HP=()=>!1,Eu=e=>e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&(e.charCodeAt(2)>122||e.charCodeAt(2)<97),xh=e=>e.startsWith("onUpdate:"),en=Object.assign,Sh=(e,t)=>{const n=e.indexOf(t);n>-1&&e.splice(n,1)},KP=Object.prototype.hasOwnProperty,ge=(e,t)=>KP.call(e,t),Xt=Array.isArray,ba=e=>Bo(e)==="[object Map]",$u=e=>Bo(e)==="[object Set]",hp=e=>Bo(e)==="[object Date]",ee=e=>typeof e=="function",Be=e=>typeof e=="string",gs=e=>typeof e=="symbol",Ee=e=>e!==null&&typeof e=="object",Vb=e=>(Ee(e)||ee(e))&&ee(e.then)&&ee(e.catch),Lb=Object.prototype.toString,Bo=e=>Lb.call(e),UP=e=>Bo(e).slice(8,-1),zb=e=>Bo(e)==="[object Object]",Ih=e=>Be(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e,lo=kh(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),Cu=e=>{const t=Object.create(null);return n=>t[n]||(t[n]=e(n))},GP=/-(\w)/g,Ms=Cu(e=>e.replace(GP,(t,n)=>n?n.toUpperCase():"")),XP=/\B([A-Z])/g,yr=Cu(e=>e.replace(XP,"-$1").toLowerCase()),Bb=Cu(e=>e.charAt(0).toUpperCase()+e.slice(1)),Dc=Cu(e=>e?`on${Bb(e)}`:""),$n=(e,t)=>!Object.is(e,t),Fi=(e,...t)=>{for(let n=0;n<e.length;n++)e[n](...t)},Wb=(e,t,n,s=!1)=>{Object.defineProperty(e,t,{configurable:!0,enumerable:!1,writable:s,value:n})},Sl=e=>{const t=parseFloat(e);return isNaN(t)?e:t};let dp;const Ou=()=>dp||(dp=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});function Oa(e){if(Xt(e)){const t={};for(let n=0;n<e.length;n++){const s=e[n],r=Be(s)?QP(s):Oa(s);if(r)for(const a in r)t[a]=r[a]}return t}else if(Be(e)||Ee(e))return e}const YP=/;(?![^(]*\))/g,JP=/:([^]+)/,ZP=/\/\*[^]*?\*\//g;function QP(e){const t={};return e.replace(ZP,"").split(YP).forEach(n=>{if(n){const s=n.split(JP);s.length>1&&(t[s[0].trim()]=s[1].trim())}}),t}function ir(e){let t="";if(Be(e))t=e;else if(Xt(e))for(let n=0;n<e.length;n++){const s=ir(e[n]);s&&(t+=s+" ")}else if(Ee(e))for(const n in e)e[n]&&(t+=n+" ");return t.trim()}const tM="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",eM=kh(tM);function jb(e){return!!e||e===""}function nM(e,t){if(e.length!==t.length)return!1;let n=!0;for(let s=0;n&&s<e.length;s++)n=Da(e[s],t[s]);return n}function Da(e,t){if(e===t)return!0;let n=hp(e),s=hp(t);if(n||s)return n&&s?e.getTime()===t.getTime():!1;if(n=gs(e),s=gs(t),n||s)return e===t;if(n=Xt(e),s=Xt(t),n||s)return n&&s?nM(e,t):!1;if(n=Ee(e),s=Ee(t),n||s){if(!n||!s)return!1;const r=Object.keys(e).length,a=Object.keys(t).length;if(r!==a)return!1;for(const o in e){const i=e.hasOwnProperty(o),u=t.hasOwnProperty(o);if(i&&!u||!i&&u||!Da(e[o],t[o]))return!1}}return String(e)===String(t)}function qb(e,t){return e.findIndex(n=>Da(n,t))}const Hb=e=>!!(e&&e.__v_isRef===!0),fn=e=>Be(e)?e:e==null?"":Xt(e)||Ee(e)&&(e.toString===Lb||!ee(e.toString))?Hb(e)?fn(e.value):JSON.stringify(e,Kb,2):String(e),Kb=(e,t)=>Hb(t)?Kb(e,t.value):ba(t)?{[`Map(${t.size})`]:[...t.entries()].reduce((n,[s,r],a)=>(n[Ac(s,a)+" =>"]=r,n),{})}:$u(t)?{[`Set(${t.size})`]:[...t.values()].map(n=>Ac(n))}:gs(t)?Ac(t):Ee(t)&&!Xt(t)&&!zb(t)?String(t):t,Ac=(e,t="")=>{var n;return gs(e)?`Symbol(${(n=e.description)!=null?n:t})`:e};/**
* @vue/reactivity v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let an;class sM{constructor(t=!1){this.detached=t,this._active=!0,this._on=0,this.effects=[],this.cleanups=[],this._isPaused=!1,this.parent=an,!t&&an&&(this.index=(an.scopes||(an.scopes=[])).push(this)-1)}get active(){return this._active}pause(){if(this._active){this._isPaused=!0;let t,n;if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].pause();for(t=0,n=this.effects.length;t<n;t++)this.effects[t].pause()}}resume(){if(this._active&&this._isPaused){this._isPaused=!1;let t,n;if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].resume();for(t=0,n=this.effects.length;t<n;t++)this.effects[t].resume()}}run(t){if(this._active){const n=an;try{return an=this,t()}finally{an=n}}}on(){++this._on===1&&(this.prevScope=an,an=this)}off(){this._on>0&&--this._on===0&&(an=this.prevScope,this.prevScope=void 0)}stop(t){if(this._active){this._active=!1;let n,s;for(n=0,s=this.effects.length;n<s;n++)this.effects[n].stop();for(this.effects.length=0,n=0,s=this.cleanups.length;n<s;n++)this.cleanups[n]();if(this.cleanups.length=0,this.scopes){for(n=0,s=this.scopes.length;n<s;n++)this.scopes[n].stop(!0);this.scopes.length=0}if(!this.detached&&this.parent&&!t){const r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0}}}function Ub(){return an}function rM(e,t=!1){an&&an.cleanups.push(e)}let Se;const Fc=new WeakSet;class Gb{constructor(t){this.fn=t,this.deps=void 0,this.depsTail=void 0,this.flags=5,this.next=void 0,this.cleanup=void 0,this.scheduler=void 0,an&&an.active&&an.effects.push(this)}pause(){this.flags|=64}resume(){this.flags&64&&(this.flags&=-65,Fc.has(this)&&(Fc.delete(this),this.trigger()))}notify(){this.flags&2&&!(this.flags&32)||this.flags&8||Yb(this)}run(){if(!(this.flags&1))return this.fn();this.flags|=2,pp(this),Jb(this);const t=Se,n=Jn;Se=this,Jn=!0;try{return this.fn()}finally{Zb(this),Se=t,Jn=n,this.flags&=-3}}stop(){if(this.flags&1){for(let t=this.deps;t;t=t.nextDep)Th(t);this.deps=this.depsTail=void 0,pp(this),this.onStop&&this.onStop(),this.flags&=-2}}trigger(){this.flags&64?Fc.add(this):this.scheduler?this.scheduler():this.runIfDirty()}runIfDirty(){Il(this)&&this.run()}get dirty(){return Il(this)}}let Xb=0,fo,ho;function Yb(e,t=!1){if(e.flags|=8,t){e.next=ho,ho=e;return}e.next=fo,fo=e}function Nh(){Xb++}function _h(){if(--Xb>0)return;if(ho){let t=ho;for(ho=void 0;t;){const n=t.next;t.next=void 0,t.flags&=-9,t=n}}let e;for(;fo;){let t=fo;for(fo=void 0;t;){const n=t.next;if(t.next=void 0,t.flags&=-9,t.flags&1)try{t.trigger()}catch(s){e||(e=s)}t=n}}if(e)throw e}function Jb(e){for(let t=e.deps;t;t=t.nextDep)t.version=-1,t.prevActiveLink=t.dep.activeLink,t.dep.activeLink=t}function Zb(e){let t,n=e.depsTail,s=n;for(;s;){const r=s.prevDep;s.version===-1?(s===n&&(n=r),Th(s),aM(s)):t=s,s.dep.activeLink=s.prevActiveLink,s.prevActiveLink=void 0,s=r}e.deps=t,e.depsTail=n}function Il(e){for(let t=e.deps;t;t=t.nextDep)if(t.dep.version!==t.version||t.dep.computed&&(Qb(t.dep.computed)||t.dep.version!==t.version))return!0;return!!e._dirty}function Qb(e){if(e.flags&4&&!(e.flags&16)||(e.flags&=-17,e.globalVersion===Co)||(e.globalVersion=Co,!e.isSSR&&e.flags&128&&(!e.deps&&!e._dirty||!Il(e))))return;e.flags|=2;const t=e.dep,n=Se,s=Jn;Se=e,Jn=!0;try{Jb(e);const r=e.fn(e._value);(t.version===0||$n(r,e._value))&&(e.flags|=128,e._value=r,t.version++)}catch(r){throw t.version++,r}finally{Se=n,Jn=s,Zb(e),e.flags&=-3}}function Th(e,t=!1){const{dep:n,prevSub:s,nextSub:r}=e;if(s&&(s.nextSub=r,e.prevSub=void 0),r&&(r.prevSub=s,e.nextSub=void 0),n.subs===e&&(n.subs=s,!s&&n.computed)){n.computed.flags&=-5;for(let a=n.computed.deps;a;a=a.nextDep)Th(a,!0)}!t&&!--n.sc&&n.map&&n.map.delete(n.key)}function aM(e){const{prevDep:t,nextDep:n}=e;t&&(t.nextDep=n,e.prevDep=void 0),n&&(n.prevDep=t,e.nextDep=void 0)}let Jn=!0;const t0=[];function Vs(){t0.push(Jn),Jn=!1}function Ls(){const e=t0.pop();Jn=e===void 0?!0:e}function pp(e){const{cleanup:t}=e;if(e.cleanup=void 0,t){const n=Se;Se=void 0;try{t()}finally{Se=n}}}let Co=0;class oM{constructor(t,n){this.sub=t,this.dep=n,this.version=n.version,this.nextDep=this.prevDep=this.nextSub=this.prevSub=this.prevActiveLink=void 0}}class Du{constructor(t){this.computed=t,this.version=0,this.activeLink=void 0,this.subs=void 0,this.map=void 0,this.key=void 0,this.sc=0}track(t){if(!Se||!Jn||Se===this.computed)return;let n=this.activeLink;if(n===void 0||n.sub!==Se)n=this.activeLink=new oM(Se,this),Se.deps?(n.prevDep=Se.depsTail,Se.depsTail.nextDep=n,Se.depsTail=n):Se.deps=Se.depsTail=n,e0(n);else if(n.version===-1&&(n.version=this.version,n.nextDep)){const s=n.nextDep;s.prevDep=n.prevDep,n.prevDep&&(n.prevDep.nextDep=s),n.prevDep=Se.depsTail,n.nextDep=void 0,Se.depsTail.nextDep=n,Se.depsTail=n,Se.deps===n&&(Se.deps=s)}return n}trigger(t){this.version++,Co++,this.notify(t)}notify(t){Nh();try{for(let n=this.subs;n;n=n.prevSub)n.sub.notify()&&n.sub.dep.notify()}finally{_h()}}}function e0(e){if(e.dep.sc++,e.sub.flags&4){const t=e.dep.computed;if(t&&!e.dep.subs){t.flags|=20;for(let s=t.deps;s;s=s.nextDep)e0(s)}const n=e.dep.subs;n!==e&&(e.prevSub=n,n&&(n.nextSub=e)),e.dep.subs=e}}const Nl=new WeakMap,Mr=Symbol(""),_l=Symbol(""),Oo=Symbol("");function ln(e,t,n){if(Jn&&Se){let s=Nl.get(e);s||Nl.set(e,s=new Map);let r=s.get(n);r||(s.set(n,r=new Du),r.map=s,r.key=n),r.track()}}function $s(e,t,n,s,r,a){const o=Nl.get(e);if(!o){Co++;return}const i=u=>{u&&u.trigger()};if(Nh(),t==="clear")o.forEach(i);else{const u=Xt(e),c=u&&Ih(n);if(u&&n==="length"){const l=Number(s);o.forEach((f,d)=>{(d==="length"||d===Oo||!gs(d)&&d>=l)&&i(f)})}else switch((n!==void 0||o.has(void 0))&&i(o.get(n)),c&&i(o.get(Oo)),t){case"add":u?c&&i(o.get("length")):(i(o.get(Mr)),ba(e)&&i(o.get(_l)));break;case"delete":u||(i(o.get(Mr)),ba(e)&&i(o.get(_l)));break;case"set":ba(e)&&i(o.get(Mr));break}}_h()}function oa(e){const t=me(e);return t===e?t:(ln(t,"iterate",Oo),Hn(e)?t:t.map(Qe))}function Au(e){return ln(e=me(e),"iterate",Oo),e}const iM={__proto__:null,[Symbol.iterator](){return Rc(this,Symbol.iterator,Qe)},concat(...e){return oa(this).concat(...e.map(t=>Xt(t)?oa(t):t))},entries(){return Rc(this,"entries",e=>(e[1]=Qe(e[1]),e))},every(e,t){return Ss(this,"every",e,t,void 0,arguments)},filter(e,t){return Ss(this,"filter",e,t,n=>n.map(Qe),arguments)},find(e,t){return Ss(this,"find",e,t,Qe,arguments)},findIndex(e,t){return Ss(this,"findIndex",e,t,void 0,arguments)},findLast(e,t){return Ss(this,"findLast",e,t,Qe,arguments)},findLastIndex(e,t){return Ss(this,"findLastIndex",e,t,void 0,arguments)},forEach(e,t){return Ss(this,"forEach",e,t,void 0,arguments)},includes(...e){return Pc(this,"includes",e)},indexOf(...e){return Pc(this,"indexOf",e)},join(e){return oa(this).join(e)},lastIndexOf(...e){return Pc(this,"lastIndexOf",e)},map(e,t){return Ss(this,"map",e,t,void 0,arguments)},pop(){return Qa(this,"pop")},push(...e){return Qa(this,"push",e)},reduce(e,...t){return mp(this,"reduce",e,t)},reduceRight(e,...t){return mp(this,"reduceRight",e,t)},shift(){return Qa(this,"shift")},some(e,t){return Ss(this,"some",e,t,void 0,arguments)},splice(...e){return Qa(this,"splice",e)},toReversed(){return oa(this).toReversed()},toSorted(e){return oa(this).toSorted(e)},toSpliced(...e){return oa(this).toSpliced(...e)},unshift(...e){return Qa(this,"unshift",e)},values(){return Rc(this,"values",Qe)}};function Rc(e,t,n){const s=Au(e),r=s[t]();return s!==e&&!Hn(e)&&(r._next=r.next,r.next=()=>{const a=r._next();return a.value&&(a.value=n(a.value)),a}),r}const uM=Array.prototype;function Ss(e,t,n,s,r,a){const o=Au(e),i=o!==e&&!Hn(e),u=o[t];if(u!==uM[t]){const f=u.apply(e,a);return i?Qe(f):f}let c=n;o!==e&&(i?c=function(f,d){return n.call(this,Qe(f),d,e)}:n.length>2&&(c=function(f,d){return n.call(this,f,d,e)}));const l=u.call(o,c,s);return i&&r?r(l):l}function mp(e,t,n,s){const r=Au(e);let a=n;return r!==e&&(Hn(e)?n.length>3&&(a=function(o,i,u){return n.call(this,o,i,u,e)}):a=function(o,i,u){return n.call(this,o,Qe(i),u,e)}),r[t](a,...s)}function Pc(e,t,n){const s=me(e);ln(s,"iterate",Oo);const r=s[t](...n);return(r===-1||r===!1)&&Oh(n[0])?(n[0]=me(n[0]),s[t](...n)):r}function Qa(e,t,n=[]){Vs(),Nh();const s=me(e)[t].apply(e,n);return _h(),Ls(),s}const cM=kh("__proto__,__v_isRef,__isVue"),n0=new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e!=="arguments"&&e!=="caller").map(e=>Symbol[e]).filter(gs));function lM(e){gs(e)||(e=String(e));const t=me(this);return ln(t,"has",e),t.hasOwnProperty(e)}class s0{constructor(t=!1,n=!1){this._isReadonly=t,this._isShallow=n}get(t,n,s){if(n==="__v_skip")return t.__v_skip;const r=this._isReadonly,a=this._isShallow;if(n==="__v_isReactive")return!r;if(n==="__v_isReadonly")return r;if(n==="__v_isShallow")return a;if(n==="__v_raw")return s===(r?a?vM:i0:a?o0:a0).get(t)||Object.getPrototypeOf(t)===Object.getPrototypeOf(s)?t:void 0;const o=Xt(t);if(!r){let u;if(o&&(u=iM[n]))return u;if(n==="hasOwnProperty")return lM}const i=Reflect.get(t,n,pn(t)?t:s);return(gs(n)?n0.has(n):cM(n))||(r||ln(t,"get",n),a)?i:pn(i)?o&&Ih(n)?i:i.value:Ee(i)?r?u0(i):$h(i):i}}class r0 extends s0{constructor(t=!1){super(!1,t)}set(t,n,s,r){let a=t[n];if(!this._isShallow){const u=fr(a);if(!Hn(s)&&!fr(s)&&(a=me(a),s=me(s)),!Xt(t)&&pn(a)&&!pn(s))return u?!1:(a.value=s,!0)}const o=Xt(t)&&Ih(n)?Number(n)<t.length:ge(t,n),i=Reflect.set(t,n,s,pn(t)?t:r);return t===me(r)&&(o?$n(s,a)&&$s(t,"set",n,s):$s(t,"add",n,s)),i}deleteProperty(t,n){const s=ge(t,n);t[n];const r=Reflect.deleteProperty(t,n);return r&&s&&$s(t,"delete",n,void 0),r}has(t,n){const s=Reflect.has(t,n);return(!gs(n)||!n0.has(n))&&ln(t,"has",n),s}ownKeys(t){return ln(t,"iterate",Xt(t)?"length":Mr),Reflect.ownKeys(t)}}class fM extends s0{constructor(t=!1){super(!0,t)}set(t,n){return!0}deleteProperty(t,n){return!0}}const hM=new r0,dM=new fM,pM=new r0(!0);const Tl=e=>e,bi=e=>Reflect.getPrototypeOf(e);function mM(e,t,n){return function(...s){const r=this.__v_raw,a=me(r),o=ba(a),i=e==="entries"||e===Symbol.iterator&&o,u=e==="keys"&&o,c=r[e](...s),l=n?Tl:t?eu:Qe;return!t&&ln(a,"iterate",u?_l:Mr),{next(){const{value:f,done:d}=c.next();return d?{value:f,done:d}:{value:i?[l(f[0]),l(f[1])]:l(f),done:d}},[Symbol.iterator](){return this}}}}function wi(e){return function(...t){return e==="delete"?!1:e==="clear"?void 0:this}}function gM(e,t){const n={get(r){const a=this.__v_raw,o=me(a),i=me(r);e||($n(r,i)&&ln(o,"get",r),ln(o,"get",i));const{has:u}=bi(o),c=t?Tl:e?eu:Qe;if(u.call(o,r))return c(a.get(r));if(u.call(o,i))return c(a.get(i));a!==o&&a.get(r)},get size(){const r=this.__v_raw;return!e&&ln(me(r),"iterate",Mr),Reflect.get(r,"size",r)},has(r){const a=this.__v_raw,o=me(a),i=me(r);return e||($n(r,i)&&ln(o,"has",r),ln(o,"has",i)),r===i?a.has(r):a.has(r)||a.has(i)},forEach(r,a){const o=this,i=o.__v_raw,u=me(i),c=t?Tl:e?eu:Qe;return!e&&ln(u,"iterate",Mr),i.forEach((l,f)=>r.call(a,c(l),c(f),o))}};return en(n,e?{add:wi("add"),set:wi("set"),delete:wi("delete"),clear:wi("clear")}:{add(r){!t&&!Hn(r)&&!fr(r)&&(r=me(r));const a=me(this);return bi(a).has.call(a,r)||(a.add(r),$s(a,"add",r,r)),this},set(r,a){!t&&!Hn(a)&&!fr(a)&&(a=me(a));const o=me(this),{has:i,get:u}=bi(o);let c=i.call(o,r);c||(r=me(r),c=i.call(o,r));const l=u.call(o,r);return o.set(r,a),c?$n(a,l)&&$s(o,"set",r,a):$s(o,"add",r,a),this},delete(r){const a=me(this),{has:o,get:i}=bi(a);let u=o.call(a,r);u||(r=me(r),u=o.call(a,r)),i&&i.call(a,r);const c=a.delete(r);return u&&$s(a,"delete",r,void 0),c},clear(){const r=me(this),a=r.size!==0,o=r.clear();return a&&$s(r,"clear",void 0,void 0),o}}),["keys","values","entries",Symbol.iterator].forEach(r=>{n[r]=mM(r,e,t)}),n}function Eh(e,t){const n=gM(e,t);return(s,r,a)=>r==="__v_isReactive"?!e:r==="__v_isReadonly"?e:r==="__v_raw"?s:Reflect.get(ge(n,r)&&r in s?n:s,r,a)}const yM={get:Eh(!1,!1)},bM={get:Eh(!1,!0)},wM={get:Eh(!0,!1)};const a0=new WeakMap,o0=new WeakMap,i0=new WeakMap,vM=new WeakMap;function kM(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function xM(e){return e.__v_skip||!Object.isExtensible(e)?0:kM(UP(e))}function $h(e){return fr(e)?e:Ch(e,!1,hM,yM,a0)}function SM(e){return Ch(e,!1,pM,bM,o0)}function u0(e){return Ch(e,!0,dM,wM,i0)}function Ch(e,t,n,s,r){if(!Ee(e)||e.__v_raw&&!(t&&e.__v_isReactive))return e;const a=xM(e);if(a===0)return e;const o=r.get(e);if(o)return o;const i=new Proxy(e,a===2?s:n);return r.set(e,i),i}function wa(e){return fr(e)?wa(e.__v_raw):!!(e&&e.__v_isReactive)}function fr(e){return!!(e&&e.__v_isReadonly)}function Hn(e){return!!(e&&e.__v_isShallow)}function Oh(e){return e?!!e.__v_raw:!1}function me(e){const t=e&&e.__v_raw;return t?me(t):e}function IM(e){return!ge(e,"__v_skip")&&Object.isExtensible(e)&&Wb(e,"__v_skip",!0),e}const Qe=e=>Ee(e)?$h(e):e,eu=e=>Ee(e)?u0(e):e;function pn(e){return e?e.__v_isRef===!0:!1}function Ie(e){return c0(e,!1)}function nu(e){return c0(e,!0)}function c0(e,t){return pn(e)?e:new NM(e,t)}class NM{constructor(t,n){this.dep=new Du,this.__v_isRef=!0,this.__v_isShallow=!1,this._rawValue=n?t:me(t),this._value=n?t:Qe(t),this.__v_isShallow=n}get value(){return this.dep.track(),this._value}set value(t){const n=this._rawValue,s=this.__v_isShallow||Hn(t)||fr(t);t=s?t:me(t),$n(t,n)&&(this._rawValue=t,this._value=s?t:Qe(t),this.dep.trigger())}}function On(e){return pn(e)?e.value:e}function va(e){return ee(e)?e():On(e)}const _M={get:(e,t,n)=>t==="__v_raw"?e:On(Reflect.get(e,t,n)),set:(e,t,n,s)=>{const r=e[t];return pn(r)&&!pn(n)?(r.value=n,!0):Reflect.set(e,t,n,s)}};function l0(e){return wa(e)?e:new Proxy(e,_M)}class TM{constructor(t){this.__v_isRef=!0,this._value=void 0;const n=this.dep=new Du,{get:s,set:r}=t(n.track.bind(n),n.trigger.bind(n));this._get=s,this._set=r}get value(){return this._value=this._get()}set value(t){this._set(t)}}function EM(e){return new TM(e)}class $M{constructor(t,n,s){this.fn=t,this.setter=n,this._value=void 0,this.dep=new Du(this),this.__v_isRef=!0,this.deps=void 0,this.depsTail=void 0,this.flags=16,this.globalVersion=Co-1,this.next=void 0,this.effect=this,this.__v_isReadonly=!n,this.isSSR=s}notify(){if(this.flags|=16,!(this.flags&8)&&Se!==this)return Yb(this,!0),!0}get value(){const t=this.dep.track();return Qb(this),t&&(t.version=this.dep.version),this._value}set value(t){this.setter&&this.setter(t)}}function CM(e,t,n=!1){let s,r;return ee(e)?s=e:(s=e.get,r=e.set),new $M(s,r,n)}const vi={},su=new WeakMap;let $r;function OM(e,t=!1,n=$r){if(n){let s=su.get(n);s||su.set(n,s=[]),s.push(e)}}function DM(e,t,n=pe){const{immediate:s,deep:r,once:a,scheduler:o,augmentJob:i,call:u}=n,c=I=>r?I:Hn(I)||r===!1||r===0?Cs(I,1):Cs(I);let l,f,d,m,g=!1,b=!1;if(pn(e)?(f=()=>e.value,g=Hn(e)):wa(e)?(f=()=>c(e),g=!0):Xt(e)?(b=!0,g=e.some(I=>wa(I)||Hn(I)),f=()=>e.map(I=>{if(pn(I))return I.value;if(wa(I))return c(I);if(ee(I))return u?u(I,2):I()})):ee(e)?t?f=u?()=>u(e,2):e:f=()=>{if(d){Vs();try{d()}finally{Ls()}}const I=$r;$r=l;try{return u?u(e,3,[m]):e(m)}finally{$r=I}}:f=ds,t&&r){const I=f,$=r===!0?1/0:r;f=()=>Cs(I(),$)}const w=Ub(),k=()=>{l.stop(),w&&w.active&&Sh(w.effects,l)};if(a&&t){const I=t;t=(...$)=>{I(...$),k()}}let N=b?new Array(e.length).fill(vi):vi;const _=I=>{if(!(!(l.flags&1)||!l.dirty&&!I))if(t){const $=l.run();if(r||g||(b?$.some((O,R)=>$n(O,N[R])):$n($,N))){d&&d();const O=$r;$r=l;try{const R=[$,N===vi?void 0:b&&N[0]===vi?[]:N,m];N=$,u?u(t,3,R):t(...R)}finally{$r=O}}}else l.run()};return i&&i(_),l=new Gb(f),l.scheduler=o?()=>o(_,!1):_,m=I=>OM(I,!1,l),d=l.onStop=()=>{const I=su.get(l);if(I){if(u)u(I,4);else for(const $ of I)$();su.delete(l)}},t?s?_(!0):N=l.run():o?o(_.bind(null,!0),!0):l.run(),k.pause=l.pause.bind(l),k.resume=l.resume.bind(l),k.stop=k,k}function Cs(e,t=1/0,n){if(t<=0||!Ee(e)||e.__v_skip||(n=n||new Set,n.has(e)))return e;if(n.add(e),t--,pn(e))Cs(e.value,t,n);else if(Xt(e))for(let s=0;s<e.length;s++)Cs(e[s],t,n);else if($u(e)||ba(e))e.forEach(s=>{Cs(s,t,n)});else if(zb(e)){for(const s in e)Cs(e[s],t,n);for(const s of Object.getOwnPropertySymbols(e))Object.prototype.propertyIsEnumerable.call(e,s)&&Cs(e[s],t,n)}return e}/**
* @vue/runtime-core v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function Wo(e,t,n,s){try{return s?e(...s):e()}catch(r){Fu(r,t,n)}}function ys(e,t,n,s){if(ee(e)){const r=Wo(e,t,n,s);return r&&Vb(r)&&r.catch(a=>{Fu(a,t,n)}),r}if(Xt(e)){const r=[];for(let a=0;a<e.length;a++)r.push(ys(e[a],t,n,s));return r}}function Fu(e,t,n,s=!0){const r=t?t.vnode:null,{errorHandler:a,throwUnhandledErrorInProduction:o}=t&&t.appContext.config||pe;if(t){let i=t.parent;const u=t.proxy,c=`https://vuejs.org/error-reference/#runtime-${n}`;for(;i;){const l=i.ec;if(l){for(let f=0;f<l.length;f++)if(l[f](e,u,c)===!1)return}i=i.parent}if(a){Vs(),Wo(a,null,10,[e,u,c]),Ls();return}}AM(e,n,r,s,o)}function AM(e,t,n,s=!0,r=!1){if(r)throw e;console.error(e)}const vn=[];let as=-1;const ka=[];let Qs=null,fa=0;const f0=Promise.resolve();let ru=null;function Ru(e){const t=ru||f0;return e?t.then(this?e.bind(this):e):t}function FM(e){let t=as+1,n=vn.length;for(;t<n;){const s=t+n>>>1,r=vn[s],a=Do(r);a<e||a===e&&r.flags&2?t=s+1:n=s}return t}function Dh(e){if(!(e.flags&1)){const t=Do(e),n=vn[vn.length-1];!n||!(e.flags&2)&&t>=Do(n)?vn.push(e):vn.splice(FM(t),0,e),e.flags|=1,h0()}}function h0(){ru||(ru=f0.then(p0))}function RM(e){Xt(e)?ka.push(...e):Qs&&e.id===-1?Qs.splice(fa+1,0,e):e.flags&1||(ka.push(e),e.flags|=1),h0()}function gp(e,t,n=as+1){for(;n<vn.length;n++){const s=vn[n];if(s&&s.flags&2){if(e&&s.id!==e.uid)continue;vn.splice(n,1),n--,s.flags&4&&(s.flags&=-2),s(),s.flags&4||(s.flags&=-2)}}}function d0(e){if(ka.length){const t=[...new Set(ka)].sort((n,s)=>Do(n)-Do(s));if(ka.length=0,Qs){Qs.push(...t);return}for(Qs=t,fa=0;fa<Qs.length;fa++){const n=Qs[fa];n.flags&4&&(n.flags&=-2),n.flags&8||n(),n.flags&=-2}Qs=null,fa=0}}const Do=e=>e.id==null?e.flags&2?-1:1/0:e.id;function p0(e){try{for(as=0;as<vn.length;as++){const t=vn[as];t&&!(t.flags&8)&&(t.flags&4&&(t.flags&=-2),Wo(t,t.i,t.i?15:14),t.flags&4||(t.flags&=-2))}}finally{for(;as<vn.length;as++){const t=vn[as];t&&(t.flags&=-2)}as=-1,vn.length=0,d0(),ru=null,(vn.length||ka.length)&&p0()}}let Rn=null,m0=null;function au(e){const t=Rn;return Rn=e,m0=e&&e.type.__scopeId||null,t}function PM(e,t=Rn,n){if(!t||e._n)return e;const s=(...r)=>{s._d&&Tp(-1);const a=au(t);let o;try{o=e(...r)}finally{au(a),s._d&&Tp(1)}return o};return s._n=!0,s._c=!0,s._d=!0,s}function os(e,t){if(Rn===null)return e;const n=Wu(Rn),s=e.dirs||(e.dirs=[]);for(let r=0;r<t.length;r++){let[a,o,i,u=pe]=t[r];a&&(ee(a)&&(a={mounted:a,updated:a}),a.deep&&Cs(o),s.push({dir:a,instance:n,value:o,oldValue:void 0,arg:i,modifiers:u}))}return e}function _r(e,t,n,s){const r=e.dirs,a=t&&t.dirs;for(let o=0;o<r.length;o++){const i=r[o];a&&(i.oldValue=a[o].value);let u=i.dir[s];u&&(Vs(),ys(u,n,8,[e.el,i,e,t]),Ls())}}const g0=Symbol("_vte"),MM=e=>e.__isTeleport,po=e=>e&&(e.disabled||e.disabled===""),yp=e=>e&&(e.defer||e.defer===""),bp=e=>typeof SVGElement<"u"&&e instanceof SVGElement,wp=e=>typeof MathMLElement=="function"&&e instanceof MathMLElement,El=(e,t)=>{const n=e&&e.to;return Be(n)?t?t(n):null:n},y0={name:"Teleport",__isTeleport:!0,process(e,t,n,s,r,a,o,i,u,c){const{mc:l,pc:f,pbc:d,o:{insert:m,querySelector:g,createText:b,createComment:w}}=c,k=po(t.props);let{shapeFlag:N,children:_,dynamicChildren:I}=t;if(e==null){const $=t.el=b(""),O=t.anchor=b("");m($,n,s),m(O,n,s);const R=(P,M)=>{N&16&&(r&&r.isCE&&(r.ce._teleportTarget=P),l(_,P,M,r,a,o,i,u))},W=()=>{const P=t.target=El(t.props,g),M=b0(P,t,b,m);P&&(o!=="svg"&&bp(P)?o="svg":o!=="mathml"&&wp(P)&&(o="mathml"),k||(R(P,M),Ri(t,!1)))};k&&(R(n,O),Ri(t,!0)),yp(t.props)?(t.el.__isMounted=!1,wn(()=>{W(),delete t.el.__isMounted},a)):W()}else{if(yp(t.props)&&e.el.__isMounted===!1){wn(()=>{y0.process(e,t,n,s,r,a,o,i,u,c)},a);return}t.el=e.el,t.targetStart=e.targetStart;const $=t.anchor=e.anchor,O=t.target=e.target,R=t.targetAnchor=e.targetAnchor,W=po(e.props),P=W?n:O,M=W?$:R;if(o==="svg"||bp(O)?o="svg":(o==="mathml"||wp(O))&&(o="mathml"),I?(d(e.dynamicChildren,I,P,r,a,o,i),Ph(e,t,!0)):u||f(e,t,P,M,r,a,o,i,!1),k)W?t.props&&e.props&&t.props.to!==e.props.to&&(t.props.to=e.props.to):ki(t,n,$,c,1);else if((t.props&&t.props.to)!==(e.props&&e.props.to)){const T=t.target=El(t.props,g);T&&ki(t,T,null,c,0)}else W&&ki(t,O,R,c,1);Ri(t,k)}},remove(e,t,n,{um:s,o:{remove:r}},a){const{shapeFlag:o,children:i,anchor:u,targetStart:c,targetAnchor:l,target:f,props:d}=e;if(f&&(r(c),r(l)),a&&r(u),o&16){const m=a||!po(d);for(let g=0;g<i.length;g++){const b=i[g];s(b,t,n,m,!!b.dynamicChildren)}}},move:ki,hydrate:VM};function ki(e,t,n,{o:{insert:s},m:r},a=2){a===0&&s(e.targetAnchor,t,n);const{el:o,anchor:i,shapeFlag:u,children:c,props:l}=e,f=a===2;if(f&&s(o,t,n),(!f||po(l))&&u&16)for(let d=0;d<c.length;d++)r(c[d],t,n,2);f&&s(i,t,n)}function VM(e,t,n,s,r,a,{o:{nextSibling:o,parentNode:i,querySelector:u,insert:c,createText:l}},f){const d=t.target=El(t.props,u);if(d){const m=po(t.props),g=d._lpa||d.firstChild;if(t.shapeFlag&16)if(m)t.anchor=f(o(e),t,i(e),n,s,r,a),t.targetStart=g,t.targetAnchor=g&&o(g);else{t.anchor=o(e);let b=g;for(;b;){if(b&&b.nodeType===8){if(b.data==="teleport start anchor")t.targetStart=b;else if(b.data==="teleport anchor"){t.targetAnchor=b,d._lpa=t.targetAnchor&&o(t.targetAnchor);break}}b=o(b)}t.targetAnchor||b0(d,t,l,c),f(g&&o(g),t,d,n,s,r,a)}Ri(t,m)}return t.anchor&&o(t.anchor)}const LM=y0;function Ri(e,t){const n=e.ctx;if(n&&n.ut){let s,r;for(t?(s=e.el,r=e.anchor):(s=e.targetStart,r=e.targetAnchor);s&&s!==r;)s.nodeType===1&&s.setAttribute("data-v-owner",n.uid),s=s.nextSibling;n.ut()}}function b0(e,t,n,s){const r=t.targetStart=n(""),a=t.targetAnchor=n("");return r[g0]=a,e&&(s(r,e),s(a,e)),a}function Ah(e,t){e.shapeFlag&6&&e.component?(e.transition=t,Ah(e.component.subTree,t)):e.shapeFlag&128?(e.ssContent.transition=t.clone(e.ssContent),e.ssFallback.transition=t.clone(e.ssFallback)):e.transition=t}/*! #__NO_SIDE_EFFECTS__ */function Ws(e,t){return ee(e)?en({name:e.name},t,{setup:e}):e}function w0(e){e.ids=[e.ids[0]+e.ids[2]+++"-",0,0]}function ou(e,t,n,s,r=!1){if(Xt(e)){e.forEach((g,b)=>ou(g,t&&(Xt(t)?t[b]:t),n,s,r));return}if(mo(s)&&!r){s.shapeFlag&512&&s.type.__asyncResolved&&s.component.subTree.component&&ou(e,t,n,s.component.subTree);return}const a=s.shapeFlag&4?Wu(s.component):s.el,o=r?null:a,{i,r:u}=e,c=t&&t.r,l=i.refs===pe?i.refs={}:i.refs,f=i.setupState,d=me(f),m=f===pe?()=>!1:g=>ge(d,g);if(c!=null&&c!==u&&(Be(c)?(l[c]=null,m(c)&&(f[c]=null)):pn(c)&&(c.value=null)),ee(u))Wo(u,i,12,[o,l]);else{const g=Be(u),b=pn(u);if(g||b){const w=()=>{if(e.f){const k=g?m(u)?f[u]:l[u]:u.value;r?Xt(k)&&Sh(k,a):Xt(k)?k.includes(a)||k.push(a):g?(l[u]=[a],m(u)&&(f[u]=l[u])):(u.value=[a],e.k&&(l[e.k]=u.value))}else g?(l[u]=o,m(u)&&(f[u]=o)):b&&(u.value=o,e.k&&(l[e.k]=o))};o?(w.id=-1,wn(w,n)):w()}}}Ou().requestIdleCallback;Ou().cancelIdleCallback;const mo=e=>!!e.type.__asyncLoader,v0=e=>e.type.__isKeepAlive;function zM(e,t){k0(e,"a",t)}function BM(e,t){k0(e,"da",t)}function k0(e,t,n=hn){const s=e.__wdc||(e.__wdc=()=>{let r=n;for(;r;){if(r.isDeactivated)return;r=r.parent}return e()});if(Pu(t,s,n),n){let r=n.parent;for(;r&&r.parent;)v0(r.parent.vnode)&&WM(s,t,n,r),r=r.parent}}function WM(e,t,n,s){const r=Pu(t,e,s,!0);Mu(()=>{Sh(s[t],r)},n)}function Pu(e,t,n=hn,s=!1){if(n){const r=n[e]||(n[e]=[]),a=t.__weh||(t.__weh=(...o)=>{Vs();const i=qo(n),u=ys(t,n,e,o);return i(),Ls(),u});return s?r.unshift(a):r.push(a),a}}const js=e=>(t,n=hn)=>{(!Ro||e==="sp")&&Pu(e,(...s)=>t(...s),n)},jM=js("bm"),jo=js("m"),qM=js("bu"),HM=js("u"),KM=js("bum"),Mu=js("um"),UM=js("sp"),GM=js("rtg"),XM=js("rtc");function YM(e,t=hn){Pu("ec",e,t)}const JM=Symbol.for("v-ndc");function ps(e,t,n,s){let r;const a=n,o=Xt(e);if(o||Be(e)){const i=o&&wa(e);let u=!1,c=!1;i&&(u=!Hn(e),c=fr(e),e=Au(e)),r=new Array(e.length);for(let l=0,f=e.length;l<f;l++)r[l]=t(u?c?eu(Qe(e[l])):Qe(e[l]):e[l],l,void 0,a)}else if(typeof e=="number"){r=new Array(e);for(let i=0;i<e;i++)r[i]=t(i+1,i,void 0,a)}else if(Ee(e))if(e[Symbol.iterator])r=Array.from(e,(i,u)=>t(i,u,void 0,a));else{const i=Object.keys(e);r=new Array(i.length);for(let u=0,c=i.length;u<c;u++){const l=i[u];r[u]=t(e[l],l,u,a)}}else r=[];return r}const $l=e=>e?j0(e)?Wu(e):$l(e.parent):null,go=en(Object.create(null),{$:e=>e,$el:e=>e.vnode.el,$data:e=>e.data,$props:e=>e.props,$attrs:e=>e.attrs,$slots:e=>e.slots,$refs:e=>e.refs,$parent:e=>$l(e.parent),$root:e=>$l(e.root),$host:e=>e.ce,$emit:e=>e.emit,$options:e=>S0(e),$forceUpdate:e=>e.f||(e.f=()=>{Dh(e.update)}),$nextTick:e=>e.n||(e.n=Ru.bind(e.proxy)),$watch:e=>vV.bind(e)}),Mc=(e,t)=>e!==pe&&!e.__isScriptSetup&&ge(e,t),ZM={get({_:e},t){if(t==="__v_skip")return!0;const{ctx:n,setupState:s,data:r,props:a,accessCache:o,type:i,appContext:u}=e;let c;if(t[0]!=="$"){const m=o[t];if(m!==void 0)switch(m){case 1:return s[t];case 2:return r[t];case 4:return n[t];case 3:return a[t]}else{if(Mc(s,t))return o[t]=1,s[t];if(r!==pe&&ge(r,t))return o[t]=2,r[t];if((c=e.propsOptions[0])&&ge(c,t))return o[t]=3,a[t];if(n!==pe&&ge(n,t))return o[t]=4,n[t];Ol&&(o[t]=0)}}const l=go[t];let f,d;if(l)return t==="$attrs"&&ln(e.attrs,"get",""),l(e);if((f=i.__cssModules)&&(f=f[t]))return f;if(n!==pe&&ge(n,t))return o[t]=4,n[t];if(d=u.config.globalProperties,ge(d,t))return d[t]},set({_:e},t,n){const{data:s,setupState:r,ctx:a}=e;return Mc(r,t)?(r[t]=n,!0):s!==pe&&ge(s,t)?(s[t]=n,!0):ge(e.props,t)||t[0]==="$"&&t.slice(1)in e?!1:(a[t]=n,!0)},has({_:{data:e,setupState:t,accessCache:n,ctx:s,appContext:r,propsOptions:a}},o){let i;return!!n[o]||e!==pe&&ge(e,o)||Mc(t,o)||(i=a[0])&&ge(i,o)||ge(s,o)||ge(go,o)||ge(r.config.globalProperties,o)},defineProperty(e,t,n){return n.get!=null?e._.accessCache[t]=0:ge(n,"value")&&this.set(e,t,n.value,null),Reflect.defineProperty(e,t,n)}};function iu(e){return Xt(e)?e.reduce((t,n)=>(t[n]=null,t),{}):e}function Cl(e,t){return!e||!t?e||t:Xt(e)&&Xt(t)?e.concat(t):en({},iu(e),iu(t))}let Ol=!0;function QM(e){const t=S0(e),n=e.proxy,s=e.ctx;Ol=!1,t.beforeCreate&&vp(t.beforeCreate,e,"bc");const{data:r,computed:a,methods:o,watch:i,provide:u,inject:c,created:l,beforeMount:f,mounted:d,beforeUpdate:m,updated:g,activated:b,deactivated:w,beforeDestroy:k,beforeUnmount:N,destroyed:_,unmounted:I,render:$,renderTracked:O,renderTriggered:R,errorCaptured:W,serverPrefetch:P,expose:M,inheritAttrs:T,components:q,directives:X,filters:st}=t;if(c&&tV(c,s,null),o)for(const ot in o){const tt=o[ot];ee(tt)&&(s[ot]=tt.bind(n))}if(r){const ot=r.call(n,n);Ee(ot)&&(e.data=$h(ot))}if(Ol=!0,a)for(const ot in a){const tt=a[ot],ct=ee(tt)?tt.bind(n,n):ee(tt.get)?tt.get.bind(n,n):ds,ht=!ee(tt)&&ee(tt.set)?tt.set.bind(n):ds,gt=xn({get:ct,set:ht});Object.defineProperty(s,ot,{enumerable:!0,configurable:!0,get:()=>gt.value,set:wt=>gt.value=wt})}if(i)for(const ot in i)x0(i[ot],s,n,ot);if(u){const ot=ee(u)?u.call(n):u;Reflect.ownKeys(ot).forEach(tt=>{oV(tt,ot[tt])})}l&&vp(l,e,"c");function nt(ot,tt){Xt(tt)?tt.forEach(ct=>ot(ct.bind(n))):tt&&ot(tt.bind(n))}if(nt(jM,f),nt(jo,d),nt(qM,m),nt(HM,g),nt(zM,b),nt(BM,w),nt(YM,W),nt(XM,O),nt(GM,R),nt(KM,N),nt(Mu,I),nt(UM,P),Xt(M))if(M.length){const ot=e.exposed||(e.exposed={});M.forEach(tt=>{Object.defineProperty(ot,tt,{get:()=>n[tt],set:ct=>n[tt]=ct})})}else e.exposed||(e.exposed={});$&&e.render===ds&&(e.render=$),T!=null&&(e.inheritAttrs=T),q&&(e.components=q),X&&(e.directives=X),P&&w0(e)}function tV(e,t,n=ds){Xt(e)&&(e=Dl(e));for(const s in e){const r=e[s];let a;Ee(r)?"default"in r?a=Pi(r.from||s,r.default,!0):a=Pi(r.from||s):a=Pi(r),pn(a)?Object.defineProperty(t,s,{enumerable:!0,configurable:!0,get:()=>a.value,set:o=>a.value=o}):t[s]=a}}function vp(e,t,n){ys(Xt(e)?e.map(s=>s.bind(t.proxy)):e.bind(t.proxy),t,n)}function x0(e,t,n,s){let r=s.includes(".")?F0(n,s):()=>n[s];if(Be(e)){const a=t[e];ee(a)&&Ds(r,a)}else if(ee(e))Ds(r,e.bind(n));else if(Ee(e))if(Xt(e))e.forEach(a=>x0(a,t,n,s));else{const a=ee(e.handler)?e.handler.bind(n):t[e.handler];ee(a)&&Ds(r,a,e)}}function S0(e){const t=e.type,{mixins:n,extends:s}=t,{mixins:r,optionsCache:a,config:{optionMergeStrategies:o}}=e.appContext,i=a.get(t);let u;return i?u=i:!r.length&&!n&&!s?u=t:(u={},r.length&&r.forEach(c=>uu(u,c,o,!0)),uu(u,t,o)),Ee(t)&&a.set(t,u),u}function uu(e,t,n,s=!1){const{mixins:r,extends:a}=t;a&&uu(e,a,n,!0),r&&r.forEach(o=>uu(e,o,n,!0));for(const o in t)if(!(s&&o==="expose")){const i=eV[o]||n&&n[o];e[o]=i?i(e[o],t[o]):t[o]}return e}const eV={data:kp,props:xp,emits:xp,methods:oo,computed:oo,beforeCreate:bn,created:bn,beforeMount:bn,mounted:bn,beforeUpdate:bn,updated:bn,beforeDestroy:bn,beforeUnmount:bn,destroyed:bn,unmounted:bn,activated:bn,deactivated:bn,errorCaptured:bn,serverPrefetch:bn,components:oo,directives:oo,watch:sV,provide:kp,inject:nV};function kp(e,t){return t?e?function(){return en(ee(e)?e.call(this,this):e,ee(t)?t.call(this,this):t)}:t:e}function nV(e,t){return oo(Dl(e),Dl(t))}function Dl(e){if(Xt(e)){const t={};for(let n=0;n<e.length;n++)t[e[n]]=e[n];return t}return e}function bn(e,t){return e?[...new Set([].concat(e,t))]:t}function oo(e,t){return e?en(Object.create(null),e,t):t}function xp(e,t){return e?Xt(e)&&Xt(t)?[...new Set([...e,...t])]:en(Object.create(null),iu(e),iu(t??{})):t}function sV(e,t){if(!e)return t;if(!t)return e;const n=en(Object.create(null),e);for(const s in t)n[s]=bn(e[s],t[s]);return n}function I0(){return{app:null,config:{isNativeTag:HP,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let rV=0;function aV(e,t){return function(s,r=null){ee(s)||(s=en({},s)),r!=null&&!Ee(r)&&(r=null);const a=I0(),o=new WeakSet,i=[];let u=!1;const c=a.app={_uid:rV++,_component:s,_props:r,_container:null,_context:a,_instance:null,version:VV,get config(){return a.config},set config(l){},use(l,...f){return o.has(l)||(l&&ee(l.install)?(o.add(l),l.install(c,...f)):ee(l)&&(o.add(l),l(c,...f))),c},mixin(l){return a.mixins.includes(l)||a.mixins.push(l),c},component(l,f){return f?(a.components[l]=f,c):a.components[l]},directive(l,f){return f?(a.directives[l]=f,c):a.directives[l]},mount(l,f,d){if(!u){const m=c._ceVNode||Kn(s,r);return m.appContext=a,d===!0?d="svg":d===!1&&(d=void 0),e(m,l,d),u=!0,c._container=l,l.__vue_app__=c,Wu(m.component)}},onUnmount(l){i.push(l)},unmount(){u&&(ys(i,c._instance,16),e(null,c._container),delete c._container.__vue_app__)},provide(l,f){return a.provides[l]=f,c},runWithContext(l){const f=xa;xa=c;try{return l()}finally{xa=f}}};return c}}let xa=null;function oV(e,t){if(hn){let n=hn.provides;const s=hn.parent&&hn.parent.provides;s===n&&(n=hn.provides=Object.create(s)),n[e]=t}}function Pi(e,t,n=!1){const s=hn||Rn;if(s||xa){let r=xa?xa._context.provides:s?s.parent==null||s.ce?s.vnode.appContext&&s.vnode.appContext.provides:s.parent.provides:void 0;if(r&&e in r)return r[e];if(arguments.length>1)return n&&ee(t)?t.call(s&&s.proxy):t}}const N0={},_0=()=>Object.create(N0),T0=e=>Object.getPrototypeOf(e)===N0;function iV(e,t,n,s=!1){const r={},a=_0();e.propsDefaults=Object.create(null),E0(e,t,r,a);for(const o in e.propsOptions[0])o in r||(r[o]=void 0);n?e.props=s?r:SM(r):e.type.props?e.props=r:e.props=a,e.attrs=a}function uV(e,t,n,s){const{props:r,attrs:a,vnode:{patchFlag:o}}=e,i=me(r),[u]=e.propsOptions;let c=!1;if((s||o>0)&&!(o&16)){if(o&8){const l=e.vnode.dynamicProps;for(let f=0;f<l.length;f++){let d=l[f];if(zu(e.emitsOptions,d))continue;const m=t[d];if(u)if(ge(a,d))m!==a[d]&&(a[d]=m,c=!0);else{const g=Ms(d);r[g]=Al(u,i,g,m,e,!1)}else m!==a[d]&&(a[d]=m,c=!0)}}}else{E0(e,t,r,a)&&(c=!0);let l;for(const f in i)(!t||!ge(t,f)&&((l=yr(f))===f||!ge(t,l)))&&(u?n&&(n[f]!==void 0||n[l]!==void 0)&&(r[f]=Al(u,i,f,void 0,e,!0)):delete r[f]);if(a!==i)for(const f in a)(!t||!ge(t,f))&&(delete a[f],c=!0)}c&&$s(e.attrs,"set","")}function E0(e,t,n,s){const[r,a]=e.propsOptions;let o=!1,i;if(t)for(let u in t){if(lo(u))continue;const c=t[u];let l;r&&ge(r,l=Ms(u))?!a||!a.includes(l)?n[l]=c:(i||(i={}))[l]=c:zu(e.emitsOptions,u)||(!(u in s)||c!==s[u])&&(s[u]=c,o=!0)}if(a){const u=me(n),c=i||pe;for(let l=0;l<a.length;l++){const f=a[l];n[f]=Al(r,u,f,c[f],e,!ge(c,f))}}return o}function Al(e,t,n,s,r,a){const o=e[n];if(o!=null){const i=ge(o,"default");if(i&&s===void 0){const u=o.default;if(o.type!==Function&&!o.skipFactory&&ee(u)){const{propsDefaults:c}=r;if(n in c)s=c[n];else{const l=qo(r);s=c[n]=u.call(null,t),l()}}else s=u;r.ce&&r.ce._setProp(n,s)}o[0]&&(a&&!i?s=!1:o[1]&&(s===""||s===yr(n))&&(s=!0))}return s}const cV=new WeakMap;function $0(e,t,n=!1){const s=n?cV:t.propsCache,r=s.get(e);if(r)return r;const a=e.props,o={},i=[];let u=!1;if(!ee(e)){const l=f=>{u=!0;const[d,m]=$0(f,t,!0);en(o,d),m&&i.push(...m)};!n&&t.mixins.length&&t.mixins.forEach(l),e.extends&&l(e.extends),e.mixins&&e.mixins.forEach(l)}if(!a&&!u)return Ee(e)&&s.set(e,ya),ya;if(Xt(a))for(let l=0;l<a.length;l++){const f=Ms(a[l]);Sp(f)&&(o[f]=pe)}else if(a)for(const l in a){const f=Ms(l);if(Sp(f)){const d=a[l],m=o[f]=Xt(d)||ee(d)?{type:d}:en({},d),g=m.type;let b=!1,w=!0;if(Xt(g))for(let k=0;k<g.length;++k){const N=g[k],_=ee(N)&&N.name;if(_==="Boolean"){b=!0;break}else _==="String"&&(w=!1)}else b=ee(g)&&g.name==="Boolean";m[0]=b,m[1]=w,(b||ge(m,"default"))&&i.push(f)}}const c=[o,i];return Ee(e)&&s.set(e,c),c}function Sp(e){return e[0]!=="$"&&!lo(e)}const Fh=e=>e[0]==="_"||e==="$stable",Rh=e=>Xt(e)?e.map(us):[us(e)],lV=(e,t,n)=>{if(t._n)return t;const s=PM((...r)=>Rh(t(...r)),n);return s._c=!1,s},C0=(e,t,n)=>{const s=e._ctx;for(const r in e){if(Fh(r))continue;const a=e[r];if(ee(a))t[r]=lV(r,a,s);else if(a!=null){const o=Rh(a);t[r]=()=>o}}},O0=(e,t)=>{const n=Rh(t);e.slots.default=()=>n},D0=(e,t,n)=>{for(const s in t)(n||!Fh(s))&&(e[s]=t[s])},fV=(e,t,n)=>{const s=e.slots=_0();if(e.vnode.shapeFlag&32){const r=t._;r?(D0(s,t,n),n&&Wb(s,"_",r,!0)):C0(t,s)}else t&&O0(e,t)},hV=(e,t,n)=>{const{vnode:s,slots:r}=e;let a=!0,o=pe;if(s.shapeFlag&32){const i=t._;i?n&&i===1?a=!1:D0(r,t,n):(a=!t.$stable,C0(t,r)),o=t}else t&&(O0(e,t),o={default:1});if(a)for(const i in r)!Fh(i)&&o[i]==null&&delete r[i]},wn=_V;function dV(e){return pV(e)}function pV(e,t){const n=Ou();n.__VUE__=!0;const{insert:s,remove:r,patchProp:a,createElement:o,createText:i,createComment:u,setText:c,setElementText:l,parentNode:f,nextSibling:d,setScopeId:m=ds,insertStaticContent:g}=e,b=(F,z,at,ft=null,lt=null,dt=null,xt=void 0,Tt=null,kt=!!z.dynamicChildren)=>{if(F===z)return;F&&!to(F,z)&&(ft=Bt(F),wt(F,lt,dt,!0),F=null),z.patchFlag===-2&&(kt=!1,z.dynamicChildren=null);const{type:yt,ref:Vt,shapeFlag:$t}=z;switch(yt){case Bu:w(F,z,at,ft);break;case hr:k(F,z,at,ft);break;case Lc:F==null&&N(z,at,ft,xt);break;case De:q(F,z,at,ft,lt,dt,xt,Tt,kt);break;default:$t&1?$(F,z,at,ft,lt,dt,xt,Tt,kt):$t&6?X(F,z,at,ft,lt,dt,xt,Tt,kt):($t&64||$t&128)&&yt.process(F,z,at,ft,lt,dt,xt,Tt,kt,Ut)}Vt!=null&&lt&&ou(Vt,F&&F.ref,dt,z||F,!z)},w=(F,z,at,ft)=>{if(F==null)s(z.el=i(z.children),at,ft);else{const lt=z.el=F.el;z.children!==F.children&&c(lt,z.children)}},k=(F,z,at,ft)=>{F==null?s(z.el=u(z.children||""),at,ft):z.el=F.el},N=(F,z,at,ft)=>{[F.el,F.anchor]=g(F.children,z,at,ft,F.el,F.anchor)},_=({el:F,anchor:z},at,ft)=>{let lt;for(;F&&F!==z;)lt=d(F),s(F,at,ft),F=lt;s(z,at,ft)},I=({el:F,anchor:z})=>{let at;for(;F&&F!==z;)at=d(F),r(F),F=at;r(z)},$=(F,z,at,ft,lt,dt,xt,Tt,kt)=>{z.type==="svg"?xt="svg":z.type==="math"&&(xt="mathml"),F==null?O(z,at,ft,lt,dt,xt,Tt,kt):P(F,z,lt,dt,xt,Tt,kt)},O=(F,z,at,ft,lt,dt,xt,Tt)=>{let kt,yt;const{props:Vt,shapeFlag:$t,transition:Lt,dirs:qt}=F;if(kt=F.el=o(F.type,dt,Vt&&Vt.is,Vt),$t&8?l(kt,F.children):$t&16&&W(F.children,kt,null,ft,lt,Vc(F,dt),xt,Tt),qt&&_r(F,null,ft,"created"),R(kt,F,F.scopeId,xt,ft),Vt){for(const Qt in Vt)Qt!=="value"&&!lo(Qt)&&a(kt,Qt,null,Vt[Qt],dt,ft);"value"in Vt&&a(kt,"value",null,Vt.value,dt),(yt=Vt.onVnodeBeforeMount)&&rs(yt,ft,F)}qt&&_r(F,null,ft,"beforeMount");const Gt=mV(lt,Lt);Gt&&Lt.beforeEnter(kt),s(kt,z,at),((yt=Vt&&Vt.onVnodeMounted)||Gt||qt)&&wn(()=>{yt&&rs(yt,ft,F),Gt&&Lt.enter(kt),qt&&_r(F,null,ft,"mounted")},lt)},R=(F,z,at,ft,lt)=>{if(at&&m(F,at),ft)for(let dt=0;dt<ft.length;dt++)m(F,ft[dt]);if(lt){let dt=lt.subTree;if(z===dt||V0(dt.type)&&(dt.ssContent===z||dt.ssFallback===z)){const xt=lt.vnode;R(F,xt,xt.scopeId,xt.slotScopeIds,lt.parent)}}},W=(F,z,at,ft,lt,dt,xt,Tt,kt=0)=>{for(let yt=kt;yt<F.length;yt++){const Vt=F[yt]=Tt?tr(F[yt]):us(F[yt]);b(null,Vt,z,at,ft,lt,dt,xt,Tt)}},P=(F,z,at,ft,lt,dt,xt)=>{const Tt=z.el=F.el;let{patchFlag:kt,dynamicChildren:yt,dirs:Vt}=z;kt|=F.patchFlag&16;const $t=F.props||pe,Lt=z.props||pe;let qt;if(at&&Tr(at,!1),(qt=Lt.onVnodeBeforeUpdate)&&rs(qt,at,z,F),Vt&&_r(z,F,at,"beforeUpdate"),at&&Tr(at,!0),($t.innerHTML&&Lt.innerHTML==null||$t.textContent&&Lt.textContent==null)&&l(Tt,""),yt?M(F.dynamicChildren,yt,Tt,at,ft,Vc(z,lt),dt):xt||tt(F,z,Tt,null,at,ft,Vc(z,lt),dt,!1),kt>0){if(kt&16)T(Tt,$t,Lt,at,lt);else if(kt&2&&$t.class!==Lt.class&&a(Tt,"class",null,Lt.class,lt),kt&4&&a(Tt,"style",$t.style,Lt.style,lt),kt&8){const Gt=z.dynamicProps;for(let Qt=0;Qt<Gt.length;Qt++){const ne=Gt[Qt],_e=$t[ne],Re=Lt[ne];(Re!==_e||ne==="value")&&a(Tt,ne,_e,Re,lt,at)}}kt&1&&F.children!==z.children&&l(Tt,z.children)}else!xt&&yt==null&&T(Tt,$t,Lt,at,lt);((qt=Lt.onVnodeUpdated)||Vt)&&wn(()=>{qt&&rs(qt,at,z,F),Vt&&_r(z,F,at,"updated")},ft)},M=(F,z,at,ft,lt,dt,xt)=>{for(let Tt=0;Tt<z.length;Tt++){const kt=F[Tt],yt=z[Tt],Vt=kt.el&&(kt.type===De||!to(kt,yt)||kt.shapeFlag&198)?f(kt.el):at;b(kt,yt,Vt,null,ft,lt,dt,xt,!0)}},T=(F,z,at,ft,lt)=>{if(z!==at){if(z!==pe)for(const dt in z)!lo(dt)&&!(dt in at)&&a(F,dt,z[dt],null,lt,ft);for(const dt in at){if(lo(dt))continue;const xt=at[dt],Tt=z[dt];xt!==Tt&&dt!=="value"&&a(F,dt,Tt,xt,lt,ft)}"value"in at&&a(F,"value",z.value,at.value,lt)}},q=(F,z,at,ft,lt,dt,xt,Tt,kt)=>{const yt=z.el=F?F.el:i(""),Vt=z.anchor=F?F.anchor:i("");let{patchFlag:$t,dynamicChildren:Lt,slotScopeIds:qt}=z;qt&&(Tt=Tt?Tt.concat(qt):qt),F==null?(s(yt,at,ft),s(Vt,at,ft),W(z.children||[],at,Vt,lt,dt,xt,Tt,kt)):$t>0&&$t&64&&Lt&&F.dynamicChildren?(M(F.dynamicChildren,Lt,at,lt,dt,xt,Tt),(z.key!=null||lt&&z===lt.subTree)&&Ph(F,z,!0)):tt(F,z,at,Vt,lt,dt,xt,Tt,kt)},X=(F,z,at,ft,lt,dt,xt,Tt,kt)=>{z.slotScopeIds=Tt,F==null?z.shapeFlag&512?lt.ctx.activate(z,at,ft,xt,kt):st(z,at,ft,lt,dt,xt,kt):et(F,z,kt)},st=(F,z,at,ft,lt,dt,xt)=>{const Tt=F.component=DV(F,ft,lt);if(v0(F)&&(Tt.ctx.renderer=Ut),AV(Tt,!1,xt),Tt.asyncDep){if(lt&&lt.registerDep(Tt,nt,xt),!F.el){const kt=Tt.subTree=Kn(hr);k(null,kt,z,at)}}else nt(Tt,F,z,at,lt,dt,xt)},et=(F,z,at)=>{const ft=z.component=F.component;if(IV(F,z,at))if(ft.asyncDep&&!ft.asyncResolved){ot(ft,z,at);return}else ft.next=z,ft.update();else z.el=F.el,ft.vnode=z},nt=(F,z,at,ft,lt,dt,xt)=>{const Tt=()=>{if(F.isMounted){let{next:$t,bu:Lt,u:qt,parent:Gt,vnode:Qt}=F;{const We=A0(F);if(We){$t&&($t.el=Qt.el,ot(F,$t,xt)),We.asyncDep.then(()=>{F.isUnmounted||Tt()});return}}let ne=$t,_e;Tr(F,!1),$t?($t.el=Qt.el,ot(F,$t,xt)):$t=Qt,Lt&&Fi(Lt),(_e=$t.props&&$t.props.onVnodeBeforeUpdate)&&rs(_e,Gt,$t,Qt),Tr(F,!0);const Re=Np(F),He=F.subTree;F.subTree=Re,b(He,Re,f(He.el),Bt(He),F,lt,dt),$t.el=Re.el,ne===null&&NV(F,Re.el),qt&&wn(qt,lt),(_e=$t.props&&$t.props.onVnodeUpdated)&&wn(()=>rs(_e,Gt,$t,Qt),lt)}else{let $t;const{el:Lt,props:qt}=z,{bm:Gt,m:Qt,parent:ne,root:_e,type:Re}=F,He=mo(z);Tr(F,!1),Gt&&Fi(Gt),!He&&($t=qt&&qt.onVnodeBeforeMount)&&rs($t,ne,z),Tr(F,!0);{_e.ce&&_e.ce._injectChildStyle(Re);const We=F.subTree=Np(F);b(null,We,at,ft,F,lt,dt),z.el=We.el}if(Qt&&wn(Qt,lt),!He&&($t=qt&&qt.onVnodeMounted)){const We=z;wn(()=>rs($t,ne,We),lt)}(z.shapeFlag&256||ne&&mo(ne.vnode)&&ne.vnode.shapeFlag&256)&&F.a&&wn(F.a,lt),F.isMounted=!0,z=at=ft=null}};F.scope.on();const kt=F.effect=new Gb(Tt);F.scope.off();const yt=F.update=kt.run.bind(kt),Vt=F.job=kt.runIfDirty.bind(kt);Vt.i=F,Vt.id=F.uid,kt.scheduler=()=>Dh(Vt),Tr(F,!0),yt()},ot=(F,z,at)=>{z.component=F;const ft=F.vnode.props;F.vnode=z,F.next=null,uV(F,z.props,ft,at),hV(F,z.children,at),Vs(),gp(F),Ls()},tt=(F,z,at,ft,lt,dt,xt,Tt,kt=!1)=>{const yt=F&&F.children,Vt=F?F.shapeFlag:0,$t=z.children,{patchFlag:Lt,shapeFlag:qt}=z;if(Lt>0){if(Lt&128){ht(yt,$t,at,ft,lt,dt,xt,Tt,kt);return}else if(Lt&256){ct(yt,$t,at,ft,lt,dt,xt,Tt,kt);return}}qt&8?(Vt&16&&Ft(yt,lt,dt),$t!==yt&&l(at,$t)):Vt&16?qt&16?ht(yt,$t,at,ft,lt,dt,xt,Tt,kt):Ft(yt,lt,dt,!0):(Vt&8&&l(at,""),qt&16&&W($t,at,ft,lt,dt,xt,Tt,kt))},ct=(F,z,at,ft,lt,dt,xt,Tt,kt)=>{F=F||ya,z=z||ya;const yt=F.length,Vt=z.length,$t=Math.min(yt,Vt);let Lt;for(Lt=0;Lt<$t;Lt++){const qt=z[Lt]=kt?tr(z[Lt]):us(z[Lt]);b(F[Lt],qt,at,null,lt,dt,xt,Tt,kt)}yt>Vt?Ft(F,lt,dt,!0,!1,$t):W(z,at,ft,lt,dt,xt,Tt,kt,$t)},ht=(F,z,at,ft,lt,dt,xt,Tt,kt)=>{let yt=0;const Vt=z.length;let $t=F.length-1,Lt=Vt-1;for(;yt<=$t&&yt<=Lt;){const qt=F[yt],Gt=z[yt]=kt?tr(z[yt]):us(z[yt]);if(to(qt,Gt))b(qt,Gt,at,null,lt,dt,xt,Tt,kt);else break;yt++}for(;yt<=$t&&yt<=Lt;){const qt=F[$t],Gt=z[Lt]=kt?tr(z[Lt]):us(z[Lt]);if(to(qt,Gt))b(qt,Gt,at,null,lt,dt,xt,Tt,kt);else break;$t--,Lt--}if(yt>$t){if(yt<=Lt){const qt=Lt+1,Gt=qt<Vt?z[qt].el:ft;for(;yt<=Lt;)b(null,z[yt]=kt?tr(z[yt]):us(z[yt]),at,Gt,lt,dt,xt,Tt,kt),yt++}}else if(yt>Lt)for(;yt<=$t;)wt(F[yt],lt,dt,!0),yt++;else{const qt=yt,Gt=yt,Qt=new Map;for(yt=Gt;yt<=Lt;yt++){const $e=z[yt]=kt?tr(z[yt]):us(z[yt]);$e.key!=null&&Qt.set($e.key,yt)}let ne,_e=0;const Re=Lt-Gt+1;let He=!1,We=0;const gn=new Array(Re);for(yt=0;yt<Re;yt++)gn[yt]=0;for(yt=qt;yt<=$t;yt++){const $e=F[yt];if(_e>=Re){wt($e,lt,dt,!0);continue}let zt;if($e.key!=null)zt=Qt.get($e.key);else for(ne=Gt;ne<=Lt;ne++)if(gn[ne-Gt]===0&&to($e,z[ne])){zt=ne;break}zt===void 0?wt($e,lt,dt,!0):(gn[zt-Gt]=yt+1,zt>=We?We=zt:He=!0,b($e,z[zt],at,null,lt,dt,xt,Tt,kt),_e++)}const qs=He?gV(gn):ya;for(ne=qs.length-1,yt=Re-1;yt>=0;yt--){const $e=Gt+yt,zt=z[$e],Hs=$e+1<Vt?z[$e+1].el:ft;gn[yt]===0?b(null,zt,at,Hs,lt,dt,xt,Tt,kt):He&&(ne<0||yt!==qs[ne]?gt(zt,at,Hs,2):ne--)}}},gt=(F,z,at,ft,lt=null)=>{const{el:dt,type:xt,transition:Tt,children:kt,shapeFlag:yt}=F;if(yt&6){gt(F.component.subTree,z,at,ft);return}if(yt&128){F.suspense.move(z,at,ft);return}if(yt&64){xt.move(F,z,at,Ut);return}if(xt===De){s(dt,z,at);for(let $t=0;$t<kt.length;$t++)gt(kt[$t],z,at,ft);s(F.anchor,z,at);return}if(xt===Lc){_(F,z,at);return}if(ft!==2&&yt&1&&Tt)if(ft===0)Tt.beforeEnter(dt),s(dt,z,at),wn(()=>Tt.enter(dt),lt);else{const{leave:$t,delayLeave:Lt,afterLeave:qt}=Tt,Gt=()=>{F.ctx.isUnmounted?r(dt):s(dt,z,at)},Qt=()=>{$t(dt,()=>{Gt(),qt&&qt()})};Lt?Lt(dt,Gt,Qt):Qt()}else s(dt,z,at)},wt=(F,z,at,ft=!1,lt=!1)=>{const{type:dt,props:xt,ref:Tt,children:kt,dynamicChildren:yt,shapeFlag:Vt,patchFlag:$t,dirs:Lt,cacheIndex:qt}=F;if($t===-2&&(lt=!1),Tt!=null&&(Vs(),ou(Tt,null,at,F,!0),Ls()),qt!=null&&(z.renderCache[qt]=void 0),Vt&256){z.ctx.deactivate(F);return}const Gt=Vt&1&&Lt,Qt=!mo(F);let ne;if(Qt&&(ne=xt&&xt.onVnodeBeforeUnmount)&&rs(ne,z,F),Vt&6)Et(F.component,at,ft);else{if(Vt&128){F.suspense.unmount(at,ft);return}Gt&&_r(F,null,z,"beforeUnmount"),Vt&64?F.type.remove(F,z,at,Ut,ft):yt&&!yt.hasOnce&&(dt!==De||$t>0&&$t&64)?Ft(yt,z,at,!1,!0):(dt===De&&$t&384||!lt&&Vt&16)&&Ft(kt,z,at),ft&&bt(F)}(Qt&&(ne=xt&&xt.onVnodeUnmounted)||Gt)&&wn(()=>{ne&&rs(ne,z,F),Gt&&_r(F,null,z,"unmounted")},at)},bt=F=>{const{type:z,el:at,anchor:ft,transition:lt}=F;if(z===De){Ct(at,ft);return}if(z===Lc){I(F);return}const dt=()=>{r(at),lt&&!lt.persisted&&lt.afterLeave&&lt.afterLeave()};if(F.shapeFlag&1&&lt&&!lt.persisted){const{leave:xt,delayLeave:Tt}=lt,kt=()=>xt(at,dt);Tt?Tt(F.el,dt,kt):kt()}else dt()},Ct=(F,z)=>{let at;for(;F!==z;)at=d(F),r(F),F=at;r(z)},Et=(F,z,at)=>{const{bum:ft,scope:lt,job:dt,subTree:xt,um:Tt,m:kt,a:yt,parent:Vt,slots:{__:$t}}=F;Ip(kt),Ip(yt),ft&&Fi(ft),Vt&&Xt($t)&&$t.forEach(Lt=>{Vt.renderCache[Lt]=void 0}),lt.stop(),dt&&(dt.flags|=8,wt(xt,F,z,at)),Tt&&wn(Tt,z),wn(()=>{F.isUnmounted=!0},z),z&&z.pendingBranch&&!z.isUnmounted&&F.asyncDep&&!F.asyncResolved&&F.suspenseId===z.pendingId&&(z.deps--,z.deps===0&&z.resolve())},Ft=(F,z,at,ft=!1,lt=!1,dt=0)=>{for(let xt=dt;xt<F.length;xt++)wt(F[xt],z,at,ft,lt)},Bt=F=>{if(F.shapeFlag&6)return Bt(F.component.subTree);if(F.shapeFlag&128)return F.suspense.next();const z=d(F.anchor||F.el),at=z&&z[g0];return at?d(at):z};let Ht=!1;const vt=(F,z,at)=>{F==null?z._vnode&&wt(z._vnode,null,null,!0):b(z._vnode||null,F,z,null,null,null,at),z._vnode=F,Ht||(Ht=!0,gp(),d0(),Ht=!1)},Ut={p:b,um:wt,m:gt,r:bt,mt:st,mc:W,pc:tt,pbc:M,n:Bt,o:e};return{render:vt,hydrate:void 0,createApp:aV(vt)}}function Vc({type:e,props:t},n){return n==="svg"&&e==="foreignObject"||n==="mathml"&&e==="annotation-xml"&&t&&t.encoding&&t.encoding.includes("html")?void 0:n}function Tr({effect:e,job:t},n){n?(e.flags|=32,t.flags|=4):(e.flags&=-33,t.flags&=-5)}function mV(e,t){return(!e||e&&!e.pendingBranch)&&t&&!t.persisted}function Ph(e,t,n=!1){const s=e.children,r=t.children;if(Xt(s)&&Xt(r))for(let a=0;a<s.length;a++){const o=s[a];let i=r[a];i.shapeFlag&1&&!i.dynamicChildren&&((i.patchFlag<=0||i.patchFlag===32)&&(i=r[a]=tr(r[a]),i.el=o.el),!n&&i.patchFlag!==-2&&Ph(o,i)),i.type===Bu&&(i.el=o.el),i.type===hr&&!i.el&&(i.el=o.el)}}function gV(e){const t=e.slice(),n=[0];let s,r,a,o,i;const u=e.length;for(s=0;s<u;s++){const c=e[s];if(c!==0){if(r=n[n.length-1],e[r]<c){t[s]=r,n.push(s);continue}for(a=0,o=n.length-1;a<o;)i=a+o>>1,e[n[i]]<c?a=i+1:o=i;c<e[n[a]]&&(a>0&&(t[s]=n[a-1]),n[a]=s)}}for(a=n.length,o=n[a-1];a-- >0;)n[a]=o,o=t[o];return n}function A0(e){const t=e.subTree.component;if(t)return t.asyncDep&&!t.asyncResolved?t:A0(t)}function Ip(e){if(e)for(let t=0;t<e.length;t++)e[t].flags|=8}const yV=Symbol.for("v-scx"),bV=()=>Pi(yV);function Vu(e,t){return Lu(e,null,t)}function wV(e,t){return Lu(e,null,{flush:"sync"})}function Ds(e,t,n){return Lu(e,t,n)}function Lu(e,t,n=pe){const{immediate:s,deep:r,flush:a,once:o}=n,i=en({},n),u=t&&s||!t&&a!=="post";let c;if(Ro){if(a==="sync"){const m=bV();c=m.__watcherHandles||(m.__watcherHandles=[])}else if(!u){const m=()=>{};return m.stop=ds,m.resume=ds,m.pause=ds,m}}const l=hn;i.call=(m,g,b)=>ys(m,l,g,b);let f=!1;a==="post"?i.scheduler=m=>{wn(m,l&&l.suspense)}:a!=="sync"&&(f=!0,i.scheduler=(m,g)=>{g?m():Dh(m)}),i.augmentJob=m=>{t&&(m.flags|=4),f&&(m.flags|=2,l&&(m.id=l.uid,m.i=l))};const d=DM(e,t,i);return Ro&&(c?c.push(d):u&&d()),d}function vV(e,t,n){const s=this.proxy,r=Be(e)?e.includes(".")?F0(s,e):()=>s[e]:e.bind(s,s);let a;ee(t)?a=t:(a=t.handler,n=t);const o=qo(this),i=Lu(r,a.bind(s),n);return o(),i}function F0(e,t){const n=t.split(".");return()=>{let s=e;for(let r=0;r<n.length&&s;r++)s=s[n[r]];return s}}function R0(e,t,n=pe){const s=Vh(),r=Ms(t),a=yr(t),o=P0(e,r),i=EM((u,c)=>{let l,f=pe,d;return wV(()=>{const m=e[r];$n(l,m)&&(l=m,c())}),{get(){return u(),n.get?n.get(l):l},set(m){const g=n.set?n.set(m):m;if(!$n(g,l)&&!(f!==pe&&$n(m,f)))return;const b=s.vnode.props;b&&(t in b||r in b||a in b)&&(`onUpdate:${t}`in b||`onUpdate:${r}`in b||`onUpdate:${a}`in b)||(l=m,c()),s.emit(`update:${t}`,g),$n(m,g)&&$n(m,f)&&!$n(g,d)&&c(),f=m,d=g}}});return i[Symbol.iterator]=()=>{let u=0;return{next(){return u<2?{value:u++?o||pe:i,done:!1}:{done:!0}}}},i}const P0=(e,t)=>t==="modelValue"||t==="model-value"?e.modelModifiers:e[`${t}Modifiers`]||e[`${Ms(t)}Modifiers`]||e[`${yr(t)}Modifiers`];function kV(e,t,...n){if(e.isUnmounted)return;const s=e.vnode.props||pe;let r=n;const a=t.startsWith("update:"),o=a&&P0(s,t.slice(7));o&&(o.trim&&(r=n.map(l=>Be(l)?l.trim():l)),o.number&&(r=n.map(Sl)));let i,u=s[i=Dc(t)]||s[i=Dc(Ms(t))];!u&&a&&(u=s[i=Dc(yr(t))]),u&&ys(u,e,6,r);const c=s[i+"Once"];if(c){if(!e.emitted)e.emitted={};else if(e.emitted[i])return;e.emitted[i]=!0,ys(c,e,6,r)}}function M0(e,t,n=!1){const s=t.emitsCache,r=s.get(e);if(r!==void 0)return r;const a=e.emits;let o={},i=!1;if(!ee(e)){const u=c=>{const l=M0(c,t,!0);l&&(i=!0,en(o,l))};!n&&t.mixins.length&&t.mixins.forEach(u),e.extends&&u(e.extends),e.mixins&&e.mixins.forEach(u)}return!a&&!i?(Ee(e)&&s.set(e,null),null):(Xt(a)?a.forEach(u=>o[u]=null):en(o,a),Ee(e)&&s.set(e,o),o)}function zu(e,t){return!e||!Eu(t)?!1:(t=t.slice(2).replace(/Once$/,""),ge(e,t[0].toLowerCase()+t.slice(1))||ge(e,yr(t))||ge(e,t))}function Np(e){const{type:t,vnode:n,proxy:s,withProxy:r,propsOptions:[a],slots:o,attrs:i,emit:u,render:c,renderCache:l,props:f,data:d,setupState:m,ctx:g,inheritAttrs:b}=e,w=au(e);let k,N;try{if(n.shapeFlag&4){const I=r||s,$=I;k=us(c.call($,I,l,f,m,d,g)),N=i}else{const I=t;k=us(I.length>1?I(f,{attrs:i,slots:o,emit:u}):I(f,null)),N=t.props?i:xV(i)}}catch(I){yo.length=0,Fu(I,e,1),k=Kn(hr)}let _=k;if(N&&b!==!1){const I=Object.keys(N),{shapeFlag:$}=_;I.length&&$&7&&(a&&I.some(xh)&&(N=SV(N,a)),_=Aa(_,N,!1,!0))}return n.dirs&&(_=Aa(_,null,!1,!0),_.dirs=_.dirs?_.dirs.concat(n.dirs):n.dirs),n.transition&&Ah(_,n.transition),k=_,au(w),k}const xV=e=>{let t;for(const n in e)(n==="class"||n==="style"||Eu(n))&&((t||(t={}))[n]=e[n]);return t},SV=(e,t)=>{const n={};for(const s in e)(!xh(s)||!(s.slice(9)in t))&&(n[s]=e[s]);return n};function IV(e,t,n){const{props:s,children:r,component:a}=e,{props:o,children:i,patchFlag:u}=t,c=a.emitsOptions;if(t.dirs||t.transition)return!0;if(n&&u>=0){if(u&1024)return!0;if(u&16)return s?_p(s,o,c):!!o;if(u&8){const l=t.dynamicProps;for(let f=0;f<l.length;f++){const d=l[f];if(o[d]!==s[d]&&!zu(c,d))return!0}}}else return(r||i)&&(!i||!i.$stable)?!0:s===o?!1:s?o?_p(s,o,c):!0:!!o;return!1}function _p(e,t,n){const s=Object.keys(t);if(s.length!==Object.keys(e).length)return!0;for(let r=0;r<s.length;r++){const a=s[r];if(t[a]!==e[a]&&!zu(n,a))return!0}return!1}function NV({vnode:e,parent:t},n){for(;t;){const s=t.subTree;if(s.suspense&&s.suspense.activeBranch===e&&(s.el=e.el),s===e)(e=t.vnode).el=n,t=t.parent;else break}}const V0=e=>e.__isSuspense;function _V(e,t){t&&t.pendingBranch?Xt(e)?t.effects.push(...e):t.effects.push(e):RM(e)}const De=Symbol.for("v-fgt"),Bu=Symbol.for("v-txt"),hr=Symbol.for("v-cmt"),Lc=Symbol.for("v-stc"),yo=[];let Pn=null;function Yt(e=!1){yo.push(Pn=e?null:[])}function TV(){yo.pop(),Pn=yo[yo.length-1]||null}let Ao=1;function Tp(e,t=!1){Ao+=e,e<0&&Pn&&t&&(Pn.hasOnce=!0)}function L0(e){return e.dynamicChildren=Ao>0?Pn||ya:null,TV(),Ao>0&&Pn&&Pn.push(e),e}function re(e,t,n,s,r,a){return L0(St(e,t,n,s,r,a,!0))}function er(e,t,n,s,r){return L0(Kn(e,t,n,s,r,!0))}function z0(e){return e?e.__v_isVNode===!0:!1}function to(e,t){return e.type===t.type&&e.key===t.key}const B0=({key:e})=>e??null,Mi=({ref:e,ref_key:t,ref_for:n})=>(typeof e=="number"&&(e=""+e),e!=null?Be(e)||pn(e)||ee(e)?{i:Rn,r:e,k:t,f:!!n}:e:null);function St(e,t=null,n=null,s=0,r=null,a=e===De?0:1,o=!1,i=!1){const u={__v_isVNode:!0,__v_skip:!0,type:e,props:t,key:t&&B0(t),ref:t&&Mi(t),scopeId:m0,slotScopeIds:null,children:n,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetStart:null,targetAnchor:null,staticCount:0,shapeFlag:a,patchFlag:s,dynamicProps:r,dynamicChildren:null,appContext:null,ctx:Rn};return i?(Mh(u,n),a&128&&e.normalize(u)):n&&(u.shapeFlag|=Be(n)?8:16),Ao>0&&!o&&Pn&&(u.patchFlag>0||a&6)&&u.patchFlag!==32&&Pn.push(u),u}const Kn=EV;function EV(e,t=null,n=null,s=0,r=null,a=!1){if((!e||e===JM)&&(e=hr),z0(e)){const i=Aa(e,t,!0);return n&&Mh(i,n),Ao>0&&!a&&Pn&&(i.shapeFlag&6?Pn[Pn.indexOf(e)]=i:Pn.push(i)),i.patchFlag=-2,i}if(MV(e)&&(e=e.__vccOpts),t){t=$V(t);let{class:i,style:u}=t;i&&!Be(i)&&(t.class=ir(i)),Ee(u)&&(Oh(u)&&!Xt(u)&&(u=en({},u)),t.style=Oa(u))}const o=Be(e)?1:V0(e)?128:MM(e)?64:Ee(e)?4:ee(e)?2:0;return St(e,t,n,s,r,o,a,!0)}function $V(e){return e?Oh(e)||T0(e)?en({},e):e:null}function Aa(e,t,n=!1,s=!1){const{props:r,ref:a,patchFlag:o,children:i,transition:u}=e,c=t?W0(r||{},t):r,l={__v_isVNode:!0,__v_skip:!0,type:e.type,props:c,key:c&&B0(c),ref:t&&t.ref?n&&a?Xt(a)?a.concat(Mi(t)):[a,Mi(t)]:Mi(t):a,scopeId:e.scopeId,slotScopeIds:e.slotScopeIds,children:i,target:e.target,targetStart:e.targetStart,targetAnchor:e.targetAnchor,staticCount:e.staticCount,shapeFlag:e.shapeFlag,patchFlag:t&&e.type!==De?o===-1?16:o|16:o,dynamicProps:e.dynamicProps,dynamicChildren:e.dynamicChildren,appContext:e.appContext,dirs:e.dirs,transition:u,component:e.component,suspense:e.suspense,ssContent:e.ssContent&&Aa(e.ssContent),ssFallback:e.ssFallback&&Aa(e.ssFallback),el:e.el,anchor:e.anchor,ctx:e.ctx,ce:e.ce};return u&&s&&Ah(l,u.clone(l)),l}function Fo(e=" ",t=0){return Kn(Bu,null,e,t)}function Vr(e="",t=!1){return t?(Yt(),er(hr,null,e)):Kn(hr,null,e)}function us(e){return e==null||typeof e=="boolean"?Kn(hr):Xt(e)?Kn(De,null,e.slice()):z0(e)?tr(e):Kn(Bu,null,String(e))}function tr(e){return e.el===null&&e.patchFlag!==-1||e.memo?e:Aa(e)}function Mh(e,t){let n=0;const{shapeFlag:s}=e;if(t==null)t=null;else if(Xt(t))n=16;else if(typeof t=="object")if(s&65){const r=t.default;r&&(r._c&&(r._d=!1),Mh(e,r()),r._c&&(r._d=!0));return}else{n=32;const r=t._;!r&&!T0(t)?t._ctx=Rn:r===3&&Rn&&(Rn.slots._===1?t._=1:(t._=2,e.patchFlag|=1024))}else ee(t)?(t={default:t,_ctx:Rn},n=32):(t=String(t),s&64?(n=16,t=[Fo(t)]):n=8);e.children=t,e.shapeFlag|=n}function W0(...e){const t={};for(let n=0;n<e.length;n++){const s=e[n];for(const r in s)if(r==="class")t.class!==s.class&&(t.class=ir([t.class,s.class]));else if(r==="style")t.style=Oa([t.style,s.style]);else if(Eu(r)){const a=t[r],o=s[r];o&&a!==o&&!(Xt(a)&&a.includes(o))&&(t[r]=a?[].concat(a,o):o)}else r!==""&&(t[r]=s[r])}return t}function rs(e,t,n,s=null){ys(e,t,7,[n,s])}const CV=I0();let OV=0;function DV(e,t,n){const s=e.type,r=(t?t.appContext:e.appContext)||CV,a={uid:OV++,vnode:e,type:s,parent:t,appContext:r,root:null,next:null,subTree:null,effect:null,update:null,job:null,scope:new sM(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:t?t.provides:Object.create(r.provides),ids:t?t.ids:["",0,0],accessCache:null,renderCache:[],components:null,directives:null,propsOptions:$0(s,r),emitsOptions:M0(s,r),emit:null,emitted:null,propsDefaults:pe,inheritAttrs:s.inheritAttrs,ctx:pe,data:pe,props:pe,attrs:pe,slots:pe,refs:pe,setupState:pe,setupContext:null,suspense:n,suspenseId:n?n.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return a.ctx={_:a},a.root=t?t.root:a,a.emit=kV.bind(null,a),e.ce&&e.ce(a),a}let hn=null;const Vh=()=>hn||Rn;let cu,Fl;{const e=Ou(),t=(n,s)=>{let r;return(r=e[n])||(r=e[n]=[]),r.push(s),a=>{r.length>1?r.forEach(o=>o(a)):r[0](a)}};cu=t("__VUE_INSTANCE_SETTERS__",n=>hn=n),Fl=t("__VUE_SSR_SETTERS__",n=>Ro=n)}const qo=e=>{const t=hn;return cu(e),e.scope.on(),()=>{e.scope.off(),cu(t)}},Ep=()=>{hn&&hn.scope.off(),cu(null)};function j0(e){return e.vnode.shapeFlag&4}let Ro=!1;function AV(e,t=!1,n=!1){t&&Fl(t);const{props:s,children:r}=e.vnode,a=j0(e);iV(e,s,a,t),fV(e,r,n||t);const o=a?FV(e,t):void 0;return t&&Fl(!1),o}function FV(e,t){const n=e.type;e.accessCache=Object.create(null),e.proxy=new Proxy(e.ctx,ZM);const{setup:s}=n;if(s){Vs();const r=e.setupContext=s.length>1?PV(e):null,a=qo(e),o=Wo(s,e,0,[e.props,r]),i=Vb(o);if(Ls(),a(),(i||e.sp)&&!mo(e)&&w0(e),i){if(o.then(Ep,Ep),t)return o.then(u=>{$p(e,u)}).catch(u=>{Fu(u,e,0)});e.asyncDep=o}else $p(e,o)}else q0(e)}function $p(e,t,n){ee(t)?e.type.__ssrInlineRender?e.ssrRender=t:e.render=t:Ee(t)&&(e.setupState=l0(t)),q0(e)}function q0(e,t,n){const s=e.type;e.render||(e.render=s.render||ds);{const r=qo(e);Vs();try{QM(e)}finally{Ls(),r()}}}const RV={get(e,t){return ln(e,"get",""),e[t]}};function PV(e){const t=n=>{e.exposed=n||{}};return{attrs:new Proxy(e.attrs,RV),slots:e.slots,emit:e.emit,expose:t}}function Wu(e){return e.exposed?e.exposeProxy||(e.exposeProxy=new Proxy(l0(IM(e.exposed)),{get(t,n){if(n in t)return t[n];if(n in go)return go[n](e)},has(t,n){return n in t||n in go}})):e.proxy}function MV(e){return ee(e)&&"__vccOpts"in e}const xn=(e,t)=>CM(e,t,Ro),VV="3.5.16";/**
* @vue/runtime-dom v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let Rl;const Cp=typeof window<"u"&&window.trustedTypes;if(Cp)try{Rl=Cp.createPolicy("vue",{createHTML:e=>e})}catch{}const H0=Rl?e=>Rl.createHTML(e):e=>e,LV="http://www.w3.org/2000/svg",zV="http://www.w3.org/1998/Math/MathML",Is=typeof document<"u"?document:null,Op=Is&&Is.createElement("template"),BV={insert:(e,t,n)=>{t.insertBefore(e,n||null)},remove:e=>{const t=e.parentNode;t&&t.removeChild(e)},createElement:(e,t,n,s)=>{const r=t==="svg"?Is.createElementNS(LV,e):t==="mathml"?Is.createElementNS(zV,e):n?Is.createElement(e,{is:n}):Is.createElement(e);return e==="select"&&s&&s.multiple!=null&&r.setAttribute("multiple",s.multiple),r},createText:e=>Is.createTextNode(e),createComment:e=>Is.createComment(e),setText:(e,t)=>{e.nodeValue=t},setElementText:(e,t)=>{e.textContent=t},parentNode:e=>e.parentNode,nextSibling:e=>e.nextSibling,querySelector:e=>Is.querySelector(e),setScopeId(e,t){e.setAttribute(t,"")},insertStaticContent(e,t,n,s,r,a){const o=n?n.previousSibling:t.lastChild;if(r&&(r===a||r.nextSibling))for(;t.insertBefore(r.cloneNode(!0),n),!(r===a||!(r=r.nextSibling)););else{Op.innerHTML=H0(s==="svg"?`<svg>${e}</svg>`:s==="mathml"?`<math>${e}</math>`:e);const i=Op.content;if(s==="svg"||s==="mathml"){const u=i.firstChild;for(;u.firstChild;)i.appendChild(u.firstChild);i.removeChild(u)}t.insertBefore(i,n)}return[o?o.nextSibling:t.firstChild,n?n.previousSibling:t.lastChild]}},WV=Symbol("_vtc");function jV(e,t,n){const s=e[WV];s&&(t=(t?[t,...s]:[...s]).join(" ")),t==null?e.removeAttribute("class"):n?e.setAttribute("class",t):e.className=t}const lu=Symbol("_vod"),K0=Symbol("_vsh"),U0={beforeMount(e,{value:t},{transition:n}){e[lu]=e.style.display==="none"?"":e.style.display,n&&t?n.beforeEnter(e):eo(e,t)},mounted(e,{value:t},{transition:n}){n&&t&&n.enter(e)},updated(e,{value:t,oldValue:n},{transition:s}){!t!=!n&&(s?t?(s.beforeEnter(e),eo(e,!0),s.enter(e)):s.leave(e,()=>{eo(e,!1)}):eo(e,t))},beforeUnmount(e,{value:t}){eo(e,t)}};function eo(e,t){e.style.display=t?e[lu]:"none",e[K0]=!t}const qV=Symbol(""),HV=/(^|;)\s*display\s*:/;function KV(e,t,n){const s=e.style,r=Be(n);let a=!1;if(n&&!r){if(t)if(Be(t))for(const o of t.split(";")){const i=o.slice(0,o.indexOf(":")).trim();n[i]==null&&Vi(s,i,"")}else for(const o in t)n[o]==null&&Vi(s,o,"");for(const o in n)o==="display"&&(a=!0),Vi(s,o,n[o])}else if(r){if(t!==n){const o=s[qV];o&&(n+=";"+o),s.cssText=n,a=HV.test(n)}}else t&&e.removeAttribute("style");lu in e&&(e[lu]=a?s.display:"",e[K0]&&(s.display="none"))}const Dp=/\s*!important$/;function Vi(e,t,n){if(Xt(n))n.forEach(s=>Vi(e,t,s));else if(n==null&&(n=""),t.startsWith("--"))e.setProperty(t,n);else{const s=UV(e,t);Dp.test(n)?e.setProperty(yr(s),n.replace(Dp,""),"important"):e[s]=n}}const Ap=["Webkit","Moz","ms"],zc={};function UV(e,t){const n=zc[t];if(n)return n;let s=Ms(t);if(s!=="filter"&&s in e)return zc[t]=s;s=Bb(s);for(let r=0;r<Ap.length;r++){const a=Ap[r]+s;if(a in e)return zc[t]=a}return t}const Fp="http://www.w3.org/1999/xlink";function Rp(e,t,n,s,r,a=eM(t)){s&&t.startsWith("xlink:")?n==null?e.removeAttributeNS(Fp,t.slice(6,t.length)):e.setAttributeNS(Fp,t,n):n==null||a&&!jb(n)?e.removeAttribute(t):e.setAttribute(t,a?"":gs(n)?String(n):n)}function Pp(e,t,n,s,r){if(t==="innerHTML"||t==="textContent"){n!=null&&(e[t]=t==="innerHTML"?H0(n):n);return}const a=e.tagName;if(t==="value"&&a!=="PROGRESS"&&!a.includes("-")){const i=a==="OPTION"?e.getAttribute("value")||"":e.value,u=n==null?e.type==="checkbox"?"on":"":String(n);(i!==u||!("_value"in e))&&(e.value=u),n==null&&e.removeAttribute(t),e._value=n;return}let o=!1;if(n===""||n==null){const i=typeof e[t];i==="boolean"?n=jb(n):n==null&&i==="string"?(n="",o=!0):i==="number"&&(n=0,o=!0)}try{e[t]=n}catch{}o&&e.removeAttribute(r||t)}function nr(e,t,n,s){e.addEventListener(t,n,s)}function GV(e,t,n,s){e.removeEventListener(t,n,s)}const Mp=Symbol("_vei");function XV(e,t,n,s,r=null){const a=e[Mp]||(e[Mp]={}),o=a[t];if(s&&o)o.value=s;else{const[i,u]=YV(t);if(s){const c=a[t]=QV(s,r);nr(e,i,c,u)}else o&&(GV(e,i,o,u),a[t]=void 0)}}const Vp=/(?:Once|Passive|Capture)$/;function YV(e){let t;if(Vp.test(e)){t={};let s;for(;s=e.match(Vp);)e=e.slice(0,e.length-s[0].length),t[s[0].toLowerCase()]=!0}return[e[2]===":"?e.slice(3):yr(e.slice(2)),t]}let Bc=0;const JV=Promise.resolve(),ZV=()=>Bc||(JV.then(()=>Bc=0),Bc=Date.now());function QV(e,t){const n=s=>{if(!s._vts)s._vts=Date.now();else if(s._vts<=n.attached)return;ys(tL(s,n.value),t,5,[s])};return n.value=e,n.attached=ZV(),n}function tL(e,t){if(Xt(t)){const n=e.stopImmediatePropagation;return e.stopImmediatePropagation=()=>{n.call(e),e._stopped=!0},t.map(s=>r=>!r._stopped&&s&&s(r))}else return t}const Lp=e=>e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&e.charCodeAt(2)>96&&e.charCodeAt(2)<123,eL=(e,t,n,s,r,a)=>{const o=r==="svg";t==="class"?jV(e,s,o):t==="style"?KV(e,n,s):Eu(t)?xh(t)||XV(e,t,n,s,a):(t[0]==="."?(t=t.slice(1),!0):t[0]==="^"?(t=t.slice(1),!1):nL(e,t,s,o))?(Pp(e,t,s),!e.tagName.includes("-")&&(t==="value"||t==="checked"||t==="selected")&&Rp(e,t,s,o,a,t!=="value")):e._isVueCE&&(/[A-Z]/.test(t)||!Be(s))?Pp(e,Ms(t),s,a,t):(t==="true-value"?e._trueValue=s:t==="false-value"&&(e._falseValue=s),Rp(e,t,s,o))};function nL(e,t,n,s){if(s)return!!(t==="innerHTML"||t==="textContent"||t in e&&Lp(t)&&ee(n));if(t==="spellcheck"||t==="draggable"||t==="translate"||t==="autocorrect"||t==="form"||t==="list"&&e.tagName==="INPUT"||t==="type"&&e.tagName==="TEXTAREA")return!1;if(t==="width"||t==="height"){const r=e.tagName;if(r==="IMG"||r==="VIDEO"||r==="CANVAS"||r==="SOURCE")return!1}return Lp(t)&&Be(n)?!1:t in e}const Fa=e=>{const t=e.props["onUpdate:modelValue"]||!1;return Xt(t)?n=>Fi(t,n):t};function sL(e){e.target.composing=!0}function zp(e){const t=e.target;t.composing&&(t.composing=!1,t.dispatchEvent(new Event("input")))}const As=Symbol("_assign"),ia={created(e,{modifiers:{lazy:t,trim:n,number:s}},r){e[As]=Fa(r);const a=s||r.props&&r.props.type==="number";nr(e,t?"change":"input",o=>{if(o.target.composing)return;let i=e.value;n&&(i=i.trim()),a&&(i=Sl(i)),e[As](i)}),n&&nr(e,"change",()=>{e.value=e.value.trim()}),t||(nr(e,"compositionstart",sL),nr(e,"compositionend",zp),nr(e,"change",zp))},mounted(e,{value:t}){e.value=t??""},beforeUpdate(e,{value:t,oldValue:n,modifiers:{lazy:s,trim:r,number:a}},o){if(e[As]=Fa(o),e.composing)return;const i=(a||e.type==="number")&&!/^0\d/.test(e.value)?Sl(e.value):e.value,u=t??"";i!==u&&(document.activeElement===e&&e.type!=="range"&&(s&&t===n||r&&e.value.trim()===u)||(e.value=u))}},rL={deep:!0,created(e,t,n){e[As]=Fa(n),nr(e,"change",()=>{const s=e._modelValue,r=G0(e),a=e.checked,o=e[As];if(Xt(s)){const i=qb(s,r),u=i!==-1;if(a&&!u)o(s.concat(r));else if(!a&&u){const c=[...s];c.splice(i,1),o(c)}}else if($u(s)){const i=new Set(s);a?i.add(r):i.delete(r),o(i)}else o(X0(e,a))})},mounted:Bp,beforeUpdate(e,t,n){e[As]=Fa(n),Bp(e,t,n)}};function Bp(e,{value:t,oldValue:n},s){e._modelValue=t;let r;if(Xt(t))r=qb(t,s.props.value)>-1;else if($u(t))r=t.has(s.props.value);else{if(t===n)return;r=Da(t,X0(e,!0))}e.checked!==r&&(e.checked=r)}const aL={created(e,{value:t},n){e.checked=Da(t,n.props.value),e[As]=Fa(n),nr(e,"change",()=>{e[As](G0(e))})},beforeUpdate(e,{value:t,oldValue:n},s){e[As]=Fa(s),t!==n&&(e.checked=Da(t,s.props.value))}};function G0(e){return"_value"in e?e._value:e.value}function X0(e,t){const n=t?"_trueValue":"_falseValue";return n in e?e[n]:t}const oL=["ctrl","shift","alt","meta"],iL={stop:e=>e.stopPropagation(),prevent:e=>e.preventDefault(),self:e=>e.target!==e.currentTarget,ctrl:e=>!e.ctrlKey,shift:e=>!e.shiftKey,alt:e=>!e.altKey,meta:e=>!e.metaKey,left:e=>"button"in e&&e.button!==0,middle:e=>"button"in e&&e.button!==1,right:e=>"button"in e&&e.button!==2,exact:(e,t)=>oL.some(n=>e[`${n}Key`]&&!t.includes(n))},uL=(e,t)=>{const n=e._withMods||(e._withMods={}),s=t.join(".");return n[s]||(n[s]=(r,...a)=>{for(let o=0;o<t.length;o++){const i=iL[t[o]];if(i&&i(r,t))return}return e(r,...a)})},cL=en({patchProp:eL},BV);let Wp;function lL(){return Wp||(Wp=dV(cL))}const fL=(...e)=>{const t=lL().createApp(...e),{mount:n}=t;return t.mount=s=>{const r=dL(s);if(!r)return;const a=t._component;!ee(a)&&!a.render&&!a.template&&(a.template=r.innerHTML),r.nodeType===1&&(r.textContent="");const o=n(r,!1,hL(r));return r instanceof Element&&(r.removeAttribute("v-cloak"),r.setAttribute("data-v-app","")),o},t};function hL(e){if(e instanceof SVGElement)return"svg";if(typeof MathMLElement=="function"&&e instanceof MathMLElement)return"mathml"}function dL(e){return Be(e)?document.querySelector(e):e}var pL=Object.defineProperty,mL=(e,t,n)=>t in e?pL(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,Ze=(e,t,n)=>mL(e,typeof t!="symbol"?t+"":t,n);function ju(e){return Ub()?(rM(e),!0):!1}const gL=typeof window<"u"&&typeof document<"u";typeof WorkerGlobalScope<"u"&&globalThis instanceof WorkerGlobalScope;const yL=e=>e!=null,bL=Object.prototype.toString,wL=e=>bL.call(e)==="[object Object]",vL=()=>{};function bo(e){return Array.isArray(e)?e:[e]}function kL(e){return Vh()}function xL(e,t=!0,n){kL()?jo(e,n):t?e():Ru(e)}function SL(e,t,n){return Ds(e,t,{...n,immediate:!0})}const za=gL?window:void 0;function Os(e){var t;const n=va(e);return(t=n==null?void 0:n.$el)!=null?t:n}function fu(...e){const t=[],n=()=>{t.forEach(i=>i()),t.length=0},s=(i,u,c,l)=>(i.addEventListener(u,c,l),()=>i.removeEventListener(u,c,l)),r=xn(()=>{const i=bo(va(e[0])).filter(u=>u!=null);return i.every(u=>typeof u!="string")?i:void 0}),a=SL(()=>{var i,u;return[(u=(i=r.value)==null?void 0:i.map(c=>Os(c)))!=null?u:[za].filter(c=>c!=null),bo(va(r.value?e[1]:e[0])),bo(On(r.value?e[2]:e[1])),va(r.value?e[3]:e[2])]},([i,u,c,l])=>{if(n(),!(i!=null&&i.length)||!(u!=null&&u.length)||!(c!=null&&c.length))return;const f=wL(l)?{...l}:l;t.push(...i.flatMap(d=>u.flatMap(m=>c.map(g=>s(d,m,g,f)))))},{flush:"post"}),o=()=>{a(),n()};return ju(n),o}function IL(){const e=nu(!1),t=Vh();return t&&jo(()=>{e.value=!0},t),e}function Y0(e){const t=IL();return xn(()=>(t.value,!!e()))}function NL(e,t,n={}){const{window:s=za,...r}=n;let a;const o=Y0(()=>s&&"MutationObserver"in s),i=()=>{a&&(a.disconnect(),a=void 0)},u=xn(()=>{const d=va(e),m=bo(d).map(Os).filter(yL);return new Set(m)}),c=Ds(()=>u.value,d=>{i(),o.value&&d.size&&(a=new MutationObserver(t),d.forEach(m=>a.observe(m,r)))},{immediate:!0,flush:"post"}),l=()=>a==null?void 0:a.takeRecords(),f=()=>{c(),i()};return ju(f),{isSupported:o,stop:f,takeRecords:l}}function _L(e,t,n={}){const{window:s=za,document:r=s==null?void 0:s.document,flush:a="sync"}=n;if(!s||!r)return vL;let o;const i=l=>{o==null||o(),o=l},u=Vu(()=>{const l=Os(e);if(l){const{stop:f}=NL(r,d=>{d.map(m=>[...m.removedNodes]).flat().some(m=>m===l||m.contains(l))&&t(d)},{window:s,childList:!0,subtree:!0});i(f)}},{flush:a}),c=()=>{u(),i()};return ju(c),c}function TL(e={}){var t;const{window:n=za,deep:s=!0,triggerOnRemoval:r=!1}=e,a=(t=e.document)!=null?t:n==null?void 0:n.document,o=()=>{var c;let l=a==null?void 0:a.activeElement;if(s)for(;l!=null&&l.shadowRoot;)l=(c=l==null?void 0:l.shadowRoot)==null?void 0:c.activeElement;return l},i=nu(),u=()=>{i.value=o()};if(n){const c={capture:!0,passive:!0};fu(n,"blur",l=>{l.relatedTarget===null&&u()},c),fu(n,"focus",u,c)}return r&&_L(i,u,{document:a}),u(),i}function EL(e,t,n={}){const{window:s=za,...r}=n;let a;const o=Y0(()=>s&&"ResizeObserver"in s),i=()=>{a&&(a.disconnect(),a=void 0)},u=xn(()=>{const f=va(e);return Array.isArray(f)?f.map(d=>Os(d)):[Os(f)]}),c=Ds(u,f=>{if(i(),o.value&&s){a=new ResizeObserver(t);for(const d of f)d&&a.observe(d,r)}},{immediate:!0,flush:"post"}),l=()=>{i(),c()};return ju(l),{isSupported:o,stop:l}}function J0(e,t={width:0,height:0},n={}){const{window:s=za,box:r="content-box"}=n,a=xn(()=>{var f,d;return(d=(f=Os(e))==null?void 0:f.namespaceURI)==null?void 0:d.includes("svg")}),o=nu(t.width),i=nu(t.height),{stop:u}=EL(e,([f])=>{const d=r==="border-box"?f.borderBoxSize:r==="content-box"?f.contentBoxSize:f.devicePixelContentBoxSize;if(s&&a.value){const m=Os(e);if(m){const g=m.getBoundingClientRect();o.value=g.width,i.value=g.height}}else if(d){const m=bo(d);o.value=m.reduce((g,{inlineSize:b})=>g+b,0),i.value=m.reduce((g,{blockSize:b})=>g+b,0)}else o.value=f.contentRect.width,i.value=f.contentRect.height},n);xL(()=>{const f=Os(e);f&&(o.value="offsetWidth"in f?f.offsetWidth:t.width,i.value="offsetHeight"in f?f.offsetHeight:t.height)});const c=Ds(()=>Os(e),f=>{o.value=f?t.width:0,i.value=f?t.height:0});function l(){u(),c()}return{width:o,height:i,stop:l}}var $L=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function CL(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var Pl={exports:{}},OL=Pl.exports,jp;function DL(){return jp||(jp=1,function(e,t){(function(n,s){e.exports=s()})(OL,function(){var n=function(h,p){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(y,x){y.__proto__=x}||function(y,x){for(var S in x)Object.prototype.hasOwnProperty.call(x,S)&&(y[S]=x[S])})(h,p)},s=function(){return(s=Object.assign||function(h){for(var p,y=1,x=arguments.length;y<x;y++)for(var S in p=arguments[y])Object.prototype.hasOwnProperty.call(p,S)&&(h[S]=p[S]);return h}).apply(this,arguments)};function r(h,p,y){for(var x,S=0,E=p.length;S<E;S++)!x&&S in p||((x=x||Array.prototype.slice.call(p,0,S))[S]=p[S]);return h.concat(x||Array.prototype.slice.call(p))}var a=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:$L,o=Object.keys,i=Array.isArray;function u(h,p){return typeof p!="object"||o(p).forEach(function(y){h[y]=p[y]}),h}typeof Promise>"u"||a.Promise||(a.Promise=Promise);var c=Object.getPrototypeOf,l={}.hasOwnProperty;function f(h,p){return l.call(h,p)}function d(h,p){typeof p=="function"&&(p=p(c(h))),(typeof Reflect>"u"?o:Reflect.ownKeys)(p).forEach(function(y){g(h,y,p[y])})}var m=Object.defineProperty;function g(h,p,y,x){m(h,p,u(y&&f(y,"get")&&typeof y.get=="function"?{get:y.get,set:y.set,configurable:!0}:{value:y,configurable:!0,writable:!0},x))}function b(h){return{from:function(p){return h.prototype=Object.create(p.prototype),g(h.prototype,"constructor",h),{extend:d.bind(null,h.prototype)}}}}var w=Object.getOwnPropertyDescriptor,k=[].slice;function N(h,p,y){return k.call(h,p,y)}function _(h,p){return p(h)}function I(h){if(!h)throw new Error("Assertion Failed")}function $(h){a.setImmediate?setImmediate(h):setTimeout(h,0)}function O(h,p){if(typeof p=="string"&&f(h,p))return h[p];if(!p)return h;if(typeof p!="string"){for(var y=[],x=0,S=p.length;x<S;++x){var E=O(h,p[x]);y.push(E)}return y}var A=p.indexOf(".");if(A!==-1){var V=h[p.substr(0,A)];return V==null?void 0:O(V,p.substr(A+1))}}function R(h,p,y){if(h&&p!==void 0&&!("isFrozen"in Object&&Object.isFrozen(h)))if(typeof p!="string"&&"length"in p){I(typeof y!="string"&&"length"in y);for(var x=0,S=p.length;x<S;++x)R(h,p[x],y[x])}else{var E,A,V=p.indexOf(".");V!==-1?(E=p.substr(0,V),(A=p.substr(V+1))===""?y===void 0?i(h)&&!isNaN(parseInt(E))?h.splice(E,1):delete h[E]:h[E]=y:R(V=!(V=h[E])||!f(h,E)?h[E]={}:V,A,y)):y===void 0?i(h)&&!isNaN(parseInt(p))?h.splice(p,1):delete h[p]:h[p]=y}}function W(h){var p,y={};for(p in h)f(h,p)&&(y[p]=h[p]);return y}var P=[].concat;function M(h){return P.apply([],h)}var Gt="BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(M([8,16,32,64].map(function(h){return["Int","Uint","Float"].map(function(p){return p+h+"Array"})}))).filter(function(h){return a[h]}),T=new Set(Gt.map(function(h){return a[h]})),q=null;function X(h){return q=new WeakMap,h=function p(y){if(!y||typeof y!="object")return y;var x=q.get(y);if(x)return x;if(i(y)){x=[],q.set(y,x);for(var S=0,E=y.length;S<E;++S)x.push(p(y[S]))}else if(T.has(y.constructor))x=y;else{var A,V=c(y);for(A in x=V===Object.prototype?{}:Object.create(V),q.set(y,x),y)f(y,A)&&(x[A]=p(y[A]))}return x}(h),q=null,h}var st={}.toString;function et(h){return st.call(h).slice(8,-1)}var nt=typeof Symbol<"u"?Symbol.iterator:"@@iterator",ot=typeof nt=="symbol"?function(h){var p;return h!=null&&(p=h[nt])&&p.apply(h)}:function(){return null};function tt(h,p){return p=h.indexOf(p),0<=p&&h.splice(p,1),0<=p}var ct={};function ht(h){var p,y,x,S;if(arguments.length===1){if(i(h))return h.slice();if(this===ct&&typeof h=="string")return[h];if(S=ot(h)){for(y=[];!(x=S.next()).done;)y.push(x.value);return y}if(h==null)return[h];if(typeof(p=h.length)!="number")return[h];for(y=new Array(p);p--;)y[p]=h[p];return y}for(p=arguments.length,y=new Array(p);p--;)y[p]=arguments[p];return y}var gt=typeof Symbol<"u"?function(h){return h[Symbol.toStringTag]==="AsyncFunction"}:function(){return!1},qt=["Unknown","Constraint","Data","TransactionInactive","ReadOnly","Version","NotFound","InvalidState","InvalidAccess","Abort","Timeout","QuotaExceeded","Syntax","DataClone"],zn=["Modify","Bulk","OpenFailed","VersionChange","Schema","Upgrade","InvalidTable","MissingAPI","NoSuchDatabase","InvalidArgument","SubTransaction","Unsupported","Internal","DatabaseClosed","PrematureCommit","ForeignAwait"].concat(qt),wt={VersionChanged:"Database version changed by other database connection",DatabaseClosed:"Database has been closed",Abort:"Transaction aborted",TransactionInactive:"Transaction has already completed or failed",MissingAPI:"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"};function bt(h,p){this.name=h,this.message=p}function Ct(h,p){return h+". Errors: "+Object.keys(p).map(function(y){return p[y].toString()}).filter(function(y,x,S){return S.indexOf(y)===x}).join(`
`)}function Et(h,p,y,x){this.failures=p,this.failedKeys=x,this.successCount=y,this.message=Ct(h,p)}function Ft(h,p){this.name="BulkError",this.failures=Object.keys(p).map(function(y){return p[y]}),this.failuresByPos=p,this.message=Ct(h,this.failures)}b(bt).from(Error).extend({toString:function(){return this.name+": "+this.message}}),b(Et).from(bt),b(Ft).from(bt);var Bt=zn.reduce(function(h,p){return h[p]=p+"Error",h},{}),Ht=bt,vt=zn.reduce(function(h,p){var y=p+"Error";function x(S,E){this.name=y,S?typeof S=="string"?(this.message="".concat(S).concat(E?`
 `+E:""),this.inner=E||null):typeof S=="object"&&(this.message="".concat(S.name," ").concat(S.message),this.inner=S):(this.message=wt[p]||y,this.inner=null)}return b(x).from(Ht),h[p]=x,h},{});vt.Syntax=SyntaxError,vt.Type=TypeError,vt.Range=RangeError;var Ut=qt.reduce(function(h,p){return h[p+"Error"]=vt[p],h},{}),Zt=zn.reduce(function(h,p){return["Syntax","Type","Range"].indexOf(p)===-1&&(h[p+"Error"]=vt[p]),h},{});function F(){}function z(h){return h}function at(h,p){return h==null||h===z?p:function(y){return p(h(y))}}function ft(h,p){return function(){h.apply(this,arguments),p.apply(this,arguments)}}function lt(h,p){return h===F?p:function(){var y=h.apply(this,arguments);y!==void 0&&(arguments[0]=y);var x=this.onsuccess,S=this.onerror;this.onsuccess=null,this.onerror=null;var E=p.apply(this,arguments);return x&&(this.onsuccess=this.onsuccess?ft(x,this.onsuccess):x),S&&(this.onerror=this.onerror?ft(S,this.onerror):S),E!==void 0?E:y}}function dt(h,p){return h===F?p:function(){h.apply(this,arguments);var y=this.onsuccess,x=this.onerror;this.onsuccess=this.onerror=null,p.apply(this,arguments),y&&(this.onsuccess=this.onsuccess?ft(y,this.onsuccess):y),x&&(this.onerror=this.onerror?ft(x,this.onerror):x)}}function xt(h,p){return h===F?p:function(y){var x=h.apply(this,arguments);u(y,x);var S=this.onsuccess,E=this.onerror;return this.onsuccess=null,this.onerror=null,y=p.apply(this,arguments),S&&(this.onsuccess=this.onsuccess?ft(S,this.onsuccess):S),E&&(this.onerror=this.onerror?ft(E,this.onerror):E),x===void 0?y===void 0?void 0:y:u(x,y)}}function Tt(h,p){return h===F?p:function(){return p.apply(this,arguments)!==!1&&h.apply(this,arguments)}}function kt(h,p){return h===F?p:function(){var y=h.apply(this,arguments);if(y&&typeof y.then=="function"){for(var x=this,S=arguments.length,E=new Array(S);S--;)E[S]=arguments[S];return y.then(function(){return p.apply(x,E)})}return p.apply(this,arguments)}}Zt.ModifyError=Et,Zt.DexieError=bt,Zt.BulkError=Ft;var yt=typeof location<"u"&&/^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);function Vt(h){yt=h}var $t={},Lt=100,Gt=typeof Promise>"u"?[]:function(){var h=Promise.resolve();if(typeof crypto>"u"||!crypto.subtle)return[h,c(h),h];var p=crypto.subtle.digest("SHA-512",new Uint8Array([0]));return[p,c(p),h]}(),qt=Gt[0],zn=Gt[1],Gt=Gt[2],zn=zn&&zn.then,Qt=qt&&qt.constructor,ne=!!Gt,_e=function(h,p){Hs.push([h,p]),He&&(queueMicrotask(sw),He=!1)},Re=!0,He=!0,We=[],gn=[],qs=z,$e={id:"global",global:!0,ref:0,unhandleds:[],onunhandled:F,pgp:!1,env:{},finalize:F},zt=$e,Hs=[],br=0,Ho=[];function Mt(h){if(typeof this!="object")throw new TypeError("Promises must be constructed via new");this._listeners=[],this._lib=!1;var p=this._PSD=zt;if(typeof h!="function"){if(h!==$t)throw new TypeError("Not a function");return this._state=arguments[1],this._value=arguments[2],void(this._state===!1&&Hu(this,this._value))}this._state=null,this._value=null,++p.ref,function y(x,S){try{S(function(E){if(x._state===null){if(E===x)throw new TypeError("A promise cannot be resolved with itself.");var A=x._lib&&Qr();E&&typeof E.then=="function"?y(x,function(V,H){E instanceof Mt?E._then(V,H):E.then(V,H)}):(x._state=!0,x._value=E,Wh(x)),A&&ta()}},Hu.bind(null,x))}catch(E){Hu(x,E)}}(this,h)}var qu={get:function(){var h=zt,p=Xo;function y(x,S){var E=this,A=!h.global&&(h!==zt||p!==Xo),V=A&&!Us(),H=new Mt(function(U,J){Ku(E,new Bh(qh(x,h,A,V),qh(S,h,A,V),U,J,h))});return this._consoleTask&&(H._consoleTask=this._consoleTask),H}return y.prototype=$t,y},set:function(h){g(this,"then",h&&h.prototype===$t?qu:{get:function(){return h},set:qu.set})}};function Bh(h,p,y,x,S){this.onFulfilled=typeof h=="function"?h:null,this.onRejected=typeof p=="function"?p:null,this.resolve=y,this.reject=x,this.psd=S}function Hu(h,p){var y,x;gn.push(p),h._state===null&&(y=h._lib&&Qr(),p=qs(p),h._state=!1,h._value=p,x=h,We.some(function(S){return S._value===x._value})||We.push(x),Wh(h),y&&ta())}function Wh(h){var p=h._listeners;h._listeners=[];for(var y=0,x=p.length;y<x;++y)Ku(h,p[y]);var S=h._PSD;--S.ref||S.finalize(),br===0&&(++br,_e(function(){--br==0&&Uu()},[]))}function Ku(h,p){if(h._state!==null){var y=h._state?p.onFulfilled:p.onRejected;if(y===null)return(h._state?p.resolve:p.reject)(h._value);++p.psd.ref,++br,_e(nw,[y,h,p])}else h._listeners.push(p)}function nw(h,p,y){try{var x,S=p._value;!p._state&&gn.length&&(gn=[]),x=yt&&p._consoleTask?p._consoleTask.run(function(){return h(S)}):h(S),p._state||gn.indexOf(S)!==-1||function(E){for(var A=We.length;A;)if(We[--A]._value===E._value)return We.splice(A,1)}(p),y.resolve(x)}catch(E){y.reject(E)}finally{--br==0&&Uu(),--y.psd.ref||y.psd.finalize()}}function sw(){wr($e,function(){Qr()&&ta()})}function Qr(){var h=Re;return He=Re=!1,h}function ta(){var h,p,y;do for(;0<Hs.length;)for(h=Hs,Hs=[],y=h.length,p=0;p<y;++p){var x=h[p];x[0].apply(null,x[1])}while(0<Hs.length);He=Re=!0}function Uu(){var h=We;We=[],h.forEach(function(x){x._PSD.onunhandled.call(null,x._value,x)});for(var p=Ho.slice(0),y=p.length;y;)p[--y]()}function Ko(h){return new Mt($t,!1,h)}function Ce(h,p){var y=zt;return function(){var x=Qr(),S=zt;try{return Gs(y,!0),h.apply(this,arguments)}catch(E){p&&p(E)}finally{Gs(S,!1),x&&ta()}}}d(Mt.prototype,{then:qu,_then:function(h,p){Ku(this,new Bh(null,null,h,p,zt))},catch:function(h){if(arguments.length===1)return this.then(null,h);var p=h,y=arguments[1];return typeof p=="function"?this.then(null,function(x){return(x instanceof p?y:Ko)(x)}):this.then(null,function(x){return(x&&x.name===p?y:Ko)(x)})},finally:function(h){return this.then(function(p){return Mt.resolve(h()).then(function(){return p})},function(p){return Mt.resolve(h()).then(function(){return Ko(p)})})},timeout:function(h,p){var y=this;return h<1/0?new Mt(function(x,S){var E=setTimeout(function(){return S(new vt.Timeout(p))},h);y.then(x,S).finally(clearTimeout.bind(null,E))}):this}}),typeof Symbol<"u"&&Symbol.toStringTag&&g(Mt.prototype,Symbol.toStringTag,"Dexie.Promise"),$e.env=jh(),d(Mt,{all:function(){var h=ht.apply(null,arguments).map(Yo);return new Mt(function(p,y){h.length===0&&p([]);var x=h.length;h.forEach(function(S,E){return Mt.resolve(S).then(function(A){h[E]=A,--x||p(h)},y)})})},resolve:function(h){return h instanceof Mt?h:h&&typeof h.then=="function"?new Mt(function(p,y){h.then(p,y)}):new Mt($t,!0,h)},reject:Ko,race:function(){var h=ht.apply(null,arguments).map(Yo);return new Mt(function(p,y){h.map(function(x){return Mt.resolve(x).then(p,y)})})},PSD:{get:function(){return zt},set:function(h){return zt=h}},totalEchoes:{get:function(){return Xo}},newPSD:Ks,usePSD:wr,scheduler:{get:function(){return _e},set:function(h){_e=h}},rejectionMapper:{get:function(){return qs},set:function(h){qs=h}},follow:function(h,p){return new Mt(function(y,x){return Ks(function(S,E){var A=zt;A.unhandleds=[],A.onunhandled=E,A.finalize=ft(function(){var V,H=this;V=function(){H.unhandleds.length===0?S():E(H.unhandleds[0])},Ho.push(function U(){V(),Ho.splice(Ho.indexOf(U),1)}),++br,_e(function(){--br==0&&Uu()},[])},A.finalize),h()},p,y,x)})}}),Qt&&(Qt.allSettled&&g(Mt,"allSettled",function(){var h=ht.apply(null,arguments).map(Yo);return new Mt(function(p){h.length===0&&p([]);var y=h.length,x=new Array(y);h.forEach(function(S,E){return Mt.resolve(S).then(function(A){return x[E]={status:"fulfilled",value:A}},function(A){return x[E]={status:"rejected",reason:A}}).then(function(){return--y||p(x)})})})}),Qt.any&&typeof AggregateError<"u"&&g(Mt,"any",function(){var h=ht.apply(null,arguments).map(Yo);return new Mt(function(p,y){h.length===0&&y(new AggregateError([]));var x=h.length,S=new Array(x);h.forEach(function(E,A){return Mt.resolve(E).then(function(V){return p(V)},function(V){S[A]=V,--x||y(new AggregateError(S))})})})}),Qt.withResolvers&&(Mt.withResolvers=Qt.withResolvers));var Ge={awaits:0,echoes:0,id:0},rw=0,Uo=[],Go=0,Xo=0,aw=0;function Ks(h,p,y,x){var S=zt,E=Object.create(S);return E.parent=S,E.ref=0,E.global=!1,E.id=++aw,$e.env,E.env=ne?{Promise:Mt,PromiseProp:{value:Mt,configurable:!0,writable:!0},all:Mt.all,race:Mt.race,allSettled:Mt.allSettled,any:Mt.any,resolve:Mt.resolve,reject:Mt.reject}:{},p&&u(E,p),++S.ref,E.finalize=function(){--this.parent.ref||this.parent.finalize()},x=wr(E,h,y,x),E.ref===0&&E.finalize(),x}function ea(){return Ge.id||(Ge.id=++rw),++Ge.awaits,Ge.echoes+=Lt,Ge.id}function Us(){return!!Ge.awaits&&(--Ge.awaits==0&&(Ge.id=0),Ge.echoes=Ge.awaits*Lt,!0)}function Yo(h){return Ge.echoes&&h&&h.constructor===Qt?(ea(),h.then(function(p){return Us(),p},function(p){return Us(),Ve(p)})):h}function ow(){var h=Uo[Uo.length-1];Uo.pop(),Gs(h,!1)}function Gs(h,p){var y,x=zt;(p?!Ge.echoes||Go++&&h===zt:!Go||--Go&&h===zt)||queueMicrotask(p?(function(S){++Xo,Ge.echoes&&--Ge.echoes!=0||(Ge.echoes=Ge.awaits=Ge.id=0),Uo.push(zt),Gs(S,!0)}).bind(null,h):ow),h!==zt&&(zt=h,x===$e&&($e.env=jh()),ne&&(y=$e.env.Promise,p=h.env,(x.global||h.global)&&(Object.defineProperty(a,"Promise",p.PromiseProp),y.all=p.all,y.race=p.race,y.resolve=p.resolve,y.reject=p.reject,p.allSettled&&(y.allSettled=p.allSettled),p.any&&(y.any=p.any))))}function jh(){var h=a.Promise;return ne?{Promise:h,PromiseProp:Object.getOwnPropertyDescriptor(a,"Promise"),all:h.all,race:h.race,allSettled:h.allSettled,any:h.any,resolve:h.resolve,reject:h.reject}:{}}function wr(h,p,y,x,S){var E=zt;try{return Gs(h,!0),p(y,x,S)}finally{Gs(E,!1)}}function qh(h,p,y,x){return typeof h!="function"?h:function(){var S=zt;y&&ea(),Gs(p,!0);try{return h.apply(this,arguments)}finally{Gs(S,!1),x&&queueMicrotask(Us)}}}function Gu(h){Promise===Qt&&Ge.echoes===0?Go===0?h():enqueueNativeMicroTask(h):setTimeout(h,0)}(""+zn).indexOf("[native code]")===-1&&(ea=Us=F);var Ve=Mt.reject,vr="",ks="Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.",Hh="String expected.",na=[],Jo="__dbnames",Xu="readonly",Yu="readwrite";function kr(h,p){return h?p?function(){return h.apply(this,arguments)&&p.apply(this,arguments)}:h:p}var Kh={type:3,lower:-1/0,lowerOpen:!1,upper:[[]],upperOpen:!1};function Zo(h){return typeof h!="string"||/\./.test(h)?function(p){return p}:function(p){return p[h]===void 0&&h in p&&delete(p=X(p))[h],p}}function Uh(){throw vt.Type()}function le(h,p){try{var y=Gh(h),x=Gh(p);if(y!==x)return y==="Array"?1:x==="Array"?-1:y==="binary"?1:x==="binary"?-1:y==="string"?1:x==="string"?-1:y==="Date"?1:x!=="Date"?NaN:-1;switch(y){case"number":case"Date":case"string":return p<h?1:h<p?-1:0;case"binary":return function(S,E){for(var A=S.length,V=E.length,H=A<V?A:V,U=0;U<H;++U)if(S[U]!==E[U])return S[U]<E[U]?-1:1;return A===V?0:A<V?-1:1}(Xh(h),Xh(p));case"Array":return function(S,E){for(var A=S.length,V=E.length,H=A<V?A:V,U=0;U<H;++U){var J=le(S[U],E[U]);if(J!==0)return J}return A===V?0:A<V?-1:1}(h,p)}}catch{}return NaN}function Gh(h){var p=typeof h;return p!="object"?p:ArrayBuffer.isView(h)?"binary":(h=et(h),h==="ArrayBuffer"?"binary":h)}function Xh(h){return h instanceof Uint8Array?h:ArrayBuffer.isView(h)?new Uint8Array(h.buffer,h.byteOffset,h.byteLength):new Uint8Array(h)}var Yh=(Te.prototype._trans=function(h,p,y){var x=this._tx||zt.trans,S=this.name,E=yt&&typeof console<"u"&&console.createTask&&console.createTask("Dexie: ".concat(h==="readonly"?"read":"write"," ").concat(this.name));function A(U,J,B){if(!B.schema[S])throw new vt.NotFound("Table "+S+" not part of transaction");return p(B.idbtrans,B)}var V=Qr();try{var H=x&&x.db._novip===this.db._novip?x===zt.trans?x._promise(h,A,y):Ks(function(){return x._promise(h,A,y)},{trans:x,transless:zt.transless||zt}):function U(J,B,Q,K){if(J.idbdb&&(J._state.openComplete||zt.letThrough||J._vip)){var Y=J._createTransaction(B,Q,J._dbSchema);try{Y.create(),J._state.PR1398_maxLoop=3}catch(Z){return Z.name===Bt.InvalidState&&J.isOpen()&&0<--J._state.PR1398_maxLoop?(console.warn("Dexie: Need to reopen db"),J.close({disableAutoOpen:!1}),J.open().then(function(){return U(J,B,Q,K)})):Ve(Z)}return Y._promise(B,function(Z,G){return Ks(function(){return zt.trans=Y,K(Z,G,Y)})}).then(function(Z){if(B==="readwrite")try{Y.idbtrans.commit()}catch{}return B==="readonly"?Z:Y._completion.then(function(){return Z})})}if(J._state.openComplete)return Ve(new vt.DatabaseClosed(J._state.dbOpenError));if(!J._state.isBeingOpened){if(!J._state.autoOpen)return Ve(new vt.DatabaseClosed);J.open().catch(F)}return J._state.dbReadyPromise.then(function(){return U(J,B,Q,K)})}(this.db,h,[this.name],A);return E&&(H._consoleTask=E,H=H.catch(function(U){return console.trace(U),Ve(U)})),H}finally{V&&ta()}},Te.prototype.get=function(h,p){var y=this;return h&&h.constructor===Object?this.where(h).first(p):h==null?Ve(new vt.Type("Invalid argument to Table.get()")):this._trans("readonly",function(x){return y.core.get({trans:x,key:h}).then(function(S){return y.hook.reading.fire(S)})}).then(p)},Te.prototype.where=function(h){if(typeof h=="string")return new this.db.WhereClause(this,h);if(i(h))return new this.db.WhereClause(this,"[".concat(h.join("+"),"]"));var p=o(h);if(p.length===1)return this.where(p[0]).equals(h[p[0]]);var y=this.schema.indexes.concat(this.schema.primKey).filter(function(V){if(V.compound&&p.every(function(U){return 0<=V.keyPath.indexOf(U)})){for(var H=0;H<p.length;++H)if(p.indexOf(V.keyPath[H])===-1)return!1;return!0}return!1}).sort(function(V,H){return V.keyPath.length-H.keyPath.length})[0];if(y&&this.db._maxKey!==vr){var E=y.keyPath.slice(0,p.length);return this.where(E).equals(E.map(function(H){return h[H]}))}!y&&yt&&console.warn("The query ".concat(JSON.stringify(h)," on ").concat(this.name," would benefit from a ")+"compound index [".concat(p.join("+"),"]"));var x=this.schema.idxByName;function S(V,H){return le(V,H)===0}var A=p.reduce(function(B,H){var U=B[0],J=B[1],B=x[H],Q=h[H];return[U||B,U||!B?kr(J,B&&B.multi?function(K){return K=O(K,H),i(K)&&K.some(function(Y){return S(Q,Y)})}:function(K){return S(Q,O(K,H))}):J]},[null,null]),E=A[0],A=A[1];return E?this.where(E.name).equals(h[E.keyPath]).filter(A):y?this.filter(A):this.where(p).equals("")},Te.prototype.filter=function(h){return this.toCollection().and(h)},Te.prototype.count=function(h){return this.toCollection().count(h)},Te.prototype.offset=function(h){return this.toCollection().offset(h)},Te.prototype.limit=function(h){return this.toCollection().limit(h)},Te.prototype.each=function(h){return this.toCollection().each(h)},Te.prototype.toArray=function(h){return this.toCollection().toArray(h)},Te.prototype.toCollection=function(){return new this.db.Collection(new this.db.WhereClause(this))},Te.prototype.orderBy=function(h){return new this.db.Collection(new this.db.WhereClause(this,i(h)?"[".concat(h.join("+"),"]"):h))},Te.prototype.reverse=function(){return this.toCollection().reverse()},Te.prototype.mapToClass=function(h){var p,y=this.db,x=this.name;function S(){return p!==null&&p.apply(this,arguments)||this}(this.schema.mappedClass=h).prototype instanceof Uh&&(function(H,U){if(typeof U!="function"&&U!==null)throw new TypeError("Class extends value "+String(U)+" is not a constructor or null");function J(){this.constructor=H}n(H,U),H.prototype=U===null?Object.create(U):(J.prototype=U.prototype,new J)}(S,p=h),Object.defineProperty(S.prototype,"db",{get:function(){return y},enumerable:!1,configurable:!0}),S.prototype.table=function(){return x},h=S);for(var E=new Set,A=h.prototype;A;A=c(A))Object.getOwnPropertyNames(A).forEach(function(H){return E.add(H)});function V(H){if(!H)return H;var U,J=Object.create(h.prototype);for(U in H)if(!E.has(U))try{J[U]=H[U]}catch{}return J}return this.schema.readHook&&this.hook.reading.unsubscribe(this.schema.readHook),this.schema.readHook=V,this.hook("reading",V),h},Te.prototype.defineClass=function(){return this.mapToClass(function(h){u(this,h)})},Te.prototype.add=function(h,p){var y=this,x=this.schema.primKey,S=x.auto,E=x.keyPath,A=h;return E&&S&&(A=Zo(E)(h)),this._trans("readwrite",function(V){return y.core.mutate({trans:V,type:"add",keys:p!=null?[p]:null,values:[A]})}).then(function(V){return V.numFailures?Mt.reject(V.failures[0]):V.lastResult}).then(function(V){if(E)try{R(h,E,V)}catch{}return V})},Te.prototype.update=function(h,p){return typeof h!="object"||i(h)?this.where(":id").equals(h).modify(p):(h=O(h,this.schema.primKey.keyPath),h===void 0?Ve(new vt.InvalidArgument("Given object does not contain its primary key")):this.where(":id").equals(h).modify(p))},Te.prototype.put=function(h,p){var y=this,x=this.schema.primKey,S=x.auto,E=x.keyPath,A=h;return E&&S&&(A=Zo(E)(h)),this._trans("readwrite",function(V){return y.core.mutate({trans:V,type:"put",values:[A],keys:p!=null?[p]:null})}).then(function(V){return V.numFailures?Mt.reject(V.failures[0]):V.lastResult}).then(function(V){if(E)try{R(h,E,V)}catch{}return V})},Te.prototype.delete=function(h){var p=this;return this._trans("readwrite",function(y){return p.core.mutate({trans:y,type:"delete",keys:[h]})}).then(function(y){return y.numFailures?Mt.reject(y.failures[0]):void 0})},Te.prototype.clear=function(){var h=this;return this._trans("readwrite",function(p){return h.core.mutate({trans:p,type:"deleteRange",range:Kh})}).then(function(p){return p.numFailures?Mt.reject(p.failures[0]):void 0})},Te.prototype.bulkGet=function(h){var p=this;return this._trans("readonly",function(y){return p.core.getMany({keys:h,trans:y}).then(function(x){return x.map(function(S){return p.hook.reading.fire(S)})})})},Te.prototype.bulkAdd=function(h,p,y){var x=this,S=Array.isArray(p)?p:void 0,E=(y=y||(S?void 0:p))?y.allKeys:void 0;return this._trans("readwrite",function(A){var U=x.schema.primKey,V=U.auto,U=U.keyPath;if(U&&S)throw new vt.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");if(S&&S.length!==h.length)throw new vt.InvalidArgument("Arguments objects and keys must have the same length");var H=h.length,U=U&&V?h.map(Zo(U)):h;return x.core.mutate({trans:A,type:"add",keys:S,values:U,wantResults:E}).then(function(Y){var B=Y.numFailures,Q=Y.results,K=Y.lastResult,Y=Y.failures;if(B===0)return E?Q:K;throw new Ft("".concat(x.name,".bulkAdd(): ").concat(B," of ").concat(H," operations failed"),Y)})})},Te.prototype.bulkPut=function(h,p,y){var x=this,S=Array.isArray(p)?p:void 0,E=(y=y||(S?void 0:p))?y.allKeys:void 0;return this._trans("readwrite",function(A){var U=x.schema.primKey,V=U.auto,U=U.keyPath;if(U&&S)throw new vt.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");if(S&&S.length!==h.length)throw new vt.InvalidArgument("Arguments objects and keys must have the same length");var H=h.length,U=U&&V?h.map(Zo(U)):h;return x.core.mutate({trans:A,type:"put",keys:S,values:U,wantResults:E}).then(function(Y){var B=Y.numFailures,Q=Y.results,K=Y.lastResult,Y=Y.failures;if(B===0)return E?Q:K;throw new Ft("".concat(x.name,".bulkPut(): ").concat(B," of ").concat(H," operations failed"),Y)})})},Te.prototype.bulkUpdate=function(h){var p=this,y=this.core,x=h.map(function(A){return A.key}),S=h.map(function(A){return A.changes}),E=[];return this._trans("readwrite",function(A){return y.getMany({trans:A,keys:x,cache:"clone"}).then(function(V){var H=[],U=[];h.forEach(function(B,Q){var K=B.key,Y=B.changes,Z=V[Q];if(Z){for(var G=0,rt=Object.keys(Y);G<rt.length;G++){var it=rt[G],ut=Y[it];if(it===p.schema.primKey.keyPath){if(le(ut,K)!==0)throw new vt.Constraint("Cannot update primary key in bulkUpdate()")}else R(Z,it,ut)}E.push(Q),H.push(K),U.push(Z)}});var J=H.length;return y.mutate({trans:A,type:"put",keys:H,values:U,updates:{keys:x,changeSpecs:S}}).then(function(B){var Q=B.numFailures,K=B.failures;if(Q===0)return J;for(var Y=0,Z=Object.keys(K);Y<Z.length;Y++){var G,rt=Z[Y],it=E[Number(rt)];it!=null&&(G=K[rt],delete K[rt],K[it]=G)}throw new Ft("".concat(p.name,".bulkUpdate(): ").concat(Q," of ").concat(J," operations failed"),K)})})})},Te.prototype.bulkDelete=function(h){var p=this,y=h.length;return this._trans("readwrite",function(x){return p.core.mutate({trans:x,type:"delete",keys:h})}).then(function(A){var S=A.numFailures,E=A.lastResult,A=A.failures;if(S===0)return E;throw new Ft("".concat(p.name,".bulkDelete(): ").concat(S," of ").concat(y," operations failed"),A)})},Te);function Te(){}function Ba(h){function p(A,V){if(V){for(var H=arguments.length,U=new Array(H-1);--H;)U[H-1]=arguments[H];return y[A].subscribe.apply(null,U),h}if(typeof A=="string")return y[A]}var y={};p.addEventType=E;for(var x=1,S=arguments.length;x<S;++x)E(arguments[x]);return p;function E(A,V,H){if(typeof A!="object"){var U;V=V||Tt;var J={subscribers:[],fire:H=H||F,subscribe:function(B){J.subscribers.indexOf(B)===-1&&(J.subscribers.push(B),J.fire=V(J.fire,B))},unsubscribe:function(B){J.subscribers=J.subscribers.filter(function(Q){return Q!==B}),J.fire=J.subscribers.reduce(V,H)}};return y[A]=p[A]=J}o(U=A).forEach(function(B){var Q=U[B];if(i(Q))E(B,U[B][0],U[B][1]);else{if(Q!=="asap")throw new vt.InvalidArgument("Invalid event config");var K=E(B,z,function(){for(var Y=arguments.length,Z=new Array(Y);Y--;)Z[Y]=arguments[Y];K.subscribers.forEach(function(G){$(function(){G.apply(null,Z)})})})}})}}function Wa(h,p){return b(p).from({prototype:h}),p}function sa(h,p){return!(h.filter||h.algorithm||h.or)&&(p?h.justLimit:!h.replayFilter)}function Ju(h,p){h.filter=kr(h.filter,p)}function Zu(h,p,y){var x=h.replayFilter;h.replayFilter=x?function(){return kr(x(),p())}:p,h.justLimit=y&&!x}function Qo(h,p){if(h.isPrimKey)return p.primaryKey;var y=p.getIndexByKeyPath(h.index);if(!y)throw new vt.Schema("KeyPath "+h.index+" on object store "+p.name+" is not indexed");return y}function Jh(h,p,y){var x=Qo(h,p.schema);return p.openCursor({trans:y,values:!h.keysOnly,reverse:h.dir==="prev",unique:!!h.unique,query:{index:x,range:h.range}})}function ti(h,p,y,x){var S=h.replayFilter?kr(h.filter,h.replayFilter()):h.filter;if(h.or){var E={},A=function(V,H,U){var J,B;S&&!S(H,U,function(Q){return H.stop(Q)},function(Q){return H.fail(Q)})||((B=""+(J=H.primaryKey))=="[object ArrayBuffer]"&&(B=""+new Uint8Array(J)),f(E,B)||(E[B]=!0,p(V,H,U)))};return Promise.all([h.or._iterate(A,y),Zh(Jh(h,x,y),h.algorithm,A,!h.keysOnly&&h.valueMapper)])}return Zh(Jh(h,x,y),kr(h.algorithm,S),p,!h.keysOnly&&h.valueMapper)}function Zh(h,p,y,x){var S=Ce(x?function(E,A,V){return y(x(E),A,V)}:y);return h.then(function(E){if(E)return E.start(function(){var A=function(){return E.continue()};p&&!p(E,function(V){return A=V},function(V){E.stop(V),A=F},function(V){E.fail(V),A=F})||S(E.value,E,function(V){return A=V}),A()})})}var ja=(Qh.prototype.execute=function(h){var p=this["@@propmod"];if(p.add!==void 0){var y=p.add;if(i(y))return r(r([],i(h)?h:[],!0),y).sort();if(typeof y=="number")return(Number(h)||0)+y;if(typeof y=="bigint")try{return BigInt(h)+y}catch{return BigInt(0)+y}throw new TypeError("Invalid term ".concat(y))}if(p.remove!==void 0){var x=p.remove;if(i(x))return i(h)?h.filter(function(S){return!x.includes(S)}).sort():[];if(typeof x=="number")return Number(h)-x;if(typeof x=="bigint")try{return BigInt(h)-x}catch{return BigInt(0)-x}throw new TypeError("Invalid subtrahend ".concat(x))}return y=(y=p.replacePrefix)===null||y===void 0?void 0:y[0],y&&typeof h=="string"&&h.startsWith(y)?p.replacePrefix[1]+h.substring(y.length):h},Qh);function Qh(h){this["@@propmod"]=h}var iw=(he.prototype._read=function(h,p){var y=this._ctx;return y.error?y.table._trans(null,Ve.bind(null,y.error)):y.table._trans("readonly",h).then(p)},he.prototype._write=function(h){var p=this._ctx;return p.error?p.table._trans(null,Ve.bind(null,p.error)):p.table._trans("readwrite",h,"locked")},he.prototype._addAlgorithm=function(h){var p=this._ctx;p.algorithm=kr(p.algorithm,h)},he.prototype._iterate=function(h,p){return ti(this._ctx,h,p,this._ctx.table.core)},he.prototype.clone=function(h){var p=Object.create(this.constructor.prototype),y=Object.create(this._ctx);return h&&u(y,h),p._ctx=y,p},he.prototype.raw=function(){return this._ctx.valueMapper=null,this},he.prototype.each=function(h){var p=this._ctx;return this._read(function(y){return ti(p,h,y,p.table.core)})},he.prototype.count=function(h){var p=this;return this._read(function(y){var x=p._ctx,S=x.table.core;if(sa(x,!0))return S.count({trans:y,query:{index:Qo(x,S.schema),range:x.range}}).then(function(A){return Math.min(A,x.limit)});var E=0;return ti(x,function(){return++E,!1},y,S).then(function(){return E})}).then(h)},he.prototype.sortBy=function(h,p){var y=h.split(".").reverse(),x=y[0],S=y.length-1;function E(H,U){return U?E(H[y[U]],U-1):H[x]}var A=this._ctx.dir==="next"?1:-1;function V(H,U){return le(E(H,S),E(U,S))*A}return this.toArray(function(H){return H.sort(V)}).then(p)},he.prototype.toArray=function(h){var p=this;return this._read(function(y){var x=p._ctx;if(x.dir==="next"&&sa(x,!0)&&0<x.limit){var S=x.valueMapper,E=Qo(x,x.table.core.schema);return x.table.core.query({trans:y,limit:x.limit,values:!0,query:{index:E,range:x.range}}).then(function(V){return V=V.result,S?V.map(S):V})}var A=[];return ti(x,function(V){return A.push(V)},y,x.table.core).then(function(){return A})},h)},he.prototype.offset=function(h){var p=this._ctx;return h<=0||(p.offset+=h,sa(p)?Zu(p,function(){var y=h;return function(x,S){return y===0||(y===1?--y:S(function(){x.advance(y),y=0}),!1)}}):Zu(p,function(){var y=h;return function(){return--y<0}})),this},he.prototype.limit=function(h){return this._ctx.limit=Math.min(this._ctx.limit,h),Zu(this._ctx,function(){var p=h;return function(y,x,S){return--p<=0&&x(S),0<=p}},!0),this},he.prototype.until=function(h,p){return Ju(this._ctx,function(y,x,S){return!h(y.value)||(x(S),p)}),this},he.prototype.first=function(h){return this.limit(1).toArray(function(p){return p[0]}).then(h)},he.prototype.last=function(h){return this.reverse().first(h)},he.prototype.filter=function(h){var p;return Ju(this._ctx,function(y){return h(y.value)}),(p=this._ctx).isMatch=kr(p.isMatch,h),this},he.prototype.and=function(h){return this.filter(h)},he.prototype.or=function(h){return new this.db.WhereClause(this._ctx.table,h,this)},he.prototype.reverse=function(){return this._ctx.dir=this._ctx.dir==="prev"?"next":"prev",this._ondirectionchange&&this._ondirectionchange(this._ctx.dir),this},he.prototype.desc=function(){return this.reverse()},he.prototype.eachKey=function(h){var p=this._ctx;return p.keysOnly=!p.isMatch,this.each(function(y,x){h(x.key,x)})},he.prototype.eachUniqueKey=function(h){return this._ctx.unique="unique",this.eachKey(h)},he.prototype.eachPrimaryKey=function(h){var p=this._ctx;return p.keysOnly=!p.isMatch,this.each(function(y,x){h(x.primaryKey,x)})},he.prototype.keys=function(h){var p=this._ctx;p.keysOnly=!p.isMatch;var y=[];return this.each(function(x,S){y.push(S.key)}).then(function(){return y}).then(h)},he.prototype.primaryKeys=function(h){var p=this._ctx;if(p.dir==="next"&&sa(p,!0)&&0<p.limit)return this._read(function(x){var S=Qo(p,p.table.core.schema);return p.table.core.query({trans:x,values:!1,limit:p.limit,query:{index:S,range:p.range}})}).then(function(x){return x.result}).then(h);p.keysOnly=!p.isMatch;var y=[];return this.each(function(x,S){y.push(S.primaryKey)}).then(function(){return y}).then(h)},he.prototype.uniqueKeys=function(h){return this._ctx.unique="unique",this.keys(h)},he.prototype.firstKey=function(h){return this.limit(1).keys(function(p){return p[0]}).then(h)},he.prototype.lastKey=function(h){return this.reverse().firstKey(h)},he.prototype.distinct=function(){var h=this._ctx,h=h.index&&h.table.schema.idxByName[h.index];if(!h||!h.multi)return this;var p={};return Ju(this._ctx,function(S){var x=S.primaryKey.toString(),S=f(p,x);return p[x]=!0,!S}),this},he.prototype.modify=function(h){var p=this,y=this._ctx;return this._write(function(x){var S,E,A;A=typeof h=="function"?h:(S=o(h),E=S.length,function(G){for(var rt=!1,it=0;it<E;++it){var ut=S[it],pt=h[ut],Nt=O(G,ut);pt instanceof ja?(R(G,ut,pt.execute(Nt)),rt=!0):Nt!==pt&&(R(G,ut,pt),rt=!0)}return rt});var V=y.table.core,B=V.schema.primaryKey,H=B.outbound,U=B.extractKey,J=200,B=p.db._options.modifyChunkSize;B&&(J=typeof B=="object"?B[V.name]||B["*"]||200:B);function Q(G,ut){var it=ut.failures,ut=ut.numFailures;Y+=G-ut;for(var pt=0,Nt=o(it);pt<Nt.length;pt++){var At=Nt[pt];K.push(it[At])}}var K=[],Y=0,Z=[];return p.clone().primaryKeys().then(function(G){function rt(ut){var pt=Math.min(J,G.length-ut);return V.getMany({trans:x,keys:G.slice(ut,ut+pt),cache:"immutable"}).then(function(Nt){for(var At=[],_t=[],Ot=H?[]:null,Rt=[],Dt=0;Dt<pt;++Dt){var Wt=Nt[Dt],se={value:X(Wt),primKey:G[ut+Dt]};A.call(se,se.value,se)!==!1&&(se.value==null?Rt.push(G[ut+Dt]):H||le(U(Wt),U(se.value))===0?(_t.push(se.value),H&&Ot.push(G[ut+Dt])):(Rt.push(G[ut+Dt]),At.push(se.value)))}return Promise.resolve(0<At.length&&V.mutate({trans:x,type:"add",values:At}).then(function(ie){for(var ue in ie.failures)Rt.splice(parseInt(ue),1);Q(At.length,ie)})).then(function(){return(0<_t.length||it&&typeof h=="object")&&V.mutate({trans:x,type:"put",keys:Ot,values:_t,criteria:it,changeSpec:typeof h!="function"&&h,isAdditionalChunk:0<ut}).then(function(ie){return Q(_t.length,ie)})}).then(function(){return(0<Rt.length||it&&h===Qu)&&V.mutate({trans:x,type:"delete",keys:Rt,criteria:it,isAdditionalChunk:0<ut}).then(function(ie){return Q(Rt.length,ie)})}).then(function(){return G.length>ut+pt&&rt(ut+J)})})}var it=sa(y)&&y.limit===1/0&&(typeof h!="function"||h===Qu)&&{index:y.index,range:y.range};return rt(0).then(function(){if(0<K.length)throw new Et("Error modifying one or more objects",K,Y,Z);return G.length})})})},he.prototype.delete=function(){var h=this._ctx,p=h.range;return sa(h)&&(h.isPrimKey||p.type===3)?this._write(function(y){var x=h.table.core.schema.primaryKey,S=p;return h.table.core.count({trans:y,query:{index:x,range:S}}).then(function(E){return h.table.core.mutate({trans:y,type:"deleteRange",range:S}).then(function(A){var V=A.failures;if(A.lastResult,A.results,A=A.numFailures,A)throw new Et("Could not delete some values",Object.keys(V).map(function(H){return V[H]}),E-A);return E-A})})}):this.modify(Qu)},he);function he(){}var Qu=function(h,p){return p.value=null};function uw(h,p){return h<p?-1:h===p?0:1}function cw(h,p){return p<h?-1:h===p?0:1}function Dn(h,p,y){return h=h instanceof ed?new h.Collection(h):h,h._ctx.error=new(y||TypeError)(p),h}function ra(h){return new h.Collection(h,function(){return td("")}).limit(0)}function ei(h,p,y,x){var S,E,A,V,H,U,J,B=y.length;if(!y.every(function(Y){return typeof Y=="string"}))return Dn(h,Hh);function Q(Y){S=Y==="next"?function(G){return G.toUpperCase()}:function(G){return G.toLowerCase()},E=Y==="next"?function(G){return G.toLowerCase()}:function(G){return G.toUpperCase()},A=Y==="next"?uw:cw;var Z=y.map(function(G){return{lower:E(G),upper:S(G)}}).sort(function(G,rt){return A(G.lower,rt.lower)});V=Z.map(function(G){return G.upper}),H=Z.map(function(G){return G.lower}),J=(U=Y)==="next"?"":x}Q("next"),h=new h.Collection(h,function(){return Xs(V[0],H[B-1]+x)}),h._ondirectionchange=function(Y){Q(Y)};var K=0;return h._addAlgorithm(function(Y,Z,G){var rt=Y.key;if(typeof rt!="string")return!1;var it=E(rt);if(p(it,H,K))return!0;for(var ut=null,pt=K;pt<B;++pt){var Nt=function(At,_t,Ot,Rt,Dt,Wt){for(var se=Math.min(At.length,Rt.length),ie=-1,ue=0;ue<se;++ue){var An=_t[ue];if(An!==Rt[ue])return Dt(At[ue],Ot[ue])<0?At.substr(0,ue)+Ot[ue]+Ot.substr(ue+1):Dt(At[ue],Rt[ue])<0?At.substr(0,ue)+Rt[ue]+Ot.substr(ue+1):0<=ie?At.substr(0,ie)+_t[ie]+Ot.substr(ie+1):null;Dt(At[ue],An)<0&&(ie=ue)}return se<Rt.length&&Wt==="next"?At+Ot.substr(At.length):se<At.length&&Wt==="prev"?At.substr(0,Ot.length):ie<0?null:At.substr(0,ie)+Rt[ie]+Ot.substr(ie+1)}(rt,it,V[pt],H[pt],A,U);Nt===null&&ut===null?K=pt+1:(ut===null||0<A(ut,Nt))&&(ut=Nt)}return Z(ut!==null?function(){Y.continue(ut+J)}:G),!1}),h}function Xs(h,p,y,x){return{type:2,lower:h,upper:p,lowerOpen:y,upperOpen:x}}function td(h){return{type:1,lower:h,upper:h}}var ed=(Object.defineProperty(Xe.prototype,"Collection",{get:function(){return this._ctx.table.db.Collection},enumerable:!1,configurable:!0}),Xe.prototype.between=function(h,p,y,x){y=y!==!1,x=x===!0;try{return 0<this._cmp(h,p)||this._cmp(h,p)===0&&(y||x)&&(!y||!x)?ra(this):new this.Collection(this,function(){return Xs(h,p,!y,!x)})}catch{return Dn(this,ks)}},Xe.prototype.equals=function(h){return h==null?Dn(this,ks):new this.Collection(this,function(){return td(h)})},Xe.prototype.above=function(h){return h==null?Dn(this,ks):new this.Collection(this,function(){return Xs(h,void 0,!0)})},Xe.prototype.aboveOrEqual=function(h){return h==null?Dn(this,ks):new this.Collection(this,function(){return Xs(h,void 0,!1)})},Xe.prototype.below=function(h){return h==null?Dn(this,ks):new this.Collection(this,function(){return Xs(void 0,h,!1,!0)})},Xe.prototype.belowOrEqual=function(h){return h==null?Dn(this,ks):new this.Collection(this,function(){return Xs(void 0,h)})},Xe.prototype.startsWith=function(h){return typeof h!="string"?Dn(this,Hh):this.between(h,h+vr,!0,!0)},Xe.prototype.startsWithIgnoreCase=function(h){return h===""?this.startsWith(h):ei(this,function(p,y){return p.indexOf(y[0])===0},[h],vr)},Xe.prototype.equalsIgnoreCase=function(h){return ei(this,function(p,y){return p===y[0]},[h],"")},Xe.prototype.anyOfIgnoreCase=function(){var h=ht.apply(ct,arguments);return h.length===0?ra(this):ei(this,function(p,y){return y.indexOf(p)!==-1},h,"")},Xe.prototype.startsWithAnyOfIgnoreCase=function(){var h=ht.apply(ct,arguments);return h.length===0?ra(this):ei(this,function(p,y){return y.some(function(x){return p.indexOf(x)===0})},h,vr)},Xe.prototype.anyOf=function(){var h=this,p=ht.apply(ct,arguments),y=this._cmp;try{p.sort(y)}catch{return Dn(this,ks)}if(p.length===0)return ra(this);var x=new this.Collection(this,function(){return Xs(p[0],p[p.length-1])});x._ondirectionchange=function(E){y=E==="next"?h._ascending:h._descending,p.sort(y)};var S=0;return x._addAlgorithm(function(E,A,V){for(var H=E.key;0<y(H,p[S]);)if(++S===p.length)return A(V),!1;return y(H,p[S])===0||(A(function(){E.continue(p[S])}),!1)}),x},Xe.prototype.notEqual=function(h){return this.inAnyRange([[-1/0,h],[h,this.db._maxKey]],{includeLowers:!1,includeUppers:!1})},Xe.prototype.noneOf=function(){var h=ht.apply(ct,arguments);if(h.length===0)return new this.Collection(this);try{h.sort(this._ascending)}catch{return Dn(this,ks)}var p=h.reduce(function(y,x){return y?y.concat([[y[y.length-1][1],x]]):[[-1/0,x]]},null);return p.push([h[h.length-1],this.db._maxKey]),this.inAnyRange(p,{includeLowers:!1,includeUppers:!1})},Xe.prototype.inAnyRange=function(rt,p){var y=this,x=this._cmp,S=this._ascending,E=this._descending,A=this._min,V=this._max;if(rt.length===0)return ra(this);if(!rt.every(function(it){return it[0]!==void 0&&it[1]!==void 0&&S(it[0],it[1])<=0}))return Dn(this,"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower",vt.InvalidArgument);var H=!p||p.includeLowers!==!1,U=p&&p.includeUppers===!0,J,B=S;function Q(it,ut){return B(it[0],ut[0])}try{(J=rt.reduce(function(it,ut){for(var pt=0,Nt=it.length;pt<Nt;++pt){var At=it[pt];if(x(ut[0],At[1])<0&&0<x(ut[1],At[0])){At[0]=A(At[0],ut[0]),At[1]=V(At[1],ut[1]);break}}return pt===Nt&&it.push(ut),it},[])).sort(Q)}catch{return Dn(this,ks)}var K=0,Y=U?function(it){return 0<S(it,J[K][1])}:function(it){return 0<=S(it,J[K][1])},Z=H?function(it){return 0<E(it,J[K][0])}:function(it){return 0<=E(it,J[K][0])},G=Y,rt=new this.Collection(this,function(){return Xs(J[0][0],J[J.length-1][1],!H,!U)});return rt._ondirectionchange=function(it){B=it==="next"?(G=Y,S):(G=Z,E),J.sort(Q)},rt._addAlgorithm(function(it,ut,pt){for(var Nt,At=it.key;G(At);)if(++K===J.length)return ut(pt),!1;return!Y(Nt=At)&&!Z(Nt)||(y._cmp(At,J[K][1])===0||y._cmp(At,J[K][0])===0||ut(function(){B===S?it.continue(J[K][0]):it.continue(J[K][1])}),!1)}),rt},Xe.prototype.startsWithAnyOf=function(){var h=ht.apply(ct,arguments);return h.every(function(p){return typeof p=="string"})?h.length===0?ra(this):this.inAnyRange(h.map(function(p){return[p,p+vr]})):Dn(this,"startsWithAnyOf() only works with strings")},Xe);function Xe(){}function ns(h){return Ce(function(p){return qa(p),h(p.target.error),!1})}function qa(h){h.stopPropagation&&h.stopPropagation(),h.preventDefault&&h.preventDefault()}var Ha="storagemutated",tc="x-storagemutated-1",Ys=Ba(null,Ha),lw=(ss.prototype._lock=function(){return I(!zt.global),++this._reculock,this._reculock!==1||zt.global||(zt.lockOwnerFor=this),this},ss.prototype._unlock=function(){if(I(!zt.global),--this._reculock==0)for(zt.global||(zt.lockOwnerFor=null);0<this._blockedFuncs.length&&!this._locked();){var h=this._blockedFuncs.shift();try{wr(h[1],h[0])}catch{}}return this},ss.prototype._locked=function(){return this._reculock&&zt.lockOwnerFor!==this},ss.prototype.create=function(h){var p=this;if(!this.mode)return this;var y=this.db.idbdb,x=this.db._state.dbOpenError;if(I(!this.idbtrans),!h&&!y)switch(x&&x.name){case"DatabaseClosedError":throw new vt.DatabaseClosed(x);case"MissingAPIError":throw new vt.MissingAPI(x.message,x);default:throw new vt.OpenFailed(x)}if(!this.active)throw new vt.TransactionInactive;return I(this._completion._state===null),(h=this.idbtrans=h||(this.db.core||y).transaction(this.storeNames,this.mode,{durability:this.chromeTransactionDurability})).onerror=Ce(function(S){qa(S),p._reject(h.error)}),h.onabort=Ce(function(S){qa(S),p.active&&p._reject(new vt.Abort(h.error)),p.active=!1,p.on("abort").fire(S)}),h.oncomplete=Ce(function(){p.active=!1,p._resolve(),"mutatedParts"in h&&Ys.storagemutated.fire(h.mutatedParts)}),this},ss.prototype._promise=function(h,p,y){var x=this;if(h==="readwrite"&&this.mode!=="readwrite")return Ve(new vt.ReadOnly("Transaction is readonly"));if(!this.active)return Ve(new vt.TransactionInactive);if(this._locked())return new Mt(function(E,A){x._blockedFuncs.push([function(){x._promise(h,p,y).then(E,A)},zt])});if(y)return Ks(function(){var E=new Mt(function(A,V){x._lock();var H=p(A,V,x);H&&H.then&&H.then(A,V)});return E.finally(function(){return x._unlock()}),E._lib=!0,E});var S=new Mt(function(E,A){var V=p(E,A,x);V&&V.then&&V.then(E,A)});return S._lib=!0,S},ss.prototype._root=function(){return this.parent?this.parent._root():this},ss.prototype.waitFor=function(h){var p,y=this._root(),x=Mt.resolve(h);y._waitingFor?y._waitingFor=y._waitingFor.then(function(){return x}):(y._waitingFor=x,y._waitingQueue=[],p=y.idbtrans.objectStore(y.storeNames[0]),function E(){for(++y._spinCount;y._waitingQueue.length;)y._waitingQueue.shift()();y._waitingFor&&(p.get(-1/0).onsuccess=E)}());var S=y._waitingFor;return new Mt(function(E,A){x.then(function(V){return y._waitingQueue.push(Ce(E.bind(null,V)))},function(V){return y._waitingQueue.push(Ce(A.bind(null,V)))}).finally(function(){y._waitingFor===S&&(y._waitingFor=null)})})},ss.prototype.abort=function(){this.active&&(this.active=!1,this.idbtrans&&this.idbtrans.abort(),this._reject(new vt.Abort))},ss.prototype.table=function(h){var p=this._memoizedTables||(this._memoizedTables={});if(f(p,h))return p[h];var y=this.schema[h];if(!y)throw new vt.NotFound("Table "+h+" not part of transaction");return y=new this.db.Table(h,y,this),y.core=this.db.core.table(h),p[h]=y},ss);function ss(){}function ec(h,p,y,x,S,E,A){return{name:h,keyPath:p,unique:y,multi:x,auto:S,compound:E,src:(y&&!A?"&":"")+(x?"*":"")+(S?"++":"")+nd(p)}}function nd(h){return typeof h=="string"?h:h?"["+[].join.call(h,"+")+"]":""}function nc(h,p,y){return{name:h,primKey:p,indexes:y,mappedClass:null,idxByName:(x=function(S){return[S.name,S]},y.reduce(function(S,E,A){return A=x(E,A),A&&(S[A[0]]=A[1]),S},{}))};var x}var Ka=function(h){try{return h.only([[]]),Ka=function(){return[[]]},[[]]}catch{return Ka=function(){return vr},vr}};function sc(h){return h==null?function(){}:typeof h=="string"?(p=h).split(".").length===1?function(y){return y[p]}:function(y){return O(y,p)}:function(y){return O(y,h)};var p}function sd(h){return[].slice.call(h)}var fw=0;function Ua(h){return h==null?":id":typeof h=="string"?h:"[".concat(h.join("+"),"]")}function hw(h,p,H){function x(G){if(G.type===3)return null;if(G.type===4)throw new Error("Cannot convert never type to IDBKeyRange");var K=G.lower,Y=G.upper,Z=G.lowerOpen,G=G.upperOpen;return K===void 0?Y===void 0?null:p.upperBound(Y,!!G):Y===void 0?p.lowerBound(K,!!Z):p.bound(K,Y,!!Z,!!G)}function S(Q){var K,Y=Q.name;return{name:Y,schema:Q,mutate:function(Z){var G=Z.trans,rt=Z.type,it=Z.keys,ut=Z.values,pt=Z.range;return new Promise(function(Nt,At){Nt=Ce(Nt);var _t=G.objectStore(Y),Ot=_t.keyPath==null,Rt=rt==="put"||rt==="add";if(!Rt&&rt!=="delete"&&rt!=="deleteRange")throw new Error("Invalid operation type: "+rt);var Dt,Wt=(it||ut||{length:1}).length;if(it&&ut&&it.length!==ut.length)throw new Error("Given keys array must have same length as given values array.");if(Wt===0)return Nt({numFailures:0,failures:{},results:[],lastResult:void 0});function se(yn){++An,qa(yn)}var ie=[],ue=[],An=0;if(rt==="deleteRange"){if(pt.type===4)return Nt({numFailures:An,failures:ue,results:[],lastResult:void 0});pt.type===3?ie.push(Dt=_t.clear()):ie.push(Dt=_t.delete(x(pt)))}else{var Ot=Rt?Ot?[ut,it]:[ut,null]:[it,null],te=Ot[0],sn=Ot[1];if(Rt)for(var rn=0;rn<Wt;++rn)ie.push(Dt=sn&&sn[rn]!==void 0?_t[rt](te[rn],sn[rn]):_t[rt](te[rn])),Dt.onerror=se;else for(rn=0;rn<Wt;++rn)ie.push(Dt=_t[rt](te[rn])),Dt.onerror=se}function pi(yn){yn=yn.target.result,ie.forEach(function(Ir,kc){return Ir.error!=null&&(ue[kc]=Ir.error)}),Nt({numFailures:An,failures:ue,results:rt==="delete"?it:ie.map(function(Ir){return Ir.result}),lastResult:yn})}Dt.onerror=function(yn){se(yn),pi(yn)},Dt.onsuccess=pi})},getMany:function(Z){var G=Z.trans,rt=Z.keys;return new Promise(function(it,ut){it=Ce(it);for(var pt,Nt=G.objectStore(Y),At=rt.length,_t=new Array(At),Ot=0,Rt=0,Dt=function(ie){ie=ie.target,_t[ie._pos]=ie.result,++Rt===Ot&&it(_t)},Wt=ns(ut),se=0;se<At;++se)rt[se]!=null&&((pt=Nt.get(rt[se]))._pos=se,pt.onsuccess=Dt,pt.onerror=Wt,++Ot);Ot===0&&it(_t)})},get:function(Z){var G=Z.trans,rt=Z.key;return new Promise(function(it,ut){it=Ce(it);var pt=G.objectStore(Y).get(rt);pt.onsuccess=function(Nt){return it(Nt.target.result)},pt.onerror=ns(ut)})},query:(K=U,function(Z){return new Promise(function(G,rt){G=Ce(G);var it,ut,pt,Ot=Z.trans,Nt=Z.values,At=Z.limit,Dt=Z.query,_t=At===1/0?void 0:At,Rt=Dt.index,Dt=Dt.range,Ot=Ot.objectStore(Y),Rt=Rt.isPrimaryKey?Ot:Ot.index(Rt.name),Dt=x(Dt);if(At===0)return G({result:[]});K?((_t=Nt?Rt.getAll(Dt,_t):Rt.getAllKeys(Dt,_t)).onsuccess=function(Wt){return G({result:Wt.target.result})},_t.onerror=ns(rt)):(it=0,ut=!Nt&&"openKeyCursor"in Rt?Rt.openKeyCursor(Dt):Rt.openCursor(Dt),pt=[],ut.onsuccess=function(Wt){var se=ut.result;return se?(pt.push(Nt?se.value:se.primaryKey),++it===At?G({result:pt}):void se.continue()):G({result:pt})},ut.onerror=ns(rt))})}),openCursor:function(Z){var G=Z.trans,rt=Z.values,it=Z.query,ut=Z.reverse,pt=Z.unique;return new Promise(function(Nt,At){Nt=Ce(Nt);var Rt=it.index,_t=it.range,Ot=G.objectStore(Y),Ot=Rt.isPrimaryKey?Ot:Ot.index(Rt.name),Rt=ut?pt?"prevunique":"prev":pt?"nextunique":"next",Dt=!rt&&"openKeyCursor"in Ot?Ot.openKeyCursor(x(_t),Rt):Ot.openCursor(x(_t),Rt);Dt.onerror=ns(At),Dt.onsuccess=Ce(function(Wt){var se,ie,ue,An,te=Dt.result;te?(te.___id=++fw,te.done=!1,se=te.continue.bind(te),ie=(ie=te.continuePrimaryKey)&&ie.bind(te),ue=te.advance.bind(te),An=function(){throw new Error("Cursor not stopped")},te.trans=G,te.stop=te.continue=te.continuePrimaryKey=te.advance=function(){throw new Error("Cursor not started")},te.fail=Ce(At),te.next=function(){var sn=this,rn=1;return this.start(function(){return rn--?sn.continue():sn.stop()}).then(function(){return sn})},te.start=function(sn){function rn(){if(Dt.result)try{sn()}catch(yn){te.fail(yn)}else te.done=!0,te.start=function(){throw new Error("Cursor behind last entry")},te.stop()}var pi=new Promise(function(yn,Ir){yn=Ce(yn),Dt.onerror=ns(Ir),te.fail=Ir,te.stop=function(kc){te.stop=te.continue=te.continuePrimaryKey=te.advance=An,yn(kc)}});return Dt.onsuccess=Ce(function(yn){Dt.onsuccess=rn,rn()}),te.continue=se,te.continuePrimaryKey=ie,te.advance=ue,rn(),pi},Nt(te)):Nt(null)},At)})},count:function(Z){var G=Z.query,rt=Z.trans,it=G.index,ut=G.range;return new Promise(function(pt,Nt){var At=rt.objectStore(Y),_t=it.isPrimaryKey?At:At.index(it.name),At=x(ut),_t=At?_t.count(At):_t.count();_t.onsuccess=Ce(function(Ot){return pt(Ot.target.result)}),_t.onerror=ns(Nt)})}}}var E,A,V,J=(A=H,V=sd((E=h).objectStoreNames),{schema:{name:E.name,tables:V.map(function(Q){return A.objectStore(Q)}).map(function(Q){var K=Q.keyPath,G=Q.autoIncrement,Y=i(K),Z={},G={name:Q.name,primaryKey:{name:null,isPrimaryKey:!0,outbound:K==null,compound:Y,keyPath:K,autoIncrement:G,unique:!0,extractKey:sc(K)},indexes:sd(Q.indexNames).map(function(rt){return Q.index(rt)}).map(function(pt){var it=pt.name,ut=pt.unique,Nt=pt.multiEntry,pt=pt.keyPath,Nt={name:it,compound:i(pt),keyPath:pt,unique:ut,multiEntry:Nt,extractKey:sc(pt)};return Z[Ua(pt)]=Nt}),getIndexByKeyPath:function(rt){return Z[Ua(rt)]}};return Z[":id"]=G.primaryKey,K!=null&&(Z[Ua(K)]=G.primaryKey),G})},hasGetAll:0<V.length&&"getAll"in A.objectStore(V[0])&&!(typeof navigator<"u"&&/Safari/.test(navigator.userAgent)&&!/(Chrome\/|Edge\/)/.test(navigator.userAgent)&&[].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1]<604)}),H=J.schema,U=J.hasGetAll,J=H.tables.map(S),B={};return J.forEach(function(Q){return B[Q.name]=Q}),{stack:"dbcore",transaction:h.transaction.bind(h),table:function(Q){if(!B[Q])throw new Error("Table '".concat(Q,"' not found"));return B[Q]},MIN_KEY:-1/0,MAX_KEY:Ka(p),schema:H}}function dw(h,p,y,x){var S=y.IDBKeyRange;return y.indexedDB,{dbcore:(x=hw(p,S,x),h.dbcore.reduce(function(E,A){return A=A.create,s(s({},E),A(E))},x))}}function ni(h,x){var y=x.db,x=dw(h._middlewares,y,h._deps,x);h.core=x.dbcore,h.tables.forEach(function(S){var E=S.name;h.core.schema.tables.some(function(A){return A.name===E})&&(S.core=h.core.table(E),h[E]instanceof h.Table&&(h[E].core=S.core))})}function si(h,p,y,x){y.forEach(function(S){var E=x[S];p.forEach(function(A){var V=function H(U,J){return w(U,J)||(U=c(U))&&H(U,J)}(A,S);(!V||"value"in V&&V.value===void 0)&&(A===h.Transaction.prototype||A instanceof h.Transaction?g(A,S,{get:function(){return this.table(S)},set:function(H){m(this,S,{value:H,writable:!0,configurable:!0,enumerable:!0})}}):A[S]=new h.Table(S,E))})})}function rc(h,p){p.forEach(function(y){for(var x in y)y[x]instanceof h.Table&&delete y[x]})}function pw(h,p){return h._cfg.version-p._cfg.version}function mw(h,p,y,x){var S=h._dbSchema;y.objectStoreNames.contains("$meta")&&!S.$meta&&(S.$meta=nc("$meta",ad("")[0],[]),h._storeNames.push("$meta"));var E=h._createTransaction("readwrite",h._storeNames,S);E.create(y),E._completion.catch(x);var A=E._reject.bind(E),V=zt.transless||zt;Ks(function(){return zt.trans=E,zt.transless=V,p!==0?(ni(h,y),U=p,((H=E).storeNames.includes("$meta")?H.table("$meta").get("version").then(function(J){return J??U}):Mt.resolve(U)).then(function(J){return Q=J,K=E,Y=y,Z=[],J=(B=h)._versions,G=B._dbSchema=ai(0,B.idbdb,Y),(J=J.filter(function(rt){return rt._cfg.version>=Q})).length!==0?(J.forEach(function(rt){Z.push(function(){var it=G,ut=rt._cfg.dbschema;oi(B,it,Y),oi(B,ut,Y),G=B._dbSchema=ut;var pt=ac(it,ut);pt.add.forEach(function(Rt){oc(Y,Rt[0],Rt[1].primKey,Rt[1].indexes)}),pt.change.forEach(function(Rt){if(Rt.recreate)throw new vt.Upgrade("Not yet support for changing primary key");var Dt=Y.objectStore(Rt.name);Rt.add.forEach(function(Wt){return ri(Dt,Wt)}),Rt.change.forEach(function(Wt){Dt.deleteIndex(Wt.name),ri(Dt,Wt)}),Rt.del.forEach(function(Wt){return Dt.deleteIndex(Wt)})});var Nt=rt._cfg.contentUpgrade;if(Nt&&rt._cfg.version>Q){ni(B,Y),K._memoizedTables={};var At=W(ut);pt.del.forEach(function(Rt){At[Rt]=it[Rt]}),rc(B,[B.Transaction.prototype]),si(B,[B.Transaction.prototype],o(At),At),K.schema=At;var _t,Ot=gt(Nt);return Ot&&ea(),pt=Mt.follow(function(){var Rt;(_t=Nt(K))&&Ot&&(Rt=Us.bind(null,null),_t.then(Rt,Rt))}),_t&&typeof _t.then=="function"?Mt.resolve(_t):pt.then(function(){return _t})}}),Z.push(function(it){var ut,pt,Nt=rt._cfg.dbschema;ut=Nt,pt=it,[].slice.call(pt.db.objectStoreNames).forEach(function(At){return ut[At]==null&&pt.db.deleteObjectStore(At)}),rc(B,[B.Transaction.prototype]),si(B,[B.Transaction.prototype],B._storeNames,B._dbSchema),K.schema=B._dbSchema}),Z.push(function(it){B.idbdb.objectStoreNames.contains("$meta")&&(Math.ceil(B.idbdb.version/10)===rt._cfg.version?(B.idbdb.deleteObjectStore("$meta"),delete B._dbSchema.$meta,B._storeNames=B._storeNames.filter(function(ut){return ut!=="$meta"})):it.objectStore("$meta").put(rt._cfg.version,"version"))})}),function rt(){return Z.length?Mt.resolve(Z.shift()(K.idbtrans)).then(rt):Mt.resolve()}().then(function(){rd(G,Y)})):Mt.resolve();var B,Q,K,Y,Z,G}).catch(A)):(o(S).forEach(function(J){oc(y,J,S[J].primKey,S[J].indexes)}),ni(h,y),void Mt.follow(function(){return h.on.populate.fire(E)}).catch(A));var H,U})}function gw(h,p){rd(h._dbSchema,p),p.db.version%10!=0||p.objectStoreNames.contains("$meta")||p.db.createObjectStore("$meta").add(Math.ceil(p.db.version/10-1),"version");var y=ai(0,h.idbdb,p);oi(h,h._dbSchema,p);for(var x=0,S=ac(y,h._dbSchema).change;x<S.length;x++){var E=function(A){if(A.change.length||A.recreate)return console.warn("Unable to patch indexes of table ".concat(A.name," because it has changes on the type of index or primary key.")),{value:void 0};var V=p.objectStore(A.name);A.add.forEach(function(H){yt&&console.debug("Dexie upgrade patch: Creating missing index ".concat(A.name,".").concat(H.src)),ri(V,H)})}(S[x]);if(typeof E=="object")return E.value}}function ac(h,p){var y,x={del:[],add:[],change:[]};for(y in h)p[y]||x.del.push(y);for(y in p){var S=h[y],E=p[y];if(S){var A={name:y,def:E,recreate:!1,del:[],add:[],change:[]};if(""+(S.primKey.keyPath||"")!=""+(E.primKey.keyPath||"")||S.primKey.auto!==E.primKey.auto)A.recreate=!0,x.change.push(A);else{var V=S.idxByName,H=E.idxByName,U=void 0;for(U in V)H[U]||A.del.push(U);for(U in H){var J=V[U],B=H[U];J?J.src!==B.src&&A.change.push(B):A.add.push(B)}(0<A.del.length||0<A.add.length||0<A.change.length)&&x.change.push(A)}}else x.add.push([y,E])}return x}function oc(h,p,y,x){var S=h.db.createObjectStore(p,y.keyPath?{keyPath:y.keyPath,autoIncrement:y.auto}:{autoIncrement:y.auto});return x.forEach(function(E){return ri(S,E)}),S}function rd(h,p){o(h).forEach(function(y){p.db.objectStoreNames.contains(y)||(yt&&console.debug("Dexie: Creating missing table",y),oc(p,y,h[y].primKey,h[y].indexes))})}function ri(h,p){h.createIndex(p.name,p.keyPath,{unique:p.unique,multiEntry:p.multi})}function ai(h,p,y){var x={};return N(p.objectStoreNames,0).forEach(function(S){for(var E=y.objectStore(S),A=ec(nd(U=E.keyPath),U||"",!0,!1,!!E.autoIncrement,U&&typeof U!="string",!0),V=[],H=0;H<E.indexNames.length;++H){var J=E.index(E.indexNames[H]),U=J.keyPath,J=ec(J.name,U,!!J.unique,!!J.multiEntry,!1,U&&typeof U!="string",!1);V.push(J)}x[S]=nc(S,A,V)}),x}function oi(h,p,y){for(var x=y.db.objectStoreNames,S=0;S<x.length;++S){var E=x[S],A=y.objectStore(E);h._hasGetAll="getAll"in A;for(var V=0;V<A.indexNames.length;++V){var H=A.indexNames[V],U=A.index(H).keyPath,J=typeof U=="string"?U:"["+N(U).join("+")+"]";!p[E]||(U=p[E].idxByName[J])&&(U.name=H,delete p[E].idxByName[J],p[E].idxByName[H]=U)}}typeof navigator<"u"&&/Safari/.test(navigator.userAgent)&&!/(Chrome\/|Edge\/)/.test(navigator.userAgent)&&a.WorkerGlobalScope&&a instanceof a.WorkerGlobalScope&&[].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1]<604&&(h._hasGetAll=!1)}function ad(h){return h.split(",").map(function(p,y){var x=(p=p.trim()).replace(/([&*]|\+\+)/g,""),S=/^\[/.test(x)?x.match(/^\[(.*)\]$/)[1].split("+"):x;return ec(x,S||null,/\&/.test(p),/\*/.test(p),/\+\+/.test(p),i(S),y===0)})}var yw=(ii.prototype._parseStoresSpec=function(h,p){o(h).forEach(function(y){if(h[y]!==null){var x=ad(h[y]),S=x.shift();if(S.unique=!0,S.multi)throw new vt.Schema("Primary key cannot be multi-valued");x.forEach(function(E){if(E.auto)throw new vt.Schema("Only primary key can be marked as autoIncrement (++)");if(!E.keyPath)throw new vt.Schema("Index must have a name and cannot be an empty string")}),p[y]=nc(y,S,x)}})},ii.prototype.stores=function(y){var p=this.db;this._cfg.storesSource=this._cfg.storesSource?u(this._cfg.storesSource,y):y;var y=p._versions,x={},S={};return y.forEach(function(E){u(x,E._cfg.storesSource),S=E._cfg.dbschema={},E._parseStoresSpec(x,S)}),p._dbSchema=S,rc(p,[p._allTables,p,p.Transaction.prototype]),si(p,[p._allTables,p,p.Transaction.prototype,this._cfg.tables],o(S),S),p._storeNames=o(S),this},ii.prototype.upgrade=function(h){return this._cfg.contentUpgrade=kt(this._cfg.contentUpgrade||F,h),this},ii);function ii(){}function ic(h,p){var y=h._dbNamesDB;return y||(y=h._dbNamesDB=new xs(Jo,{addons:[],indexedDB:h,IDBKeyRange:p})).version(1).stores({dbnames:"name"}),y.table("dbnames")}function uc(h){return h&&typeof h.databases=="function"}function cc(h){return Ks(function(){return zt.letThrough=!0,h()})}function lc(h){return!("from"in h)}var nn=function(h,p){if(!this){var y=new nn;return h&&"d"in h&&u(y,h),y}u(this,arguments.length?{d:1,from:h,to:1<arguments.length?p:h}:{d:0})};function Ga(h,p,y){var x=le(p,y);if(!isNaN(x)){if(0<x)throw RangeError();if(lc(h))return u(h,{from:p,to:y,d:1});var S=h.l,x=h.r;if(le(y,h.from)<0)return S?Ga(S,p,y):h.l={from:p,to:y,d:1,l:null,r:null},id(h);if(0<le(p,h.to))return x?Ga(x,p,y):h.r={from:p,to:y,d:1,l:null,r:null},id(h);le(p,h.from)<0&&(h.from=p,h.l=null,h.d=x?x.d+1:1),0<le(y,h.to)&&(h.to=y,h.r=null,h.d=h.l?h.l.d+1:1),y=!h.r,S&&!h.l&&Xa(h,S),x&&y&&Xa(h,x)}}function Xa(h,p){lc(p)||function y(x,H){var E=H.from,A=H.to,V=H.l,H=H.r;Ga(x,E,A),V&&y(x,V),H&&y(x,H)}(h,p)}function od(h,p){var y=ui(p),x=y.next();if(x.done)return!1;for(var S=x.value,E=ui(h),A=E.next(S.from),V=A.value;!x.done&&!A.done;){if(le(V.from,S.to)<=0&&0<=le(V.to,S.from))return!0;le(S.from,V.from)<0?S=(x=y.next(V.from)).value:V=(A=E.next(S.from)).value}return!1}function ui(h){var p=lc(h)?null:{s:0,n:h};return{next:function(y){for(var x=0<arguments.length;p;)switch(p.s){case 0:if(p.s=1,x)for(;p.n.l&&le(y,p.n.from)<0;)p={up:p,n:p.n.l,s:1};else for(;p.n.l;)p={up:p,n:p.n.l,s:1};case 1:if(p.s=2,!x||le(y,p.n.to)<=0)return{value:p.n,done:!1};case 2:if(p.n.r){p.s=3,p={up:p,n:p.n.r,s:0};continue}case 3:p=p.up}return{done:!0}}}}function id(h){var p,y,x=(((p=h.r)===null||p===void 0?void 0:p.d)||0)-(((y=h.l)===null||y===void 0?void 0:y.d)||0),S=1<x?"r":x<-1?"l":"";S&&(p=S=="r"?"l":"r",y=s({},h),x=h[S],h.from=x.from,h.to=x.to,h[S]=x[S],y[S]=x[p],(h[p]=y).d=ud(y)),h.d=ud(h)}function ud(y){var p=y.r,y=y.l;return(p?y?Math.max(p.d,y.d):p.d:y?y.d:0)+1}function ci(h,p){return o(p).forEach(function(y){h[y]?Xa(h[y],p[y]):h[y]=function x(S){var E,A,V={};for(E in S)f(S,E)&&(A=S[E],V[E]=!A||typeof A!="object"||T.has(A.constructor)?A:x(A));return V}(p[y])}),h}function fc(h,p){return h.all||p.all||Object.keys(h).some(function(y){return p[y]&&od(p[y],h[y])})}d(nn.prototype,((zn={add:function(h){return Xa(this,h),this},addKey:function(h){return Ga(this,h,h),this},addKeys:function(h){var p=this;return h.forEach(function(y){return Ga(p,y,y)}),this},hasKey:function(h){var p=ui(this).next(h).value;return p&&le(p.from,h)<=0&&0<=le(p.to,h)}})[nt]=function(){return ui(this)},zn));var xr={},hc={},dc=!1;function li(h){ci(hc,h),dc||(dc=!0,setTimeout(function(){dc=!1,pc(hc,!(hc={}))},0))}function pc(h,p){p===void 0&&(p=!1);var y=new Set;if(h.all)for(var x=0,S=Object.values(xr);x<S.length;x++)cd(A=S[x],h,y,p);else for(var E in h){var A,V=/^idb\:\/\/(.*)\/(.*)\//.exec(E);V&&(E=V[1],V=V[2],(A=xr["idb://".concat(E,"/").concat(V)])&&cd(A,h,y,p))}y.forEach(function(H){return H()})}function cd(h,p,y,x){for(var S=[],E=0,A=Object.entries(h.queries.query);E<A.length;E++){for(var V=A[E],H=V[0],U=[],J=0,B=V[1];J<B.length;J++){var Q=B[J];fc(p,Q.obsSet)?Q.subscribers.forEach(function(G){return y.add(G)}):x&&U.push(Q)}x&&S.push([H,U])}if(x)for(var K=0,Y=S;K<Y.length;K++){var Z=Y[K],H=Z[0],U=Z[1];h.queries.query[H]=U}}function bw(h){var p=h._state,y=h._deps.indexedDB;if(p.isBeingOpened||h.idbdb)return p.dbReadyPromise.then(function(){return p.dbOpenError?Ve(p.dbOpenError):h});p.isBeingOpened=!0,p.dbOpenError=null,p.openComplete=!1;var x=p.openCanceller,S=Math.round(10*h.verno),E=!1;function A(){if(p.openCanceller!==x)throw new vt.DatabaseClosed("db.open() was cancelled")}function V(){return new Mt(function(Q,K){if(A(),!y)throw new vt.MissingAPI;var Y=h.name,Z=p.autoSchema||!S?y.open(Y):y.open(Y,S);if(!Z)throw new vt.MissingAPI;Z.onerror=ns(K),Z.onblocked=Ce(h._fireOnBlocked),Z.onupgradeneeded=Ce(function(G){var rt;J=Z.transaction,p.autoSchema&&!h._options.allowEmptyDB?(Z.onerror=qa,J.abort(),Z.result.close(),(rt=y.deleteDatabase(Y)).onsuccess=rt.onerror=Ce(function(){K(new vt.NoSuchDatabase("Database ".concat(Y," doesnt exist")))})):(J.onerror=ns(K),G=G.oldVersion>Math.pow(2,62)?0:G.oldVersion,B=G<1,h.idbdb=Z.result,E&&gw(h,J),mw(h,G/10,J,K))},K),Z.onsuccess=Ce(function(){J=null;var G,rt,it,ut,pt,Nt=h.idbdb=Z.result,At=N(Nt.objectStoreNames);if(0<At.length)try{var _t=Nt.transaction((ut=At).length===1?ut[0]:ut,"readonly");if(p.autoSchema)rt=Nt,it=_t,(G=h).verno=rt.version/10,it=G._dbSchema=ai(0,rt,it),G._storeNames=N(rt.objectStoreNames,0),si(G,[G._allTables],o(it),it);else if(oi(h,h._dbSchema,_t),((pt=ac(ai(0,(pt=h).idbdb,_t),pt._dbSchema)).add.length||pt.change.some(function(Ot){return Ot.add.length||Ot.change.length}))&&!E)return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."),Nt.close(),S=Nt.version+1,E=!0,Q(V());ni(h,_t)}catch{}na.push(h),Nt.onversionchange=Ce(function(Ot){p.vcFired=!0,h.on("versionchange").fire(Ot)}),Nt.onclose=Ce(function(Ot){h.on("close").fire(Ot)}),B&&(pt=h._deps,_t=Y,Nt=pt.indexedDB,pt=pt.IDBKeyRange,uc(Nt)||_t===Jo||ic(Nt,pt).put({name:_t}).catch(F)),Q()},K)}).catch(function(Q){switch(Q==null?void 0:Q.name){case"UnknownError":if(0<p.PR1398_maxLoop)return p.PR1398_maxLoop--,console.warn("Dexie: Workaround for Chrome UnknownError on open()"),V();break;case"VersionError":if(0<S)return S=0,V()}return Mt.reject(Q)})}var H,U=p.dbReadyResolve,J=null,B=!1;return Mt.race([x,(typeof navigator>"u"?Mt.resolve():!navigator.userAgentData&&/Safari\//.test(navigator.userAgent)&&!/Chrom(e|ium)\//.test(navigator.userAgent)&&indexedDB.databases?new Promise(function(Q){function K(){return indexedDB.databases().finally(Q)}H=setInterval(K,100),K()}).finally(function(){return clearInterval(H)}):Promise.resolve()).then(V)]).then(function(){return A(),p.onReadyBeingFired=[],Mt.resolve(cc(function(){return h.on.ready.fire(h.vip)})).then(function Q(){if(0<p.onReadyBeingFired.length){var K=p.onReadyBeingFired.reduce(kt,F);return p.onReadyBeingFired=[],Mt.resolve(cc(function(){return K(h.vip)})).then(Q)}})}).finally(function(){p.openCanceller===x&&(p.onReadyBeingFired=null,p.isBeingOpened=!1)}).catch(function(Q){p.dbOpenError=Q;try{J&&J.abort()}catch{}return x===p.openCanceller&&h._close(),Ve(Q)}).finally(function(){p.openComplete=!0,U()}).then(function(){var Q;return B&&(Q={},h.tables.forEach(function(K){K.schema.indexes.forEach(function(Y){Y.name&&(Q["idb://".concat(h.name,"/").concat(K.name,"/").concat(Y.name)]=new nn(-1/0,[[[]]]))}),Q["idb://".concat(h.name,"/").concat(K.name,"/")]=Q["idb://".concat(h.name,"/").concat(K.name,"/:dels")]=new nn(-1/0,[[[]]])}),Ys(Ha).fire(Q),pc(Q,!0)),h})}function mc(h){function p(E){return h.next(E)}var y=S(p),x=S(function(E){return h.throw(E)});function S(E){return function(H){var V=E(H),H=V.value;return V.done?H:H&&typeof H.then=="function"?H.then(y,x):i(H)?Promise.all(H).then(y,x):y(H)}}return S(p)()}function fi(h,p,y){for(var x=i(h)?h.slice():[h],S=0;S<y;++S)x.push(p);return x}var ww={stack:"dbcore",name:"VirtualIndexMiddleware",level:1,create:function(h){return s(s({},h),{table:function(p){var y=h.table(p),x=y.schema,S={},E=[];function A(B,Q,K){var Y=Ua(B),Z=S[Y]=S[Y]||[],G=B==null?0:typeof B=="string"?1:B.length,rt=0<Q,rt=s(s({},K),{name:rt?"".concat(Y,"(virtual-from:").concat(K.name,")"):K.name,lowLevelIndex:K,isVirtual:rt,keyTail:Q,keyLength:G,extractKey:sc(B),unique:!rt&&K.unique});return Z.push(rt),rt.isPrimaryKey||E.push(rt),1<G&&A(G===2?B[0]:B.slice(0,G-1),Q+1,K),Z.sort(function(it,ut){return it.keyTail-ut.keyTail}),rt}p=A(x.primaryKey.keyPath,0,x.primaryKey),S[":id"]=[p];for(var V=0,H=x.indexes;V<H.length;V++){var U=H[V];A(U.keyPath,0,U)}function J(B){var Q,K=B.query.index;return K.isVirtual?s(s({},B),{query:{index:K.lowLevelIndex,range:(Q=B.query.range,K=K.keyTail,{type:Q.type===1?2:Q.type,lower:fi(Q.lower,Q.lowerOpen?h.MAX_KEY:h.MIN_KEY,K),lowerOpen:!0,upper:fi(Q.upper,Q.upperOpen?h.MIN_KEY:h.MAX_KEY,K),upperOpen:!0})}}):B}return s(s({},y),{schema:s(s({},x),{primaryKey:p,indexes:E,getIndexByKeyPath:function(B){return(B=S[Ua(B)])&&B[0]}}),count:function(B){return y.count(J(B))},query:function(B){return y.query(J(B))},openCursor:function(B){var Q=B.query.index,K=Q.keyTail,Y=Q.isVirtual,Z=Q.keyLength;return Y?y.openCursor(J(B)).then(function(rt){return rt&&G(rt)}):y.openCursor(B);function G(rt){return Object.create(rt,{continue:{value:function(it){it!=null?rt.continue(fi(it,B.reverse?h.MAX_KEY:h.MIN_KEY,K)):B.unique?rt.continue(rt.key.slice(0,Z).concat(B.reverse?h.MIN_KEY:h.MAX_KEY,K)):rt.continue()}},continuePrimaryKey:{value:function(it,ut){rt.continuePrimaryKey(fi(it,h.MAX_KEY,K),ut)}},primaryKey:{get:function(){return rt.primaryKey}},key:{get:function(){var it=rt.key;return Z===1?it[0]:it.slice(0,Z)}},value:{get:function(){return rt.value}}})}}})}})}};function gc(h,p,y,x){return y=y||{},x=x||"",o(h).forEach(function(S){var E,A,V;f(p,S)?(E=h[S],A=p[S],typeof E=="object"&&typeof A=="object"&&E&&A?(V=et(E))!==et(A)?y[x+S]=p[S]:V==="Object"?gc(E,A,y,x+S+"."):E!==A&&(y[x+S]=p[S]):E!==A&&(y[x+S]=p[S])):y[x+S]=void 0}),o(p).forEach(function(S){f(h,S)||(y[x+S]=p[S])}),y}function yc(h,p){return p.type==="delete"?p.keys:p.keys||p.values.map(h.extractKey)}var vw={stack:"dbcore",name:"HooksMiddleware",level:2,create:function(h){return s(s({},h),{table:function(p){var y=h.table(p),x=y.schema.primaryKey;return s(s({},y),{mutate:function(S){var E=zt.trans,A=E.table(p).hook,V=A.deleting,H=A.creating,U=A.updating;switch(S.type){case"add":if(H.fire===F)break;return E._promise("readwrite",function(){return J(S)},!0);case"put":if(H.fire===F&&U.fire===F)break;return E._promise("readwrite",function(){return J(S)},!0);case"delete":if(V.fire===F)break;return E._promise("readwrite",function(){return J(S)},!0);case"deleteRange":if(V.fire===F)break;return E._promise("readwrite",function(){return function B(Q,K,Y){return y.query({trans:Q,values:!1,query:{index:x,range:K},limit:Y}).then(function(Z){var G=Z.result;return J({type:"delete",keys:G,trans:Q}).then(function(rt){return 0<rt.numFailures?Promise.reject(rt.failures[0]):G.length<Y?{failures:[],numFailures:0,lastResult:void 0}:B(Q,s(s({},K),{lower:G[G.length-1],lowerOpen:!0}),Y)})})}(S.trans,S.range,1e4)},!0)}return y.mutate(S);function J(B){var Q,K,Y,Z=zt.trans,G=B.keys||yc(x,B);if(!G)throw new Error("Keys missing");return(B=B.type==="add"||B.type==="put"?s(s({},B),{keys:G}):s({},B)).type!=="delete"&&(B.values=r([],B.values)),B.keys&&(B.keys=r([],B.keys)),Q=y,Y=G,((K=B).type==="add"?Promise.resolve([]):Q.getMany({trans:K.trans,keys:Y,cache:"immutable"})).then(function(rt){var it=G.map(function(ut,pt){var Nt,At,_t,Ot=rt[pt],Rt={onerror:null,onsuccess:null};return B.type==="delete"?V.fire.call(Rt,ut,Ot,Z):B.type==="add"||Ot===void 0?(Nt=H.fire.call(Rt,ut,B.values[pt],Z),ut==null&&Nt!=null&&(B.keys[pt]=ut=Nt,x.outbound||R(B.values[pt],x.keyPath,ut))):(Nt=gc(Ot,B.values[pt]),(At=U.fire.call(Rt,Nt,ut,Ot,Z))&&(_t=B.values[pt],Object.keys(At).forEach(function(Dt){f(_t,Dt)?_t[Dt]=At[Dt]:R(_t,Dt,At[Dt])}))),Rt});return y.mutate(B).then(function(ut){for(var pt=ut.failures,Nt=ut.results,At=ut.numFailures,ut=ut.lastResult,_t=0;_t<G.length;++_t){var Ot=(Nt||G)[_t],Rt=it[_t];Ot==null?Rt.onerror&&Rt.onerror(pt[_t]):Rt.onsuccess&&Rt.onsuccess(B.type==="put"&&rt[_t]?B.values[_t]:Ot)}return{failures:pt,results:Nt,numFailures:At,lastResult:ut}}).catch(function(ut){return it.forEach(function(pt){return pt.onerror&&pt.onerror(ut)}),Promise.reject(ut)})})}}})}})}};function ld(h,p,y){try{if(!p||p.keys.length<h.length)return null;for(var x=[],S=0,E=0;S<p.keys.length&&E<h.length;++S)le(p.keys[S],h[E])===0&&(x.push(y?X(p.values[S]):p.values[S]),++E);return x.length===h.length?x:null}catch{return null}}var kw={stack:"dbcore",level:-1,create:function(h){return{table:function(p){var y=h.table(p);return s(s({},y),{getMany:function(x){if(!x.cache)return y.getMany(x);var S=ld(x.keys,x.trans._cache,x.cache==="clone");return S?Mt.resolve(S):y.getMany(x).then(function(E){return x.trans._cache={keys:x.keys,values:x.cache==="clone"?X(E):E},E})},mutate:function(x){return x.type!=="add"&&(x.trans._cache=null),y.mutate(x)}})}}}};function fd(h,p){return h.trans.mode==="readonly"&&!!h.subscr&&!h.trans.explicit&&h.trans.db._options.cache!=="disabled"&&!p.schema.primaryKey.outbound}function hd(h,p){switch(h){case"query":return p.values&&!p.unique;case"get":case"getMany":case"count":case"openCursor":return!1}}var xw={stack:"dbcore",level:0,name:"Observability",create:function(h){var p=h.schema.name,y=new nn(h.MIN_KEY,h.MAX_KEY);return s(s({},h),{transaction:function(x,S,E){if(zt.subscr&&S!=="readonly")throw new vt.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(zt.querier));return h.transaction(x,S,E)},table:function(x){var S=h.table(x),E=S.schema,A=E.primaryKey,B=E.indexes,V=A.extractKey,H=A.outbound,U=A.autoIncrement&&B.filter(function(K){return K.compound&&K.keyPath.includes(A.keyPath)}),J=s(s({},S),{mutate:function(K){function Y(Dt){return Dt="idb://".concat(p,"/").concat(x,"/").concat(Dt),ut[Dt]||(ut[Dt]=new nn)}var Z,G,rt,it=K.trans,ut=K.mutatedParts||(K.mutatedParts={}),pt=Y(""),Nt=Y(":dels"),At=K.type,Rt=K.type==="deleteRange"?[K.range]:K.type==="delete"?[K.keys]:K.values.length<50?[yc(A,K).filter(function(Dt){return Dt}),K.values]:[],_t=Rt[0],Ot=Rt[1],Rt=K.trans._cache;return i(_t)?(pt.addKeys(_t),(Rt=At==="delete"||_t.length===Ot.length?ld(_t,Rt):null)||Nt.addKeys(_t),(Rt||Ot)&&(Z=Y,G=Rt,rt=Ot,E.indexes.forEach(function(Dt){var Wt=Z(Dt.name||"");function se(ue){return ue!=null?Dt.extractKey(ue):null}function ie(ue){return Dt.multiEntry&&i(ue)?ue.forEach(function(An){return Wt.addKey(An)}):Wt.addKey(ue)}(G||rt).forEach(function(ue,sn){var te=G&&se(G[sn]),sn=rt&&se(rt[sn]);le(te,sn)!==0&&(te!=null&&ie(te),sn!=null&&ie(sn))})}))):_t?(Ot={from:(Ot=_t.lower)!==null&&Ot!==void 0?Ot:h.MIN_KEY,to:(Ot=_t.upper)!==null&&Ot!==void 0?Ot:h.MAX_KEY},Nt.add(Ot),pt.add(Ot)):(pt.add(y),Nt.add(y),E.indexes.forEach(function(Dt){return Y(Dt.name).add(y)})),S.mutate(K).then(function(Dt){return!_t||K.type!=="add"&&K.type!=="put"||(pt.addKeys(Dt.results),U&&U.forEach(function(Wt){for(var se=K.values.map(function(te){return Wt.extractKey(te)}),ie=Wt.keyPath.findIndex(function(te){return te===A.keyPath}),ue=0,An=Dt.results.length;ue<An;++ue)se[ue][ie]=Dt.results[ue];Y(Wt.name).addKeys(se)})),it.mutatedParts=ci(it.mutatedParts||{},ut),Dt})}}),B=function(Y){var Z=Y.query,Y=Z.index,Z=Z.range;return[Y,new nn((Y=Z.lower)!==null&&Y!==void 0?Y:h.MIN_KEY,(Z=Z.upper)!==null&&Z!==void 0?Z:h.MAX_KEY)]},Q={get:function(K){return[A,new nn(K.key)]},getMany:function(K){return[A,new nn().addKeys(K.keys)]},count:B,query:B,openCursor:B};return o(Q).forEach(function(K){J[K]=function(Y){var Z=zt.subscr,G=!!Z,rt=fd(zt,S)&&hd(K,Y)?Y.obsSet={}:Z;if(G){var it=function(Ot){return Ot="idb://".concat(p,"/").concat(x,"/").concat(Ot),rt[Ot]||(rt[Ot]=new nn)},ut=it(""),pt=it(":dels"),Z=Q[K](Y),G=Z[0],Z=Z[1];if((K==="query"&&G.isPrimaryKey&&!Y.values?pt:it(G.name||"")).add(Z),!G.isPrimaryKey){if(K!=="count"){var Nt=K==="query"&&H&&Y.values&&S.query(s(s({},Y),{values:!1}));return S[K].apply(this,arguments).then(function(Ot){if(K==="query"){if(H&&Y.values)return Nt.then(function(se){return se=se.result,ut.addKeys(se),Ot});var Rt=Y.values?Ot.result.map(V):Ot.result;(Y.values?ut:pt).addKeys(Rt)}else if(K==="openCursor"){var Dt=Ot,Wt=Y.values;return Dt&&Object.create(Dt,{key:{get:function(){return pt.addKey(Dt.primaryKey),Dt.key}},primaryKey:{get:function(){var se=Dt.primaryKey;return pt.addKey(se),se}},value:{get:function(){return Wt&&ut.addKey(Dt.primaryKey),Dt.value}}})}return Ot})}pt.add(y)}}return S[K].apply(this,arguments)}}),J}})}};function dd(h,p,y){if(y.numFailures===0)return p;if(p.type==="deleteRange")return null;var x=p.keys?p.keys.length:"values"in p&&p.values?p.values.length:1;return y.numFailures===x?null:(p=s({},p),i(p.keys)&&(p.keys=p.keys.filter(function(S,E){return!(E in y.failures)})),"values"in p&&i(p.values)&&(p.values=p.values.filter(function(S,E){return!(E in y.failures)})),p)}function bc(h,p){return y=h,((x=p).lower===void 0||(x.lowerOpen?0<le(y,x.lower):0<=le(y,x.lower)))&&(h=h,(p=p).upper===void 0||(p.upperOpen?le(h,p.upper)<0:le(h,p.upper)<=0));var y,x}function pd(h,p,Q,x,S,E){if(!Q||Q.length===0)return h;var A=p.query.index,V=A.multiEntry,H=p.query.range,U=x.schema.primaryKey.extractKey,J=A.extractKey,B=(A.lowLevelIndex||A).extractKey,Q=Q.reduce(function(K,Y){var Z=K,G=[];if(Y.type==="add"||Y.type==="put")for(var rt=new nn,it=Y.values.length-1;0<=it;--it){var ut,pt=Y.values[it],Nt=U(pt);rt.hasKey(Nt)||(ut=J(pt),(V&&i(ut)?ut.some(function(Dt){return bc(Dt,H)}):bc(ut,H))&&(rt.addKey(Nt),G.push(pt)))}switch(Y.type){case"add":var At=new nn().addKeys(p.values?K.map(function(Wt){return U(Wt)}):K),Z=K.concat(p.values?G.filter(function(Wt){return Wt=U(Wt),!At.hasKey(Wt)&&(At.addKey(Wt),!0)}):G.map(function(Wt){return U(Wt)}).filter(function(Wt){return!At.hasKey(Wt)&&(At.addKey(Wt),!0)}));break;case"put":var _t=new nn().addKeys(Y.values.map(function(Wt){return U(Wt)}));Z=K.filter(function(Wt){return!_t.hasKey(p.values?U(Wt):Wt)}).concat(p.values?G:G.map(function(Wt){return U(Wt)}));break;case"delete":var Ot=new nn().addKeys(Y.keys);Z=K.filter(function(Wt){return!Ot.hasKey(p.values?U(Wt):Wt)});break;case"deleteRange":var Rt=Y.range;Z=K.filter(function(Wt){return!bc(U(Wt),Rt)})}return Z},h);return Q===h?h:(Q.sort(function(K,Y){return le(B(K),B(Y))||le(U(K),U(Y))}),p.limit&&p.limit<1/0&&(Q.length>p.limit?Q.length=p.limit:h.length===p.limit&&Q.length<p.limit&&(S.dirty=!0)),E?Object.freeze(Q):Q)}function md(h,p){return le(h.lower,p.lower)===0&&le(h.upper,p.upper)===0&&!!h.lowerOpen==!!p.lowerOpen&&!!h.upperOpen==!!p.upperOpen}function Sw(h,p){return function(y,x,S,E){if(y===void 0)return x!==void 0?-1:0;if(x===void 0)return 1;if((x=le(y,x))===0){if(S&&E)return 0;if(S)return 1;if(E)return-1}return x}(h.lower,p.lower,h.lowerOpen,p.lowerOpen)<=0&&0<=function(y,x,S,E){if(y===void 0)return x!==void 0?1:0;if(x===void 0)return-1;if((x=le(y,x))===0){if(S&&E)return 0;if(S)return-1;if(E)return 1}return x}(h.upper,p.upper,h.upperOpen,p.upperOpen)}function Iw(h,p,y,x){h.subscribers.add(y),x.addEventListener("abort",function(){var S,E;h.subscribers.delete(y),h.subscribers.size===0&&(S=h,E=p,setTimeout(function(){S.subscribers.size===0&&tt(E,S)},3e3))})}var Nw={stack:"dbcore",level:0,name:"Cache",create:function(h){var p=h.schema.name;return s(s({},h),{transaction:function(y,x,S){var E,A,V=h.transaction(y,x,S);return x==="readwrite"&&(A=(E=new AbortController).signal,S=function(H){return function(){if(E.abort(),x==="readwrite"){for(var U=new Set,J=0,B=y;J<B.length;J++){var Q=B[J],K=xr["idb://".concat(p,"/").concat(Q)];if(K){var Y=h.table(Q),Z=K.optimisticOps.filter(function(Wt){return Wt.trans===V});if(V._explicit&&H&&V.mutatedParts)for(var G=0,rt=Object.values(K.queries.query);G<rt.length;G++)for(var it=0,ut=(At=rt[G]).slice();it<ut.length;it++)fc((_t=ut[it]).obsSet,V.mutatedParts)&&(tt(At,_t),_t.subscribers.forEach(function(Wt){return U.add(Wt)}));else if(0<Z.length){K.optimisticOps=K.optimisticOps.filter(function(Wt){return Wt.trans!==V});for(var pt=0,Nt=Object.values(K.queries.query);pt<Nt.length;pt++)for(var At,_t,Ot,Rt=0,Dt=(At=Nt[pt]).slice();Rt<Dt.length;Rt++)(_t=Dt[Rt]).res!=null&&V.mutatedParts&&(H&&!_t.dirty?(Ot=Object.isFrozen(_t.res),Ot=pd(_t.res,_t.req,Z,Y,_t,Ot),_t.dirty?(tt(At,_t),_t.subscribers.forEach(function(Wt){return U.add(Wt)})):Ot!==_t.res&&(_t.res=Ot,_t.promise=Mt.resolve({result:Ot}))):(_t.dirty&&tt(At,_t),_t.subscribers.forEach(function(Wt){return U.add(Wt)})))}}}U.forEach(function(Wt){return Wt()})}}},V.addEventListener("abort",S(!1),{signal:A}),V.addEventListener("error",S(!1),{signal:A}),V.addEventListener("complete",S(!0),{signal:A})),V},table:function(y){var x=h.table(y),S=x.schema.primaryKey;return s(s({},x),{mutate:function(E){var A=zt.trans;if(S.outbound||A.db._options.cache==="disabled"||A.explicit||A.idbtrans.mode!=="readwrite")return x.mutate(E);var V=xr["idb://".concat(p,"/").concat(y)];return V?(A=x.mutate(E),E.type!=="add"&&E.type!=="put"||!(50<=E.values.length||yc(S,E).some(function(H){return H==null}))?(V.optimisticOps.push(E),E.mutatedParts&&li(E.mutatedParts),A.then(function(H){0<H.numFailures&&(tt(V.optimisticOps,E),(H=dd(0,E,H))&&V.optimisticOps.push(H),E.mutatedParts&&li(E.mutatedParts))}),A.catch(function(){tt(V.optimisticOps,E),E.mutatedParts&&li(E.mutatedParts)})):A.then(function(H){var U=dd(0,s(s({},E),{values:E.values.map(function(J,B){var Q;return H.failures[B]||(J=(Q=S.keyPath)!==null&&Q!==void 0&&Q.includes(".")?X(J):s({},J),R(J,S.keyPath,H.results[B])),J})}),H);V.optimisticOps.push(U),queueMicrotask(function(){return E.mutatedParts&&li(E.mutatedParts)})}),A):x.mutate(E)},query:function(E){if(!fd(zt,x)||!hd("query",E))return x.query(E);var A=((U=zt.trans)===null||U===void 0?void 0:U.db._options.cache)==="immutable",B=zt,V=B.requery,H=B.signal,U=function(Y,Z,G,rt){var it=xr["idb://".concat(Y,"/").concat(Z)];if(!it)return[];if(!(Z=it.queries[G]))return[null,!1,it,null];var ut=Z[(rt.query?rt.query.index.name:null)||""];if(!ut)return[null,!1,it,null];switch(G){case"query":var pt=ut.find(function(Nt){return Nt.req.limit===rt.limit&&Nt.req.values===rt.values&&md(Nt.req.query.range,rt.query.range)});return pt?[pt,!0,it,ut]:[ut.find(function(Nt){return("limit"in Nt.req?Nt.req.limit:1/0)>=rt.limit&&(!rt.values||Nt.req.values)&&Sw(Nt.req.query.range,rt.query.range)}),!1,it,ut];case"count":return pt=ut.find(function(Nt){return md(Nt.req.query.range,rt.query.range)}),[pt,!!pt,it,ut]}}(p,y,"query",E),J=U[0],B=U[1],Q=U[2],K=U[3];return J&&B?J.obsSet=E.obsSet:(B=x.query(E).then(function(Y){var Z=Y.result;if(J&&(J.res=Z),A){for(var G=0,rt=Z.length;G<rt;++G)Object.freeze(Z[G]);Object.freeze(Z)}else Y.result=X(Z);return Y}).catch(function(Y){return K&&J&&tt(K,J),Promise.reject(Y)}),J={obsSet:E.obsSet,promise:B,subscribers:new Set,type:"query",req:E,dirty:!1},K?K.push(J):(K=[J],(Q=Q||(xr["idb://".concat(p,"/").concat(y)]={queries:{query:{},count:{}},objs:new Map,optimisticOps:[],unsignaledParts:{}})).queries.query[E.query.index.name||""]=K)),Iw(J,K,V,H),J.promise.then(function(Y){return{result:pd(Y.result,E,Q==null?void 0:Q.optimisticOps,x,J,A)}})}})}})}};function hi(h,p){return new Proxy(h,{get:function(y,x,S){return x==="db"?p:Reflect.get(y,x,S)}})}var xs=(Le.prototype.version=function(h){if(isNaN(h)||h<.1)throw new vt.Type("Given version is not a positive number");if(h=Math.round(10*h)/10,this.idbdb||this._state.isBeingOpened)throw new vt.Schema("Cannot add version when database is open");this.verno=Math.max(this.verno,h);var p=this._versions,y=p.filter(function(x){return x._cfg.version===h})[0];return y||(y=new this.Version(h),p.push(y),p.sort(pw),y.stores({}),this._state.autoSchema=!1,y)},Le.prototype._whenReady=function(h){var p=this;return this.idbdb&&(this._state.openComplete||zt.letThrough||this._vip)?h():new Mt(function(y,x){if(p._state.openComplete)return x(new vt.DatabaseClosed(p._state.dbOpenError));if(!p._state.isBeingOpened){if(!p._state.autoOpen)return void x(new vt.DatabaseClosed);p.open().catch(F)}p._state.dbReadyPromise.then(y,x)}).then(h)},Le.prototype.use=function(h){var p=h.stack,y=h.create,x=h.level,S=h.name;return S&&this.unuse({stack:p,name:S}),h=this._middlewares[p]||(this._middlewares[p]=[]),h.push({stack:p,create:y,level:x??10,name:S}),h.sort(function(E,A){return E.level-A.level}),this},Le.prototype.unuse=function(h){var p=h.stack,y=h.name,x=h.create;return p&&this._middlewares[p]&&(this._middlewares[p]=this._middlewares[p].filter(function(S){return x?S.create!==x:!!y&&S.name!==y})),this},Le.prototype.open=function(){var h=this;return wr($e,function(){return bw(h)})},Le.prototype._close=function(){var h=this._state,p=na.indexOf(this);if(0<=p&&na.splice(p,1),this.idbdb){try{this.idbdb.close()}catch{}this.idbdb=null}h.isBeingOpened||(h.dbReadyPromise=new Mt(function(y){h.dbReadyResolve=y}),h.openCanceller=new Mt(function(y,x){h.cancelOpen=x}))},Le.prototype.close=function(y){var p=(y===void 0?{disableAutoOpen:!0}:y).disableAutoOpen,y=this._state;p?(y.isBeingOpened&&y.cancelOpen(new vt.DatabaseClosed),this._close(),y.autoOpen=!1,y.dbOpenError=new vt.DatabaseClosed):(this._close(),y.autoOpen=this._options.autoOpen||y.isBeingOpened,y.openComplete=!1,y.dbOpenError=null)},Le.prototype.delete=function(h){var p=this;h===void 0&&(h={disableAutoOpen:!0});var y=0<arguments.length&&typeof arguments[0]!="object",x=this._state;return new Mt(function(S,E){function A(){p.close(h);var V=p._deps.indexedDB.deleteDatabase(p.name);V.onsuccess=Ce(function(){var H,U,J;H=p._deps,U=p.name,J=H.indexedDB,H=H.IDBKeyRange,uc(J)||U===Jo||ic(J,H).delete(U).catch(F),S()}),V.onerror=ns(E),V.onblocked=p._fireOnBlocked}if(y)throw new vt.InvalidArgument("Invalid closeOptions argument to db.delete()");x.isBeingOpened?x.dbReadyPromise.then(A):A()})},Le.prototype.backendDB=function(){return this.idbdb},Le.prototype.isOpen=function(){return this.idbdb!==null},Le.prototype.hasBeenClosed=function(){var h=this._state.dbOpenError;return h&&h.name==="DatabaseClosed"},Le.prototype.hasFailed=function(){return this._state.dbOpenError!==null},Le.prototype.dynamicallyOpened=function(){return this._state.autoSchema},Object.defineProperty(Le.prototype,"tables",{get:function(){var h=this;return o(this._allTables).map(function(p){return h._allTables[p]})},enumerable:!1,configurable:!0}),Le.prototype.transaction=function(){var h=(function(p,y,x){var S=arguments.length;if(S<2)throw new vt.InvalidArgument("Too few arguments");for(var E=new Array(S-1);--S;)E[S-1]=arguments[S];return x=E.pop(),[p,M(E),x]}).apply(this,arguments);return this._transaction.apply(this,h)},Le.prototype._transaction=function(h,p,y){var x=this,S=zt.trans;S&&S.db===this&&h.indexOf("!")===-1||(S=null);var E,A,V=h.indexOf("?")!==-1;h=h.replace("!","").replace("?","");try{if(A=p.map(function(U){if(U=U instanceof x.Table?U.name:U,typeof U!="string")throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");return U}),h=="r"||h===Xu)E=Xu;else{if(h!="rw"&&h!=Yu)throw new vt.InvalidArgument("Invalid transaction mode: "+h);E=Yu}if(S){if(S.mode===Xu&&E===Yu){if(!V)throw new vt.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");S=null}S&&A.forEach(function(U){if(S&&S.storeNames.indexOf(U)===-1){if(!V)throw new vt.SubTransaction("Table "+U+" not included in parent transaction.");S=null}}),V&&S&&!S.active&&(S=null)}}catch(U){return S?S._promise(null,function(J,B){B(U)}):Ve(U)}var H=(function U(J,B,Q,K,Y){return Mt.resolve().then(function(){var Z=zt.transless||zt,G=J._createTransaction(B,Q,J._dbSchema,K);if(G.explicit=!0,Z={trans:G,transless:Z},K)G.idbtrans=K.idbtrans;else try{G.create(),G.idbtrans._explicit=!0,J._state.PR1398_maxLoop=3}catch(ut){return ut.name===Bt.InvalidState&&J.isOpen()&&0<--J._state.PR1398_maxLoop?(console.warn("Dexie: Need to reopen db"),J.close({disableAutoOpen:!1}),J.open().then(function(){return U(J,B,Q,null,Y)})):Ve(ut)}var rt,it=gt(Y);return it&&ea(),Z=Mt.follow(function(){var ut;(rt=Y.call(G,G))&&(it?(ut=Us.bind(null,null),rt.then(ut,ut)):typeof rt.next=="function"&&typeof rt.throw=="function"&&(rt=mc(rt)))},Z),(rt&&typeof rt.then=="function"?Mt.resolve(rt).then(function(ut){return G.active?ut:Ve(new vt.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))}):Z.then(function(){return rt})).then(function(ut){return K&&G._resolve(),G._completion.then(function(){return ut})}).catch(function(ut){return G._reject(ut),Ve(ut)})})}).bind(null,this,E,A,S,y);return S?S._promise(E,H,"lock"):zt.trans?wr(zt.transless,function(){return x._whenReady(H)}):this._whenReady(H)},Le.prototype.table=function(h){if(!f(this._allTables,h))throw new vt.InvalidTable("Table ".concat(h," does not exist"));return this._allTables[h]},Le);function Le(h,p){var y=this;this._middlewares={},this.verno=0;var x=Le.dependencies;this._options=p=s({addons:Le.addons,autoOpen:!0,indexedDB:x.indexedDB,IDBKeyRange:x.IDBKeyRange,cache:"cloned"},p),this._deps={indexedDB:p.indexedDB,IDBKeyRange:p.IDBKeyRange},x=p.addons,this._dbSchema={},this._versions=[],this._storeNames=[],this._allTables={},this.idbdb=null,this._novip=this;var S,E,A,V,H,U={dbOpenError:null,isBeingOpened:!1,onReadyBeingFired:null,openComplete:!1,dbReadyResolve:F,dbReadyPromise:null,cancelOpen:F,openCanceller:null,autoSchema:!0,PR1398_maxLoop:3,autoOpen:p.autoOpen};U.dbReadyPromise=new Mt(function(B){U.dbReadyResolve=B}),U.openCanceller=new Mt(function(B,Q){U.cancelOpen=Q}),this._state=U,this.name=h,this.on=Ba(this,"populate","blocked","versionchange","close",{ready:[kt,F]}),this.on.ready.subscribe=_(this.on.ready.subscribe,function(B){return function(Q,K){Le.vip(function(){var Y,Z=y._state;Z.openComplete?(Z.dbOpenError||Mt.resolve().then(Q),K&&B(Q)):Z.onReadyBeingFired?(Z.onReadyBeingFired.push(Q),K&&B(Q)):(B(Q),Y=y,K||B(function G(){Y.on.ready.unsubscribe(Q),Y.on.ready.unsubscribe(G)}))})}}),this.Collection=(S=this,Wa(iw.prototype,function(rt,G){this.db=S;var K=Kh,Y=null;if(G)try{K=G()}catch(it){Y=it}var Z=rt._ctx,G=Z.table,rt=G.hook.reading.fire;this._ctx={table:G,index:Z.index,isPrimKey:!Z.index||G.schema.primKey.keyPath&&Z.index===G.schema.primKey.name,range:K,keysOnly:!1,dir:"next",unique:"",algorithm:null,filter:null,replayFilter:null,justLimit:!0,isMatch:null,offset:0,limit:1/0,error:Y,or:Z.or,valueMapper:rt!==z?rt:null}})),this.Table=(E=this,Wa(Yh.prototype,function(B,Q,K){this.db=E,this._tx=K,this.name=B,this.schema=Q,this.hook=E._allTables[B]?E._allTables[B].hook:Ba(null,{creating:[lt,F],reading:[at,z],updating:[xt,F],deleting:[dt,F]})})),this.Transaction=(A=this,Wa(lw.prototype,function(B,Q,K,Y,Z){var G=this;this.db=A,this.mode=B,this.storeNames=Q,this.schema=K,this.chromeTransactionDurability=Y,this.idbtrans=null,this.on=Ba(this,"complete","error","abort"),this.parent=Z||null,this.active=!0,this._reculock=0,this._blockedFuncs=[],this._resolve=null,this._reject=null,this._waitingFor=null,this._waitingQueue=null,this._spinCount=0,this._completion=new Mt(function(rt,it){G._resolve=rt,G._reject=it}),this._completion.then(function(){G.active=!1,G.on.complete.fire()},function(rt){var it=G.active;return G.active=!1,G.on.error.fire(rt),G.parent?G.parent._reject(rt):it&&G.idbtrans&&G.idbtrans.abort(),Ve(rt)})})),this.Version=(V=this,Wa(yw.prototype,function(B){this.db=V,this._cfg={version:B,storesSource:null,dbschema:{},tables:{},contentUpgrade:null}})),this.WhereClause=(H=this,Wa(ed.prototype,function(B,Q,K){if(this.db=H,this._ctx={table:B,index:Q===":id"?null:Q,or:K},this._cmp=this._ascending=le,this._descending=function(Y,Z){return le(Z,Y)},this._max=function(Y,Z){return 0<le(Y,Z)?Y:Z},this._min=function(Y,Z){return le(Y,Z)<0?Y:Z},this._IDBKeyRange=H._deps.IDBKeyRange,!this._IDBKeyRange)throw new vt.MissingAPI})),this.on("versionchange",function(B){0<B.newVersion?console.warn("Another connection wants to upgrade database '".concat(y.name,"'. Closing db now to resume the upgrade.")):console.warn("Another connection wants to delete database '".concat(y.name,"'. Closing db now to resume the delete request.")),y.close({disableAutoOpen:!1})}),this.on("blocked",function(B){!B.newVersion||B.newVersion<B.oldVersion?console.warn("Dexie.delete('".concat(y.name,"') was blocked")):console.warn("Upgrade '".concat(y.name,"' blocked by other connection holding version ").concat(B.oldVersion/10))}),this._maxKey=Ka(p.IDBKeyRange),this._createTransaction=function(B,Q,K,Y){return new y.Transaction(B,Q,K,y._options.chromeTransactionDurability,Y)},this._fireOnBlocked=function(B){y.on("blocked").fire(B),na.filter(function(Q){return Q.name===y.name&&Q!==y&&!Q._state.vcFired}).map(function(Q){return Q.on("versionchange").fire(B)})},this.use(kw),this.use(Nw),this.use(xw),this.use(ww),this.use(vw);var J=new Proxy(this,{get:function(B,Q,K){if(Q==="_vip")return!0;if(Q==="table")return function(Z){return hi(y.table(Z),J)};var Y=Reflect.get(B,Q,K);return Y instanceof Yh?hi(Y,J):Q==="tables"?Y.map(function(Z){return hi(Z,J)}):Q==="_createTransaction"?function(){return hi(Y.apply(this,arguments),J)}:Y}});this.vip=J,x.forEach(function(B){return B(y)})}var di,zn=typeof Symbol<"u"&&"observable"in Symbol?Symbol.observable:"@@observable",_w=(wc.prototype.subscribe=function(h,p,y){return this._subscribe(h&&typeof h!="function"?h:{next:h,error:p,complete:y})},wc.prototype[zn]=function(){return this},wc);function wc(h){this._subscribe=h}try{di={indexedDB:a.indexedDB||a.mozIndexedDB||a.webkitIndexedDB||a.msIndexedDB,IDBKeyRange:a.IDBKeyRange||a.webkitIDBKeyRange}}catch{di={indexedDB:null,IDBKeyRange:null}}function gd(h){var p,y=!1,x=new _w(function(S){var E=gt(h),A,V=!1,H={},U={},J={get closed(){return V},unsubscribe:function(){V||(V=!0,A&&A.abort(),B&&Ys.storagemutated.unsubscribe(K))}};S.start&&S.start(J);var B=!1,Q=function(){return Gu(Y)},K=function(Z){ci(H,Z),fc(U,H)&&Q()},Y=function(){var Z,G,rt;!V&&di.indexedDB&&(H={},Z={},A&&A.abort(),A=new AbortController,rt=function(it){var ut=Qr();try{E&&ea();var pt=Ks(h,it);return pt=E?pt.finally(Us):pt}finally{ut&&ta()}}(G={subscr:Z,signal:A.signal,requery:Q,querier:h,trans:null}),Promise.resolve(rt).then(function(it){y=!0,p=it,V||G.signal.aborted||(H={},function(ut){for(var pt in ut)if(f(ut,pt))return;return 1}(U=Z)||B||(Ys(Ha,K),B=!0),Gu(function(){return!V&&S.next&&S.next(it)}))},function(it){y=!1,["DatabaseClosedError","AbortError"].includes(it==null?void 0:it.name)||V||Gu(function(){V||S.error&&S.error(it)})}))};return setTimeout(Q,0),J});return x.hasValue=function(){return y},x.getValue=function(){return p},x}var Sr=xs;function vc(h){var p=Js;try{Js=!0,Ys.storagemutated.fire(h),pc(h,!0)}finally{Js=p}}d(Sr,s(s({},Zt),{delete:function(h){return new Sr(h,{addons:[]}).delete()},exists:function(h){return new Sr(h,{addons:[]}).open().then(function(p){return p.close(),!0}).catch("NoSuchDatabaseError",function(){return!1})},getDatabaseNames:function(h){try{return p=Sr.dependencies,y=p.indexedDB,p=p.IDBKeyRange,(uc(y)?Promise.resolve(y.databases()).then(function(x){return x.map(function(S){return S.name}).filter(function(S){return S!==Jo})}):ic(y,p).toCollection().primaryKeys()).then(h)}catch{return Ve(new vt.MissingAPI)}var p,y},defineClass:function(){return function(h){u(this,h)}},ignoreTransaction:function(h){return zt.trans?wr(zt.transless,h):h()},vip:cc,async:function(h){return function(){try{var p=mc(h.apply(this,arguments));return p&&typeof p.then=="function"?p:Mt.resolve(p)}catch(y){return Ve(y)}}},spawn:function(h,p,y){try{var x=mc(h.apply(y,p||[]));return x&&typeof x.then=="function"?x:Mt.resolve(x)}catch(S){return Ve(S)}},currentTransaction:{get:function(){return zt.trans||null}},waitFor:function(h,p){return p=Mt.resolve(typeof h=="function"?Sr.ignoreTransaction(h):h).timeout(p||6e4),zt.trans?zt.trans.waitFor(p):p},Promise:Mt,debug:{get:function(){return yt},set:function(h){Vt(h)}},derive:b,extend:u,props:d,override:_,Events:Ba,on:Ys,liveQuery:gd,extendObservabilitySet:ci,getByKeyPath:O,setByKeyPath:R,delByKeyPath:function(h,p){typeof p=="string"?R(h,p,void 0):"length"in p&&[].map.call(p,function(y){R(h,y,void 0)})},shallowClone:W,deepClone:X,getObjectDiff:gc,cmp:le,asap:$,minKey:-1/0,addons:[],connections:na,errnames:Bt,dependencies:di,cache:xr,semVer:"4.0.11",version:"4.0.11".split(".").map(function(h){return parseInt(h)}).reduce(function(h,p,y){return h+p/Math.pow(10,2*y)})})),Sr.maxKey=Ka(Sr.dependencies.IDBKeyRange),typeof dispatchEvent<"u"&&typeof addEventListener<"u"&&(Ys(Ha,function(h){Js||(h=new CustomEvent(tc,{detail:h}),Js=!0,dispatchEvent(h),Js=!1)}),addEventListener(tc,function(h){h=h.detail,Js||vc(h)}));var aa,Js=!1,yd=function(){};return typeof BroadcastChannel<"u"&&((yd=function(){(aa=new BroadcastChannel(tc)).onmessage=function(h){return h.data&&vc(h.data)}})(),typeof aa.unref=="function"&&aa.unref(),Ys(Ha,function(h){Js||aa.postMessage(h)})),typeof addEventListener<"u"&&(addEventListener("pagehide",function(h){if(!xs.disableBfCache&&h.persisted){yt&&console.debug("Dexie: handling persisted pagehide"),aa!=null&&aa.close();for(var p=0,y=na;p<y.length;p++)y[p].close({disableAutoOpen:!1})}}),addEventListener("pageshow",function(h){!xs.disableBfCache&&h.persisted&&(yt&&console.debug("Dexie: handling persisted pageshow"),yd(),vc({all:new nn(-1/0,[[]])}))})),Mt.rejectionMapper=function(h,p){return!h||h instanceof bt||h instanceof TypeError||h instanceof SyntaxError||!h.name||!Ut[h.name]?h:(p=new Ut[h.name](p||h.message,h),"stack"in h&&g(p,"stack",{get:function(){return this.inner.stack}}),p)},Vt(yt),s(xs,Object.freeze({__proto__:null,Dexie:xs,liveQuery:gd,Entity:Uh,cmp:le,PropModification:ja,replacePrefix:function(h,p){return new ja({replacePrefix:[h,p]})},add:function(h){return new ja({add:h})},remove:function(h){return new ja({remove:h})},default:xs,RangeSet:nn,mergeRanges:Xa,rangesOverlap:od}),{default:xs}),xs})}(Pl)),Pl.exports}var AL=DL();const Ml=CL(AL),qp=Symbol.for("Dexie"),hu=globalThis[qp]||(globalThis[qp]=Ml);if(Ml.semVer!==hu.semVer)throw new Error(`Two different versions of Dexie loaded in the same app: ${Ml.semVer} and ${hu.semVer}`);const{liveQuery:z6,mergeRanges:B6,rangesOverlap:W6,RangeSet:j6,cmp:q6,Entity:H6,PropModification:K6,replacePrefix:U6,add:G6,remove:X6}=hu;var FL="",RL="",PL="",ML="",VL="",LL="",zL="",BL="",WL="",jL="",qL="",HL="",KL="",UL="",GL="",XL="",YL="",JL="",ZL="",QL="",tz="",ez="",nz="",sz="",rz="",az="",oz="",iz="",uz="",cz="",lz="",fz="",hz="",dz="",pz="",mz="",gz="",yz="",bz="",wz="",vz="",kz="",xz="",Sz="",Iz="",Nz="",_z="",Tz="",Ez="",$z="",Cz="",Oz="",Dz="",Az="",Fz="",Rz="",Pz="",Mz="",Vz="",Lz="",zz="",Bz="",Wz="",jz="",qz="",Hz="",Kz="",Uz="",Gz="",Xz="",Yz="",Jz="",Zz="",Qz="",tB="",eB="",nB="",sB="",rB="",aB="",oB="",iB="",uB="",cB="",lB="",fB="",hB="",dB="",pB="",mB="",gB="",yB="",bB="",wB="",vB="",kB="",xB="",SB="",IB="",NB="",_B="",TB="",EB="",$B="",CB="",OB="",DB="",AB="",FB="",RB="",PB="",MB="",VB="",LB="",zB="",BB="",WB="",jB="",qB="",HB="",KB="",UB="",GB="",XB="",YB="",JB="",ZB="",QB="",tW="",eW="",nW="",sW="",rW="",aW="",oW="",iW="",uW="",cW="",lW="",fW="",hW="",dW="",pW="",mW="",gW="",yW="",bW="",wW="",vW="",kW="",xW="",SW="",IW="",NW="",_W="",TW="",EW="",$W="",CW="",OW="",DW="",AW="",FW="",RW="",PW="",MW="",VW="",LW="",zW="",BW="",WW="",jW="",qW="",HW="",KW="",UW="",GW="",XW="",YW="",JW="",ZW="",QW="",t4="",e4="",n4="",s4="",r4="",a4="",o4="",i4="",u4="",c4="",l4="",f4="",h4="",d4="",p4="",m4="",g4="",y4="",b4="",w4="",v4="",k4="",x4="",S4="",I4="",N4="",_4="",T4="",E4="",$4="",C4="",O4="",D4="",A4="",F4="",R4="",P4="",M4="",V4="",L4="",z4="",B4="",W4="",j4="",q4="",H4="",K4="",U4="",G4="",X4="",Y4="",J4="",Z4="",Q4="",tj="",ej="",nj="",sj="",rj="",aj="",oj="",ij="",uj="",cj="",lj="",fj="",hj="",dj="",pj="",mj="",gj="",yj="",bj="",wj="",vj="",kj="",xj="",Sj="",Ij="",Nj="",_j="",Tj="",Ej="",$j="",Cj="",Oj="",Dj="",Aj="",Fj="",Rj="",Pj="",Mj="",Vj="",Lj="",zj="",Bj="",Wj="",jj="",qj="",Hj="",Kj="",Uj="",Gj="",Xj="",Yj="",Jj="",Zj="",Qj="",tq="",eq="",nq="",sq="",rq="",aq="",oq="",iq="",uq="",cq="",lq="",fq="",hq="",dq="",pq="",mq="",gq="",yq="",bq="",wq="",vq="",kq="",xq="",Sq="",Iq="",Nq="",_q="",Tq="",Eq="",$q="",Cq="",Oq="",Dq="",Aq="",Fq="",Rq="",Pq="",Mq="",Vq="",Lq="",zq="",Bq="",Wq="",jq="",qq="",Hq="",Kq="",Uq="",Gq="",Xq="",Yq="",Jq="",Zq="",Qq="",tH="",eH="",nH="",sH="",rH="",aH="",oH="",iH="",uH="",cH="",lH="",fH="",hH="",dH="",pH="",mH="",gH="",yH="",bH="",wH="",vH="",kH="",xH="",SH="",IH="",NH="",_H="",TH="",EH="",$H="",CH="",OH="",DH="",AH="",FH="",RH="",PH="",MH="",VH="",LH="",zH="",BH="",WH="",jH="",qH="",HH="",KH="",UH="",GH="",XH="",YH="",JH="",ZH="",QH="",tK="",eK="",nK="",sK="",rK="",aK="",oK={a:FL,e:RL,ai:PL,ei:ML,xi:VL,yi:LL,an:zL,han:BL,ang:WL,ao:jL,wa:qL,yu:HL,niu:KL,o:UL,ba:GL,pa:XL,pi:YL,bi:JL,bai:ZL,bo:QL,bei:tz,ban:ez,pan:nz,bin:sz,bang:rz,pang:az,beng:oz,bao:iz,bu:uz,pu:cz,mian:lz,po:fz,fan:hz,fu:dz,ben:pz,feng:mz,bian:gz,pian:yz,zhen:bz,biao:wz,piao:vz,huo:kz,bie:xz,min:Sz,fen:Iz,bing:Nz,geng:_z,fang:Tz,xian:Ez,fou:$z,ca:Cz,cha:Oz,cai:Dz,can:Az,shen:Fz,cen:Rz,san:Pz,cang:Mz,zang:Vz,chen:Lz,cao:zz,ce:Bz,ze:Wz,zhai:jz,dao:qz,ceng:Hz,zha:Kz,chai:Uz,ci:Gz,zi:Xz,cuo:Yz,chan:Jz,shan:Zz,zhan:Qz,xin:tB,lian:eB,chang:nB,zhang:sB,chao:rB,zhao:aB,zhou:oB,che:iB,ju:uB,cheng:cB,rong:lB,sheng:fB,deng:hB,zhi:dB,zheng:pB,tang:mB,chi:gB,shi:yB,qi:bB,chuai:wB,tuo:vB,duo:kB,xue:xB,chong:SB,chou:IB,qiu:NB,xiu:_B,chu:TB,tuan:EB,zhui:$B,chuan:CB,zhuan:OB,yuan:DB,cuan:AB,chuang:FB,zhuang:RB,chui:PB,chun:MB,zhun:VB,cu:LB,dun:zB,qu:BB,xu:WB,chuo:jB,zu:qB,ji:HB,cong:KB,zong:UB,cou:GB,cui:XB,wei:YB,cun:JB,zuo:ZB,zuan:QB,da:tW,dai:eW,tai:nW,ta:sW,dan:rW,lu:aW,tan:oW,ren:iW,jie:uW,yan:cW,dang:lW,tao:fW,tiao:hW,te:dW,de:pW,dei:mW,di:gW,ti:yW,tui:bW,you:wW,dian:vW,tian:kW,zhu:xW,nian:SW,diao:IW,yao:NW,die:_W,she:TW,ye:EW,xie:$W,zhe:CW,ding:OW,diu:DW,ting:AW,dong:FW,tong:RW,zhong:PW,dou:MW,du:VW,duan:LW,dui:zW,rui:BW,yue:WW,tun:jW,hui:qW,wu:HW,ya:KW,he:UW,wo:GW,en:XW,n:YW,er:JW,fa:ZW,quan:QW,fei:t4,pei:e4,ping:n4,fo:s4,hu:r4,ga:a4,ge:o4,ha:i4,xia:u4,gai:c4,hai:l4,gan:f4,gang:h4,jiang:d4,hang:p4,gong:m4,hong:g4,guang:y4,qiong:b4,gao:w4,hao:v4,li:k4,jia:x4,luo:S4,ke:I4,qia:N4,gei:_4,gen:T4,hen:E4,gou:$4,kou:C4,gu:O4,pai:D4,gua:A4,tou:F4,guai:R4,kuai:P4,guan:M4,wan:V4,ne:L4,gui:z4,jun:B4,jiong:W4,jue:j4,gun:q4,hun:H4,guo:K4,hei:U4,kan:G4,heng:X4,mo:Y4,peng:J4,hou:Z4,hua:Q4,huai:tj,huan:ej,xun:nj,huang:sj,nai:rj,luan:aj,qie:oj,jian:ij,nan:uj,qian:cj,qiang:lj,xiang:fj,jiao:hj,zhuo:dj,qiao:pj,xiao:mj,si:gj,kai:yj,jin:bj,qin:wj,jing:vj,ying:kj,jiu:xj,zui:Sj,juan:Ij,suan:Nj,yun:_j,qun:Tj,ka:Ej,kang:$j,keng:Cj,kao:Oj,ken:Dj,yin:Aj,kong:Fj,ku:Rj,kua:Pj,kui:Mj,kuan:Vj,kuang:Lj,que:zj,kun:Bj,kuo:Wj,la:jj,lai:qj,lan:Hj,lin:Kj,lang:Uj,liang:Gj,lao:Xj,mu:Yj,le:Jj,lei:Zj,sui:Qj,lie:tq,leng:eq,ling:nq,lia:sq,liao:rq,liu:aq,lun:oq,lv:iq,lou:uq,mao:cq,long:lq,nong:fq,shuang:hq,shu:dq,shuai:pq,lve:mq,ma:gq,me:yq,mai:bq,man:wq,mi:vq,men:kq,mang:xq,meng:Sq,miao:Iq,mou:Nq,miu:_q,mei:Tq,wen:Eq,mie:$q,ming:Cq,na:Oq,nei:Dq,nuo:Aq,ruo:Fq,nang:Rq,nao:Pq,ni:Mq,nen:Vq,neng:Lq,nin:zq,niao:Bq,nie:Wq,niang:jq,ning:qq,nu:Hq,nv:Kq,ru:Uq,nuan:Gq,nve:Xq,re:Yq,ou:Jq,pao:Zq,pou:Qq,pen:tH,pie:eH,pin:nH,se:sH,qing:rH,zan:aH,shao:oH,sao:iH,sha:uH,xuan:cH,ran:lH,rang:fH,rao:hH,reng:dH,ri:pH,rou:mH,ruan:gH,run:yH,sa:bH,suo:wH,sai:vH,shui:kH,sang:xH,sen:SH,seng:IH,shai:NH,shang:_H,xing:TH,shou:EH,shuo:$H,su:CH,shua:OH,shuan:DH,shun:AH,song:FH,sou:RH,sun:PH,teng:MH,tie:VH,tu:LH,wai:zH,wang:BH,weng:WH,zhua:jH,yang:qH,xiong:HH,yo:KH,yong:UH,za:GH,zai:XH,zao:YH,zei:JH,zen:ZH,zeng:QH,zhei:tK,zou:eK,zhuai:nK,zun:sK,dia:rK,nou:aK};const iK=5;var uK=class{constructor(){Ze(this,"currentInput",""),Ze(this,"candidates",[]),Ze(this,"db"),Ze(this,"pinyinDict",oK),Ze(this,"pinyinCharTable"),Ze(this,"initializationPromise"),this.db=new hu("PinyinCharDB"),this.db.version(1).stores({pinyinCharEntries:"++id, &[pinyin+char], pinyin, char, weight"}),this.pinyinCharTable=this.db.table("pinyinCharEntries"),this.initializationPromise=this.initializeDatabase()}async initializeDatabase(){try{if(await this.pinyinCharTable.count()===0){const e=[];for(const[t,n]of Object.entries(this.pinyinDict))for(const s of n.split(""))e.push({pinyin:t,char:s,weight:1});await this.pinyinCharTable.bulkAdd(e)}}catch(e){throw console.error(" PinyinCharDB :",e),e}}async processInput(e){if(await this.initializationPromise,this.currentInput=e.toLowerCase(),this.candidates=[],!this.currentInput)return[];const t=await this.pinyinCharTable.where("pinyin").startsWith(this.currentInput).toArray(),n=(s,r)=>{const a=s.pinyin===r,o=s.weight>1;return a&&o?1:!a&&o?2:a&&!o?3:!a&&!o?4:5};return t.sort((s,r)=>{const a=n(s,this.currentInput),o=n(r,this.currentInput);return a!==o?a-o:r.weight!==s.weight?r.weight-s.weight:s.id-r.id}),this.candidates=t.map(s=>s.char),this.candidates=[...new Set(this.candidates)],this.candidates}async selectCandidate(e){var t,n,s;if(await this.initializationPromise,!this.currentInput)return;let r=this.currentInput;for(const o of Object.keys(this.pinyinDict))if(o.startsWith(this.currentInput)&&this.pinyinDict[o].includes(e))if(o.length>r.length||o===this.currentInput){if(r=o,(t=this.pinyinDict[this.currentInput])!=null&&t.includes(e)&&this.currentInput===o)break}else r===this.currentInput&&(n=this.pinyinDict[o])!=null&&n.includes(e)&&(r=o);if(!((s=this.pinyinDict[r])!=null&&s.includes(e))){for(const o of Object.keys(this.pinyinDict))if(this.pinyinDict[o].includes(e)){if(o.startsWith(this.currentInput)){r=o;break}r===this.currentInput&&(r=o)}}const a=await this.pinyinCharTable.where({pinyin:r,char:e}).first();if(a&&a.id!==void 0){const o=Math.min((a.weight||0)+1,iK);await this.pinyinCharTable.update(a.id,{weight:o})}else this.pinyinDict[r]?await this.pinyinCharTable.add({pinyin:r,char:e,weight:1}):console.warn(` ${e}  ${r} `);this.clear()}clear(){this.currentInput="",this.candidates=[]}getCurrentInput(){return this.currentInput}getCandidates(){return this.candidates}},cK=class{constructor(e,t={}){Ze(this,"canvas"),Ze(this,"ctx"),Ze(this,"lastX",0),Ze(this,"lastY",0),Ze(this,"strokeData",[]),Ze(this,"clearTimerId",null),Ze(this,"isDrawing",!1),Ze(this,"options"),Ze(this,"handleStart",s=>{s.preventDefault(),this.isDrawing=!0;const{offsetX:r,offsetY:a}=this.getEventCoordinates(s);this.startDrawing(r,a),this.resetClearTimer()}),Ze(this,"handleMove",s=>{if(!this.isDrawing)return;s.preventDefault();const{offsetX:r,offsetY:a}=this.getEventCoordinates(s);this.draw(r,a),this.resetClearTimer()}),Ze(this,"handleEnd",s=>{this.isDrawing&&(s.preventDefault(),this.isDrawing=!1,this.endStroke(),this.startClearTimer(),this.options.onDrawEnd&&this.options.onDrawEnd())}),this.canvas=e,this.options={clearDelay:1e3,...t};const n=this.canvas.getContext("2d");if(!n)throw new Error("Failed to get 2D rendering context");this.ctx=n,this.setupCanvas(),this.attachEvents()}setupCanvas(){this.ctx.lineJoin="round",this.ctx.lineCap="round",this.ctx.lineWidth=3,this.ctx.strokeStyle="#000",this.clearCanvas(),this.drawGrid()}drawGrid(){const e=this.canvas.width,t=this.canvas.height;this.ctx.save(),this.ctx.strokeStyle="#ddd",this.ctx.lineWidth=1,this.ctx.setLineDash([3,3]),this.ctx.beginPath(),this.ctx.moveTo(0,t/2),this.ctx.lineTo(e,t/2),this.ctx.moveTo(e/2,0),this.ctx.lineTo(e/2,t),this.ctx.stroke(),this.ctx.setLineDash([]),this.ctx.beginPath(),this.ctx.rect(0,0,e,t),this.ctx.stroke(),this.ctx.restore()}clearCanvas(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),this.drawGrid(),this.strokeData=[],this.resetClearTimer()}startDrawing(e,t){this.lastX=e,this.lastY=t,this.ctx.strokeStyle="#000",this.ctx.lineWidth=3,this.ctx.setLineDash([]),this.strokeData.push(e,t,0)}draw(e,t){this.ctx.beginPath(),this.ctx.moveTo(this.lastX,this.lastY),this.ctx.lineTo(e,t),this.ctx.stroke(),this.lastX=e,this.lastY=t,this.strokeData.push(e,t,0)}endStroke(){this.strokeData.length>=3&&(this.strokeData[this.strokeData.length-1]=1)}getStrokeData(){return this.strokeData}resetClearTimer(){this.clearTimerId&&(window.clearTimeout(this.clearTimerId),this.clearTimerId=null)}startClearTimer(){this.resetClearTimer(),this.clearTimerId=window.setTimeout(()=>{this.clearCanvas(),this.clearTimerId=null},this.options.clearDelay)}getEventCoordinates(e){if(e instanceof MouseEvent)return{offsetX:e.offsetX,offsetY:e.offsetY};{const t=e.touches[0]||e.changedTouches[0],n=e.target.getBoundingClientRect();return{offsetX:t.clientX-n.left,offsetY:t.clientY-n.top}}}attachEvents(){this.canvas.addEventListener("mousedown",this.handleStart),this.canvas.addEventListener("mousemove",this.handleMove),this.canvas.addEventListener("mouseup",this.handleEnd),this.canvas.addEventListener("mouseleave",this.handleEnd),this.canvas.addEventListener("touchstart",this.handleStart,{passive:!1}),this.canvas.addEventListener("touchmove",this.handleMove,{passive:!1}),this.canvas.addEventListener("touchend",this.handleEnd),this.canvas.addEventListener("touchcancel",this.handleEnd)}detachEvents(){this.canvas.removeEventListener("mousedown",this.handleStart),this.canvas.removeEventListener("mousemove",this.handleMove),this.canvas.removeEventListener("mouseup",this.handleEnd),this.canvas.removeEventListener("mouseleave",this.handleEnd),this.canvas.removeEventListener("touchstart",this.handleStart),this.canvas.removeEventListener("touchmove",this.handleMove),this.canvas.removeEventListener("touchend",this.handleEnd),this.canvas.removeEventListener("touchcancel",this.handleEnd)}destroy(){this.detachEvents(),this.resetClearTimer()}getCanvas(){return this.canvas}getContext(){return this.ctx}};function lK(e,t,n){if(!e||!t||n==="static")return null;let s,r;if(n==="bottom")s=window.innerHeight-t.offsetHeight,r=0;else{const a=e.getBoundingClientRect(),o=t.offsetWidth;s=a.bottom+window.scrollY,r=a.left+window.scrollX+a.width/2-o/2;const i=window.innerWidth;r+o>i&&(r=i-o-10),r<10&&(r=10)}return{top:`${s}px`,left:`${r}px`}}function Hp(e){if(!e)return!1;if(e.tagName==="TEXTAREA")return!0;if(e.tagName==="INPUT"){const t=(e.type||"text").toLowerCase();return!["checkbox","radio","button","submit","reset","file","image","range","color","hidden","date","datetime-local","month","week","time"].includes(t)}return!1}function fK(e,t,n){e.value=t,mK(e,n),e.dispatchEvent(new Event("input",{bubbles:!0}))}function hK(e,t,n,s=""){return e.slice(0,t)+s+e.slice(t+n)}function Z0(e,t=""){const n=Number(e.getAttribute("maxlength"));let s=e.selectionStart??0;const r=e.selectionEnd??s;let a;if(t.length>0)a=r-s;else{const u=r-s;if(u>0)a=u;else if(s>0)a=1,s--;else return}if(t.length>0&&n&&e.value.length-a+t.length>n)return;const o=hK(e.value,s,a,t),i=s+t.length;fK(e,o,i)}function dK(e,t){Z0(e,t)}function pK(e){Z0(e)}function mK(e,t){e.selectionStart=t,e.selectionEnd=t}let Q0=null;function gK(e){Q0=e}function Vl(){return Q0}function yK(e=!1){const t=Ie(!1),n=Ie(0);async function s(){const a=Vl();if(a)try{t.value=await a.initialize({onProgress:o=>{n.value=o}})}catch(o){console.error(":",o),t.value=!1}else console.warn(""),t.value=!1}async function r(){const a=Vl();if(a&&t.value)try{await a.close(),t.value=!1}catch(o){console.error(":",o)}}return jo(()=>{e&&s()}),Mu(()=>{r()}),{recognizerInitialized:t,recognizerProgress:n}}const Lh="data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%3e%3cpath%20d='M21,11H6.83L10.41,7.41L9,6L3,12L9,18L10.41,16.58L6.83,13H21V11Z'%20/%3e%3c/svg%3e",zh="data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%3e%3cpath%20d='M19,7V11H5.83L9.41,7.41L8,6L2,12L8,18L9.41,16.58L5.83,13H21V7H19Z'%20/%3e%3c/svg%3e",bK={class:"zhk-candidate-list"},wK=["onClick"],tw=Ws({__name:"CandidateList",props:{candidates:{}},emits:["select"],setup(e,{emit:t}){const n=t;function s(r){n("select",r)}return(r,a)=>(Yt(),re("div",bK,[(Yt(!0),re(De,null,ps(r.candidates,(o,i)=>(Yt(),re("button",{key:`candidate-${i}`,class:"zhk-candidate-list__item",onClick:u=>s(o)},fn(o),9,wK))),128))]))}}),vK={class:"handwriting-input"},kK={class:"handwriting-buttons"},xK={class:"handwriting-canvas-container"},SK={class:"progress-bar"},IK={class:"progress-text"},NK=["width","height"],_K={class:"handwriting-buttons"},TK=Ws({__name:"HandwritingInput",props:{recognizerInitialized:{type:Boolean},recognizerProgress:{}},emits:["key","exit"],setup(e,{emit:t}){const n=e,s=t,r=Ie(null),a=Ie(null);let o=null;const i=Ie(!1),{height:u}=J0(a);function c(){o&&o.clearCanvas()}function l(){r.value&&(o&&o.destroy(),o=new cK(r.value,{onDrawEnd:d}))}const f=Ie([]);async function d(){if(!o||o.getStrokeData().length===0||i.value)return;const g=Vl();if(g){i.value=!0;try{const b=[...o.getStrokeData()],w=await g.recognize(b);f.value=w}catch(b){console.error(":",b)}finally{i.value=!1}}else console.warn("")}Mu(()=>{o&&o.destroy()}),Vu(()=>{r.value&&u.value&&n.recognizerInitialized&&Ru(()=>{l()})});function m(g){s("key",{key:g}),f.value=[],c()}return(g,b)=>(Yt(),re("div",vK,[Kn(tw,{candidates:f.value,onSelect:m},null,8,["candidates"]),St("div",{ref_key:"containerRef",ref:a,class:"handwriting-content"},[St("div",kK,[St("button",{class:"handwriting-btn handwriting-btn--function",onClick:b[0]||(b[0]=w=>s("key",{key:""}))},"  "),St("button",{class:"handwriting-btn handwriting-btn--function",onClick:b[1]||(b[1]=w=>s("key",{key:""}))},"  "),St("button",{class:"handwriting-btn handwriting-btn--function",onClick:b[2]||(b[2]=w=>s("key",{key:""}))},"  "),b[8]||(b[8]=Fo()),St("button",{class:"handwriting-btn handwriting-btn--function",onClick:b[3]||(b[3]=w=>s("key",{key:""}))},"  ")]),St("div",xK,[g.recognizerInitialized?(Yt(),re("canvas",{key:1,ref_key:"canvasRef",ref:r,class:"handwriting-canvas",width:On(u),height:On(u)},null,8,NK)):(Yt(),re("div",{key:0,class:"handwriting-loading",style:Oa({width:`${On(u)}px`,height:`${On(u)}px`})},[b[9]||(b[9]=St("div",{class:"loading-text"}," ... ",-1)),St("div",SK,[St("div",{class:"progress-fill",style:Oa({width:`${g.recognizerProgress*100}%`})},null,4)]),St("div",IK,fn(Math.round(g.recognizerProgress*100))+"% ",1)],4))]),St("div",_K,[St("button",{class:"handwriting-btn handwriting-btn--function",onClick:b[4]||(b[4]=w=>s("key",{key:"delete",isControl:!0}))},b[10]||(b[10]=[St("img",{src:Lh,alt:""},null,-1)])),St("button",{class:"handwriting-btn handwriting-btn--function",onClick:b[5]||(b[5]=w=>s("exit"))},"  "),St("button",{class:"handwriting-btn handwriting-btn--function",onClick:b[6]||(b[6]=w=>s("key",{key:""}))},"  "),St("button",{class:"handwriting-btn handwriting-btn--function",onClick:b[7]||(b[7]=w=>s("key",{key:"enter",isControl:!0}))},b[11]||(b[11]=[St("img",{src:zh,alt:""},null,-1)]))])],512)]))}}),EK="data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%3e%3cpath%20d='M6,18H18V16H6M12,8.41L16.59,13L18,11.58L12,5.58L6,11.58L7.41,13L12,8.41Z'%20/%3e%3c/svg%3e",ew="data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%3e%3cpath%20d='M3%2015H5V19H19V15H21V19C21%2020.1%2020.1%2021%2019%2021H5C3.9%2021%203%2020.1%203%2019V15Z'%20/%3e%3c/svg%3e",$K="data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%3e%3cpath%20d='M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z'%20/%3e%3c/svg%3e",CK={class:"zhk-selection"},OK={class:"zhk-selection__list"},DK=["onClick"],AK=Ws({__name:"CandidateSelection",props:{candidates:{}},emits:["select","close"],setup(e,{emit:t}){const n=t;function s(a){n("select",a)}function r(){n("close")}return(a,o)=>(Yt(),re("div",CK,[St("div",OK,[(Yt(!0),re(De,null,ps(a.candidates,(i,u)=>(Yt(),re("div",{key:u,class:"zhk-selection__text",onClick:c=>s(i)},fn(i),9,DK))),128))]),St("div",{class:"zhk-selection__func"},[St("button",{class:"zhk-selection__func-btn",onClick:r},"  ")])]))}}),FK={class:"zhk-candidate"},RK={class:"zhk-candidate__container"},PK={key:0,class:"zhk-candidate__pinyin"},MK={class:"zhk-candidate__bottom-container"},VK=Ws({__name:"CandidateBar",props:{modelValue:{required:!0},modelModifiers:{}},emits:Cl(["key","input"],["update:modelValue"]),setup(e,{emit:t}){const n=t,s=R0(e,"modelValue"),r=new uK,a=Ie([]);Vu(async()=>{a.value=await r.processInput(s.value)});const o=xn(()=>a.value.slice(0,30)),i=Ie(!1);function u(c){r.selectCandidate(c),n("input",c),s.value="",i.value=!1}return(c,l)=>(Yt(),re("div",FK,[St("div",RK,[s.value?(Yt(),re("div",PK,fn(s.value),1)):Vr("",!0),St("div",MK,[a.value.length>0?(Yt(),er(tw,{key:0,candidates:o.value,onSelect:u},null,8,["candidates"])):Vr("",!0),a.value.length>0?(Yt(),re("button",{key:1,class:"zhk-candidate__more",onClick:l[0]||(l[0]=f=>i.value=!0)},l[2]||(l[2]=[St("img",{src:$K,alt:""},null,-1)]))):Vr("",!0)])]),os(Kn(AK,{candidates:a.value,onSelect:u,onClose:l[1]||(l[1]=f=>i.value=!1)},null,8,["candidates"]),[[U0,i.value]])]))}}),LK={class:"zhk-base"},zK={class:"zhk-base__row"},BK=["onClick"],WK=["disabled"],jK={key:1,src:EK,class:"zhk-base__key-icon",alt:"Shift"},qK=["onClick"],HK={class:"zhk-base__row"},KK={class:"zhk-base__toggle-main"},UK={class:"zhk-base__toggle-sub"},GK=Ws({__name:"KeyboardBase",props:Cl({enableHandwriting:{type:Boolean}},{modelValue:{default:"en"},modelModifiers:{}}),emits:Cl(["key"],["update:modelValue"]),setup(e,{emit:t}){const n=e,s=t,r=R0(e,"modelValue"),a=Ie(!1),o=xn(()=>r.value==="zh"),i=xn(()=>o.value?!0:a.value);function u(I,$=!1){s("key",{key:I,isControl:$})}function c(){o.value?r.value="hand":a.value=!a.value}function l(){r.value="num"}function f(){r.value="symbol"}const d=["1","2","3","4","5","6","7","8","9","0"],m=[["q","w","e","r","t","y","u","i","o","p"],["a","s","d","f","g","h","j","k","l"],["z","x","c","v","b","n","m"]],g=Ie("");function b(){if(r.value==="zh"&&g.value){g.value=g.value.slice(0,-1);return}u("delete",!0)}function w(I){if(r.value==="zh"){g.value+=I;return}const $=a.value?I.toUpperCase():I;u($)}function k(){r.value=r.value==="zh"?"en":"zh"}const N=xn(()=>n.enableHandwriting?"":"-"),_=xn(()=>!n.enableHandwriting);return(I,$)=>(Yt(),re("div",LK,[St("div",zK,[r.value==="zh"?(Yt(),er(VK,{key:0,modelValue:g.value,"onUpdate:modelValue":$[0]||($[0]=O=>g.value=O),onInput:$[1]||($[1]=O=>u(O,!1))},null,8,["modelValue"])):(Yt(),re(De,{key:1},ps(d,(O,R)=>St("button",{key:`number-${R}`,class:"zhk-base__key zhk-base__key--letter",onClick:W=>w(O)},fn(O),9,BK)),64))]),(Yt(),re(De,null,ps(m,(O,R)=>St("div",{key:`row-${R}`,class:"zhk-base__row"},[R===2?(Yt(),re("button",{key:0,class:ir(["zhk-base__key zhk-base__key--function zhk-base__key--shift",{"zhk-base__key--active":!o.value&&a.value,"zhk-base__key--disabled":o.value&&_.value}]),disabled:o.value&&_.value,onClick:c},[o.value?(Yt(),re(De,{key:0},[Fo(fn(N.value),1)],64)):(Yt(),re("img",jK))],10,WK)):Vr("",!0),(Yt(!0),re(De,null,ps(O,(W,P)=>(Yt(),re("button",{key:`key-${R}-${P}`,class:"zhk-base__key zhk-base__key--letter",onClick:M=>w(W)},fn(i.value?W.toUpperCase():W),9,qK))),128)),R===2?(Yt(),re("button",{key:1,class:"zhk-base__key zhk-base__key--function zhk-base__key--delete",onClick:$[2]||($[2]=()=>b())},$[7]||($[7]=[St("img",{src:Lh,class:"zhk-base__key-icon",alt:"Delete"},null,-1)]))):Vr("",!0)])),64)),St("div",HK,[St("button",{class:"zhk-base__key zhk-base__key--function",onClick:f},"  "),St("button",{class:"zhk-base__key zhk-base__key--function",onClick:l}," 123 "),St("button",{class:"zhk-base__key",onClick:$[3]||($[3]=()=>u(","))},"  "),St("button",{class:"zhk-base__key zhk-base__key--space",onClick:$[4]||($[4]=()=>u(" "))},$[8]||($[8]=[St("img",{src:ew,class:"zhk-base__key-icon",alt:"Space"},null,-1)])),St("button",{class:"zhk-base__key",onClick:$[5]||($[5]=()=>u(""))},"  "),St("button",{class:"zhk-base__key zhk-base__key--function",onClick:k},[St("span",KK,fn(r.value==="zh"?"":""),1),St("span",UK,"/"+fn(r.value==="zh"?"":""),1)]),St("button",{class:"zhk-base__key zhk-base__key--function",onClick:$[6]||($[6]=()=>u("enter",!0))},$[9]||($[9]=[St("img",{src:zh,class:"zhk-base__key-icon",alt:"Enter"},null,-1)]))])]))}}),XK={class:"num-keyboard"},YK={class:"num-keyboard__container"},JK={class:"num-keyboard__left"},ZK={class:"num-keyboard__rows"},QK=["onClick"],t6={key:1,src:ew,class:"zhk-base__key-icon",alt:"Space"},e6={class:"num-keyboard__right"},n6=["onClick"],s6=["src","alt"],r6={key:1},a6=Ws({__name:"NumericKeyboard",emits:["key","exit"],setup(e,{emit:t}){const n=t,s=[["1","2","3"],["4","5","6"],["7","8","9"],["back","0","space"]],r=[{key:"delete",icon:Lh,text:"",alt:"Delete"},{key:".",icon:"",text:".",alt:"."},{key:"@",icon:"",text:"@",alt:"@"},{key:"enter",icon:zh,text:"",alt:"Enter"}];function a(u){n("key",{key:u})}function o(u,c=!0){n("key",{key:u,isControl:c})}function i(){n("exit")}return(u,c)=>(Yt(),re("div",XK,[St("div",YK,[St("div",JK,[St("div",ZK,[(Yt(),re(De,null,ps(s,(l,f)=>St("div",{key:`row-${f}`,class:"num-keyboard__row"},[(Yt(!0),re(De,null,ps(l,(d,m)=>(Yt(),re("button",{key:`key-${f}-${m}`,class:ir(["num-keyboard__key",{"num-keyboard__key--back":d==="back","num-keyboard__key--space":d==="space"}]),onClick:g=>d==="back"?i():a(d==="space"?" ":d)},[d==="back"?(Yt(),re(De,{key:0},[Fo("  ")],64)):d==="space"?(Yt(),re("img",t6)):(Yt(),re(De,{key:2},[Fo(fn(d),1)],64))],10,QK))),128))])),64))])]),St("div",e6,[(Yt(),re(De,null,ps(r,(l,f)=>St("button",{key:`func-${f}`,class:"num-keyboard__key num-keyboard__key--function",onClick:d=>l.key==="."||l.key==="@"?a(l.key):o(l.key)},[l.icon?(Yt(),re("img",{key:0,src:l.icon,class:"num-keyboard__key-icon",alt:l.alt},null,8,s6)):(Yt(),re("span",r6,fn(l.text),1))],8,n6)),64))])])]))}}),o6="data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%3e%3cpath%20d='M18,20V10H6V20H18M18,8A2,2%200%200,1%2020,10V20A2,2%200%200,1%2018,22H6C4.89,22%204,21.1%204,20V10A2,2%200%200,1%206,8H15V6A3,3%200%200,0%2012,3A3,3%200%200,0%209,6H7A5,5%200%200,1%2012,1A5,5%200%200,1%2017,6V8H18M12,17A2,2%200%200,1%2010,15A2,2%200%200,1%2012,13A2,2%200%200,1%2014,15A2,2%200%200,1%2012,17Z'%20/%3e%3c/svg%3e",i6="data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%3e%3cpath%20d='M12,17C10.89,17%2010,16.1%2010,15C10,13.89%2010.89,13%2012,13A2,2%200%200,1%2014,15A2,2%200%200,1%2012,17M18,20V10H6V20H18M18,8A2,2%200%200,1%2020,10V20A2,2%200%200,1%2018,22H6C4.89,22%204,21.1%204,20V10C4,8.89%204.89,8%206,8H7V6A5,5%200%200,1%2012,1A5,5%200%200,1%2017,6V8H18M12,3A3,3%200%200,0%209,6V8H15V6A3,3%200%200,0%2012,3Z'%20/%3e%3c/svg%3e",u6={class:"symbol-keyboard"},c6={class:"symbol-keyboard__content"},l6={class:"symbol-keyboard__functions"},f6={class:"symbol-keyboard__lang-selector"},h6={class:"symbol-keyboard__control-group"},d6=["src"],p6=["src"],m6={class:"symbol-keyboard__symbols-container"},g6={class:"symbol-keyboard__symbols-grid"},y6=["onClick"],b6="!@#$%^&*(){}[]<>/\\|:;\"',.,?+-=_~`",w6="",v6=Ws({__name:"SymbolKeyboard",emits:["key","exit"],setup(e,{emit:t}){const n=t,s=Ie("en"),r=xn(()=>s.value==="zh"?w6:b6),a=Ie(!1);function o(l){n("key",{key:l}),a.value||n("exit")}function i(){n("exit")}function u(l){s.value=l}function c(){a.value=!a.value}return(l,f)=>(Yt(),re("div",u6,[St("div",c6,[St("div",l6,[St("div",f6,[St("button",{class:ir(["symbol-keyboard__lang-btn",{"symbol-keyboard__lang-btn--active":s.value==="zh"}]),onClick:f[0]||(f[0]=d=>u("zh"))},"  ",2),St("button",{class:ir(["symbol-keyboard__lang-btn",{"symbol-keyboard__lang-btn--active":s.value==="en"}]),onClick:f[1]||(f[1]=d=>u("en"))},"  ",2)]),St("div",h6,[St("button",{class:ir(["symbol-keyboard__key symbol-keyboard__key--function symbol-keyboard__key--lock",{"symbol-keyboard__key--locked":a.value}]),onClick:c},[a.value?(Yt(),re("img",{key:1,src:On(i6),alt:"Lock closed"},null,8,p6)):(Yt(),re("img",{key:0,src:On(o6),alt:"Lock open"},null,8,d6))],2),St("button",{class:"symbol-keyboard__key symbol-keyboard__key--function symbol-keyboard__key--back",onClick:i},"  ")])]),St("div",m6,[St("div",g6,[(Yt(!0),re(De,null,ps(r.value,(d,m)=>(Yt(),re("button",{key:`key-${m}`,class:"symbol-keyboard__key",onClick:g=>o(d)},fn(d),9,y6))),128))])])])]))}}),k6={key:0,class:"zhk__disabled-overlay"},x6=Ws({__name:"ZhKeyboard",props:{defaultMode:{default:"en"},enableHandwriting:{type:Boolean,default:!1},position:{default:"static"},disableWhenNoFocus:{type:Boolean,default:!0}},emits:["key"],setup(e,{emit:t}){const n=e,s=t,r=Ie(n.defaultMode||"en"),a=Ie(n.defaultMode||"en"),o=Ie([]),i=Ie(!1),u=Ie(null),c=Ie(null),{recognizerInitialized:l,recognizerProgress:f}=yK(n.enableHandwriting);Ds(r,(O,R)=>{O!==R&&(a.value=R)});const d=TL(),m=xn(()=>d.value&&Hp(d.value)?d.value:null),g=xn(()=>n.position==="static"||!!(d.value&&Hp(d.value))),{height:b}=J0(c);Vu(()=>{if(m.value){const O=m.value.dataset.inputmode;O&&(r.value=O)}}),Ds([g,b,m],()=>{g.value&&b.value&&Ru(()=>{k()})});const w=xn(()=>n.disableWhenNoFocus===!1?!1:!m.value);function k(){if(!b.value)return;const O=lK(m.value,c.value,n.position);u.value=O}fu(window,"scroll",k,{passive:!0}),fu(window,"resize",k,{passive:!0});function N(O){if(O.isControl){switch(O.key){case"delete":pK(m.value);break;case"more":i.value=!0;break}return}else _(O.key);s("key",O)}function _(O){dK(m.value,O)}function I(){r.value=a.value}function $(O){o.value=O}return(O,R)=>(Yt(),er(LM,{to:"body",disabled:O.position==="static"},[os(St("div",W0(O.$attrs,{ref_key:"keyboardRef",ref:c,class:["zhk",{"zhk--floating":O.position==="float","zhk--bottom":O.position==="bottom","zhk--disabled":w.value}],style:{"--keyboard-height":`${On(b)}px`,...u.value},onMousedown:R[1]||(R[1]=uL(()=>{},["prevent"]))}),[w.value||!g.value||!On(b)?(Yt(),re("div",k6,R[2]||(R[2]=[St("span",null,"",-1)]))):(Yt(),re(De,{key:1},[r.value==="hand"?(Yt(),er(TK,{key:0,"recognizer-initialized":On(l),"recognizer-progress":On(f),onKey:N,onExit:I,onRecognize:$},null,8,["recognizer-initialized","recognizer-progress"])):r.value==="num"?(Yt(),er(a6,{key:1,onKey:N,onExit:I})):r.value==="symbol"?(Yt(),er(v6,{key:2,onKey:N,onExit:I})):r.value==="en"||r.value==="zh"?(Yt(),er(GK,{key:3,modelValue:r.value,"onUpdate:modelValue":R[0]||(R[0]=W=>r.value=W),"enable-handwriting":O.enableHandwriting,onKey:N},null,8,["modelValue","enable-handwriting"])):Vr("",!0)],64))],16),[[U0,g.value]])],8,["disabled"]))}}),S6={class:"root-container"},I6={class:"container"},N6={class:"input-grid"},_6={class:"input-container"},T6={class:"input-container"},E6={class:"input-container"},$6={class:"input-container"},C6={class:"controls"},O6={class:"checkbox-container"},D6={class:"checkbox-item"},A6={class:"position-container"},F6={class:"radio-group"},R6=["id","value"],P6=["for"],M6={class:"keyboard-wrapper"},V6=Ws({__name:"App",setup(e){const t=Ie(""),n=Ie(""),s=Ie(""),r=Ie(""),a=Ie(400),o=Ie(300),i=Ie("float"),u=Ie(!0),c={static:"",float:"",bottom:""};return jo(()=>{window.innerWidth<960&&(i.value="bottom")}),(l,f)=>(Yt(),re("div",S6,[St("div",I6,[f[14]||(f[14]=St("div",{class:"header"},[St("h1",null,""),St("div",{class:"github-link"},[St("a",{href:"https://github.com/dusionlike/zh-keyboard",target:"_blank",rel:"noopener noreferrer"},[St("img",{src:"https://img.shields.io/github/stars/dusionlike/zh-keyboard?style=social",alt:"GitHub stars"})])])],-1)),St("div",N6,[St("div",_6,[f[8]||(f[8]=St("label",null,":",-1)),os(St("input",{"onUpdate:modelValue":f[0]||(f[0]=d=>t.value=d),type:"text","data-inputmode":"en",inputmode:"none",placeholder:""},null,512),[[ia,t.value]])]),St("div",T6,[f[9]||(f[9]=St("label",null,":",-1)),os(St("input",{"onUpdate:modelValue":f[1]||(f[1]=d=>n.value=d),type:"text","data-inputmode":"zh",inputmode:"none",placeholder:""},null,512),[[ia,n.value]])]),St("div",E6,[f[10]||(f[10]=St("label",null,":",-1)),os(St("input",{"onUpdate:modelValue":f[2]||(f[2]=d=>s.value=d),type:"text","data-inputmode":"hand",inputmode:"none",placeholder:""},null,512),[[ia,s.value]])]),St("div",$6,[f[11]||(f[11]=St("label",null,":",-1)),os(St("input",{"onUpdate:modelValue":f[3]||(f[3]=d=>r.value=d),type:"text","data-inputmode":"num",inputmode:"none",placeholder:""},null,512),[[ia,r.value]])])]),St("div",C6,[i.value!=="bottom"?(Yt(),re(De,{key:0},[St("label",null,": "+fn(a.value)+"px",1),os(St("input",{"onUpdate:modelValue":f[4]||(f[4]=d=>a.value=d),type:"range",min:"400",max:"1080",step:"10",class:"width-slider"},null,512),[[ia,a.value]]),St("label",null,": "+fn(o.value)+"px",1),os(St("input",{"onUpdate:modelValue":f[5]||(f[5]=d=>o.value=d),type:"range",min:"300",max:"1000",step:"10",class:"width-slider"},null,512),[[ia,o.value]])],64)):Vr("",!0),St("div",O6,[St("div",D6,[os(St("input",{id:"disable-when-no-focus","onUpdate:modelValue":f[6]||(f[6]=d=>u.value=d),type:"checkbox"},null,512),[[rL,u.value]]),f[12]||(f[12]=St("label",{for:"disable-when-no-focus"},"",-1))])]),St("div",A6,[f[13]||(f[13]=St("label",null,":",-1)),St("div",F6,[(Yt(),re(De,null,ps(c,(d,m)=>St("div",{key:m,class:"radio-item"},[os(St("input",{id:`pos-${m}`,"onUpdate:modelValue":f[7]||(f[7]=g=>i.value=g),type:"radio",value:m,name:"position"},null,8,R6),[[aL,i.value]]),St("label",{for:`pos-${m}`},fn(d),9,P6)])),64))])])])]),St("div",M6,[Kn(On(x6),{position:i.value,style:Oa(i.value==="bottom"?{width:"100%",height:"auto"}:{width:`${a.value}px`,height:`${o.value}px`}),"enable-handwriting":"","disable-when-no-focus":u.value},null,8,["position","style","disable-when-no-focus"])])]))}});gK(new qP({modelPath:new URL(""+new URL("../models/handwrite/model.json",import.meta.url).href,import.meta.url).href,dictPath:new URL(""+new URL("../models/dict.txt",import.meta.url).href,import.meta.url).href}));fL(V6).mount("#app");
