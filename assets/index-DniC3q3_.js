var t_=Object.defineProperty;var n_=(n,e,t)=>e in n?t_(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var Bo=(n,e,t)=>n_(n,typeof e!="symbol"?e+"":e,t);function s_(n,e){for(var t=0;t<e.length;t++){const s=e[t];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in n)){const o=Object.getOwnPropertyDescriptor(s,r);o&&Object.defineProperty(n,r,o.get?o:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const o of r)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&s(i)}).observe(document,{childList:!0,subtree:!0});function t(r){const o={};return r.integrity&&(o.integrity=r.integrity),r.referrerPolicy&&(o.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?o.credentials="include":r.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(r){if(r.ep)return;r.ep=!0;const o=t(r);fetch(r.href,o)}})();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r_=1e-7,o_=1e-4;class ak{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Ny{refCount(e){return $s("refCount")}incRef(e){return $s("incRef")}timerAvailable(){return!0}time(e){return $s("time")}read(e){return $s("read")}readSync(e){return $s("readSync")}readToGPU(e,t){return $s("readToGPU")}numDataIds(){return $s("numDataIds")}disposeData(e,t){return $s("disposeData")}write(e,t,s){return $s("write")}move(e,t,s,r,o){return $s("move")}createTensorFromGPUData(e,t,s){return $s("createTensorFromGPUData")}memory(){return $s("memory")}floatPrecision(){return $s("floatPrecision")}epsilon(){return this.floatPrecision()===32?r_:o_}dispose(){return $s("dispose")}}function $s(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i_(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,Da(n,e,t)}function Xi(n,e,t){return Math.max(n,Math.min(e,t))}function Ty(n){return n%2===0?n:n+1}function Da(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function a_(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function A(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function Ms(n,e,t=""){A(Tt(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function dl(n){A(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function pe(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function l_(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function Tt(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Za(n){return n%1===0}function pg(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function za(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function Ow(n,e=r=>0,t,s){return new Promise((r,o)=>{let i=0;const a=()=>{if(n()){r();return}i++;const l=e(i);if(t!=null&&i>=t){o();return}s!=null?s(a,l):setTimeout(a,l)};a()})}function lk(n,e){let t=1,s=-1;for(let o=0;o<n.length;++o)if(n[o]>=0)t*=n[o];else if(n[o]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${o}`);s=o}else if(n[o]<0)throw Error(`Shapes can not be < 0. Found ${n[o]} at dim ${o}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const r=n.slice();return r[s]=e/t,r}function kt(n,e){const t=e.length;return n=n==null?e.map((s,r)=>r):[].concat(n),A(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),A(n.every(s=>Za(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function di(n,e){const t=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,o=e==null||r?null:kt(e,n).sort();let i=0;for(let a=0;a<n.length;++a){if(o!=null){if(o[i]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(o[i]==null||o[i]>a)&&n[a]===1&&(t.push(n[a]),s.push(a)),o[i]<=a&&i++}n[a]!==1&&(t.push(n[a]),s.push(a))}return{newShape:t,keptDims:s}}function Bn(n,e){return hn(n,e)}function hn(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function u_(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function c_(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function uk(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function id(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function h_(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function Au(n){return typeof n=="string"||n instanceof String}function d_(n){return typeof n=="boolean"}function fg(n){return typeof n=="number"}function pl(n){return Array.isArray(n)?pl(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":fg(n)?"float32":Au(n)?"string":d_(n)?"bool":"float32"}function mg(n){return!!(n&&n.constructor&&n.call&&n.apply)}function gg(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function rt(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function ck(n,e,t,s=!1){const r=new Array;if(e.length===1){const o=e[0]*(s?2:1);for(let i=0;i<o;i++)r[i]=t[n+i]}else{const o=e[0],i=e.slice(1),a=i.reduce((l,u)=>l*u)*(s?2:1);for(let l=0;l<o;l++)r[l]=ck(n+l*a,i,t,s)}return r}function ir(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((r,o)=>r*o)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return ck(0,n,e,t)}function p_(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function Ey(n,e){const t=Xn(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function Xn(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function hk(n,e){const t=n.reduce((s,r)=>s*r,1);if(e==null||e==="float32")return ir(n,new Float32Array(t));if(e==="int32")return ir(n,new Int32Array(t));if(e==="bool")return ir(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function Xs(n){n.forEach(e=>{A(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Wr(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=t[r]*n[r];return s}function fl(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/t[r]),n-=s[r]*t[r];return s[s.length-1]=n,s}function Yi(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fw="tfjsflags";class f_{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=m_,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(ue().getBool("IS_TEST")||ue().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];ue().getBool("IS_TEST")||ue().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Yi(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);Fw in e&&e[Fw].split(",").forEach(s=>{const[r,o]=s.split(":");this.urlFlags[r]=y_(r,o)})}}function m_(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>(g_(e,s[0],s[1]),s.join("="))),e}function g_(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function y_(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function ue(){return dk}let dk=null;function b_(n){dk=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Lm;function pk(){if(Lm==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");Lm=n}return Lm}function x_(){const n=pk();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function _y(n,e){const t=x_();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const qd="Abs",Ru="Acos",Du="Acosh",ml="Add",Xd="AddN",Ay="All",Ry="Any",Yd="ArgMax",Zd="ArgMin",Ou="Asin",Fu="Asinh",Lu="Atan",Pu="Atanh",zu="Atan2",Jd="AvgPool",Dy="AvgPoolGrad",Qd="AvgPool3D",Oy="AvgPool3DGrad",ep="BatchMatMul",tp="BatchToSpaceND",Fy="Bincount",np="BitwiseAnd",w_="BroadcastTo",Ly="BroadcastArgs",Mu="Cast",Bu="Ceil",Vu="ClipByValue",Py="Complex",sp="ComplexAbs",rp="Concat",op="Conv2D",zy="Conv2DBackpropFilter",ip="Conv2DBackpropInput",ap="Conv3D",My="Conv3DBackpropFilterV2",By="Conv3DBackpropInputV2",Wu="Cos",Uu="Cosh",Vy="Cumprod",lp="Cumsum",Wy="CropAndResize",Uy="DenseBincount",Gy="DepthToSpace",up="DepthwiseConv2dNative",Hy="DepthwiseConv2dNativeBackpropFilter",jy="DepthwiseConv2dNativeBackpropInput",Ky="Diag",cp="Dilation2D",yg="Dilation2DBackpropInput",bg="Dilation2DBackpropFilter",v_="Draw",Gu="RealDiv",qy="Einsum",Hu="Elu",Xy="EluGrad",ju="Erf",hp="Equal",Ku="Exp",dp="ExpandDims",qu="Expm1",Yy="FFT",Zy="Fill",Jy="FlipLeftRight",Xu="Floor",Yu="FloorDiv",pp="FusedBatchNorm",fp="GatherV2",Qy="GatherNd",mp="Greater",Zu="GreaterEqual",Ju="Identity",eb="IFFT",tb="Imag",Qu="IsFinite",ec="IsInf",tc="IsNan",gp="LeakyRelu",yp="Less",bp="LessEqual",nb="LinSpace",nc="Log",sc="Log1p",xp="LogicalAnd",wp="LogicalNot",vp="LogicalOr",k_="LogSoftmax",kp="LRN",sb="LRNGrad",Cp="Max",rc="Maximum",Sp="MaxPool",rb="MaxPoolGrad",Ip="MaxPool3D",ob="MaxPool3DGrad",ib="MaxPoolWithArgmax",$p="Mean",Np="Min",oc="Minimum",Tp="MirrorPad",ic="Mod",ab="Multinomial",ac="Multiply",Ep="Neg",_p="NotEqual",lb="NonMaxSuppressionV3",ub="NonMaxSuppressionV4",cb="NonMaxSuppressionV5",Ap="OnesLike",Rp="OneHot",Dp="Pack",Op="PadV2",lc="Pow",Fp="Prelu",Lp="Prod",hb="RaggedGather",db="RaggedRange",pb="RaggedTensorToTensor",fb="Range",mb="Real",uc="Reciprocal",cc="Relu",Pp="Reshape",zp="ResizeNearestNeighbor",gb="ResizeNearestNeighborGrad",Mp="ResizeBilinear",yb="ResizeBilinearGrad",hc="Relu6",Bp="Reverse",dc="Round",pc="Rsqrt",bb="ScatterNd",xb="TensorScatterUpdate",wb="SearchSorted",Vp="Select",fc="Selu",Wp="Slice",mc="Sin",gc="Sinh",yc="Sign",bc="Sigmoid",xc="Softplus",wc="Sqrt",Up="Sum",Gp="SpaceToBatchND",Hp="SplitV",jp="Softmax",vb="SparseFillEmptyRows",kb="SparseReshape",Cb="SparseSegmentMean",Sb="SparseSegmentSum",Ib="SparseToDense",vc="SquaredDifference",$b="Square",Kp="StaticRegexReplace",Nb="StridedSlice",Tb="StringNGrams",Eb="StringSplit",_b="StringToHashBucketFast",kc="Sub",Cc="Tan",Sc="Tanh",Ic="Tile",Ab="TopK",Rb="Transform",Ma="Transpose",Db="Unique",qp="Unpack",Xp="UnsortedSegmentSum",Yp="ZerosLike",$c="Step",xg="FromPixels",Ob="RotateWithOffset",ad="_FusedMatMul",ld="FusedConv2D",ud="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Us(...n){ue().getBool("IS_TEST")||ue().getBool("PROD")||console.warn(...n)}function C_(...n){ue().getBool("IS_TEST")||ue().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cd=_y("kernelRegistry",()=>new Map),wg=_y("gradRegistry",()=>new Map);function vg(n,e){const t=mk(n,e);return cd.get(t)}function Lw(n){return wg.get(n)}function Pw(n){const e=cd.entries(),t=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[o,i]=r,[a]=o.split("_");a===n&&t.push(i)}return t}function fk(n){const{kernelName:e,backendName:t}=n,s=mk(e,t);cd.has(s)&&Us(`The kernel '${e}' for backend '${t}' is already registered`),cd.set(s,n)}function S_(n){const{kernelName:e}=n;wg.has(e)&&ue().getBool("DEBUG")&&Us(`Overriding the gradient for '${e}'`),wg.set(e,n)}function mk(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gk(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}function I_(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function $_(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var e=n.default;if(typeof e=="function"){var t=function s(){return this instanceof s?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var r=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(t,s,r.get?r:{enumerable:!0,get:function(){return n[s]}})}),t}var Pm,zw;function N_(){if(zw)return Pm;zw=1,Pm=e;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(F,T,V){this.low=F|0,this.high=T|0,this.unsigned=!!V}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function t(F){return(F&&F.__isLong__)===!0}e.isLong=t;var s={},r={};function o(F,T){var V,q,se;return T?(F>>>=0,(se=0<=F&&F<256)&&(q=r[F],q)?q:(V=a(F,(F|0)<0?-1:0,!0),se&&(r[F]=V),V)):(F|=0,(se=-128<=F&&F<128)&&(q=s[F],q)?q:(V=a(F,F<0?-1:0,!1),se&&(s[F]=V),V))}e.fromInt=o;function i(F,T){if(isNaN(F))return T?w:b;if(T){if(F<0)return w;if(F>=f)return R}else{if(F<=-9223372036854776e3)return L;if(F+1>=g)return E}return F<0?i(-F,T).neg():a(F%p|0,F/p|0,T)}e.fromNumber=i;function a(F,T,V){return new e(F,T,V)}e.fromBits=a;var l=Math.pow;function u(F,T,V){if(F.length===0)throw Error("empty string");if(F==="NaN"||F==="Infinity"||F==="+Infinity"||F==="-Infinity")return b;if(typeof T=="number"?(V=T,T=!1):T=!!T,V=V||10,V<2||36<V)throw RangeError("radix");var q;if((q=F.indexOf("-"))>0)throw Error("interior hyphen");if(q===0)return u(F.substring(1),T,V).neg();for(var se=i(l(V,8)),ee=b,te=0;te<F.length;te+=8){var le=Math.min(8,F.length-te),Q=parseInt(F.substring(te,te+le),V);if(le<8){var he=i(l(V,le));ee=ee.mul(he).add(i(Q))}else ee=ee.mul(se),ee=ee.add(i(Q))}return ee.unsigned=T,ee}e.fromString=u;function c(F,T){return typeof F=="number"?i(F,T):typeof F=="string"?u(F,T):a(F.low,F.high,typeof T=="boolean"?T:F.unsigned)}e.fromValue=c;var h=65536,d=1<<24,p=h*h,f=p*p,g=f/2,y=o(d),b=o(0);e.ZERO=b;var w=o(0,!0);e.UZERO=w;var C=o(1);e.ONE=C;var v=o(1,!0);e.UONE=v;var I=o(-1);e.NEG_ONE=I;var E=a(-1,2147483647,!1);e.MAX_VALUE=E;var R=a(-1,-1,!0);e.MAX_UNSIGNED_VALUE=R;var L=a(0,-2147483648,!1);e.MIN_VALUE=L;var D=e.prototype;return D.toInt=function(){return this.unsigned?this.low>>>0:this.low},D.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},D.toString=function(T){if(T=T||10,T<2||36<T)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(L)){var V=i(T),q=this.div(V),se=q.mul(V).sub(this);return q.toString(T)+se.toInt().toString(T)}else return"-"+this.neg().toString(T);for(var ee=i(l(T,6),this.unsigned),te=this,le="";;){var Q=te.div(ee),he=te.sub(Q.mul(ee)).toInt()>>>0,ye=he.toString(T);if(te=Q,te.isZero())return ye+le;for(;ye.length<6;)ye="0"+ye;le=""+ye+le}},D.getHighBits=function(){return this.high},D.getHighBitsUnsigned=function(){return this.high>>>0},D.getLowBits=function(){return this.low},D.getLowBitsUnsigned=function(){return this.low>>>0},D.getNumBitsAbs=function(){if(this.isNegative())return this.eq(L)?64:this.neg().getNumBitsAbs();for(var T=this.high!=0?this.high:this.low,V=31;V>0&&(T&1<<V)==0;V--);return this.high!=0?V+33:V+1},D.isZero=function(){return this.high===0&&this.low===0},D.eqz=D.isZero,D.isNegative=function(){return!this.unsigned&&this.high<0},D.isPositive=function(){return this.unsigned||this.high>=0},D.isOdd=function(){return(this.low&1)===1},D.isEven=function(){return(this.low&1)===0},D.equals=function(T){return t(T)||(T=c(T)),this.unsigned!==T.unsigned&&this.high>>>31===1&&T.high>>>31===1?!1:this.high===T.high&&this.low===T.low},D.eq=D.equals,D.notEquals=function(T){return!this.eq(T)},D.neq=D.notEquals,D.ne=D.notEquals,D.lessThan=function(T){return this.comp(T)<0},D.lt=D.lessThan,D.lessThanOrEqual=function(T){return this.comp(T)<=0},D.lte=D.lessThanOrEqual,D.le=D.lessThanOrEqual,D.greaterThan=function(T){return this.comp(T)>0},D.gt=D.greaterThan,D.greaterThanOrEqual=function(T){return this.comp(T)>=0},D.gte=D.greaterThanOrEqual,D.ge=D.greaterThanOrEqual,D.compare=function(T){if(t(T)||(T=c(T)),this.eq(T))return 0;var V=this.isNegative(),q=T.isNegative();return V&&!q?-1:!V&&q?1:this.unsigned?T.high>>>0>this.high>>>0||T.high===this.high&&T.low>>>0>this.low>>>0?-1:1:this.sub(T).isNegative()?-1:1},D.comp=D.compare,D.negate=function(){return!this.unsigned&&this.eq(L)?L:this.not().add(C)},D.neg=D.negate,D.add=function(T){t(T)||(T=c(T));var V=this.high>>>16,q=this.high&65535,se=this.low>>>16,ee=this.low&65535,te=T.high>>>16,le=T.high&65535,Q=T.low>>>16,he=T.low&65535,ye=0,we=0,Ce=0,Se=0;return Se+=ee+he,Ce+=Se>>>16,Se&=65535,Ce+=se+Q,we+=Ce>>>16,Ce&=65535,we+=q+le,ye+=we>>>16,we&=65535,ye+=V+te,ye&=65535,a(Ce<<16|Se,ye<<16|we,this.unsigned)},D.subtract=function(T){return t(T)||(T=c(T)),this.add(T.neg())},D.sub=D.subtract,D.multiply=function(T){if(this.isZero())return b;if(t(T)||(T=c(T)),n){var V=n.mul(this.low,this.high,T.low,T.high);return a(V,n.get_high(),this.unsigned)}if(T.isZero())return b;if(this.eq(L))return T.isOdd()?L:b;if(T.eq(L))return this.isOdd()?L:b;if(this.isNegative())return T.isNegative()?this.neg().mul(T.neg()):this.neg().mul(T).neg();if(T.isNegative())return this.mul(T.neg()).neg();if(this.lt(y)&&T.lt(y))return i(this.toNumber()*T.toNumber(),this.unsigned);var q=this.high>>>16,se=this.high&65535,ee=this.low>>>16,te=this.low&65535,le=T.high>>>16,Q=T.high&65535,he=T.low>>>16,ye=T.low&65535,we=0,Ce=0,Se=0,Le=0;return Le+=te*ye,Se+=Le>>>16,Le&=65535,Se+=ee*ye,Ce+=Se>>>16,Se&=65535,Se+=te*he,Ce+=Se>>>16,Se&=65535,Ce+=se*ye,we+=Ce>>>16,Ce&=65535,Ce+=ee*he,we+=Ce>>>16,Ce&=65535,Ce+=te*Q,we+=Ce>>>16,Ce&=65535,we+=q*ye+se*he+ee*Q+te*le,we&=65535,a(Se<<16|Le,we<<16|Ce,this.unsigned)},D.mul=D.multiply,D.divide=function(T){if(t(T)||(T=c(T)),T.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&T.low===-1&&T.high===-1)return this;var V=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,T.low,T.high);return a(V,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?w:b;var q,se,ee;if(this.unsigned){if(T.unsigned||(T=T.toUnsigned()),T.gt(this))return w;if(T.gt(this.shru(1)))return v;ee=w}else{if(this.eq(L)){if(T.eq(C)||T.eq(I))return L;if(T.eq(L))return C;var te=this.shr(1);return q=te.div(T).shl(1),q.eq(b)?T.isNegative()?C:I:(se=this.sub(T.mul(q)),ee=q.add(se.div(T)),ee)}else if(T.eq(L))return this.unsigned?w:b;if(this.isNegative())return T.isNegative()?this.neg().div(T.neg()):this.neg().div(T).neg();if(T.isNegative())return this.div(T.neg()).neg();ee=b}for(se=this;se.gte(T);){q=Math.max(1,Math.floor(se.toNumber()/T.toNumber()));for(var le=Math.ceil(Math.log(q)/Math.LN2),Q=le<=48?1:l(2,le-48),he=i(q),ye=he.mul(T);ye.isNegative()||ye.gt(se);)q-=Q,he=i(q,this.unsigned),ye=he.mul(T);he.isZero()&&(he=C),ee=ee.add(he),se=se.sub(ye)}return ee},D.div=D.divide,D.modulo=function(T){if(t(T)||(T=c(T)),n){var V=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,T.low,T.high);return a(V,n.get_high(),this.unsigned)}return this.sub(this.div(T).mul(T))},D.mod=D.modulo,D.rem=D.modulo,D.not=function(){return a(~this.low,~this.high,this.unsigned)},D.and=function(T){return t(T)||(T=c(T)),a(this.low&T.low,this.high&T.high,this.unsigned)},D.or=function(T){return t(T)||(T=c(T)),a(this.low|T.low,this.high|T.high,this.unsigned)},D.xor=function(T){return t(T)||(T=c(T)),a(this.low^T.low,this.high^T.high,this.unsigned)},D.shiftLeft=function(T){return t(T)&&(T=T.toInt()),(T&=63)===0?this:T<32?a(this.low<<T,this.high<<T|this.low>>>32-T,this.unsigned):a(0,this.low<<T-32,this.unsigned)},D.shl=D.shiftLeft,D.shiftRight=function(T){return t(T)&&(T=T.toInt()),(T&=63)===0?this:T<32?a(this.low>>>T|this.high<<32-T,this.high>>T,this.unsigned):a(this.high>>T-32,this.high>=0?0:-1,this.unsigned)},D.shr=D.shiftRight,D.shiftRightUnsigned=function(T){if(t(T)&&(T=T.toInt()),T&=63,T===0)return this;var V=this.high;if(T<32){var q=this.low;return a(q>>>T|V<<32-T,V>>>T,this.unsigned)}else return T===32?a(V,0,this.unsigned):a(V>>>T-32,0,this.unsigned)},D.shru=D.shiftRightUnsigned,D.shr_u=D.shiftRightUnsigned,D.toSigned=function(){return this.unsigned?a(this.low,this.high,!1):this},D.toUnsigned=function(){return this.unsigned?this:a(this.low,this.high,!0)},D.toBytes=function(T){return T?this.toBytesLE():this.toBytesBE()},D.toBytesLE=function(){var T=this.high,V=this.low;return[V&255,V>>>8&255,V>>>16&255,V>>>24,T&255,T>>>8&255,T>>>16&255,T>>>24]},D.toBytesBE=function(){var T=this.high,V=this.low;return[T>>>24,T>>>16&255,T>>>8&255,T&255,V>>>24,V>>>16&255,V>>>8&255,V&255]},e.fromBytes=function(T,V,q){return q?e.fromBytesLE(T,V):e.fromBytesBE(T,V)},e.fromBytesLE=function(T,V){return new e(T[0]|T[1]<<8|T[2]<<16|T[3]<<24,T[4]|T[5]<<8|T[6]<<16|T[7]<<24,V)},e.fromBytesBE=function(T,V){return new e(T[4]<<24|T[5]<<16|T[6]<<8|T[7],T[0]<<24|T[1]<<16|T[2]<<8|T[3],V)},Pm}var yk=N_();const bk=I_(yk),T_=s_({__proto__:null,default:bk},[yk]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mi=bk||T_;function Zp(n){return Mi.fromString(n,!0,16)}const xk=Zp("c3a5c85c97cb3127"),Pi=Zp("b492b66fbe98f273"),rs=Zp("9ae16a3b2f90404f");function kg(n){return n.xor(n.shru(47))}function wk(n,e,t){const s=n.slice(e,e+t);return Mi.fromBytes(Array.from(s),!0,!0)}function Gt(n,e){return wk(n,e,8)}function Mw(n,e){return wk(n,e,4)}function An(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function Xo(n,e,t=Zp("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let r=e.xor(s).mul(t);return r=r.xor(r.shru(47)),r=r.mul(t),r}function E_(n,e,t,s,r,o){r=r.add(n),o=An(o.add(r).add(s),21);const i=r;return r=r.add(e),r=r.add(t),o=o.add(An(r,44)),[r.add(s),o.add(i)]}function Ih(n,e,t,s){return E_(Gt(n,e),Gt(n,e+8),Gt(n,e+16),Gt(n,e+24),t,s)}function __(n,e=n.length){if(e>=8){const t=rs.add(e*2),s=Gt(n,0).add(rs),r=Gt(n,e-8),o=An(r,37).mul(t).add(s),i=An(s,25).add(r).mul(t);return Xo(o,i,t)}if(e>=4){const t=rs.add(e*2),s=Mw(n,0);return Xo(s.shl(3).add(e),Mw(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],r=n[e-1],o=t+(s<<8),i=e+(r<<2);return kg(rs.mul(o).xor(xk.mul(i))).mul(rs)}return rs}function A_(n,e=n.length){const t=rs.add(e*2),s=Gt(n,0).mul(Pi),r=Gt(n,8),o=Gt(n,e-8).mul(t),i=Gt(n,e-16).mul(rs);return Xo(An(s.add(r),43).add(An(o,30)).add(i),s.add(An(r.add(rs),18)).add(o),t)}function R_(n,e=n.length){const t=rs.add(e*2),s=Gt(n,0).mul(rs),r=Gt(n,8),o=Gt(n,e-8).mul(t),i=Gt(n,e-16).mul(rs),a=An(s.add(r),43).add(An(o,30)).add(i),l=Xo(a,s.add(An(r.add(rs),18)).add(o),t),u=Gt(n,16).mul(t),c=Gt(n,24),h=a.add(Gt(n,e-32)).mul(t),d=l.add(Gt(n,e-24)).mul(t);return Xo(An(u.add(c),43).add(An(h,30)).add(d),u.add(An(c.add(s),18)).add(h),t)}function D_(n,e=n.length){const t=Mi.fromNumber(81,!0);if(e<=32)return e<=16?__(n,e):A_(n,e);if(e<=64)return R_(n,e);let s=t,r=t.mul(Pi).add(113),o=kg(r.mul(rs).add(113)).mul(rs),i=[Mi.UZERO,Mi.UZERO],a=[Mi.UZERO,Mi.UZERO];s=s.mul(rs).add(Gt(n,0));let l=0;const u=(e-1>>6)*64,c=u+(e-1&63)-63;do s=An(s.add(r).add(i[0]).add(Gt(n,l+8)),37).mul(Pi),r=An(r.add(i[1]).add(Gt(n,l+48)),42).mul(Pi),s=s.xor(a[1]),r=r.add(i[0]).add(Gt(n,l+40)),o=An(o.add(a[0]),33).mul(Pi),i=Ih(n,l,i[1].mul(Pi),s.add(a[0])),a=Ih(n,l+32,o.add(a[1]),r.add(Gt(n,l+16))),[o,s]=[s,o],l+=64;while(l!==u);const h=Pi.add(o.and(255).shl(1));return l=c,a[0]=a[0].add(e-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),s=An(s.add(r).add(i[0]).add(Gt(n,l+8)),37).mul(h),r=An(r.add(i[1]).add(Gt(n,l+48)),42).mul(h),s=s.xor(a[1].mul(9)),r=r.add(i[0].mul(9).add(Gt(n,l+40))),o=An(o.add(a[0]),33).mul(h),i=Ih(n,l,i[1].mul(h),s.add(a[0])),a=Ih(n,l+32,o.add(a[1]),r.add(Gt(n,l+16))),[o,s]=[s,o],Xo(Xo(i[0],a[0],h).add(kg(r).mul(xk)).add(o),Xo(i[1],a[1],h).add(s),h)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pi(n,e){return e==="string"?Yo(n):ca([n],e)}function O_(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function ca(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Zi(n)),ue().getBool("DEBUG")&&u_(n,e),O_(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function bs(){return ue().platform.now()}function Yo(n,e="utf-8"){return e=e||"utf-8",ue().platform.encode(n,e)}function ei(n,e="utf-8"){return e=e||"utf-8",ue().platform.decode(n,e)}function cr(n){return ue().platform.isTypedArray!=null?ue().platform.isTypedArray(n):gk(n)}function Zi(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||Yi(n)||n==null||cr(n)&&t)e.push(n);else if(Array.isArray(n)||cr(n))for(let s=0;s<n.length;++s)Zi(n[s],e,t);else{let s=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)Zi(n[r],e,t)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F_{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new P_)}profileKernel(e,t,s){let r;const o=()=>{r=s()};let i;const a=bs();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(o);else{o();for(const u of r)u.dataSync();i=Promise.resolve({kernelMs:bs()-a})}if(ue().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<r.length;u++){const c=r[u];c.data().then(h=>{L_(h,c.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:i.then(u=>u.kernelMs),extraInfo:i.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:r,inputs:o,extraInfo:i}=e;s.forEach(a=>{Promise.all([a.data(),r,i]).then(l=>{this.logger.logKernelProfile(t,a,l[0],l[1],o,l[2])})})}}function L_(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${t}'`),!0}return!1}class P_{logKernelProfile(e,t,s,r,o,i){const a=typeof r=="number"?za(`${r}ms`,9):r.error,l=za(e,25),u=t.rank,c=t.size,h=za(t.shape.toString(),14);let d="";for(const p in o){const f=o[p];if(f!=null){const g=f.shape||t.shape,y=g.length;d+=`${p}: ${y}D ${y>0?g:""} `}}console.log(`%c${l}	%c${a}	%c${u}D ${h}	%c${c}	%c${d}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z_(n,e,t){const s={},r={};for(let l=0;l<e.length;l++)s[e[l].id]=!0;for(let l=0;l<n.length;l++){const u=n[l],c=u.inputs;for(const h in c){const d=c[h];let p=!1;for(let f=0;f<e.length;f++)if(s[d.id]){u.outputs.forEach(g=>s[g.id]=!0),p=!0,r[u.id]=!0;break}if(p)break}}const o={};o[t.id]=!0;const i={};for(let l=n.length-1;l>=0;l--){const u=n[l],c=u.inputs;for(let h=0;h<u.outputs.length;h++)if(o[u.outputs[h].id]){for(const d in c)o[c[d].id]=!0,i[u.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const u=n[l];if(r[u.id]&&i[u.id]){const c={};for(const d in u.inputs){const p=u.inputs[d];s[p.id]&&(c[d]=p)}const h=Object.assign({},u);h.inputs=c,h.outputs=u.outputs,a.push(h)}}return a}function M_(n,e,t,s){for(let r=e.length-1;r>=0;r--){const o=e[r],i=[];if(o.outputs.forEach(l=>{const u=n[l.id];u!=null?i.push(u):i.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const a=o.gradient(i);for(const l in o.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const u=t(()=>a[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=o.inputs[l];if(!Tt(u.shape,c.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(n[c.id]==null)n[c.id]=u;else{const h=n[c.id];n[c.id]=s(h,u),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bw=20,Vl=3,zm=7;function B_(n,e,t,s){const r=rt(e),o=V_(n,e,t,r),i=e.length,a=Gh(n,e,t,r,o),l=["Tensor"];return s&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${i}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(u=>"    "+u).join(`
`)),l.join(`
`)}function V_(n,e,t,s){const r=pe(e),o=s[s.length-1],i=new Array(o).fill(0),a=e.length,l=t==="complex64"?Xl(n):n;if(a>1)for(let u=0;u<r/o;u++){const c=u*o;for(let h=0;h<o;h++)i[h]=Math.max(i[h],ql(l[c+h],0,t).length)}return i}function ql(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(zm))} + ${parseFloat(n[1].toFixed(zm))}j`:Au(n)?s=`'${n}'`:t==="bool"?s=vk(n):s=parseFloat(n.toFixed(zm)).toString(),za(s,e)}function vk(n){return n===0?"false":"true"}function Gh(n,e,t,s,r,o=!0){const i=t==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(t==="complex64"){const g=Xl(n);return[ql(g[0],0,t)]}return t==="bool"?[vk(n[0])]:[n[0].toString()]}if(l===1){if(a>Bw){const y=Vl*i;let b=Array.from(n.slice(0,y)),w=Array.from(n.slice((a-Vl)*i,a*i));return t==="complex64"&&(b=Xl(b),w=Xl(w)),["["+b.map((C,v)=>ql(C,r[v],t)).join(", ")+", ..., "+w.map((C,v)=>ql(C,r[a-Vl+v],t)).join(", ")+"]"]}return["["+(t==="complex64"?Xl(n):Array.from(n)).map((y,b)=>ql(y,r[b],t)).join(", ")+"]"]}const u=e.slice(1),c=s.slice(1),h=s[0]*i,d=[];if(a>Bw){for(let g=0;g<Vl;g++){const y=g*h,b=y+h;d.push(...Gh(n.slice(y,b),u,t,c,r,!1))}d.push("...");for(let g=a-Vl;g<a;g++){const y=g*h,b=y+h;d.push(...Gh(n.slice(y,b),u,t,c,r,g===a-1))}}else for(let g=0;g<a;g++){const y=g*h,b=y+h;d.push(...Gh(n.slice(y,b),u,t,c,r,g===a-1))}const p=l===2?",":"";d[0]="["+(a>0?d[0]+p:"");for(let g=1;g<d.length-1;g++)d[g]=" "+d[g]+p;let f=`,
`;for(let g=2;g<l;g++)f+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(o?"":f),d}function Xl(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class In{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=pe(e),s!=null){const r=s.length;A(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||hn(t,this.size),this.strides=rt(e)}set(e,...t){t.length===0&&(t=[0]),A(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const o=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(o)}t++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return br().makeTensor(this.values,this.shape,this.dtype)}}let br=null,Oa=null;function W_(n){br=n}function U_(n){Oa=n}class sn{constructor(e,t,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=pe(e),this.strides=rt(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Oa.buffer(this.shape,this.dtype,e)}bufferSync(){return Oa.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return ir(this.shape,e,this.dtype==="complex64")}arraySync(){return ir(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=br().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>ei(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),br().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=br().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>ei(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await br().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),br().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Oa.print(this,e)}clone(){return this.throwIfDisposed(),Oa.clone(this)}toString(e=!1){const t=this.dataSync();return B_(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Oa.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),br().makeVariable(this,e,t,s)}}Object.defineProperty(sn,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function ge(){return _y("Tensor",()=>sn)}ge();class hd extends sn{constructor(e,t,s,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Tt(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);br().disposeTensor(this),this.dataId=e.dataId,br().incRef(this,null)}dispose(){br().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(hd,Symbol.hasInstance,{value:n=>n instanceof sn&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Vw;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(Vw||(Vw={}));var Cg;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(Cg||(Cg={}));var Sg;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(Sg||(Sg={}));var Ig;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(Ig||(Ig={}));var $g;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})($g||($g={}));const G_={float32:Ig,int32:Cg,bool:Sg,complex64:$g};function Ds(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return G_[n][e]}function Fb(n){return Ds(n,"int32")}function kk(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function Ck(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function un(n,e){if(n.dtype===e.dtype)return[n,e];const t=Ds(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function H_(n,e){A(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function Sk(n){const e=[];return Ik(n,e,new Set),e}function Ik(n,e,t){if(n==null)return;if(n instanceof sn){e.push(n);return}if(!j_(n))return;const s=n;for(const r in s){const o=s[r];t.has(o)||(t.add(o),Ik(o,e,t))}}function j_(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mm(n){return n.kernelName!=null}class Ww{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Ja{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Ww}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(Us(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new F_(this.backendInstance),!0}setupRegisteredKernels(){Pw(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Pw(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof Ny)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,o=s.then(i=>r<this.pendingBackendInitId?!1:(this.registry[e]=i,this.pendingBackendInit=null,!0)).catch(i=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Us(`Initialization of backend ${e} failed`),Us(i.stack||i.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return Us(`Initialization of backend ${e} failed`),Us(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:r,asyncInit:o}=this.initializeBackend(s);if(o||r)return{name:s,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),r=s.backend,o=this.readSync(t),i=r.refCount(t);r.disposeData(t,!0),s.backend=e,e.move(t,o,s.shape,s.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,s){e();try{const r=s();return t(),r}catch(r){throw t(),r}}nextTensorId(){return Ja.nextTensorId++}nextVariableId(){return Ja.nextVariableId++}clone(e){const t=W.runKernel(Ju,{x:e}),s={x:e},r=i=>({x:()=>{const a="float32",l={x:i},u={dtype:a};return W.runKernel(Mu,l,u)}}),o=[];return this.addTapeNode(this.state.activeScope.name,s,[t],r,o,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,!(vg(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const r=this.backend.numDataIds();let o=0;s.forEach(l=>{o+=l.dtype==="complex64"?3:1});const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-t-o-i;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const r=this.isTapeOn(),o=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const u=Mm(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Mm(e)){const{kernelName:f,inputs:g,attrs:y}=e;this.backendName==null&&this.backend;const b=vg(f,this.backendName);A(b!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),a=()=>{const w=this.backend.numDataIds();l=b.kernelFunc({inputs:g,attrs:y,backend:this.backend});const C=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,w,C);const v=C.map(I=>I.rank!=null?I:this.makeTensorFromTensorInfo(I));if(r){const I=this.getTensorsForGradient(f,g,v);s=this.saveTensorsForBackwardMode(I)}return v}}else{const{forwardFunc:f}=e,g=y=>{r&&(s=y.map(b=>this.keep(this.clone(b))))};a=()=>{const y=this.backend.numDataIds();l=this.tidy(()=>f(this.backend,g));const b=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,y,b),b}}const{inputs:c,attrs:h}=e,d=Mm(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(p=this.profiler.profileKernel(u,c,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),t=p.outputs)}),r&&this.addTapeNode(u,c,t,d,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(f=>c[f]!=null?c[f].shape:null),outputShapes:t.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,t,s){const r=Lw(e);if(r!=null){const o=r.inputsToSave||[],i=r.outputsToSave||[];let a;r.saveAllInputs?(A(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(u=>t[u])):a=o.map(u=>t[u]);const l=s.filter((u,c)=>i[c]);return a.concat(l)}return[]}makeTensor(e,t,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let o=e;s==="string"&&Au(e[0])&&(o=e.map(l=>Yo(l)));const i=r.write(o,t,s),a=new sn(t,s,i,this.nextTensorId());if(this.trackTensor(a,r),s==="string"){const l=this.state.tensorInfo.get(i),u=h_(o);this.state.numBytes+=u-l.bytes,l.bytes=u}return a}makeTensorFromDataId(e,t,s,r){s=s||"float32";const o={dataId:e,shape:t,dtype:s};return this.makeTensorFromTensorInfo(o,r)}makeTensorFromTensorInfo(e,t){const{dataId:s,shape:r,dtype:o}=e,i=new sn(r,o,s,this.nextTensorId());return this.trackTensor(i,t),i}makeVariable(e,t=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const o=new hd(e,t,s,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*id(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof hd||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*id(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,r,o,i){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:o},l=Lw(e);l!=null&&(r=l.gradFunc),r!=null&&(a.gradient=u=>(u=u.map((c,h)=>{if(c==null){const d=s[h],p=Xn(d.size,d.dtype);return this.makeTensor(p,d.shape,d.dtype)}return c}),r(u.length>1?u:u[0],o,i))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Sk(e),s=new Set(t.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const i=this.state.activeScope.track[o];!i.kept&&!s.has(i.id)&&i.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(o=>{!o.kept&&o.scopeId===r.id&&this.track(o)})}gradients(e,t,s,r=!1){if(A(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));A(o instanceof sn,()=>"The result y returned by f() must be a tensor.");const i=z_(this.state.activeTape,t,o);if(!r&&i.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[o.id]=s??K_(o.shape),M_(a,i,u=>this.tidy(u),q_);const l=t.map(u=>a[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(const c of u.saved)c.dispose()}),this.state.activeTape=null),{value:o,grads:l}})}customGrad(e){return A(mg(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{A(t.every(a=>a instanceof sn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};t.forEach((a,l)=>{r[l]=a});const o=(a,l)=>(s=e(...t,l),A(s.value instanceof sn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),A(mg(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),i=(a,l)=>{const u=s.gradFunc(a,l),c=Array.isArray(u)?u:[u];A(c.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),A(c.every(d=>d instanceof sn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return c.forEach((d,p)=>{h[p]=()=>d}),h};return this.runKernelFunc({forwardFunc:o,backwardsFunc:i,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=bs(),s=await this.backend.time(e);return s.wallMs=bs()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Ww;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Ja.nextTensorId=0;Ja.nextVariableId=0;function K_(n){const e=Ey(pe(n),"float32");return W.makeTensor(e,n,"float32")}function $k(){const n=pk();if(n._tfengine==null){const e=new f_(n);n._tfengine=new Ja(e)}return b_(n._tfengine.ENV),W_(()=>n._tfengine),n._tfengine}const W=$k();function q_(n,e){const t={a:n,b:e};return W.runKernel(ml,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X_(){return typeof navigator<"u"&&navigator!=null}function Nk(n){if(n||X_()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function Tk(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ss=ue();Ss.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Ss.registerFlag("IS_BROWSER",()=>Tk());Ss.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Ss.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Ss.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Ss.registerFlag("PROD",()=>!1);Ss.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Ss.getBool("DEBUG"));Ss.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Ss.registerFlag("IS_TEST",()=>!1);Ss.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Ss.getBool("DEBUG"));Ss.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Ss.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Ss.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fi(n,e){let t=n;if(cr(n))return e==="string"?[]:[n.length];if(kk(n)){const r=n.channels||"RGBA";return[n.height,n.width*r.length]}else if(Ck(n))return[n.buffer.size/(e==null?4:id(e))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(t)||cr(t)&&e!=="string";)s.push(t.length),t=t[0];return Array.isArray(n)&&ue().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Ek(n,s,[]),s}function Ek(n,e,t){if(t=t||[],!Array.isArray(n)&&!cr(n)){A(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}A(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),A(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let r=0;r<n.length;++r)Ek(n[r],s,t.concat(r))}function Uw(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function O(n,e,t,s="numeric"){if(n instanceof ge())return Uw(s,n.dtype,e,t),n;let r=pl(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),Uw(s,r,e,t),n==null||!cr(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const o=fi(n,r);!cr(n)&&!Array.isArray(n)&&(n=[n]);const a=r!=="string"?ca(n,r):Zi(n,[],!0);return W.makeTensor(a,o,r)}function dd(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((o,i)=>O(o,`${e}[${i}]`,t,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _k="__op";function B(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+_k;const r=(...o)=>{W.startScope(t);try{const i=s(...o);return Yi(i)&&console.error("Cannot return a Promise inside of tidy."),W.endScope(i),i}catch(i){throw W.endScope(null),i}};return Object.defineProperty(r,"name",{value:t,configurable:!0}),r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y_(n,e){const t=O(n,"real","complex"),s=O(e,"imag","complex");Ms(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:t,imag:s};return W.runKernel(Py,r)}const ti=B({complex_:Y_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mi(n,e,t,s){if(s==null)s=pl(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Ck(n)||kk(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return W.backend.createTensorFromGPUData(n,e||t,s)}if(!cr(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Xs(e);const r=pe(e),o=pe(t);A(r===o,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${o}`);for(let i=0;i<t.length;++i){const a=t[i],l=i===t.length-1?a!==pe(e.slice(i)):!0;A(t[i]===e[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!cr(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?ca(n,s):Zi(n,[],!0),W.makeTensor(n,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wr(n,e,t){const s=fi(n,t);return mi(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ji={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Tr{static join(e){return new Tr(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>cr(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let s=0;s<e.length;s++){const r=e[s];s!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const o=t+r.byteLength;this.shards.push({buffer:r,start:t,end:o}),t=o}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const r=t-e,o=new ArrayBuffer(r),i=new Uint8Array(o);let a=0;for(let l=s;l<this.shards.length;l++){const u=this.shards[l],h=e+a-u.start,d=a,f=Math.min(t,u.end)-u.start,g=new Uint8Array(u.buffer,h,f-h);if(i.set(g,d),a+=g.length,t<u.end)break}return o}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(r){return e<r.start?-1:e>=r.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=Z_(this.shards,t);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function Z_(n,e){let t=0,s=n.length;for(;t<=s;){const r=Math.floor((s-t)/2)+t,o=e(n[r]);if(o===0)return r;o<0?s=r:t=r+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dr(){return W}function Gw(){return W.memory()}function oe(n,e){return W.tidy(n,e)}function vt(n){Sk(n).forEach(t=>t.dispose())}function Rn(n){return W.keep(n)}function Hw(n){return W.setBackend(n)}function J_(){return W.ready()}function Q_(){return W.backendName}function Ak(n,e,t=1){return W.registerBackend(n,e,t)}function Rk(){return W.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ni=4;async function Ng(n,e){const t=[],s=[],r=Array.isArray(n)?n.map(i=>i.name):Object.keys(n);for(let i=0;i<r.length;++i){const a=r[i],l=Array.isArray(n)?n[i].tensor:n[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const u={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const c=new Promise(async h=>{const d=await l.bytes(),p=d.reduce((y,b)=>y+b.length,0)+ni*d.length,f=new Uint8Array(p);let g=0;for(let y=0;y<d.length;y++){const b=d[y],w=new Uint8Array(new Uint32Array([b.length]).buffer);f.set(w,g),g+=ni,f.set(b,g),g+=b.length}h(f)});s.push(c)}else s.push(l.data());e!=null&&(u.group=e),t.push(u)}const o=await Promise.all(s);return{data:nA(o),specs:t}}function Dk(n,e){const t=new Tr(n),s={};let r=0;for(const o of e){const i=eA(o,(a,l)=>t.slice(r+a,r+l));s[o.name]=Ok(o,t.slice(r,r+i)),r+=i}return s}function eA(n,e){const t=pe(n.shape);let s;if("quantization"in n){const r=n.quantization;s=Ji[r.dtype]}else if(n.dtype==="string"){let r=0;for(let o=0;o<t;o++)r+=ni+new Uint32Array(e(r,r+ni))[0];return r}else s=Ji[n.dtype];return t*s}async function tA(n,e){const t=pe(n.shape);let s;if("quantization"in n){const r=n.quantization;s=Ji[r.dtype]}else if(n.dtype==="string"){let r=0;for(let o=0;o<t;o++)r+=ni+new Uint32Array(await e(r,r+ni))[0];return r}else s=Ji[n.dtype];return t*s}function Ok(n,e){const t=n.name,s=n.dtype,r=n.shape,o=pe(r);let i,a=0;if("quantization"in n){const l=n.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${n.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${n.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const u=Ji[l.dtype],c=l.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(s==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){i=new Float32Array(c.length);for(let h=0;h<c.length;h++){const d=c[h];i[h]=d*l.scale+l.min}}else if(l.dtype==="float16")i=lA()(c);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(s==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(c.length);for(let h=0;h<c.length;h++){const d=c[h];i[h]=Math.round(d*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);a+=o*u}else if(s==="string"){const l=pe(n.shape);i=[];for(let u=0;u<l;u++){const c=new Uint32Array(e.slice(a,a+ni))[0];a+=ni;const h=new Uint8Array(e.slice(a,a+c));i.push(h),a+=c}}else{const l=Ji[s];if(s==="float32")i=new Float32Array(e);else if(s==="int32")i=new Int32Array(e);else if(s==="bool")i=new Uint8Array(e);else if(s==="complex64"){i=new Float32Array(e);const u=new Float32Array(i.length/2),c=new Float32Array(i.length/2);for(let f=0;f<u.length;f++)u[f]=i[f*2],c[f]=i[f*2+1];const h=wr(u,r,"float32"),d=wr(c,r,"float32"),p=ti(h,d);return h.dispose(),d.dispose(),p}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);a+=o*l}return wr(i,r,s)}async function jw(n,e,t){let s=new Uint8Array(e);for(;s.byteLength<t;){const{done:r,value:o}=await n.read();if(r&&o==null){const a=t-s.byteLength;throw new Error(`Reader is done but ${a} bytes are still expected`)}const i=new Uint8Array(s.length+o.byteLength);i.set(s,0),i.set(new Uint8Array(o),s.length),s=i}return s.buffer}async function Fk(n,e){const t={},s=n.getReader();let r=new ArrayBuffer(0);for(const o of e){const i=await tA(o,async(u,c)=>(r=await jw(s,r,c),r.slice(u,c)));r=await jw(s,r,i);const a=r.slice(0,i);r=r.slice(i);const l=Ok(o,a);if(t[o.name]=l,Q_()==="webgpu"){const u=Rk();"uploadToGPU"in u&&pe(l.shape)>=ue().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&u.uploadToGPU(l.dataId)}}return t}function nA(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(o=>{if(e+=o.byteLength,t.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const s=new Uint8Array(e);let r=0;return t.forEach(o=>{s.set(new Uint8Array(o.buffer),r),r+=o.byteLength}),s.buffer}const Lb=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function Kw(n){return Lb?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function sA(n){if(Lb)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,r=e.length;s<r;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function rA(n){if(Lb){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function Lk(n){return Tr.join(n)}function qw(n){const e="/";for(n=n.trim();n.endsWith(e);)n=n.slice(0,n.length-1);const t=n.split(e);return t[t.length-1]}function Pk(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function zk(n,e,t){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=t}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function Pb(n,e){let t,s;return n.weightsManifest!=null&&([t,s]=await e(n.weightsManifest)),zk(n,t,s)}function Nc(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:Kw(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:Kw(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new Tr(n.weightData).byteLength}}function Tg(n){const e=[];for(const t of n)e.push(...t.weights);return e}function oA(){const n=t=>{let s=t<<13,r=0;for(;(s&8388608)===0;)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function iA(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function aA(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function lA(){const n=oA(),e=iA(),t=aA();return s=>{const r=new ArrayBuffer(4*s.length),o=new Uint32Array(r);for(let i=0;i<s.length;i++){const a=s[i],l=n[t[a>>10]+(a&1023)]+e[a>>10];o[i]=l}return new Float32Array(r)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return nn.instance==null&&(nn.instance=new nn),nn.instance}static registerSaveRouter(e){nn.getInstance().saveRouters.push(e)}static registerLoadRouter(e){nn.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return nn.getHandlers(e,"save")}static getLoadHandlers(e,t){return nn.getHandlers(e,"load",t)}static getHandlers(e,t,s){const r=[];return(t==="load"?nn.getInstance().loadRouters:nn.getInstance().saveRouters).forEach(i=>{const a=i(e,s);a!==null&&r.push(a)}),r}}const uA=n=>nn.registerSaveRouter(n),cA=n=>nn.registerLoadRouter(n),Mk=n=>nn.getSaveHandlers(n),hA=(n,e)=>nn.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eg="tensorflowjs",_g=1,Ui="models_store",jo="model_info_store";function Bk(){if(!ue().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Ag(n){const e=n.result;e.createObjectStore(Ui,{keyPath:"modelPath"}),e.createObjectStore(jo,{keyPath:"modelPath"})}class Qi{constructor(e){if(this.indexedDB=Bk(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,r)=>{const o=this.indexedDB.open(Eg,_g);o.onupgradeneeded=()=>Ag(o),o.onsuccess=()=>{const i=o.result;if(t==null){const a=i.transaction(Ui,"readonly"),u=a.objectStore(Ui).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return i.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(u.result.modelArtifacts)},u.onerror=c=>(i.close(),r(u.error)),a.oncomplete=()=>i.close()}else{t.weightData=Tr.join(t.weightData);const a=Nc(t),l=i.transaction(jo,"readwrite");let u=l.objectStore(jo),c;try{c=u.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(d){return r(d)}let h;c.onsuccess=()=>{h=i.transaction(Ui,"readwrite");const d=h.objectStore(Ui);let p;try{p=d.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(f){return r(f)}p.onsuccess=()=>s({modelArtifactsInfo:a}),p.onerror=f=>{u=l.objectStore(jo);const g=u.delete(this.modelPath);g.onsuccess=()=>(i.close(),r(p.error)),g.onerror=y=>(i.close(),r(p.error))}},c.onerror=d=>(i.close(),r(c.error)),l.oncomplete=()=>{h==null?i.close():h.oncomplete=()=>i.close()}}},o.onerror=i=>r(o.error)})}}Qi.URL_SCHEME="indexeddb://";const Vk=n=>ue().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Qi.URL_SCHEME)?dA(n.slice(Qi.URL_SCHEME.length)):null;nn.registerSaveRouter(Vk);nn.registerLoadRouter(Vk);function dA(n){return new Qi(n)}function pA(n){return n.startsWith(Qi.URL_SCHEME)?n.slice(Qi.URL_SCHEME.length):n}class fA{constructor(){this.indexedDB=Bk()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open(Eg,_g);s.onupgradeneeded=()=>Ag(s),s.onsuccess=()=>{const r=s.result,o=r.transaction(jo,"readonly"),a=o.objectStore(jo).getAll();a.onsuccess=()=>{const l={};for(const u of a.result)l[u.modelPath]=u.modelArtifactsInfo;e(l)},a.onerror=l=>(r.close(),t(a.error)),o.oncomplete=()=>r.close()},s.onerror=r=>t(s.error)})}async removeModel(e){return e=pA(e),new Promise((t,s)=>{const r=this.indexedDB.open(Eg,_g);r.onupgradeneeded=()=>Ag(r),r.onsuccess=()=>{const o=r.result,i=o.transaction(jo,"readwrite"),a=i.objectStore(jo),l=a.get(e);let u;l.onsuccess=()=>{if(l.result==null)return o.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const c=a.delete(e),h=()=>{u=o.transaction(Ui,"readwrite");const p=u.objectStore(Ui).delete(e);p.onsuccess=()=>t(l.result.modelArtifactsInfo),p.onerror=f=>s(l.error)};c.onsuccess=h,c.onerror=d=>(h(),o.close(),s(l.error))}},l.onerror=c=>(o.close(),s(l.error)),i.oncomplete=()=>{u==null?o.close():u.oncomplete=()=>o.close()}},r.onerror=o=>s(r.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const co="/",Fa="tensorflowjs_models",Wk="info",mA="model_topology",gA="weight_specs",yA="weight_data",bA="model_metadata";function Uk(n){return{info:[Fa,n,Wk].join(co),topology:[Fa,n,mA].join(co),weightSpecs:[Fa,n,gA].join(co),weightData:[Fa,n,yA].join(co),modelMetadata:[Fa,n,bA].join(co)}}function Gk(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function xA(n){const e=n.split(co);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(co)}function wA(n){return n.startsWith(ea.URL_SCHEME)?n.slice(ea.URL_SCHEME.length):n}class ea{constructor(e){if(!ue().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Uk(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=Nc(e),o=Tr.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,sA(o));const i={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:r}}catch{throw Gk(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const a=JSON.parse(o);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(t.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=rA(i),t}}ea.URL_SCHEME="localstorage://";const Hk=n=>ue().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ea.URL_SCHEME)?vA(n.slice(ea.URL_SCHEME.length)):null;nn.registerSaveRouter(Hk);nn.registerLoadRouter(Hk);function vA(n){return new ea(n)}class kA{constructor(){A(ue().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),A(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=Fa+co,s=co+Wk;for(let r=0;r<this.LS.length;++r){const o=this.LS.key(r);if(o.startsWith(t)&&o.endsWith(s)){const i=xA(o);e[i]=JSON.parse(this.LS.getItem(o))}}return e}async removeModel(e){e=wA(e);const t=Uk(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return Gk(t),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ba="://";class ss{constructor(){this.managers={}}static getInstance(){return ss.instance==null&&(ss.instance=new ss),ss.instance}static registerManager(e,t){A(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Ba)&&(e=e.slice(0,e.indexOf(Ba))),A(e.length>0,()=>"scheme must not be an empty string.");const s=ss.getInstance();A(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=ss.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(ss.getInstance().managers)}}function Hh(n){if(n.indexOf(Ba)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${ss.getSchemes().join(",")}`);return{scheme:n.split(Ba)[0],path:n.split(Ba)[1]}}async function jk(n,e,t=!1){A(n!==e,()=>`Old path and new path are the same: '${n}'`);const s=nn.getLoadHandlers(n);A(s.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),A(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${n}.`);const r=s[0],o=nn.getSaveHandlers(e);A(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),A(o.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const i=o[0],a=Hh(n).scheme,l=Hh(n).path,u=a===Hh(n).scheme,c=await r.load();t&&u&&await ss.getManager(a).removeModel(l);const h=await i.save(c);return t&&!u&&await ss.getManager(a).removeModel(l),h.modelArtifactsInfo}async function CA(){const n=ss.getSchemes(),e={};for(const t of n){const s=await ss.getManager(t).listModels();for(const r in s){const o=t+Ba+r;e[o]=s[r]}}return e}async function SA(n){const e=Hh(n);return ss.getManager(e.scheme).removeModel(e.path)}async function IA(n,e){return jk(n,e,!1)}async function $A(n,e){return jk(n,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NA{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!ue().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return gk(e)}}if(ue().get("IS_BROWSER")){ue().setPlatform("browser",new NA);try{ss.registerManager(ea.URL_SCHEME,new kA)}catch{}try{ss.registerManager(Qi.URL_SCHEME,new fA)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TA={importFetch:()=>require("node-fetch")};let Bm;class EA{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return ue().global.fetch!=null?ue().global.fetch(e,t):(Bm==null&&(Bm=TA.importFetch()),Bm(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}ue().get("IS_NODE")&&!ue().get("IS_BROWSER")&&ue().setPlatform("node",new EA);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wt(n,e="float32",t){return e=e||"float32",Xs(n),new In(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _A(n,e){const t=O(n,"x","cast");if(!c_(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},r={dtype:e};return W.runKernel(Mu,s,r)}const Ue=B({cast_:_A});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AA(n){const t={x:O(n,"x","clone","string_or_numeric")};return W.runKernel(Ju,t)}const mo=B({clone_:AA});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kk(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */$k();const RA={buffer:wt,cast:Ue,clone:mo,print:Kk};U_(RA);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DA(n,e){let t=O(n,"a","add"),s=O(e,"b","add");[t,s]=un(t,s);const r={a:t,b:s};return W.runKernel(ml,r)}const Ne=B({add_:DA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OA(n,e){let t=O(n,"a","floorDiv"),s=O(e,"b","floorDiv");[t,s]=un(t,s);const r={a:t,b:s};return W.runKernel(Yu,r)}const zb=B({floorDiv_:OA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FA(n,e){let t=O(n,"a","div"),s=O(e,"b","div");if([t,s]=un(t,s),t.dtype==="int32"&&s.dtype==="int32")return zb(t,s);const r={a:t,b:s},o={};return W.runKernel(Gu,r,o)}const nt=B({div_:FA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LA(n,e){let t=O(n,"a","mul"),s=O(e,"b","mul");[t,s]=un(t,s);const r={a:t,b:s};return W.runKernel(ac,r)}const H=B({mul_:LA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PA(n){const e=O(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return W.runKernel(sp,t)}else{const t={x:e};return W.runKernel(qd,t)}}const vn=B({abs_:PA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zA(n){const t={x:O(n,"x","acos")};return W.runKernel(Ru,t)}const qk=B({acos_:zA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MA(n){const t={x:O(n,"x","acosh")};return W.runKernel(Du,t)}const Xk=B({acosh_:MA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BA(n){A(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),A(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((r,o)=>O(r,`tensors${o}`,"addN")),t=e[0];e.forEach(r=>{if(r.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!Tt(r.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return W.runKernel(Xd,s)}const VA=B({addN_:BA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WA(n,e=null,t=!1){const r={x:O(n,"x","all","bool")},o={axis:e,keepDims:t};return W.runKernel(Ay,r,o)}const Mb=B({all_:WA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UA(n,e=null,t=!1){const r={x:O(n,"x","any","bool")},o={axis:e,keepDims:t};return W.runKernel(Ry,r,o)}const pd=B({any_:UA});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GA(n,e=0){const s={x:O(n,"x","argMax")},r={axis:e};return W.runKernel(Yd,s,r)}const Qa=B({argMax_:GA});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HA(n,e=0){const s={x:O(n,"x","argMin")},r={axis:e};return W.runKernel(Zd,s,r)}const Yk=B({argMin_:HA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jA(n){const t={x:O(n,"x","asin")};return W.runKernel(Ou,t)}const Zk=B({asin_:jA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KA(n){const t={x:O(n,"x","asinh")};return W.runKernel(Fu,t)}const Jk=B({asinh_:KA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qA(n){const t={x:O(n,"x","atan")};return W.runKernel(Lu,t)}const Qk=B({atan_:qA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XA(n,e){let t=O(n,"a","atan2"),s=O(e,"b","atan2");[t,s]=un(t,s);const r={a:t,b:s};return W.runKernel(zu,r)}const eC=B({atan2_:XA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YA(n){const t={x:O(n,"x","atanh")};return W.runKernel(Pu,t)}const tC=B({atanh_:YA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tc(n,e,t,s,r="NHWC",o){const i=n[3],a=[...e,i],l=$o(r);return On(n,a,t,o,s,null,null,l)}function pr(n,e,t,s,r,o,i="channelsLast"){const[a,l]=hu(e);let u;if(i==="channelsLast")u=[a,l,n[3],n[3]];else if(i==="channelsFirst")u=[a,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${i}`);return On(n,u,t,s,r,o,!1,i)}function Io(n,e,t,s,r,o,i="NDHWC"){const[a,l,u]=Rg(e);let c,h;if(i==="NDHWC")h="channelsLast",c=[a,l,u,n[4],n[4]];else if(i==="NCDHW")h="channelsFirst",c=[a,l,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${i}`);return gi(n,c,t,s,r,!1,h,o)}function On(n,e,t,s,r,o,i=!1,a="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if(a==="channelsLast")[l,u,c,h]=n;else if(a==="channelsFirst")[l,h,u,c]=n;else throw new Error(`Unknown dataFormat ${a}`);const[d,p,,f]=e,[g,y]=hu(t),[b,w]=hu(s),C=Va(d,b),v=Va(p,w),{padInfo:I,outHeight:E,outWidth:R}=QA(r,u,c,g,y,C,v,o,a),L=i?f*h:f;let D;return a==="channelsFirst"?D=[l,L,E,R]:a==="channelsLast"&&(D=[l,E,R,L]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:h,outHeight:E,outWidth:R,outChannels:L,padInfo:I,strideHeight:g,strideWidth:y,filterHeight:d,filterWidth:p,effectiveFilterHeight:C,effectiveFilterWidth:v,dilationHeight:b,dilationWidth:w,inShape:n,outShape:D,filterShape:e}}function gi(n,e,t,s,r,o=!1,i="channelsLast",a){let[l,u,c,h,d]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,u,c,h,d]=n;else if(i==="channelsFirst")[l,d,u,c,h]=n;else throw new Error(`Unknown dataFormat ${i}`);const[p,f,g,,y]=e,[b,w,C]=Rg(t),[v,I,E]=Rg(s),R=Va(p,v),L=Va(f,I),D=Va(g,E),{padInfo:F,outDepth:T,outHeight:V,outWidth:q}=eR(r,u,c,h,b,w,C,R,L,D,a),se=o?y*d:y;let ee;return i==="channelsFirst"?ee=[l,se,T,V,q]:i==="channelsLast"&&(ee=[l,T,V,q,se]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:h,inChannels:d,outDepth:T,outHeight:V,outWidth:q,outChannels:se,padInfo:F,strideDepth:b,strideHeight:w,strideWidth:C,filterDepth:p,filterHeight:f,filterWidth:g,effectiveFilterDepth:R,effectiveFilterHeight:L,effectiveFilterWidth:D,dilationDepth:v,dilationHeight:I,dilationWidth:E,inShape:n,outShape:ee,filterShape:e}}function ZA(n,e,t,s,r){s==null&&(s=Bb(n,e,t));const o=n[0],i=n[1],a=du((o-e+2*s)/t+1,r),l=du((i-e+2*s)/t+1,r);return[a,l]}function JA(n,e,t,s,r,o){r==null&&(r=Bb(n,e[0],s[0]));const i=[0,0,0,t];for(let a=0;a<3;a++)n[a]+2*r>=e[a]&&(i[a]=du((n[a]-e[a]+2*r)/s[a]+1,o));return i}function Bb(n,e,t,s=1){const r=Va(e,s);return Math.floor((n[0]*(t-1)-t+r)/2)}function hu(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function Rg(n){return typeof n=="number"?[n,n,n]:n}function Va(n,e){return e<=1?n:n+(n-1)*(e-1)}function QA(n,e,t,s,r,o,i,a,l){let u,c,h;if(typeof n=="number"){u={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const p=ZA([e,t],o,s,n,a);c=p[0],h=p[1]}else if(n==="same"){c=Math.ceil(e/s),h=Math.ceil(t/r);const d=Math.max(0,(c-1)*s+o-e),p=Math.max(0,(h-1)*r+i-t),f=Math.floor(d/2),g=d-f,y=Math.floor(p/2),b=p-y;u={top:f,bottom:g,left:y,right:b,type:"SAME"}}else if(n==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-o+1)/s),h=Math.ceil((t-i+1)/r);else if(typeof n=="object"){const d=l==="channelsLast"?n[1][0]:n[2][0],p=l==="channelsLast"?n[1][1]:n[2][1],f=l==="channelsLast"?n[2][0]:n[3][0],g=l==="channelsLast"?n[2][1]:n[3][1];u={top:d,bottom:p,left:f,right:g,type:d===0&&p===0&&f===0&&g===0?"VALID":"EXPLICIT"},c=du((e-o+d+p)/s+1,a),h=du((t-i+f+g)/r+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:u,outHeight:c,outWidth:h}}function eR(n,e,t,s,r,o,i,a,l,u,c){let h,d,p,f;if(n==="valid"&&(n=0),typeof n=="number"){h={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const y=JA([e,t,s,1],[a,l,u],1,[r,o,i],n,c);d=y[0],p=y[1],f=y[2]}else if(n==="same"){d=Math.ceil(e/r),p=Math.ceil(t/o),f=Math.ceil(s/i);const g=(d-1)*r+a-e,y=(p-1)*o+l-t,b=(f-1)*i+u-s,w=Math.floor(g/2),C=g-w,v=Math.floor(y/2),I=y-v,E=Math.floor(b/2),R=b-E;h={top:v,bottom:I,left:E,right:R,front:w,back:C,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}function du(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function si(n){const[e,t,s]=hu(n);return e===1&&t===1&&s===1}function Wn(n,e){return si(n)||si(e)}function ta(n){return hu(n).every(e=>e>0)}function $o(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function ds(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")A(Za(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{A(Za(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tR(n,e){const s={x:O(n,"x","reshape","string_or_numeric")},r={shape:e};return W.runKernel(Pp,s,r)}const j=B({reshape_:tR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nR(n,e,t,s,r){const o=O(n,"x","avgPool","float32"),i=1;A(Wn(t,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);let a=o,l=!1;o.rank===3&&(l=!0,a=j(o,[1,o.shape[0],o.shape[1],o.shape[2]])),A(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),ds("avgPool",s,r);const u={x:a},c={filterSize:e,strides:t,pad:s,dimRoundingMode:r};let h=W.runKernel(Jd,u,c);return h=Ue(h,o.dtype),l?j(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Jp=B({avgPool_:nR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sR(n,e,t,s,r,o="NDHWC"){const i=O(n,"x","avgPool3d","float32");let a=i,l=!1;i.rank===4&&(l=!0,a=j(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),A(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),A(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),ds("avgPool3d",s,r);const u={x:a},c={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:o};let h=W.runKernel(Qd,u,c);return h=Ue(h,a.dtype),l?j(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const nC=B({avgPool3d_:sR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rR(n,e=0){A(n.length>=1,()=>"Pass at least one tensor to concat");const t=dd(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),t.length===1)return mo(t[0]);const s=t,r={axis:e};return W.runKernel(rp,s,r)}const bn=B({concat_:rR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oR(n,e,t=!1,s=!1){let r=O(n,"a","matMul"),o=O(e,"b","matMul");[r,o]=un(r,o);const i={a:r,b:o},a={transposeA:t,transposeB:s};return W.runKernel(ep,i,a)}const It=B({matMul_:oR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iR(n){const t={x:O(n,"x","sigmoid","float32")};return W.runKernel(bc,t)}const Ur=B({sigmoid_:iR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aR(n,e,t){const s=O(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},o={begin:e,size:t};return W.runKernel(Wp,r,o)}const Et=B({slice_:aR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lR(n){const t={x:O(n,"x","tanh","float32")};return W.runKernel(Sc,t)}const na=B({tanh_:lR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uR(n,e,t,s,r,o){const i=O(n,"forgetBias","basicLSTMCell"),a=O(e,"lstmKernel","basicLSTMCell"),l=O(t,"lstmBias","basicLSTMCell"),u=O(s,"data","basicLSTMCell"),c=O(r,"c","basicLSTMCell"),h=O(o,"h","basicLSTMCell"),d=bn([u,h],1),p=It(d,a),f=Ne(p,l),g=f.shape[0],y=f.shape[1]/4,b=[g,y],w=Et(f,[0,0],b),C=Et(f,[0,y],b),v=Et(f,[0,y*2],b),I=Et(f,[0,y*3],b),E=Ne(H(Ur(w),na(C)),H(c,Ur(Ne(i,v)))),R=H(na(E),Ur(I));return[E,R]}const cR=B({basicLSTMCell_:uR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hR(n,e,t){const s=O(n,"x","batchToSpaceND"),r=e.reduce((a,l)=>a*l);A(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),A(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),A(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const o={x:s},i={blockShape:e,crops:t};return W.runKernel(tp,o,i)}const Qp=B({batchToSpaceND_:hR});function dR(n){let e;return n.rank===0||n.rank===1?e=j(n,[1,1,1,n.size]):n.rank===2?e=j(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=j(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pR(n,e,t,s,r,o){o==null&&(o=.001);const i=O(n,"x","batchNorm"),a=O(e,"mean","batchNorm"),l=O(t,"variance","batchNorm");let u;r!=null&&(u=O(r,"scale","batchNorm"));let c;s!=null&&(c=O(s,"offset","batchNorm")),A(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),A(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),A(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:dR(i),scale:u,offset:c,mean:a,variance:l},p={varianceEpsilon:o},f=W.runKernel(pp,d,p);return j(f,i.shape)}const Ec=B({batchNorm_:pR});function fR(n,e,t,s,r,o){const i=O(n,"x","batchNorm"),a=O(e,"mean","batchNorm"),l=O(t,"variance","batchNorm");let u;r!=null&&(u=O(r,"scale","batchNorm"));let c;return s!=null&&(c=O(s,"offset","batchNorm")),A(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),A(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),A(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&A(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&A(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Ec(i,a,l,c,u,o)}const sC=B({batchNorm2d_:fR});function mR(n,e,t,s,r,o){const i=O(n,"x","batchNorm"),a=O(e,"mean","batchNorm"),l=O(t,"variance","batchNorm");let u;r!=null&&(u=O(r,"scale","batchNorm"));let c;return s!=null&&(c=O(s,"offset","batchNorm")),A(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),A(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),A(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&A(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&A(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Ec(i,a,l,c,u,o)}const rC=B({batchNorm3d_:mR});function gR(n,e,t,s,r,o){const i=O(n,"x","batchNorm"),a=O(e,"mean","batchNorm"),l=O(t,"variance","batchNorm");let u;r!=null&&(u=O(r,"scale","batchNorm"));let c;return s!=null&&(c=O(s,"offset","batchNorm")),A(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),A(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),A(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&A(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&A(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Ec(i,a,l,c,u,o)}const oC=B({batchNorm4d_:gR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yR(n,e,t){const s=O(n,"x","bincount"),r=O(e,"weights","bincount");A(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),A(t>=0,()=>`size must be non-negative, but got ${t}.`),A(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const o={x:s,weights:r},i={size:t};return W.runKernel(Fy,o,i)}const iC=B({bincount_:yR});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bR(n,e){const t=O(n,"x","bitwiseAnd"),s=O(e,"y","bitwiseAnd");if(!Tt(t.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${s.shape}`);if(t.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${s.dtype}`);const r={a:t,b:s};return W.runKernel(np,r)}const xR=B({bitwiseAnd_:bR});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wR(n,e){const t=O(n,"s0","broadcastArgs","int32"),s=O(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:t,s1:s};return W.runKernel(Ly,r)}const vR=B({broadcastArgs_:wR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kR(n,e){let t=O(n,"broadcastTo","x");const s=t.shape;if(Xs(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const u=t.shape.slice();for(;u.length<e.length;)u.unshift(1);t=j(t,u)}const r=t.shape,o=Array.from(e);for(let u=e.length-1;u>=0;u--)if(r[u]===e[u])o[u]=1;else if(t.shape[u]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(o.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return mo(t);const a={x:t},l={reps:o};return W.runKernel(Ic,a,l)}const Wa=B({broadcastTo_:kR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CR(n){const t={x:O(n,"x","ceil","float32")};return W.runKernel(Bu,t)}const aC=B({ceil_:CR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gl(n,e,t){Xs(n),t=t||pl(e);const s={shape:n,value:e,dtype:t};return W.runKernel(Zy,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SR(n,e,t){const s=O(n,"x","clipByValue");if(A(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return gl(s.shape,e,s.dtype);const r={x:s},o={clipValueMin:e,clipValueMax:t};return W.runKernel(Vu,r,o)}const Os=B({clipByValue_:SR});function IR(n){return bn(n,0)}const lC=B({concat1d_:IR});function $R(n,e){return bn(n,e)}const uC=B({concat2d_:$R});function NR(n,e){return bn(n,e)}const cC=B({concat3d_:NR});function TR(n,e){return bn(n,e)}const hC=B({concat4d_:TR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ER(n,e,t,s,r="NHWC",o=[1,1],i){const a=O(n,"x","conv2d","float32"),l=O(e,"filter","conv2d","float32");let u=a,c=!1;a.rank===3&&(c=!0,u=j(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),A(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),ds("conv2d",s,i);const h=r==="NHWC"?u.shape[3]:u.shape[1];A(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),A(Wn(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),A(ta(o),()=>"Error in conv2D: Dilated rates should be larger than 0."),A(ta(t),()=>"Error in conv2D: Strides should be larger than 0.");const d={x:u,filter:l},p={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:i},f=W.runKernel(op,d,p);return c?j(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const ri=B({conv2d_:ER});function _R(n,e,t,s,r="NWC",o=1,i){const a=O(n,"x","conv1d"),l=O(e,"filter","conv1d");let u=a,c=!1;a.rank===2&&(c=!0,u=j(a,[1,a.shape[0],a.shape[1]])),A(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),A(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),ds("conv1d",s,i),A(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),A(Wn(t,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${o}'`),A(ta(o),()=>"Error in conv1D: Dilated rates should be larger than 0."),A(ta(t),()=>"Error in conv1D: Stride should be larger than 0."),A(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const h=j(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=j(u,[u.shape[0],1,u.shape[1],u.shape[2]]),y=ri(d,h,[1,t],s,"NHWC",[1,o],i);return c?j(y,[y.shape[2],y.shape[3]]):j(y,[y.shape[0],y.shape[2],y.shape[3]])}const Vb=B({conv1d_:_R});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AR(n,e,t,s,r,o="NHWC",i){A(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,l=e,u=!1;e.rank===3&&(u=!0,l=j(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),A(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),A(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),A(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const c=o==="NHWC"?a[3]:a[1],h=o==="NHWC"?l.shape[3]:l.shape[1];A(c===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[2]}.`),A(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),ds("conv2dDerInput",r,i);const d={dy:l,filter:t},p={strides:s,pad:r,dataFormat:o,dimRoundingMode:i,inputShape:a},f=W.runKernel(ip,d,p);return u?j(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Wb=B({conv2DBackpropInput_:AR});function RR(n,e,t,s,r,o){const i=O(n,"x","conv2dTranspose"),a=O(e,"filter","conv2dTranspose");return Wb(t,i,a,s,r,"NHWC",o)}const Ub=B({conv2dTranspose_:RR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DR(n,e,t,s,r="NDHWC",o=[1,1,1]){const i=O(n,"x","conv3d"),a=O(e,"filter","conv3d");let l=i,u=!1;i.rank===4&&(u=!0,l=j(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),A(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),A(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),A(Wn(t,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),A(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),A(ta(o),()=>"Error in conv3D: Dilated rates should be larger than 0."),A(ta(t),()=>"Error in conv3D: Strides should be larger than 0.");const c={x:l,filter:a},h={strides:t,pad:s,dataFormat:r,dilations:o},d=W.runKernel(ap,c,h);return u?j(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const dC=B({conv3d_:DR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OR(n,e,t,s,r){A(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let o=n,i=e,a=!1;e.rank===4&&(a=!0,i=j(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),o=[1,n[0],n[1],n[2],n[3]]);const l=o[4],u=i.shape[4];A(o.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),A(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),A(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),A(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),A(u===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${t.shape[4]}.`);const c={dy:i,filter:t},h={pad:r,strides:s,inputShape:o},d=W.runKernel(By,c,h);return a?j(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const pC=B({conv3DBackpropInput_:OR});function FR(n,e,t,s,r){const o=O(n,"x","conv3dTranspose"),i=O(e,"filter","conv3dTranspose");return pC(t,o,i,s,r)}const fC=B({conv3dTranspose_:FR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LR(n){const t={x:O(n,"x","cos","float32")};return W.runKernel(Wu,t)}const ef=B({cos_:LR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PR(n){const t={x:O(n,"x","cosh","float32")};return W.runKernel(Uu,t)}const Gb=B({cosh_:PR});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zR(n,e=0,t=!1,s=!1){const o={x:O(n,"x","cumprod")},i={axis:e,exclusive:t,reverse:s};return W.runKernel(Vy,o,i)}const fd=B({cumprod_:zR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MR(n,e=0,t=!1,s=!1){const o={x:O(n,"x","cumsum")},i={axis:e,exclusive:t,reverse:s};return W.runKernel(lp,o,i)}const Hb=B({cumsum_:MR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BR(n,e,t,s=!1){const r=O(n,"x","denseBincount"),o=O(e,"weights","denseBincount");A(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),A(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),A(t>=0,()=>`size must be non-negative, but got ${t}.`),A(o.size===r.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${o.shape}.`);const i={x:r,weights:o},a={size:t,binaryOutput:s};return W.runKernel(Uy,i,a)}const Dg=B({denseBincount_:BR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VR(n,e,t="NHWC"){const s=O(n,"x","depthToSpace","float32"),r=t==="NHWC"?s.shape[1]:s.shape[2],o=t==="NHWC"?s.shape[2]:s.shape[3],i=t==="NHWC"?s.shape[3]:s.shape[1];A(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),A(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),A(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e} for depthToSpace with input shape
        ${s.shape}`),A(i%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${i} for depthToSpace with input shape ${s.shape}`);const a={x:s},l={blockSize:e,dataFormat:t};return W.runKernel(Gy,a,l)}const mC=B({depthToSpace_:VR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WR(n,e,t,s,r="NHWC",o=[1,1],i){const a=O(n,"x","depthwiseConv2d","float32"),l=O(e,"filter","depthwiseConv2d","float32");let u=a,c=!1;a.rank===3&&(c=!0,u=j(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),A(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const h=r==="NHWC"?u.shape[3]:u.shape[1];A(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),ds("depthwiseConv2d",s,i);const d={x:u,filter:l},p={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:i},f=W.runKernel(up,d,p);return c?j(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const _c=B({depthwiseConv2d_:WR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UR(n){const t={x:O(n,"x","diag")};return W.runKernel(Ky,t)}const GR=B({diag_:UR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HR(n,e,t,s,r=[1,1],o="NHWC"){const i=O(n,"x","dilation2d"),a=O(e,"filter","dilation2d");A(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),A(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),A(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let l=i,u=!1;i.rank===3&&(l=j(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),A(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const c={x:l,filter:a},h={strides:t,pad:s,dilations:r},d=W.runKernel(cp,c,h);return u?j(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const gC=B({dilation2d_:HR});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function el(n,e){const t=n.length,s=[];for(let r=0;r<t;r++){const o=t-1-r,i=n[o]||1;(e[e.length-1-r]||1)>1&&i===1&&s.unshift(o)}return s}function Tn(n,e){const t=[];for(let s=0;s<e.length;s++){const r=n[n.length-s-1],o=e.length-s-1,i=e[o];(r==null||r===1&&i>1)&&t.unshift(o)}return t}function pt(n,e){const t=Math.max(n.length,e.length),s=new Array(t);for(let r=0;r<t;r++){let o=n[n.length-r-1];o==null&&(o=1);let i=e[e.length-r-1];if(i==null&&(i=1),o===1)s[t-r-1]=i;else if(i===1)s[t-r-1]=o;else if(o!==i){const a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else s[t-r-1]=o}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jR(n,e){let t=O(n,"a","equal","string_or_numeric"),s=O(e,"b","equal","string_or_numeric");[t,s]=un(t,s),pt(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(hp,r)}const Sr=B({equal_:jR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KR(n,e,t){const s=O(e,"a","where"),r=O(t,"b","where"),o=O(n,"condition","where","bool"),i=pt(pt(o.shape,s.shape),r.shape),a=Wa(o,i),l=Wa(s,i),u=Wa(r,i),c={condition:a,t:l,e:u};return W.runKernel(Vp,c)}const qn=B({where_:KR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qR(n){const t={x:O(n,"x","zerosLike")};return W.runKernel(Yp,t)}const At=B({zerosLike_:qR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XR(n,e){let t=O(n,"a","div"),s=O(e,"b","div");[t,s]=un(t,s);const r=nt(t,s),o=At(r),i=Sr(s,o);return qn(i,o,r)}const yC=B({divNoNan_:XR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YR(n,e){const t=O(n,"t1","dot"),s=O(e,"t2","dot");A((t.rank===1||t.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${s.rank}.`);const r=t.rank===1?t.size:t.shape[1],o=s.rank===1?s.size:s.shape[0];if(A(r===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${o}.`),t.rank===1&&s.rank===1){const i=j(t,[1,-1]),a=j(s,[-1,1]),l=It(i,a);return j(l,[])}else if(t.rank===1&&s.rank===2){const i=j(t,[1,-1]),a=j(s,[s.shape[0],s.shape[1]]),l=It(i,a);return j(l,[l.size])}else if(t.rank===2&&s.rank===1){const i=j(s,[-1,1]),a=It(t,i);return j(a,[a.size])}else{const i=j(s,[s.shape[0],s.shape[1]]);return It(t,i)}}const bC=B({dot_:YR});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZR(n,...e){const t=e.map((r,o)=>O(r,`tensors${o}`,"einsum")),s={equation:n};return W.runKernel(qy,t,s)}const La=B({einsum_:ZR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JR(n){const t={x:O(n,"x","elu","float32")};return W.runKernel(Hu,t)}const Ac=B({elu_:JR});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QR(n,e){const t=O(n,"x","ensureShape","string_or_numeric");if(!l_(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}const eD=B({ensureShape_:QR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tD(n){let e=O(n,"x","erf");A(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Ue(e,"float32"));const t={x:e};return W.runKernel(ju,t)}const jb=B({erf_:tD});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kb(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function xC(n,e,t){const s=n.length+e.length,r=[];let o=0,i=0;for(let a=0;a<s;a++)t.indexOf(a)===-1?r.push(n[o++]):r.push(e[i++]);return r}function Fn(n,e){const t=[],s=n.length;for(let o=0;o<s;o++)e.indexOf(o)===-1&&t.push(n[o]);const r=e.map(o=>n[o]);return[t,r]}function dn(n,e){const t=e.map(s=>1);return xC(n,t,e)}function Un(n,e,t){A(Kb(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function an(n,e){if(Kb(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function yi(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function pn(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nD(n,e=null,t=!1){const r={x:O(n,"x","max")},o={reductionIndices:e,keepDims:t};return W.runKernel(Cp,r,o)}const ar=B({max_:nD});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sD(n,e=null,t=!1){const r={x:O(n,"x","min")},o={axis:e,keepDims:t};return W.runKernel(Np,r,o)}const pu=B({min_:sD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rD(n,e){let t=O(n,"base","pow"),s=O(e,"exp","pow");[t,s]=un(t,s);const r={a:t,b:s};return W.runKernel(lc,r)}const bo=B({pow_:rD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function it(n,e){if((cr(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&cr(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return mi(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oD(n){const t={x:O(n,"x","sqrt","float32")};return W.runKernel(wc,t)}const Vn=B({sqrt_:oD});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iD(n){const e=O(n,"x","square"),t={};return W.runKernel("Square",{x:e},t)}const Wt=B({square_:iD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aD(n,e=null,t=!1){let s=O(n,"x","sum");s.dtype==="bool"&&(s=Ue(s,"int32"));const r={x:s},o={axis:e,keepDims:t};return W.runKernel(Up,r,o)}const Qe=B({sum_:aD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lD(n,e="euclidean",t=null,s=!1){n=O(n,"x","norm");const r=wC(n,e,t);let o=r.shape;if(s){const i=kt(t,n.shape);o=dn(r.shape,i)}return j(r,o)}function wC(n,e,t=null){if(n.rank===0)return vn(n);if(n.rank!==1&&t===null)return wC(j(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Qe(vn(n),t);if(e===1/0)return ar(vn(n),t);if(e===-1/0)return pu(vn(n),t);if(e==="euclidean"||e===2)return Vn(Qe(bo(vn(n),it(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return ar(Qe(vn(n),t[0]),t[1]-1);if(e===1/0)return ar(Qe(vn(n),t[1]),t[0]);if(e===-1/0)return pu(Qe(vn(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Vn(Qe(Wt(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Rc=B({norm_:lD});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uD(n,e=null,t=!1){return Rc(n,"euclidean",e,t)}const vC=B({euclideanNorm_:uD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cD(n){const t={x:O(n,"x","exp")};return W.runKernel(Ku,t)}const Fs=B({exp_:cD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hD(n,e=0){const t=O(n,"x","expandDims","string_or_numeric");A(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},r={dim:e};return W.runKernel(dp,s,r)}const os=B({expandDims_:hD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dD(n){const t={x:O(n,"x","expm1")};return W.runKernel(qu,t)}const kC=B({expm1_:dD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pD(n,e){const t=O(n,"x","tile","string_or_numeric");A(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},r={reps:e};return W.runKernel(Ic,s,r)}const sr=B({tile_:pD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fD(n,e,t,s="float32"){e==null&&(e=n);const r=wt([n,e],s),o=n<=e?n:e;for(let a=0;a<o;++a)r.set(1,a,a);const i=j(r.toTensor(),[n,e]);if(t==null)return i;if(t.length===1)return sr(os(i,0),[t[0],1,1]);if(t.length===2)return sr(os(os(i,0),0),[t[0],t[1],1,1]);if(t.length===3)return sr(os(os(os(i,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const qb=B({eye_:fD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mD(n){const t={x:O(n,"x","floor","float32")};return W.runKernel(Xu,t)}const Dc=B({floor_:mD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gD(n,e,t=0,s=0){const r=O(n,"x","gather"),o=O(e,"indices","gather","int32"),i={x:r,indices:o},a={axis:t,batchDims:s};return W.runKernel(fp,i,a)}const Oc=B({gather_:gD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yD(n,e){let t=O(n,"a","greater","string_or_numeric"),s=O(e,"b","greater","string_or_numeric");[t,s]=un(t,s),pt(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(mp,r)}const Bs=B({greater_:yD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bD(n,e){let t=O(n,"a","greaterEqual","string_or_numeric"),s=O(e,"b","greaterEqual","string_or_numeric");[t,s]=un(t,s),pt(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(Zu,r)}const bi=B({greaterEqual_:bD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xD(n){const t={input:O(n,"input","imag")};return W.runKernel(tb,t)}const tf=B({imag_:xD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wD(n){const t={x:O(n,"x","isFinite")};return W.runKernel(Qu,t)}const CC=B({isFinite_:wD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vD(n){const t={x:O(n,"x","isInf")};return W.runKernel(ec,t)}const SC=B({isInf_:vD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kD(n){const t={x:O(n,"x","isNaN")};return W.runKernel(tc,t)}const IC=B({isNaN_:kD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CD(n,e=.2){const s={x:O(n,"x","leakyRelu")},r={alpha:e};return W.runKernel(gp,s,r)}const nf=B({leakyRelu_:CD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SD(n,e){let t=O(n,"a","less","string_or_numeric"),s=O(e,"b","less","string_or_numeric");[t,s]=un(t,s),pt(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(yp,r)}const fu=B({less_:SD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ID(n,e){let t=O(n,"a","lessEqual","string_or_numeric"),s=O(e,"b","lessEqual","string_or_numeric");[t,s]=un(t,s),pt(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(bp,r)}const ha=B({lessEqual_:ID});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $D(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const s={start:n,stop:e,num:t};return W.runKernel(nb,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ND(n,e=5,t=1,s=1,r=.5){const o=O(n,"x","localResponseNormalization");A(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),A(Za(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let i=o,a=!1;o.rank===3&&(a=!0,i=j(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const l={x:i},u={depthRadius:e,bias:t,alpha:s,beta:r},c=W.runKernel(kp,l,u);return a?j(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const $C=B({localResponseNormalization_:ND});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TD(n){const t={x:O(n,"x","log","float32")};return W.runKernel(nc,t)}const Ks=B({log_:TD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ED(n){const t={x:O(n,"x","log1p")};return W.runKernel(sc,t)}const sf=B({log1p_:ED});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _D(n,e){A(mg(n),()=>"The f passed in variableGrads(f) must be a function"),A(e==null||Array.isArray(e)&&e.every(u=>u instanceof hd),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const u in W.registeredVariables)e.push(W.registeredVariables[u])}const s=t?e.filter(u=>!u.trainable):null,r=e.length;e=e.filter(u=>u.trainable),A(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const o=!0,{value:i,grads:a}=W.gradients(n,e,null,o);A(a.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),A(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const l={};return e.forEach((u,c)=>{a[c]!=null&&(l[u.name]=a[c])}),s!=null&&s.forEach(u=>l[u.name]=null),{value:i,grads:l}}function xo(n){return W.customGrad(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AD(n){const t={x:O(n,"x","neg")};return W.runKernel(Ep,t)}const Kt=B({neg_:AD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RD(n){const t={x:O(n,"x","softplus")};return W.runKernel(xc,t)}const yl=B({softplus_:RD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DD(n){const e=O(n,"x","logSigmoid");return xo(s=>({value:Kt(yl(Kt(s))),gradFunc:i=>H(i,Ur(Kt(s)))}))(e)}const NC=B({logSigmoid_:DD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OD(n,e){let t=O(n,"a","sub"),s=O(e,"b","sub");[t,s]=un(t,s);const r={a:t,b:s};return W.runKernel(kc,r)}const Ke=B({sub_:OD});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FD(n,e=-1){const t=O(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return xo((r,o)=>{const a=ar(r,e,!0),l=Ke(r,a),u=Ke(Ue(l,"float32"),Ks(Qe(Fs(l),e,!0)));return o([u]),{value:u,gradFunc:(h,d)=>{const[p]=d,f=!0,g=Fs(p);return Ke(h,H(Qe(h,e,f),g))}}})(t)}const Xb=B({logSoftmax_:FD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LD(n,e=null,t=!1){const s=O(n,"x","logSumExp"),r=kt(e,s.shape),o=ar(s,r,!0),i=Ke(s,o),a=Fs(i),l=Qe(a,r),u=Ks(l),c=Ne(j(o,u.shape),u);if(t){const h=dn(c.shape,r);return j(c,h)}return c}const rf=B({logSumExp_:LD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PD(n,e){const t=O(n,"a","logicalAnd","bool"),s=O(e,"b","logicalAnd","bool");pt(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(xp,r)}const Yr=B({logicalAnd_:PD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zD(n){const t={x:O(n,"x","logicalNot","bool")};return W.runKernel(wp,t)}const of=B({logicalNot_:zD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MD(n,e){const t=O(n,"a","logicalOr","bool"),s=O(e,"b","logicalOr","bool");pt(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(vp,r)}const Yb=B({logicalOr_:MD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BD(n,e){const t=O(n,"a","logicalXor","bool"),s=O(e,"b","logicalXor","bool");return pt(t.shape,s.shape),Yr(Yb(n,e),of(Yr(n,e)))}const TC=B({logicalXor_:BD});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $h=2147483648;function VD(n,e,t="left"){const s=O(n,"sortedSequence","searchSorted"),r=O(e,"values","searchSorted"),o=s.shape[s.shape.length-1],i=r.shape[r.shape.length-1],a=j(s,[-1,o]),l=j(r,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(pe(l.shape)>=$h)throw new Error(`values tensor size must less than ${$h}`);if(a.shape[1]>=$h)throw new Error(`trailing dim_size must less than ${$h} for int32 output type, was ${a.shape[1]}`);const u={sortedSequence:a,values:l},c={side:t};return W.runKernel(wb,u,c)}const Zb=B({searchSorted_:VD});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WD(n,e){return Zb(n,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UD(n,e,t,s,r){const o=O(n,"x","maxPool"),i=1;let a=o,l=!1;o.rank===3&&(l=!0,a=j(o,[1,o.shape[0],o.shape[1],o.shape[2]])),A(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),A(Wn(t,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),ds("maxPool",s,r);const u={x:a},c={filterSize:e,strides:t,pad:s,dimRoundingMode:r},h=W.runKernel(Sp,u,c);return l?j(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const af=B({maxPool_:UD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GD(n,e=[1,1,1],t,s,r,o="NDHWC"){const i=O(n,"x","maxPool3d");let a=i,l=!1;i.rank===4&&(l=!0,a=j(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),A(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),ds("maxPool3d",s,r);const u={x:a},c={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:o},h=W.runKernel(Ip,u,c);return l?j(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const EC=B({maxPool3d_:GD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HD(n,e,t,s,r=!1){const i={x:O(n,"x","maxPoolWithArgmax")},a={filterSize:e,strides:t,pad:s,includeBatchInIndex:r},l=W.runKernel(ib,i,a);return{result:l[0],indexes:l[1]}}const jD=B({maxPoolWithArgmax_:HD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KD(n,e){let t=O(n,"a","maximum"),s=O(e,"b","maximum");[t,s]=un(t,s),t.dtype==="bool"&&(t=Ue(t,"int32"),s=Ue(s,"int32")),pt(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(rc,r)}const No=B({maximum_:KD});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qD(n,e=null,t=!1){const r={x:O(n,"x","mean")},o={axis:e,keepDims:t};return W.runKernel($p,r,o)}const ln=B({mean_:qD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kn(n,e="float32"){if(Xs(n),e==="complex64"){const s=kn(n,"float32"),r=kn(n,"float32");return ti(s,r)}const t=Xn(pe(n),e);return W.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function As(n,e="float32"){if(Xs(n),e==="complex64"){const s=As(n,"float32"),r=kn(n,"float32");return ti(s,r)}const t=Ey(pe(n),e);return W.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XD(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let s=O(n,"x","meshgrid",n instanceof sn?n.dtype:"float32");if(e===void 0)return[s];let r=O(e,"y","meshgrid",e instanceof sn?e.dtype:"float32");const o=pe(s.shape),i=pe(r.shape);return t==="xy"?(s=j(s,[1,-1]),r=j(r,[-1,1]),[It(As([i,1],s.dtype),s),It(r,As([1,o],r.dtype))]):(s=j(s,[-1,1]),r=j(r,[1,-1]),[It(s,As([1,i],s.dtype)),It(As([o,1],r.dtype),r)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YD(n,e){let t=O(n,"a","minimum"),s=O(e,"b","minimum");[t,s]=un(t,s),t.dtype==="bool"&&(t=Ue(t,"int32"),s=Ue(s,"int32")),pt(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(oc,r)}const sa=B({minimum_:YD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZD(n,e,t){A(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=O(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");A(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=t==="reflect"?1:0;for(let a=0;a<s.rank;a++)A(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),A(e[a][0]>=0&&e[a][0]<=s.shape[a]-r&&e[a][1]>=0&&e[a][1]<=s.shape[a]-r,()=>`Padding in dimension ${a} cannot be greater than or equal to ${s.shape[a]-r} or less than 0 for input of shape ${s.shape}`);const o={paddings:e,mode:t},i={x:s};return W.runKernel(Tp,i,o)}const _C=B({mirrorPad_:ZD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JD(n,e){let t=O(n,"a","mod"),s=O(e,"b","mod");[t,s]=un(t,s);const r={a:t,b:s};return W.runKernel(ic,r)}const AC=B({mod_:JD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QD(n,e=null,t=!1){n=O(n,"x","moments");const s=kt(e,n.shape),r=ln(n,s,t);let o=r.shape;t||(o=dn(r.shape,s));const i=Wt(Ke(Ue(n,"float32"),j(r,o))),a=ln(i,s,t);return{mean:r,variance:a}}const lf=B({moments_:QD});function eO(n,e,t,s){const r=O(e,"data","multiRNNCell"),o=dd(t,"c","multiRNNCell"),i=dd(s,"h","multiRNNCell");let a=r;const l=[];for(let h=0;h<n.length;h++){const d=n[h](a,o[h],i[h]);l.push(d[0]),l.push(d[1]),a=d[1]}const u=[],c=[];for(let h=0;h<l.length;h+=2)u.push(l[h]),c.push(l[h+1]);return[u,c]}const tO=B({multiRNNCell_:eO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nO(n,e,t,s=!1){const r=O(n,"logits","multinomial"),o=r.size,i=r.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);t=t||Math.random();const l={logits:i===1?j(r,[1,-1]):r},u={numSamples:e,seed:t,normalized:s},c=W.runKernel(ab,l,u);return i===1?j(c,[c.size]):c}const sO=B({multinomial_:nO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rO(n,e){let t=O(n,"a","notEqual","string_or_numeric"),s=O(e,"b","notEqual","string_or_numeric");[t,s]=un(t,s),pt(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(_p,r)}const tl=B({notEqual_:rO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oO(n,e,t=1,s=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const i={indices:O(n,"indices","oneHot","int32")},a={dtype:r,depth:e,onValue:t,offValue:s};return W.runKernel(Rp,i,a)}const Jb=B({oneHot_:oO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iO(n){const t={x:O(n,"x","onesLike")};return W.runKernel(Ap,t)}const qs=B({onesLike_:iO});function aO(n,e){const t=O(n,"v1","outerProduct"),s=O(e,"v2","outerProduct");A(t.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${s.rank}.`);const r=j(t,[-1,1]),o=j(s,[1,-1]);return It(r,o)}const lO=B({outerProduct_:aO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uO(n,e,t=0){const s=O(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:t},o={x:s};return W.runKernel(Op,o,r)}const xi=B({pad_:uO});function cO(n,e,t=0){return A(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),xi(n,[e],t)}const hO=B({pad1d_:cO});function dO(n,e,t=0){return A(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),xi(n,e,t)}const pO=B({pad2d_:dO});function fO(n,e,t=0){return A(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),xi(n,e,t)}const mO=B({pad3d_:fO});function gO(n,e,t=0){return A(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),xi(n,e,t)}const yO=B({pad4d_:gO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bO(n,e,t){const s=O(n,"x","spaceToBatchND");A(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),A(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),A(s.shape.reduce((i,a,l)=>l>0&&l<=e.length?i&&(a+t[l-1][0]+t[l-1][1])%e[l-1]===0:i,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},o={blockShape:e,paddings:t};return W.runKernel(Gp,r,o)}const uf=B({spaceToBatchND_:bO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xO(n,e,t,s,r,o,i){r==null&&(r=[1,1]),o==null&&(o=1),s===0&&(s="valid");const a=O(n,"x","maxPool");let l=a,u=!1;a.rank===3&&(u=!0,l=j(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A(Wn(o,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${r}'`);const c=pr(l.shape,e,o,r,s),h=[c.dilationHeight,c.dilationWidth];let d;s==="same"?d=vO([c.filterHeight,c.filterWidth],h):d=[[0,0],[0,0]];const p=h[0]===1&&h[1]===1,[f,g]=wO([c.inHeight,c.inWidth],h,d),y=p?s:"valid",b=p?l:uf(l,h,f),C=(t==="avg"?()=>Jp(b,e,o,y,i):()=>af(b,e,o,y,i))(),v=p?C:Qp(C,h,g);return u?j(v,[v.shape[1],v.shape[2],v.shape[3]]):v}function wO(n,e,t){const s=t.map(c=>c[0]),r=t.map(c=>c[1]),o=n.concat(s,r),i=e.map((c,h)=>(c-o[h]%c)%c),a=r.map((c,h)=>c+i[h]),l=e.map((c,h)=>[s[h],a[h]]),u=e.map((c,h)=>[0,i[h]]);return[l,u]}function vO(n,e){const s=n.map((i,a)=>i+(i-1)*(e[a]-1)).map(i=>i-1),r=s.map(i=>Math.floor(i/2)),o=s.map((i,a)=>i-r[a]);return s.map((i,a)=>[r[a],o[a]])}const RC=B({pool_:xO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kO(n,e){const t=O(n,"x","prelu"),s=O(e,"alpha","prelu"),r={x:t,alpha:s};return W.runKernel(Fp,r)}const cf=B({prelu_:kO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CO(n,e=null,t=!1){let s=O(n,"x","prod");s.dtype==="bool"&&(s=Ue(s,"int32"));const r={x:s},o={axis:e,keepDims:t};return W.runKernel(Lp,r,o)}const DC=B({prod_:CO});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SO(n,e,t,s){const r=n.map((c,h)=>O(c,`tensors${h}`,"raggedGather","int32")),o=O(e,"paramsDenseValues","raggedGather"),i=O(t,"indices","raggedGather","int32"),a={paramsNestedSplits:r,paramsDenseValues:o,indices:i},l={outputRaggedRank:s},u=W.runKernel(hb,a,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}const IO=B({raggedGather_:SO});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $O(n,e,t){const s=O(n,"starts","raggedRange"),r=O(e,"limits","raggedRange",s.dtype),o=O(t,"deltas","raggedRange",s.dtype),i={starts:s,limits:r,deltas:o},a=W.runKernel(db,i);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}const NO=B({raggedRange_:$O});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TO(n,e,t,s,r){const o=O(n,"shape","raggedTensorToTensor","int32"),i=O(e,"values","raggedTensorToTensor"),a=O(t,"defaultValue","raggedTensorToTensor",i.dtype),l=s.map((h,d)=>O(h,`tensors${d}`,"raggedTensorToTensor","int32")),u={shape:o,values:i,defaultValue:a,rowPartitionTensors:l},c={rowPartitionTypes:r};return W.runKernel(pb,u,c)}const EO=B({raggedTensorToTensor_:TO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _O(n,e,t){Xs(n);const s=pe(n);let r=null;if(t==null||t==="float32")r=new Float32Array(s);else if(t==="int32")r=new Int32Array(s);else if(t==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${t}`);for(let o=0;o<s;o++)r[o]=e();return W.makeTensor(r,n,t)}const AO=B({rand_:_O});var jh={exports:{}},RO=jh.exports,Xw;function DO(){return Xw||(Xw=1,function(n){(function(e,t,s){function r(l){var u=this,c=a();u.next=function(){var h=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=h-(u.c=h|0)},u.c=1,u.s0=c(" "),u.s1=c(" "),u.s2=c(" "),u.s0-=c(l),u.s0<0&&(u.s0+=1),u.s1-=c(l),u.s1<0&&(u.s1+=1),u.s2-=c(l),u.s2<0&&(u.s2+=1),c=null}function o(l,u){return u.c=l.c,u.s0=l.s0,u.s1=l.s1,u.s2=l.s2,u}function i(l,u){var c=new r(l),h=u&&u.state,d=c.next;return d.int32=function(){return c.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,h&&(typeof h=="object"&&o(h,c),d.state=function(){return o(c,{})}),d}function a(){var l=4022871197,u=function(c){c=String(c);for(var h=0;h<c.length;h++){l+=c.charCodeAt(h);var d=.02519603282416938*l;l=d>>>0,d-=l,d*=l,l=d>>>0,d-=l,l+=d*4294967296}return(l>>>0)*23283064365386963e-26};return u}t&&t.exports?t.exports=i:this.alea=i})(RO,n)}(jh)),jh.exports}var Kh={exports:{}},OO=Kh.exports,Yw;function FO(){return Yw||(Yw=1,function(n){(function(e,t,s){function r(a){var l=this,u="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},a===(a|0)?l.x=a:u+=a;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,l.next()}function o(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function i(a,l){var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=i:this.xor128=i})(OO,n)}(Kh)),Kh.exports}var qh={exports:{}},LO=qh.exports,Zw;function PO(){return Zw||(Zw=1,function(n){(function(e,t,s){function r(a){var l=this,u="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:u+=a;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,c==u.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function o(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function i(a,l){var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=i:this.xorwow=i})(LO,n)}(qh)),qh.exports}var Xh={exports:{}},zO=Xh.exports,Jw;function MO(){return Jw||(Jw=1,function(n){(function(e,t,s){function r(a){var l=this;l.next=function(){var c=l.x,h=l.i,d,p;return d=c[h],d^=d>>>7,p=d^d<<24,d=c[h+1&7],p^=d^d>>>10,d=c[h+3&7],p^=d^d>>>3,d=c[h+4&7],p^=d^d<<7,d=c[h+7&7],d=d^d<<13,p^=d^d<<9,c[h]=p,l.i=h+1&7,p};function u(c,h){var d,p=[];if(h===(h|0))p[0]=h;else for(h=""+h,d=0;d<h.length;++d)p[d&7]=p[d&7]<<15^h.charCodeAt(d)+p[d+1&7]<<13;for(;p.length<8;)p.push(0);for(d=0;d<8&&p[d]===0;++d);for(d==8?p[7]=-1:p[d],c.x=p,c.i=0,d=256;d>0;--d)c.next()}u(l,a)}function o(a,l){return l.x=a.x.slice(),l.i=a.i,l}function i(a,l){a==null&&(a=+new Date);var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(c.x&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=i:this.xorshift7=i})(zO,n)}(Xh)),Xh.exports}var Yh={exports:{}},BO=Yh.exports,Qw;function VO(){return Qw||(Qw=1,function(n){(function(e,t,s){function r(a){var l=this;l.next=function(){var c=l.w,h=l.X,d=l.i,p,f;return l.w=c=c+1640531527|0,f=h[d+34&127],p=h[d=d+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,f=h[d]=f^p,l.i=d,f+(c^c>>>16)|0};function u(c,h){var d,p,f,g,y,b=[],w=128;for(h===(h|0)?(p=h,h=null):(h=h+"\0",p=0,w=Math.max(w,h.length)),f=0,g=-32;g<w;++g)h&&(p^=h.charCodeAt((g+32)%h.length)),g===0&&(y=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,g>=0&&(y=y+1640531527|0,d=b[g&127]^=p+y,f=d==0?f+1:0);for(f>=128&&(b[(h&&h.length||0)&127]=-1),f=127,g=4*128;g>0;--g)p=b[f+34&127],d=b[f=f+1&127],p^=p<<13,d^=d<<17,p^=p>>>15,d^=d>>>12,b[f]=p^d;c.w=y,c.X=b,c.i=f}u(l,a)}function o(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function i(a,l){a==null&&(a=+new Date);var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(c.X&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=i:this.xor4096=i})(BO,n)}(Yh)),Yh.exports}var Zh={exports:{}},WO=Zh.exports,ev;function UO(){return ev||(ev=1,function(n){(function(e,t,s){function r(a){var l=this,u="";l.next=function(){var h=l.b,d=l.c,p=l.d,f=l.a;return h=h<<25^h>>>7^d,d=d-p|0,p=p<<24^p>>>8^f,f=f-h|0,l.b=h=h<<20^h>>>12^d,l.c=d=d-p|0,l.d=p<<16^d>>>16^f,l.a=f-h|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):u+=a;for(var c=0;c<u.length+20;c++)l.b^=u.charCodeAt(c)|0,l.next()}function o(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function i(a,l){var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=i:this.tychei=i})(WO,n)}(Zh)),Zh.exports}var Jh={exports:{}};const GO={},HO=Object.freeze(Object.defineProperty({__proto__:null,default:GO},Symbol.toStringTag,{value:"Module"})),jO=$_(HO);var KO=Jh.exports,tv;function qO(){return tv||(tv=1,function(n){(function(e,t,s){var r=256,o=6,i=52,a="random",l=s.pow(r,o),u=s.pow(2,i),c=u*2,h=r-1,d;function p(v,I,E){var R=[];I=I==!0?{entropy:!0}:I||{};var L=b(y(I.entropy?[v,C(t)]:v??w(),3),R),D=new f(R),F=function(){for(var T=D.g(o),V=l,q=0;T<u;)T=(T+q)*r,V*=r,q=D.g(1);for(;T>=c;)T/=2,V/=2,q>>>=1;return(T+q)/V};return F.int32=function(){return D.g(4)|0},F.quick=function(){return D.g(4)/4294967296},F.double=F,b(C(D.S),t),(I.pass||E||function(T,V,q,se){return se&&(se.S&&g(se,D),T.state=function(){return g(D,{})}),q?(s[a]=T,V):T})(F,L,"global"in I?I.global:this==s,I.state)}function f(v){var I,E=v.length,R=this,L=0,D=R.i=R.j=0,F=R.S=[];for(E||(v=[E++]);L<r;)F[L]=L++;for(L=0;L<r;L++)F[L]=F[D=h&D+v[L%E]+(I=F[L])],F[D]=I;(R.g=function(T){for(var V,q=0,se=R.i,ee=R.j,te=R.S;T--;)V=te[se=h&se+1],q=q*r+te[h&(te[se]=te[ee=h&ee+V])+(te[ee]=V)];return R.i=se,R.j=ee,q})(r)}function g(v,I){return I.i=v.i,I.j=v.j,I.S=v.S.slice(),I}function y(v,I){var E=[],R=typeof v,L;if(I&&R=="object")for(L in v)try{E.push(y(v[L],I-1))}catch{}return E.length?E:R=="string"?v:v+"\0"}function b(v,I){for(var E=v+"",R,L=0;L<E.length;)I[h&L]=h&(R^=I[h&L]*19)+E.charCodeAt(L++);return C(I)}function w(){try{var v;return d&&(v=d.randomBytes)?v=v(r):(v=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(v)),C(v)}catch{var I=e.navigator,E=I&&I.plugins;return[+new Date,e,E,e.screen,C(t)]}}function C(v){return String.fromCharCode.apply(0,v)}if(b(s.random(),t),n.exports){n.exports=p;try{d=jO}catch{}}else s["seed"+a]=p})(typeof self<"u"?self:KO,[],Math)}(Jh)),Jh.exports}var Vm,nv;function XO(){if(nv)return Vm;nv=1;var n=DO(),e=FO(),t=PO(),s=MO(),r=VO(),o=UO(),i=qO();return i.alea=n,i.xor128=e,i.xorwow=t,i.xorshift7=s,i.xor4096=r,i.tychei=o,Vm=i,Vm}var hf=XO();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qb{constructor(e,t,s,r,o){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const i=o||Math.random();this.random=hf.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,t,s=!1;for(;!s;){let r,o,i;do r=2*this.random()-1,o=2*this.random()-1,i=r*r+o*o;while(i>=1||i===0);const a=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*r*a,t=this.mean+this.stdDev*o*a,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class YO{constructor(e,t,s,r){this.alpha=e,this.beta=1/t,this.dtype=s;const o=r||Math.random();this.randu=hf.alea(o.toString()),this.randn=new Qb(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,s,r,o,i;for(;;){do r=this.randn.nextValue(),i=1+this.c*r;while(i<=0);if(i*=i*i,e=r*r,t=1-.331*e*e,s=.5*e+this.d*(1-i+Math.log(i)),o=this.randu(),o<t||Math.log(o)<s)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class ZO{constructor(e=0,t=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=hf.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JO(n,e,t=1,s="float32",r){if(Xs(n),t==null&&(t=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const o=new YO(e,t,s,r),i=wt(n,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const QO=B({randomGamma_:JO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eF(n,e=0,t=1,s,r){if(Xs(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const o=new Qb(e,t,s,!1,r),i=wt(n,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const ex=B({randomNormal_:eF});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tF(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return ex(n,0,1,e,t)}const nF=B({randomStandardNormal_:tF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sF(n,e=0,t=1,s="float32",r){Xs(n);const o=wt(n,s),i=new ZO(e,t,null,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const da=B({randomUniform_:sF});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rF(n,e,t,s){return da(n,e,t,"int32",s)}const oF=B({randomUniformInt_:rF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nl(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:e,step:t,dtype:s};return W.runKernel(fb,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iF(n){const t={input:O(n,"input","real")};return W.runKernel(mb,t)}const mu=B({real_:iF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aF(n){const t={x:O(n,"x","reciprocal")};return W.runKernel(uc,t)}const OC=B({reciprocal_:aF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lF(n){const t={x:O(n,"x","relu")};return W.runKernel(cc,t)}const to=B({relu_:lF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uF(n){const t={x:O(n,"x","relu6")};return W.runKernel(hc,t)}const tx=B({relu6_:uF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cF(n,e){const s={x:O(n,"x","reverse")},r={dims:e};return W.runKernel(Bp,s,r)}const hr=B({reverse_:cF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hF(n){const e=O(n,"x","reverse");return A(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),hr(e,0)}const dF=B({reverse1d_:hF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pF(n,e){const t=O(n,"x","reverse");return A(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),hr(t,e)}const fF=B({reverse2d_:pF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mF(n,e){const t=O(n,"x","reverse");return A(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),hr(t,e)}const gF=B({reverse3d_:mF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yF(n,e){const t=O(n,"x","reverse");return A(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),hr(t,e)}const bF=B({reverse4d_:yF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xF(n){const t={x:O(n,"x","round")};return W.runKernel(dc,t)}const nx=B({round_:xF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wF(n){const t={x:O(n,"x","rsqrt","float32")};return W.runKernel(pc,t)}const sx=B({rsqrt_:wF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vF(n){const t={x:O(n,"x","selu")};return W.runKernel(fc,t)}const rx=B({selu_:vF});function kF(n,e,t,s,r,o=[1,1],i="NHWC"){const a=O(n,"x","separableConv2d"),l=O(e,"depthwiseFilter","separableConv2d"),u=O(t,"pointwiseFilter","separableConv2d");let c=a,h=!1;if(a.rank===3&&(h=!0,c=j(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");A(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),A(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),A(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),A(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),A(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const d=l.shape[2],p=l.shape[3];A(u.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`);const f=_c(c,l,s,r,i,o),y=ri(f,u,1,"valid",i);return h?j(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const ox=B({separableConv2d_:kF});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function CF(n,e){const t=O(n,"x","setdiff1d"),s=O(e,"y","setdiff1d");A(t.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`),A(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),A(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await t.data(),o=await s.data(),i=new Set(o);let a=0;for(let c=0;c<r.length;c++)i.has(r[c])||a++;const l=new In([a],t.dtype),u=new In([a],"int32");for(let c=0,h=0;c<r.length;c++)i.has(r[c])||(l.values[h]=r[c],u.values[h]=c,h++);return[l.toTensor(),u.toTensor()]}const SF=CF;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IF(n){const t={x:O(n,"x","sign")};return W.runKernel(yc,t)}const FC=B({sign_:IF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $F(n){const t={x:O(n,"x","sin","float32")};return W.runKernel(mc,t)}const ix=B({sin_:$F});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NF(n){const t={x:O(n,"x","sinh")};return W.runKernel(gc,t)}const ax=B({sinh_:NF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TF(n,e,t){const s=O(n,"x","slice1d");return A(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),Et(s,[e],[t])}const df=B({slice1d_:TF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EF(n,e,t){const s=O(n,"x","slice2d");return A(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),Et(s,e,t)}const lx=B({slice2d_:EF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _F(n,e,t){const s=O(n,"x","slice3d");return A(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),Et(s,e,t)}const pf=B({slice3d_:_F});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AF(n,e,t){const s=O(n,"x","slice4d");return A(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),Et(s,e,t)}const gu=B({slice4d_:AF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RF(n,e=-1){const t=O(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},r={dim:e};return W.runKernel(jp,s,r)}const ff=B({softmax_:RF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DF(n){A(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return W.runKernel(Yy,e)}const mf=B({fft_:DF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OF(n){A(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return W.runKernel(eb,e)}const yu=B({ifft_:OF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FF(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const r=j(n,[t,e]);s=yu(r)}else{const r=[t,2*(e-1)],o=j(mu(n),[t,e]),i=j(tf(n),[t,e]),a=hr(Et(o,[0,1],[t,e-2]),1),l=H(hr(Et(i,[0,1],[t,e-2]),1),it(-1)),u=bn([o,a],1),c=bn([i,l],1),h=j(ti(u,c),[r[0],r[1]]);s=yu(h)}if(s=mu(s),n.rank===3&&n.shape[0]!==0){const r=s,o=n.shape[0];s=j(s,[o,s.shape[0]/o,s.shape[1]]),r.dispose()}return s}const ux=B({irfft_:FF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LF(n,e,t=0){const r={x:O(n,"x","split")},o={numOrSizeSplits:e,axis:t};return W.runKernel(Hp,r,o)}const Rs=B({split_:LF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PF(n,e){A(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let r;if(e!=null&&e<t){const f=n.shape.map(y=>0),g=n.shape.map(y=>y);g[n.shape.length-1]=e,r=Et(n,f,g),t=e}else if(e!=null&&e>t){const f=n.shape.map(g=>g);f[n.shape.length-1]=e-t,r=bn([n,kn(f)],n.shape.length-1),t=e}else r=n;const o=At(r),i=j(ti(r,o),[s,t]),a=mf(i),l=Math.floor(t/2)+1,u=mu(a),c=tf(a),h=Rs(u,[l,t-l],u.shape.length-1),d=Rs(c,[l,t-l],c.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=l,j(ti(h[0],d[0]),p)}const gf=B({rfft_:PF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zF(n,e){let t=O(n,"a","squaredDifference"),s=O(e,"b","squaredDifference");[t,s]=un(t,s),pt(t.shape,s.shape);const r={a:t,b:s},o={};return W.runKernel(vc,r,o)}const cx=B({squaredDifference_:zF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MF(n,e){const t=O(n,"x","squeeze","string_or_numeric");return j(t,di(t.shape,e).newShape)}const pa=B({squeeze_:MF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BF(n,e=0){const t=dd(n,"tensors","stack","string_or_numeric");A(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&A(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,r={axis:e};return W.runKernel(Dp,s,r)}const Ls=B({stack_:BF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VF(n,e=0){const s={x:O(n,"x","step")},r={alpha:e};return W.runKernel($c,s,r)}const bl=B({step_:VF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WF(n,e,t,s,r=0,o=0,i=0,a=0,l=0){const c={x:O(n,"x","stridedSlice","string_or_numeric")},h={begin:e,end:t,strides:s,beginMask:r,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};return W.runKernel(Nb,c,h)}const LC=B({stridedSlice_:WF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UF(n){const t={x:O(n,"x","tan","float32")};return W.runKernel(Cc,t)}const PC=B({tan_:UF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function us(n,e){dl(n);const t=fi(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return mi(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tu(n,e,t){if(dl(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=fi(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return mi(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zC(n,e,t){if(dl(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=fi(n,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return mi(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GF(n,e,t){if(dl(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=fi(n,t);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return mi(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HF(n,e,t){if(dl(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=fi(n,t);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return mi(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jF(n,e,t){if(dl(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=fi(n,t);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,mi(n,e,s,t)}function MC(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(t.rank<r)throw new Error(o+` update.rank < ${r}. `);if(n.length<s+(t.rank-r))throw new Error(o+` Output shape length < ${s+(t.rank-r)}`);if(t.rank!==r+n.length-s)throw new Error(o+` update.rank != ${r+n.length-s}`);for(let i=0;i<r;++i)if(t.shape[i]!==e.shape[i])throw new Error(o+` updates.shape[${i}] (${t.shape[i]}) != indices.shape[${i}] (${e.shape[i]}).`);for(let i=0;i<t.rank-r;++i)if(t.shape[i+r]!==n[i+s])throw new Error(o+` updates.shape[${i+r}] (${t.shape[i+r]}) != shape[${i+r}] (${n[i+r]})`)}function hx(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}MC(t,e,n)}function fa(n,e,t){const s=e.shape.length,r=s>1?e.shape[s-1]:1,o=t.length;let i=1;for(let h=r;h<o;++h)i*=t[h];const a=r<1?1:r,l=pe(e.shape)/a,u=[...rt(t.slice(0,r)),1],c=pe(t);return{sliceRank:r,numUpdates:l,sliceSize:i,strides:u,outputSize:c}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KF(n,e,t){const s=O(n,"tensor","tensorScatterupdate"),r=O(e,"indices","tensorScatterupdate","int32"),o=O(t,"updates","tensorScatterupdate");if(hx(o,r,s.shape),s.dtype!==o.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${o.dtype}.`);const i={tensor:s,indices:r,updates:o},a={};return W.runKernel(xb,i,a)}const qF=B({tensorScatterUpdate_:KF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XF(n,e=1,t=!0){const s=O(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const o={x:s},i={k:e,sorted:t},[a,l]=W.runKernel(Ab,o,i);return{values:a,indices:l}}const BC=B({topk_:XF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YF(n,e=0,t=1,s,r){if(Xs(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const o=new Qb(e,t,s,!0,r),i=wt(n,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const dx=B({truncatedNormal_:YF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZF(n,e=0){const t=O(n,"x","unique","string_or_numeric");A(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},r={axis:e},[o,i]=W.runKernel(Db,s,r);return{values:o,indices:i}}const VC=B({unique_:ZF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JF(n,e,t){const s=O(n,"x","unsortedSegmentSum"),r=O(e,"segmentIds","unsortedSegmentSum","int32");A(Za(t),()=>"numSegments must be of dtype int");const o={x:s,segmentIds:r},i={numSegments:t};return W.runKernel(Xp,o,i)}const px=B({unsortedSegmentSum_:JF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QF(n,e=0){const t=O(n,"x","unstack","string_or_numeric");A(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},r={axis:e};return W.runKernel(qp,s,r)}const dr=B({unstack_:QF});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eL(n,e){return Zb(n,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WC(n,e=!0,t,s){return W.makeVariable(n,e,t,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fx(n,e){const t=[];for(let o=0;o<e.length;o++)e[o]&&t.push(o);const s=wt(n,"int32"),r=wt([t.length,n.length],"int32");for(let o=0;o<t.length;o++){const i=s.indexToLoc(t[o]),a=o*n.length;r.values.set(i,a)}return r.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function tL(n){const e=O(n,"condition","whereAsync","bool"),t=await e.data(),s=fx(e.shape,t);return n!==e&&e.dispose(),s}const UC=tL;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function nL(n,e,t){const s=O(n,"tensor","boolMask"),r=O(e,"mask","boolMask","bool"),o=t??0,i=r.rank,a=s.shape;A(i>0,()=>"mask cannot be scalar"),Ms(a.slice(o,o+i),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let g=o;g<o+i;g++)l*=a[g];const u=a.slice(0,o).concat([l],a.slice(o+i)),c=j(s,u),h=j(r,[-1]),d=await UC(h),p=pa(d,[1]),f=Oc(c,p,o);return n!==s&&s.dispose(),e!==r&&r.dispose(),p.dispose(),c.dispose(),h.dispose(),d.dispose(),f}const sL=nL;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rL(n,e,t){const s=O(n,"x","transpose");if(e==null&&(e=s.shape.map((i,a)=>a).reverse()),A(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(i=>{A(i>=0&&i<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const r={x:s},o={perm:e};return s.dtype==="complex64"?oe(()=>{let i=mu(s),a=tf(s);return i=W.runKernel(Ma,{x:i},o),a=W.runKernel(Ma,{x:a},o),t&&(a=Kt(a)),ti(i,a)}):W.runKernel(Ma,r,o)}const _t=B({transpose_:rL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oL(n,e,t,s,r=!0){const o=O(n,"v","movingAverage"),i=O(e,"x","movingAverage"),a=O(t,"decay","movingAverage");H_(o,i),A(Tt(o.shape,i.shape),()=>"Shape mismatch in v and x");const l=it(1),u=Ke(l,a);let c=H(Ke(i,o),u);if(r){A(s!=null,()=>"When using zeroDebias: true, step is required.");const h=O(s,"step","movingAverage");c=nt(c,Ke(l,bo(a,h)))}return Ne(o,c)}const iL=B({movingAverage_:oL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aL(n,e,t){Xs(t);const s=O(n,"indices","scatterND","int32"),r=O(e,"updates","scatterND");hx(r,s,t);const o={indices:s,updates:r},i={shape:t};return W.runKernel(bb,o,i)}const lL=B({scatterND_:aL});function uL(n,e,t,s){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const r=n.rank>0?n.shape[0]:1,o=n.rank>1?n.shape[1]:1;if(t.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${o}.`);const i=e.size;if(!(e.rank===0||e.rank===1&&i===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cL(n,e,t,s=0){Xs(t);const r=O(n,"sparseIndices","sparseToDense","int32"),o=O(e,"sparseValues","sparseToDense","string_or_numeric"),i=O(s,"defaultValue","sparseToDense",o.dtype);uL(r,o,t,i);const a={sparseIndices:r,sparseValues:o,defaultValue:i},l={outputShape:t};return W.runKernel(Ib,a,l)}const hL=B({sparseToDense_:cL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dL(n,e){const t=O(e,"indices","gatherND","int32"),r={params:O(n,"x","gatherND","string_or_numeric"),indices:t};return W.runKernel(Qy,r)}const pL=B({gatherND_:dL});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fL(n,e){if(e==null)return n.shape.slice();if(Tt(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let s=0;s<n.shape.length;s++)e[s]==null&&n.shape[s]!=null?t.push(n.shape[s]):t.push(e[s]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mL(n,e,t,s){const r=O(n,"x","dropout");if(A(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),A(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof sn?r.clone():r;const o=fL(r,t),i=1-e,a=nt(Dc(Ne(da(o,0,1,"float32",s),i)),i);return H(r,a)}const GC=B({dropout_:mL});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HC(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function mx(n,e,t){const s=1-n%2,r=new Float32Array(n);for(let o=0;o<n;++o){const i=2*Math.PI*o/(n+s-1);r[o]=e-t*Math.cos(i)}return us(r,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function gL(n,e,t=1){const s=O(n,"predictions","inTopK"),r=O(e,"targets","inTopK");A(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),A(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),Ms(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=s.shape[s.shape.length-1];A(t>0&&t<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${t}`);const i=await s.data(),a=await r.data(),[l,u]=[i.length/o,o],c=Bn("bool",l);for(let h=0;h<l;h++){const d=h*u,p=i.subarray(d,d+u),f=[];for(let g=0;g<p.length;g++)f.push({value:p[g],index:g});f.sort((g,y)=>y.value-g.value),c[h]=0;for(let g=0;g<t;g++)if(f[g].index===a[h]){c[h]=1;break}}return n!==s&&s.dispose(),e!==r&&r.dispose(),wr(c,r.shape,"bool")}const yL=gL;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bL(n,e,t,s,r,o="NHWC",i){let a=n;n.rank===3&&(a=j(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=j(e,[1,e.shape[0],e.shape[1],e.shape[2]])),A(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),A(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),A(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const u=o==="NHWC"?a.shape[3]:a.shape[1],c=o==="NHWC"?l.shape[3]:l.shape[1];A(u===t[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${t[2]}.`),A(c===t[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${t[3]}).`),ds("conv2dDerFilter",r,i);const h={x:a,dy:l},d={strides:s,pad:r,dataFormat:o,dimRoundingMode:i,filterShape:t};return W.runKernel(zy,h,d)}const gx=B({conv2DBackpropFilter_:bL});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yf(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return H(n,bl(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function bf(n,e){let t=e;const s=Tn(n.shape,e.shape);return s.length>0&&(t=Qe(t,s)),j(t,n.shape)}function xf(n,e,t,s){if(e==="linear")return n;if(e==="relu")return to(n);if(e==="elu")return Ac(n);if(e==="relu6")return tx(n);if(e==="prelu")return cf(n,t);if(e==="leakyrelu")return nf(n,s);if(e==="sigmoid")return Ur(n);throw new Error(`Unknown fused activation ${e}.`)}const wf=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xL({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",wf(W.state.gradientDepth,l)===!1){A(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let E=ri(n,e,t,s,r,o,i);return a!=null&&(E=Ne(E,a)),xf(E,l,u,c)}const h=O(n,"x","conv2d","float32"),d=O(e,"filter","conv2d","float32");let p=h,f=!1;h.rank===3&&(f=!0,p=j(h,[1,h.shape[0],h.shape[1],h.shape[2]])),A(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),A(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),ds("fused conv2d",s,i);const g=r==="NHWC"?p.shape[3]:p.shape[1];A(d.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${d.shape[2]}.`),A(Wn(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);const y=On(p.shape,d.shape,t,o,s,i);let b;a!=null&&(b=O(a,"bias","fused conv2d"),[b]=un(b,h),r==="NHWC"?pt(y.outShape,b.shape):(A(b.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`),A(b.shape.length===0||b.shape[0]===y.outChannels||b.shape[0]===1,()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${y.outChannels})`)));let w;if(u!=null){const E=u.shape;if(A(E.length<=1||E.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${E.length}.`),E.length===1)A(E[0]===1||E[0]===y.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${E}) is not compatible with the number of output channels (${y.outChannels}).`);else if(E.length===3)try{pt(E,y.outShape)}catch{const L=`Error in fused conv2d: PReLU activation weights (${E}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(L)}w=O(u,"prelu weights","fused conv2d")}const C=(E,R)=>{A(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[L,D,F,T]=R,V=yf(E,F,l);A(si(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const q=Wb(D.shape,V,L,t,s),se=gx(D,V,L.shape,t,s),ee=[q,se];if(T!=null){const te=bf(T,V);ee.push(te)}return ee},v={x:p,filter:d,bias:b,preluActivationWeights:w},I={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return a==null?xo((R,L,D)=>{let F=W.runKernel(ld,v,I);return D([L,R,F]),f&&(F=j(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:C}})(p,d):xo((R,L,D,F)=>{let T=W.runKernel(ld,v,I);return F([L,R,T,D]),f&&(T=j(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:C}})(p,d,b)}const jC=B({fusedConv2d_:xL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wL(n,e,t,s,r,o=[1,1],i){let a=n;n.rank===3&&(a=j(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=j(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={x:a,dy:l},c={strides:s,pad:r,dimRoundingMode:i,dilations:o,filterShape:t};return W.runKernel(Hy,u,c)}const KC=B({depthwiseConv2dNativeBackpropFilter_:wL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vL(n,e,t,s,r,o=[1,1],i){let a=e,l=!1;e.rank===3&&(l=!0,a=j(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={dy:a,filter:t},c={strides:s,pad:r,dimRoundingMode:i,dilations:o,inputShape:n},h=W.runKernel(jy,u,c);return l?j(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const qC=B({depthwiseConv2dNativeBackpropInput_:vL});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kL({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(wf(W.state.gradientDepth,l)===!1){let I=_c(n,e,t,s,r,o,i);return a!=null&&(I=Ne(I,a)),xf(I,l,u,c)}const h=O(n,"x","depthwiseConv2d","float32"),d=O(e,"filter","depthwiseConv2d","float32");let p=h,f=!1;h.rank===3&&(f=!0,p=j(h,[1,h.shape[0],h.shape[1],h.shape[2]])),A(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),A(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),A(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),o==null&&(o=[1,1]),A(Wn(t,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),ds("fused depthwiseConv2d",s,i);const g=On(p.shape,d.shape,t,o,s,i,!0);let y;a!=null&&(y=O(a,"bias","fused conv2d"),[y]=un(y,h),pt(g.outShape,y.shape));let b;u!=null&&(b=O(u,"prelu weights","fused depthwiseConv2d"));const w=(I,E)=>{A(si(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[R,L,D,F]=E,T=yf(I,D,l),V=qC(L.shape,T,R,t,s,o,i),q=KC(L,T,R.shape,t,s,o,i);if(F!=null){const se=bf(y,T);return[V,q,se]}return[V,q]},C={x:p,filter:d,bias:y,preluActivationWeights:b},v={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return a==null?xo((E,R,L)=>{let D=W.runKernel(ud,C,v);return L([R,E,D]),f&&(D=j(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:w}})(p,d):xo((E,R,L,D)=>{let F=W.runKernel(ud,C,v);return D([R,E,F,L]),f&&(F=j(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:w}})(p,d,y)}const CL=B({fusedDepthwiseConv2d_:kL});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SL({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:r,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(wf(W.state.gradientDepth,o)===!1){let T=It(n,e,t,s);return r!=null&&(T=Ne(T,r)),xf(T,o,i,a)}let l=O(n,"a","fused matMul"),u=O(e,"b","fused matMul");[l,u]=un(l,u);const c=t?l.shape[l.rank-2]:l.shape[l.rank-1],h=s?u.shape[u.rank-1]:u.shape[u.rank-2],d=t?l.shape[l.rank-1]:l.shape[l.rank-2],p=s?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),g=u.shape.slice(0,-2),y=pe(f),b=pe(g);A(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${t} and transposeB=${s} must match.`);const C=pt(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([d,p]),v=t?j(l,[y,c,d]):j(l,[y,d,c]),I=s?j(u,[b,p,h]):j(u,[b,h,p]);let E;r!=null&&(E=O(r,"bias","fused matMul"),[E]=un(E,l),pt(C,E.shape));let R;i!=null&&(R=O(i,"prelu weights","fused matMul"));const L=(T,V)=>{const[q,se,ee,te]=V,le=yf(j(T,ee.shape),ee,o);let Q,he;if(!t&&!s?(Q=It(le,se,!1,!0),he=It(q,le,!0,!1)):!t&&s?(Q=It(le,se,!1,!1),he=It(le,q,!0,!1)):t&&!s?(Q=It(se,le,!1,!0),he=It(q,le,!1,!1)):(Q=It(se,le,!0,!0),he=It(le,q,!0,!0)),r!=null){const ye=bf(te,le);return[Q,he,ye]}else return[Q,he]},D={a:v,b:I,bias:E,preluActivationWeights:R},F={transposeA:t,transposeB:s,activation:o,leakyreluAlpha:a};return r==null?xo((V,q,se)=>{const ee=W.runKernel(ad,D,F);return se([V,q,ee]),{value:j(ee,C),gradFunc:L}})(v,I):xo((V,q,se,ee)=>{const te=W.runKernel(ad,D,F);return ee([V,q,te,se]),{value:j(te,C),gradFunc:L}})(v,I,E)}const Og=B({fusedMatMul_:SL});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IL=Object.freeze(Object.defineProperty({__proto__:null,conv2d:jC,depthwiseConv2d:CL,matMul:Og},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $L(n){return mx(n,.54,.46)}const NL=B({hammingWindow_:$L});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TL(n){return mx(n,.5,.5)}const XC=B({hannWindow_:TL});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EL(n,e,t,s=!1,r=0){let o=0;const i=[];for(;o+e<=n.size;)i.push(Et(n,o,e)),o+=t;if(s)for(;o<n.size;){const a=o+e-n.size,l=bn([Et(n,o,e-a),gl([a],r)]);i.push(l),o+=t}return i.length===0?tu([],[0,e]):j(bn(i),[i.length,e])}const YC=B({frame_:EL});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _L(n,e,t,s,r=XC){s==null&&(s=HC(e));const o=YC(n,e,t),i=H(o,r(e));return gf(i,s)}const AL=B({stft_:_L});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RL(n,e,t,s,r="bilinear",o=0){const i=O(n,"image","cropAndResize"),a=O(e,"boxes","cropAndResize","float32"),l=O(t,"boxInd","cropAndResize","int32"),u=a.shape[0];A(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),A(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),A(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),A(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),A(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),A(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const c={image:i,boxes:a,boxInd:l},h={method:r,extrapolationValue:o,cropSize:s};return W.runKernel(Wy,c,h)}const DL=B({cropAndResize_:RL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OL(n){const e=O(n,"image","flipLeftRight","float32");A(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return W.runKernel(Jy,t,{})}const FL=B({flipLeftRight_:OL});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LL(n){const e=O(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];A(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),A(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,sr(e,r)}const PL=B({grayscaleToRGB_:LL});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zL(n){const e=O(n,"image","RGBToGrayscale"),t=e.rank-1,s=e.shape[t];A(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),A(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=e.dtype,o=Ue(e,"float32"),i=us([.2989,.587,.114]);let a;switch(e.rank){case 2:a=La("ij,j->i",o,i);break;case 3:a=La("ijk,k->ij",o,i);break;case 4:a=La("ijkl,l->ijk",o,i);break;case 5:a=La("ijklm,m->ijkl",o,i);break;case 6:a=La("ijklmn,n->ijklm",o,i);break;default:throw new Error("Not a valid tensor rank.")}return a=os(a,-1),Ue(a,r)}const ML=B({rgbToGrayscale_:zL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BL(n,e,t=0,s=.5){const r=O(n,"image","rotateWithOffset","float32");A(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const o={image:r},i={radians:e,fillValue:t,center:s};return W.runKernel(Ob,o,i)}const VL=B({rotateWithOffset_:BL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xl(n,e,t,s,r,o){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),o==null&&(o=0);const i=n.shape[0];return t=Math.min(t,i),A(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),A(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),A(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),A(e.rank===1,()=>"scores must be a 1D tensor"),A(e.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${e.shape[0]}`),A(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WL(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const o=O(n,"boxes","nonMaxSuppression","float32"),i=O(e,"scores","nonMaxSuppression","float32"),a=xl(o,i,t,s,r);t=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const l={maxOutputSize:t,iouThreshold:s,scoreThreshold:r};return W.runKernel(lb,{boxes:o,scores:i},l)}const UL=B({nonMaxSuppression_:WL});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GL(n,e,t){const s=HL(n,e,t),r=s<0?-(s+1):s;n.splice(r,0,e)}function HL(n,e,t){return KL(n,e,t||jL)}function jL(n,e){return n>e?1:n<e?-1:0}function KL(n,e,t){let s=0,r=n.length,o=0,i=!1;for(;s<r;){o=s+(r-s>>>1);const a=t(e,n[o]);a>0?s=o+1:(r=o,i=!a)}return i?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yx(n,e,t,s,r){return wx(n,e,t,s,r,0)}function bx(n,e,t,s,r,o){return wx(n,e,t,s,r,0,!1,o,!0)}function xx(n,e,t,s,r,o){return wx(n,e,t,s,r,o,!0)}function wx(n,e,t,s,r,o,i=!1,a=!1,l=!1){const u=[];for(let y=0;y<e.length;y++)e[y]>r&&u.push({score:e[y],boxIndex:y,suppressBeginIndex:0});u.sort(sv);const c=o>0?-.5/o:0,h=[],d=[];for(;h.length<t&&u.length>0;){const y=u.pop(),{score:b,boxIndex:w,suppressBeginIndex:C}=y;if(b<r)break;let v=!1;for(let I=h.length-1;I>=C;--I){const E=qL(n,w,h[I]);if(E>=s){v=!0;break}if(y.score=y.score*XL(s,c,E),y.score<=r)break}y.suppressBeginIndex=h.length,v||(y.score===b?(h.push(w),d.push(y.score)):y.score>r&&GL(u,y,sv))}const p=h.length,f=t-p;a&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const g={selectedIndices:h};return i&&(g.selectedScores=d),l&&(g.validOutputs=p),g}function qL(n,e,t){const s=n.subarray(e*4,e*4+4),r=n.subarray(t*4,t*4+4),o=Math.min(s[0],s[2]),i=Math.min(s[1],s[3]),a=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),u=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(a-o)*(l-i),f=(h-u)*(d-c);if(p<=0||f<=0)return 0;const g=Math.max(o,u),y=Math.max(i,c),b=Math.min(a,h),w=Math.min(l,d),C=Math.max(b-g,0)*Math.max(w-y,0);return C/(p+f-C)}function XL(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function sv(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function YL(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const o=O(n,"boxes","nonMaxSuppressionAsync"),i=O(e,"scores","nonMaxSuppressionAsync"),a=xl(o,i,t,s,r);t=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const l=await Promise.all([o.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:h}=yx(u,c,t,s,r);return o!==n&&o.dispose(),i!==e&&i.dispose(),us(h,"int32")}const ZL=YL;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JL(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=0){const i=O(n,"boxes","nonMaxSuppression"),a=O(e,"scores","nonMaxSuppression"),l=xl(i,a,t,s,r,o);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,o=l.softNmsSigma;const u={boxes:i,scores:a},c={maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:o},h=W.runKernel(cb,u,c);return{selectedIndices:h[0],selectedScores:h[1]}}const QL=B({nonMaxSuppressionWithScore_:JL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function eP(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=0){const i=O(n,"boxes","nonMaxSuppressionAsync"),a=O(e,"scores","nonMaxSuppressionAsync"),l=xl(i,a,t,s,r,o);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,o=l.softNmsSigma;const u=await Promise.all([i.data(),a.data()]),c=u[0],h=u[1],{selectedIndices:d,selectedScores:p}=xx(c,h,t,s,r,o);return i!==n&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:us(d,"int32"),selectedScores:us(p)}}const tP=eP;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nP(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=!1){const i=O(n,"boxes","nonMaxSuppression"),a=O(e,"scores","nonMaxSuppression"),l=xl(i,a,t,s,r,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,d={boxes:i,scores:a},p={maxOutputSize:u,iouThreshold:c,scoreThreshold:h,padToMaxOutputSize:o},f=W.runKernel(ub,d,p);return{selectedIndices:f[0],validOutputs:f[1]}}const sP=B({nonMaxSuppressionPadded_:nP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function rP(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=!1){const i=O(n,"boxes","nonMaxSuppressionAsync"),a=O(e,"scores","nonMaxSuppressionAsync"),l=xl(i,a,t,s,r,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([i.data(),a.data()]),{selectedIndices:f,validOutputs:g}=bx(d,p,u,c,h,o);return i!==n&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:us(f,"int32"),validOutputs:it(g,"int32")}}const oP=rP;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iP(n,e,t=!1,s=!1){const r=O(n,"images","resizeBilinear");A(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),A(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),A(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=r,i=!1;r.rank===3&&(i=!0,o=j(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:o},l={alignCorners:t,halfPixelCenters:s,size:e},u=W.runKernel(Mp,a,l);return i?j(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const ZC=B({resizeBilinear_:iP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aP(n,e,t=!1,s=!1){const r=O(n,"images","resizeNearestNeighbor");A(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),A(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),A(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),A(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=r,i=!1;r.rank===3&&(i=!0,o=j(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:o},l={alignCorners:t,halfPixelCenters:s,size:e},u=W.runKernel(zp,a,l);return i?j(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const JC=B({resizeNearestNeighbor_:aP});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lP(n,e="binary",t=!1,s=.5){const r=O(n,"image","threshold"),o=.2989,i=.587,a=.114,l=r.shape[0]*r.shape[1];let u=H(us([s]),255),c,h,d,p;if(A(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),A(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),A(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),A(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[c,h,d]=Rs(r,[1,1,1],-1);const y=H(c,o),b=H(h,i),w=H(d,a);p=Ne(Ne(y,b),w)}else p=n;if(e==="otsu"){const y=iC(Ue(nx(p),"int32"),wr([]),256);u=uP(y,l)}const f=t?ha(p,u):Bs(p,u);return Ue(H(f,255),"int32")}function uP(n,e){let t=us([-1]),s=us([0]),r=us([0]),o,i,a,l,u,c;for(let h=0;h<n.size-1;h++){o=Et(n,0,h+1),i=Et(n,h+1),u=nt(Qe(o),e),c=nt(Qe(i),e);const d=Qe(H(o,nl(0,o.size)));a=nt(d,Qe(o));const p=gl(i.shape,o.size),f=Ne(nl(0,i.size),p),g=H(i,f);l=nt(Qe(g),Qe(i));const y=Ke(a,l),b=Ke(a,l),w=H(u,c);r=H(H(w,y),b);const C=Bs(r,s);s=qn(C,r,s),t=qn(C,us([h]),t)}return t}const cP=B({threshold_:lP});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hP(n,e,t="nearest",s="constant",r=0,o){const i=O(n,"image","transform","float32"),a=O(e,"transforms","transform","float32");A(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),A(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),A(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);const l={image:i,transforms:a},u={interpolation:t,fillMode:s,fillValue:r,outputShape:o};return W.runKernel(Rb,l,u)}const dP=B({transform_:hP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pP(n,e,t){const s=O(n,"a","bandPart");A(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[o,i]=s.shape.slice(-2);let a,l;typeof e=="number"?(A(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),A(e<=o,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`),a=O(e<0?o:e,"numLower","bandPart")):(A(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=qn(fu(e,0),o,sa(e,o))),typeof t=="number"?(A(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),A(t<=i,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${i}).`),l=O(t<0?i:t,"numUpper","bandPart")):(A(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=qn(fu(t,0),i,sa(t,i)));const u=j(nl(0,o,1,"int32"),[-1,1]),c=nl(0,i,1,"int32"),h=Ke(u,c),d=Yr(ha(h,a),bi(h,Kt(l))),p=kn([o,i],s.dtype);return j(Ls(dr(j(s,[-1,o,i])).map(f=>qn(d,f,p))),r)}const fP=B({bandPart_:pP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mP(n){let e;if(Array.isArray(n)){e=!1,A(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let o=1;o<n.length;++o)A(n[o].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[o].shape[0]} vs. ${r})`)}else e=!0,n=Rs(n,n.shape[0],0).map(r=>pa(r,[0]));A(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let r=0;r<n.length;++r)t.push(W.tidy(()=>{let o=s[r];if(r>0)for(let i=0;i<r;++i){const a=H(Qe(H(t[i],o)),t[i]);o=Ke(o,a)}return nt(o,Rc(o,"euclidean"))}));return e?Ls(t,0):t}const gP=B({gramSchmidt_:mP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yP(n,e=!1){if(A(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return rv(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((l,u)=>l*u),s=dr(j(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],o=[];s.forEach(l=>{const[u,c]=rv(l,e);r.push(u),o.push(c)});const i=j(Ls(r,0),n.shape),a=j(Ls(o,0),n.shape);return[i,a]}}function rv(n,e=!1){return W.tidy(()=>{A(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let r=qb(t),o=mo(n);const i=tu([[1]],[1,1]);let a=mo(i);const l=t>=s?s:t;for(let u=0;u<l;++u){const c=o,h=a,d=r;[a,o,r]=W.tidy(()=>{const p=Et(o,[u,u],[t-u,1]),f=Rc(p),g=Et(o,[u,u],[1,1]),y=qn(Bs(g,0),tu([[-1]]),tu([[1]])),b=Ke(g,H(y,f)),w=nt(p,b);w.shape[0]===1?a=mo(i):a=bn([i,Et(w,[1,0],[w.shape[0]-1,w.shape[1]])],0);const C=Kt(nt(It(y,b),f)),v=Et(o,[u,0],[t-u,s]),I=H(C,a),E=_t(a);if(u===0)o=Ke(v,It(I,It(E,v)));else{const D=Ke(v,It(I,It(E,v)));o=bn([Et(o,[0,0],[u,s]),D],0)}const R=_t(I),L=Et(r,[0,u],[t,r.shape[1]-u]);if(u===0)r=Ke(L,It(It(L,a),R));else{const D=Ke(L,It(It(L,a),R));r=bn([Et(r,[0,0],[t,u]),D],1)}return[a,o,r]}),vt([c,h,d])}return!e&&t>s&&(r=Et(r,[0,0],[t,s]),o=Et(o,[0,0],[s,s])),[r,o]})}const bP=B({qr_:yP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var vs;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(vs||(vs={}));function xP(n,e,t=vs.SUM_BY_NONZERO_WEIGHTS){const s=O(n,"losses","computeWeightedLoss");let r=null;e!=null&&(r=O(e,"weights","computeWeightedLoss"));const o=r==null?s:H(s,r);if(t===vs.NONE)return o;if(t===vs.SUM)return Qe(o);if(t===vs.MEAN){if(r==null)return ln(o);{const i=s.size/r.size,a=nt(Qe(o),Qe(r));return i>1?nt(a,it(i)):a}}if(t===vs.SUM_BY_NONZERO_WEIGHTS){if(r==null)return nt(Qe(o),it(s.size));{const i=H(r,As(s.shape)),a=Ue(Qe(tl(i,it(0))),"float32");return nt(Qe(o),a)}}throw Error(`Unknown reduction: ${t}`)}const To=B({computeWeightedLoss_:xP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wP(n,e,t,s=vs.SUM_BY_NONZERO_WEIGHTS){const r=O(n,"labels","absoluteDifference"),o=O(e,"predictions","absoluteDifference");let i=null;t!=null&&(i=O(t,"weights","absoluteDifference")),Ms(r.shape,o.shape,"Error in absoluteDifference: ");const a=vn(Ke(r,o));return To(a,i,s)}const vP=B({absoluteDifference_:wP});function kP(n,e,t,s,r=vs.SUM_BY_NONZERO_WEIGHTS){const o=O(n,"labels","cosineDistance"),i=O(e,"predictions","cosineDistance");let a=null;s!=null&&(a=O(s,"weights","cosineDistance")),Ms(o.shape,i.shape,"Error in cosineDistance: ");const l=it(1),u=Ke(l,Qe(H(o,i),t,!0));return To(u,a,r)}const CP=B({cosineDistance_:kP});function SP(n,e,t,s=vs.SUM_BY_NONZERO_WEIGHTS){let r=O(n,"labels","hingeLoss");const o=O(e,"predictions","hingeLoss");let i=null;t!=null&&(i=O(t,"weights","hingeLoss")),Ms(r.shape,o.shape,"Error in hingeLoss: ");const a=it(1);r=Ke(H(it(2),r),a);const l=to(Ke(a,H(r,o)));return To(l,i,s)}const IP=B({hingeLoss_:SP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $P(n,e,t,s=1,r=vs.SUM_BY_NONZERO_WEIGHTS){const o=O(n,"labels","huberLoss"),i=O(e,"predictions","huberLoss");let a=null;t!=null&&(a=O(t,"weights","huberLoss")),Ms(o.shape,i.shape,"Error in huberLoss: ");const l=it(s),u=vn(Ke(i,o)),c=sa(u,l),h=Ke(u,c),d=Ne(H(it(.5),Wt(c)),H(l,h));return To(d,a,r)}const NP=B({huberLoss_:$P});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TP(n,e,t,s=1e-7,r=vs.SUM_BY_NONZERO_WEIGHTS){const o=O(n,"labels","logLoss"),i=O(e,"predictions","logLoss");let a=null;t!=null&&(a=O(t,"weights","logLoss")),Ms(o.shape,i.shape,"Error in logLoss: ");const l=it(1),u=it(s),c=Kt(H(o,Ks(Ne(i,u)))),h=H(Ke(l,o),Ks(Ne(Ke(l,i),u))),d=Ke(c,h);return To(d,a,r)}const EP=B({logLoss_:TP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _P(n,e,t,s=vs.SUM_BY_NONZERO_WEIGHTS){const r=O(n,"labels","meanSquaredError"),o=O(e,"predictions","meanSquaredError");let i=null;t!=null&&(i=O(t,"weights","meanSquaredError")),Ms(r.shape,o.shape,"Error in meanSquaredError: ");const a=cx(r,o);return To(a,i,s)}const AP=B({meanSquaredError_:_P});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RP(n,e){const t=O(n,"labels","sigmoidCrossEntropyWithLogits"),s=O(e,"logits","sigmoidCrossEntropyWithLogits");Ms(t.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=to(s),o=H(s,t),i=sf(Fs(Kt(vn(s))));return Ne(Ke(r,o),i)}function DP(n,e,t,s=0,r=vs.SUM_BY_NONZERO_WEIGHTS){let o=O(n,"multiClassLabels","sigmoidCrossEntropy");const i=O(e,"logits","sigmoidCrossEntropy");let a=null;if(t!=null&&(a=O(t,"weights","sigmoidCrossEntropy")),Ms(o.shape,i.shape,"Error in sigmoidCrossEntropy: "),s>0){const u=it(s),c=it(1),h=it(.5);o=Ne(H(o,Ke(c,u)),H(h,u))}const l=RP(o,i);return To(l,a,r)}const OP=B({sigmoidCrossEntropy_:DP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FP(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return xo((r,o,i)=>{const l=rf(o,[t],!0),u=Ke(Ue(o,"float32"),l);i([r,u]);const c=Kt(H(u,r));return{value:Qe(c,[t]),gradFunc:(p,f)=>{const[g,y]=f,b=dn(p.shape,[t]);return[H(j(p,b),Ke(Ue(g,"float32"),Fs(y))),H(j(p,b),Ke(Fs(y),Ue(g,"float32")))]}}})(n,e)}function LP(n,e,t,s=0,r=vs.SUM_BY_NONZERO_WEIGHTS){let o=O(n,"onehotLabels","softmaxCrossEntropy");const i=O(e,"logits","softmaxCrossEntropy");let a=null;if(t!=null&&(a=O(t,"weights","softmaxCrossEntropy")),Ms(o.shape,i.shape,"Error in softmaxCrossEntropy: "),s>0){const u=it(s),c=it(1),h=it(o.shape[1]);o=Ne(H(o,Ke(c,u)),nt(u,h))}const l=FP(o,i);return To(l,a,r)}const PP=B({softmaxCrossEntropy_:LP});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zP(n,e,t,s){const r=O(n,"indices","sparseFillEmptyRows","int32"),o=O(e,"values","sparseFillEmptyRows"),i=O(t,"denseShape","sparseFillEmptyRows","int32"),a=O(s,"defaultValue","sparseFillEmptyRows",o.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(o.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l={indices:r,values:o,denseShape:i,defaultValue:a},u=W.runKernel(vb,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}const MP=B({sparseFillEmptyRows_:zP});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BP(n,e,t){const s=O(n,"inputIndices","sparseReshape","int32"),r=O(e,"inputShape","sparseReshape","int32"),o=O(t,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(o.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const i={inputIndices:s,inputShape:r,newShape:o},a=W.runKernel(kb,i);return{outputIndices:a[0],outputShape:a[1]}}const VP=B({sparseReshape_:BP});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WP(n,e,t){const s=O(n,"data","sparseSegmentMean"),r=O(e,"indices","sparseSegmentMean","int32"),o=O(t,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`);const i={data:s,indices:r,segmentIds:o};return W.runKernel(Cb,i)}const UP=B({sparseSegmentMean_:WP});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GP(n,e,t){const s=O(n,"data","sparseSegmentSum"),r=O(e,"indices","sparseSegmentSum","int32"),o=O(t,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`);const i={data:s,indices:r,segmentIds:o};return W.runKernel(Sb,i)}const HP=B({sparseSegmentSum_:GP});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jP(n,e,t,s,r,o,i,a){const l=O(n,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=O(e,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:t,nGramWidths:s,leftPad:r,rightPad:o,padWidth:i,preserveShortSequences:a},h={data:l,dataSplits:u},d=W.runKernel(Tb,h,c);return{nGrams:d[0],nGramsSplits:d[1]}}const KP=B({stringNGrams_:jP});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qP(n,e,t=!0){const s=O(n,"input","stringSplit","string"),r=O(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const o={skipEmpty:t},i={input:s,delimiter:r},a=W.runKernel(Eb,i,o);return{indices:a[0],values:a[1],shape:a[2]}}const XP=B({stringSplit_:qP});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YP(n,e){const t=O(n,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:t};return W.runKernel(_b,r,s)}const ZP=B({stringToHashBucketFast_:YP});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JP(n,e,t,s=!0){const r=O(n,"input","staticRegexReplace","string"),o={pattern:e,rewrite:t,replaceGlobal:s};return W.runKernel(Kp,{x:r},o)}const QP=B({staticRegexReplace_:JP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e3={fft:mf,ifft:yu,rfft:gf,irfft:ux},t3={hammingWindow:NL,hannWindow:XC,frame:YC,stft:AL},Br={flipLeftRight:FL,grayscaleToRGB:PL,resizeNearestNeighbor:JC,resizeBilinear:ZC,rgbToGrayscale:ML,rotateWithOffset:VL,cropAndResize:DL,nonMaxSuppression:UL,nonMaxSuppressionAsync:ZL,nonMaxSuppressionWithScore:QL,nonMaxSuppressionWithScoreAsync:tP,nonMaxSuppressionPadded:sP,nonMaxSuppressionPaddedAsync:oP,threshold:cP,transform:dP},QC={bandPart:fP,gramSchmidt:gP,qr:bP},n3={absoluteDifference:vP,computeWeightedLoss:To,cosineDistance:CP,hingeLoss:IP,huberLoss:NP,logLoss:EP,meanSquaredError:AP,sigmoidCrossEntropy:OP,softmaxCrossEntropy:PP},s3={sparseFillEmptyRows:MP,sparseReshape:VP,sparseSegmentMean:UP,sparseSegmentSum:HP},r3={stringNGrams:KP,stringSplit:XP,stringToHashBucketFast:ZP,staticRegexReplace:QP};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o3=new Map,i3=new Map;class wl{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class nr{constructor(){this.classNameMap={}}static getMap(){return nr.instance==null&&(nr.instance=new nr),nr.instance}static register(e){nr.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Te(n,e,t){A(n.className!=null,()=>"Class being registered does not have the static className property defined."),A(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),A(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const s=t,r=e+">"+s;return nr.register(n),o3.set(r,n),i3.set(n,r),n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wi extends wl{minimize(e,t=!1,s){const{value:r,grads:o}=this.computeGradients(e,s);if(s!=null){const i=s.map(a=>({name:a.name,tensor:o[a.name]}));this.applyGradients(i)}else this.applyGradients(o);return vt(o),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return _D(e,t)}dispose(){this.iterations_!=null&&vt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:it(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(wi,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eS extends wi{static get className(){return"Adadelta"}constructor(e,t,s=null){super(),this.learningRate=e,this.rho=t,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=W.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=W.registeredVariables[s],i=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:oe(()=>At(o).variable(i))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:oe(()=>At(o).variable(i))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const l=this.accumulatedGrads[r].variable,u=this.accumulatedUpdates[r].variable;oe(()=>{const c=Ne(H(l,this.rho),H(Wt(a),1-this.rho)),h=H(nt(Vn(Ne(u,this.epsilon)),Vn(Ne(l,this.epsilon))),a),d=Ne(H(u,this.rho),H(Wt(h),1-this.rho));l.assign(c),u.assign(d);const p=Ne(H(h,-this.learningRate),o);o.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(vt(this.accumulatedGrads.map(e=>e.variable)),vt(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tS extends wi{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=W.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:oe(()=>gl(o.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const a=this.accumulatedGrads[r].variable;oe(()=>{const l=Ne(a,Wt(i));a.assign(l);const u=Ne(H(nt(i,Vn(Ne(l,W.backend.epsilon()))),-this.learningRate),o);o.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&vt(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nS extends wi{static get className(){return"Adam"}constructor(e,t,s,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],oe(()=>{this.accBeta1=it(t).variable(),this.accBeta2=it(s).variable()}),r==null&&(this.epsilon=W.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);oe(()=>{const s=Ke(1,this.accBeta1),r=Ke(1,this.accBeta2);t.forEach((o,i)=>{const a=W.registeredVariables[o],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:oe(()=>At(a).variable(l))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${o}/v`,variable:oe(()=>At(a).variable(l))});const u=Array.isArray(e)?e[i].tensor:e[o];if(u==null)return;const c=this.accumulatedFirstMoment[i].variable,h=this.accumulatedSecondMoment[i].variable,d=Ne(H(c,this.beta1),H(u,1-this.beta1)),p=Ne(H(h,this.beta2),H(Wt(u),1-this.beta2)),f=nt(d,s),g=nt(p,r);c.assign(d),h.assign(p);const y=Ne(H(nt(f,Ne(Vn(g),this.epsilon)),-this.learningRate),a);a.assign(y)}),this.accBeta1.assign(H(this.accBeta1,this.beta1)),this.accBeta2.assign(H(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&vt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&vt(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),oe(()=>{this.accBeta1.assign(bo(this.beta1,this.iterations_+1)),this.accBeta2.assign(bo(this.beta2,this.iterations_+1))});const t=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sS extends wi{static get className(){return"Adamax"}constructor(e,t,s,r=null,o=0){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],oe(()=>{this.iteration=it(0).variable(),this.accBeta1=it(t).variable()}),r==null&&(this.epsilon=W.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);oe(()=>{const s=Ke(1,this.accBeta1),r=nt(-this.learningRate,Ne(H(this.iteration,this.decay),1));t.forEach((o,i)=>{const a=W.registeredVariables[o],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:At(a).variable(l)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${o}/v`,variable:At(a).variable(l)});const u=Array.isArray(e)?e[i].tensor:e[o];if(u==null)return;const c=this.accumulatedFirstMoment[i].variable,h=this.accumulatedWeightedInfNorm[i].variable,d=Ne(H(c,this.beta1),H(u,1-this.beta1)),p=H(h,this.beta2),f=vn(u),g=No(p,f);c.assign(d),h.assign(g);const y=Ne(H(nt(r,s),nt(d,Ne(g,this.epsilon))),a);a.assign(y)}),this.iteration.assign(Ne(this.iteration,1)),this.accBeta1.assign(H(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&vt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&vt(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vx extends wi{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const i=W.registeredVariables[s];oe(()=>{const a=Ne(H(this.c,o),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Rn(it(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rS extends vx{static get className(){return"Momentum"}constructor(e,t,s=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=it(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=W.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:oe(()=>At(o).variable(!1))});const i=this.accumulations[r].variable,a=Array.isArray(e)?e[r].tensor:e[s];a!=null&&oe(()=>{let l;const u=Ne(H(this.m,i),a);this.useNesterov?l=Ne(H(this.c,Ne(a,H(u,this.m))),o):l=Ne(H(this.c,u),o),i.assign(u),o.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&vt(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oS extends wi{static get className(){return"RMSProp"}constructor(e,t=.9,s=0,r=null,o=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,r==null&&(this.epsilon=W.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=W.registeredVariables[s],i=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:oe(()=>At(o).variable(i))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:oe(()=>At(o).variable(i))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:oe(()=>At(o).variable(i))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const l=this.accumulatedMeanSquares[r].variable,u=this.accumulatedMoments[r].variable;oe(()=>{const c=Ne(H(l,this.decay),H(Wt(a),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[r].variable,d=Ne(H(h,this.decay),H(a,1-this.decay)),p=nt(H(a,this.learningRate),Vn(Ke(c,Ne(Wt(d),this.epsilon)))),f=Ne(H(u,this.momentum),p);l.assign(c),h.assign(d),u.assign(f);const g=Ke(o,f);o.assign(g)}else{const h=Ne(H(l,this.decay),H(Wt(a),1-this.decay)),d=Ne(H(u,this.momentum),nt(H(a,this.learningRate),Vn(Ne(h,this.epsilon))));l.assign(h),u.assign(d);const p=Ke(o,d);o.assign(p)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&vt(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&vt(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&vt(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a3=[eS,tS,nS,sS,rS,oS,vx];function l3(){for(const n of a3)Te(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u3="model",c3=".json",h3=".weights.bin";function ov(n){return new Promise(e=>setTimeout(e)).then(n)}class ra{constructor(e){if(!ue().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(ra.URL_SCHEME)&&(e=e.slice(ra.URL_SCHEME.length)),(e==null||e.length===0)&&(e=u3),this.modelJsonFileName=e+c3,this.weightDataFileName=e+h3}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Tr.join(e.weightData),s=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],o=Pk(e,r),i=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=i,await ov(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=s,await ov(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Nc(e)}}}}ra.URL_SCHEME="downloads://";class d3{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const s=new FileReader;s.onload=r=>{const o=JSON.parse(r.target.result),i=o.modelTopology;if(i==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(o.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:i});return}const l=Pb(o,u=>this.loadWeights(u));e(l)},s.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const t=[],s=[];for(const i of e)t.push(...i.weights),s.push(...i.paths);const r=this.checkManifestAndWeightFiles(e),o=s.map(i=>this.loadWeightsFile(i,r[i]));return Promise.all(o).then(i=>[t,i])}loadWeightsFile(e,t){return new Promise((s,r)=>{const o=new FileReader;o.onload=i=>{const a=i.target.result;s(a)},o.onerror=i=>r(`Failed to weights data from file of path '${e}'.`),o.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],s=this.weightsFiles.map(o=>qw(o.name)),r={};for(const o of e)o.paths.forEach(i=>{const a=qw(i);if(t.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),s.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);r[i]=this.weightsFiles[s.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const p3=n=>ue().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ra.URL_SCHEME)?f3(n.slice(ra.URL_SCHEME.length)):null;nn.registerSaveRouter(p3);function f3(n="model"){return new ra(n)}function m3(n){return new d3(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iv(n,e,t,s){i(n),t=t??0,s=s??1,a(t,s);let r=0;const o=l=>(l.then(u=>{const c=t+ ++r/n.length*(s-t);return e(c),u}),l);function i(l){A(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,u){A(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),A(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),A(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(n.map(o))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function iS(n,e){e==null&&(e={});const t=e.fetchFunc==null?ue().platform.fetch:e.fetchFunc,s=n.map(h=>t(h,e.requestInit,{isBinary:!0})),a=(e.onProgress==null?await Promise.all(s):await iv(s,e.onProgress,0,.5)).map(h=>h.arrayBuffer());return e.onProgress==null?await Promise.all(a):await iv(a,e.onProgress,.5,1)}function g3(n,e){var t;const s=e.fetchFunc==null?ue().platform.fetch:e.fetchFunc;let r=0,o;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async i=>{for(var a;r<n.length;){o||(o=(await s(n[r],e.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:u}=await o.read();if(l){r++,o=void 0,(a=e.onProgress)===null||a===void 0||a.call(e,r/n.length);continue}i.enqueue(u);return}i.close()}})}async function y3(n,e="",t,s){return aS(i=>iS(i,{requestInit:s}))(n,e,t)}function aS(n){return async(e,t="",s)=>{const r=e.map(()=>!1),o={},i=s!=null?s.map(()=>!1):[],a=[];if(e.forEach((p,f)=>{let g=0;p.weights.forEach(y=>{const b="quantization"in y?y.quantization.dtype:y.dtype,w=Ji[b]*pe(y.shape),C=()=>{r[f]=!0,o[f]==null&&(o[f]=[]),o[f].push({manifestEntry:y,groupOffset:g,sizeBytes:w})};s!=null?s.forEach((v,I)=>{v===y.name&&(C(),i[I]=!0)}):C(),a.push(y.name),g+=w})}),!i.every(p=>p)){const p=s.filter((f,g)=>!i[g]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const l=r.reduce((p,f,g)=>(f&&p.push(g),p),[]),u=[];l.forEach(p=>{e[p].paths.forEach(f=>{const g=t+(t.endsWith("/")?"":"/")+f;u.push(g)})});const c=await n(u),h={};let d=0;return l.forEach(p=>{const f=e[p].paths.length,g=new Tr(c.slice(d,d+f));o[p].forEach(b=>{const w=g.slice(b.groupOffset,b.groupOffset+b.sizeBytes),C=Dk(w,[b.manifestEntry]);for(const v in C)h[v]=C[v]}),d+=f}),h}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b3="application/octet-stream",x3="application/json";class kx{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(A(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=ue().platform.fetch,A(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&A(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=Pk(e,s);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:x3}),"model.json"),e.weightData!=null){const i=Tr.join(e.weightData);t.body.append("model.weights.bin",new Blob([i],{type:b3}),"model.weights.bin")}const o=await this.fetch(this.path,t);if(o.ok)return{modelArtifactsInfo:Nc(e),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}const s=t.modelTopology,r=t.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return Pb(e,t=>this.loadWeights(t))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),s=Tg(e.weightsManifest),r=()=>g3(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:s,getWeightStream:r})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=w3(t),o=this.weightPathPrefix||s,i=[],a=[];for(const l of e)for(const u of l.paths)this.weightUrlConverter!=null?a.push(this.weightUrlConverter(u)):i.push(o+u+r);return this.weightUrlConverter&&i.push(...await Promise.all(a)),i}async loadWeights(e){const t=await this.getWeightUrls(e),s=Tg(e),r=await iS(t,this.loadOptions);return[s,r]}}kx.URL_SCHEME_REGEX=/^https?:\/\//;function w3(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),s=n.substring(0,e),r=t>e?n.substring(t):"";return[s+"/",r]}function Fg(n){return n.match(kx.URL_SCHEME_REGEX)!=null}const lS=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(s=>Fg(s)):t=Fg(n),t)return Cx(n,e)}return null};nn.registerSaveRouter(lS);nn.registerLoadRouter(lS);function Cx(n,e){return new kx(n,e)}function v3(n,e){return Cx(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wm{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class uS{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class k3{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function C3(n,e,t,s){const r=arguments;return new k3(cS(...r))}function cS(n,e,t,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new Wm(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Wm({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Wm({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:s}))}function S3(n){return new uS(n)}function I3(n){return new uS(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hS=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Tr,browserFiles:m3,browserHTTPRequest:v3,concatenateArrayBuffers:Lk,copyModel:IA,decodeWeights:Dk,decodeWeightsStream:Fk,encodeWeights:Ng,fromMemory:C3,fromMemorySync:cS,getLoadHandlers:hA,getModelArtifactsForJSON:Pb,getModelArtifactsForJSONSync:zk,getModelArtifactsInfoForJSON:Nc,getSaveHandlers:Mk,getWeightSpecs:Tg,http:Cx,isHTTPScheme:Fg,listModels:CA,loadWeights:y3,moveModel:$A,registerLoadRouter:cA,registerSaveRouter:uA,removeModel:SA,weightsLoaderFactory:aS,withSaveHandler:S3,withSaveHandlerSync:I3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ri;function $3(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,s=!1,r=!1,o=!1,i=!1,a=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)o=!0;else if(n.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(vg(xg,W.backendName)!=null){const f={pixels:n},g={numChannels:e};return W.runKernel(xg,f,g)}const[u,c]=r?[n.videoWidth,n.videoHeight]:[n.width,n.height];let h;if(i)h=n.getContext("2d").getImageData(0,0,u,c).data;else if(s||t)h=n.data;else if(o||r||a){if(Ri==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Ri=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Ri=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Ri.canvas.width=u,Ri.canvas.height=c,Ri.drawImage(n,0,0,u,c),h=Ri.getImageData(0,0,u,c).data}let d;if(e===4)d=new Int32Array(h);else{const f=u*c;d=new Int32Array(f*e);for(let g=0;g<f;g++)for(let y=0;y<e;++y)d[g*e+y]=h[g*4+y]}return zC(d,[c,u,e],"int32")}const N3=B({fromPixels_:$3});function Sx(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(pe(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=e.shape,o=r[r.length-1];let i=1;for(let h=0;h<r.length-1;++h)i*=r[h];const a=n.shape,l=r.slice();l.pop();let u=1;for(let h=o;h<t;++h)u*=a[h],l.push(a[h]);const c=[...rt(n.shape).map(h=>h/u),1].slice(0,o);return[l,i,u,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lg=-2,T3=-1;function Ix(n,e,t){const s=n.shape.length;A(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),A(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)A(e[r]+t[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function E3(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function $x(n,e,t){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((e[r]-n[r])/t[r]);return s}function dS(n,e,t,s){const r=[...n];for(let o=r.length;o<s.length;o++)r.push(1);for(let o=0;o<t;o++)o===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function pS(n,e,t){return t<=n?t:t-(e-1)}function fS(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function _3(n,e,t,s,r,o,i,a,l){const u=n.length;let c=new Array(u),h=new Array(u),d=new Array(u);if(e.length&&t>0){const p=e[0],f=t+1;c=mS(i,p,f,s,n),h=gS(a,p,f,r,n),d=dS(o,p,f,n)}else for(let p=0;p<u;p++)c[p]=bS(i,s,o,n,p,l),h[p]=xS(a,r,o,n,p,l),d[p]=yS(o,p,l);return{begin:c,end:h,strides:d}}function mS(n,e,t,s,r){const o=[...r],i=fS(t,e);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=0;else{const l=pS(e,t,a);let u=s[l];n&1<<l&&(u=0),o[a]=u}return o}function gS(n,e,t,s,r){const o=[...r],i=fS(t,e);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=Number.MAX_SAFE_INTEGER;else{const l=pS(e,t,a);let u=s[l];n&1<<l&&(u=Number.MAX_SAFE_INTEGER),o[a]=u}for(let a=0;a<o.length;a++){const l=r[a];o[a]<0&&(o[a]+=l),o[a]=Xi(0,o[a],r[a])}return o}function yS(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function bS(n,e,t,s,r,o){let i=e[r];const a=t[r]||1;(n&1<<r||o&1<<r||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);const l=s[r];return i<0&&(i+=l),i=Xi(0,i,l-1),i}function xS(n,e,t,s,r,o){let i=e[r];const a=t[r]||1;(n&1<<r||o&1<<r||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);const l=s[r];return i<0&&(i+=l),a>0?i=Xi(0,i,l):i=Xi(-1,i,l-1),i}function Nx(n,e,t){let s=t.length;for(let r=0;r<t.length;r++)if(t[r]>1){s=r;break}for(let r=s+1;r<t.length;r++)if(e[r]>0||t[r]!==n[r])return!1;return!0}function Tx(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function vf(n,e,t){let s;const r=n.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(i=>{A(i!==-1,()=>"slice() does not support negative begin indexing.")});let o;return t==null?o=new Array(r).fill(-1):typeof t=="number"?o=[t,...new Array(r-1).fill(-1)]:t.length<r?o=t.concat(new Array(r-t.length).fill(-1)):o=t,o=o.map((i,a)=>i>=0?i:(A(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),n.shape[a]-s[a])),[s,o]}function Ex(n,e,t,s,r,o,i,a,l){let u;if(s==null?(u=new Array(e.length),u.fill(1)):u=s,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:u.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:u.slice(),beginMask:r,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};for(let C=0;C<h.dims;C++)c&&(1<<C&a)!==0&&h.numAddAxisAfterEllipsis++,1<<C&i&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};A3(h,d);let p=!0,f=!0,g=!0;const y=[],b=[];for(let C=0;C<n.length;++C){if(d.strides[C]===0)throw Error(`strides[${C}] must be non-zero`);const v=!!(d.shrinkAxisMask&1<<C),I=n[C];if(I===-1){y.push(v?1:-1);continue}const E=[d.beginMask&1<<C,d.endMask&1<<C],R=[d.strides[C]>0?0:-1,d.strides[C]>0?I:I-1];if(v&&d.strides[C]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&d.strides[C]===1;const L=!!(d.beginMask&1<<C&&d.endMask&1<<C);if(d.beginValid&&d.endValid){if(v){const V=d.begin[C]<0?I+d.begin[C]:d.begin[C];if(d.begin[C]=V,d.end[C]=d.begin[C]+1,V<0||V>=I)throw Error(`slice index ${d.begin[C]} of dimension ${C} out of bounds.`)}else d.begin[C]=av(d.begin[C],0,d.strides[C],I,E,R),d.end[C]=av(d.end[C],1,d.strides[C],I,E,R);const T=d.strides[C]===1&&d.begin[C]===0&&d.end[C]===I;p=p&&T,f=f&&(C===0&&d.strides[C]===1||T)}else p=p&&d.strides[C]===1&&L,f=f&&(C===0&&d.strides[C]===1||L);let D,F=!1;if(d.beginValid&&d.endValid?(D=d.end[C]-d.begin[C],F=!0):v?(D=1,F=!0):L&&I>=0&&(d.strides[C]<0?D=-I:D=I,F=!0),F){let T;D===0||D<0!=d.strides[C]<0?T=0:T=Math.trunc(D/d.strides[C])+(D%d.strides[C]!==0?1:0),y.push(T)}else y.push(-1)}for(let C=0;C<d.finalShapeGatherIndices.length;++C){const v=d.finalShapeGatherIndices[C];v>=0?b.push(y[v]):v===Lg&&b.push(1)}return{finalShapeSparse:b.filter((C,v)=>d.finalShapeGatherIndices[v]!==Lg),finalShape:b,isIdentity:p,sliceDim0:f,isSimpleSlice:g,begin:d.begin,end:d.end,strides:d.strides}}function A3(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<r;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(Lg),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(T3),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function av(n,e,t,s,r,o){if(r[e])return t>0?o[e]:o[e+1&1];{const i=n<0?s+n:n;return i<o[0]?o[0]:i>o[1]?o[1]:i}}const R3=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:Ix,computeFlatOffset:Tx,computeOutShape:$x,getNormalizedAxes:_3,isSliceContinous:Nx,maskToAxes:E3,parseSliceParams:vf,sliceInfo:Ex,startForAxis:bS,startIndicesWithElidedDims:mS,stopForAxis:xS,stopIndicesWithElidedDims:gS,stridesForAxis:yS,stridesWithElidedDims:dS},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class D3{static sgd(e){return new vx(e)}static momentum(e,t,s=!1){return new rS(e,t,s)}static rmsprop(e,t=.9,s=0,r=null,o=!1){return new oS(e,t,s,r,o)}static adam(e=.001,t=.9,s=.999,r=null){return new nS(e,t,s,r)}static adadelta(e=.001,t=.95,s=null){return new eS(e,t,s)}static adamax(e=.002,t=.9,s=.999,r=null,o=0){return new sS(e,t,s,r,o)}static adagrad(e,t=.1){return new tS(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ta=D3;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O3=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function wS(){return new Promise(n=>O3(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _x(n,e){const t=n[0].length;n.forEach((r,o)=>{A(r.length===t,()=>`Error in concat${t}D: rank of tensors[${o}] must be the same as the rank of the rest (${t})`)}),A(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((r,o)=>{for(let i=0;i<t;i++)A(i===e||r[i]===s[i],()=>`Error in concat${t}D: Shape of tensors[${o}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${o}.`)})}function Gr(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var xr;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(xr||(xr={}));function vS(n,e,t){let s=new Array;if(t==null&&e==null)return s;if(e==null)for(;s.length<n+t.length;)s.push(-1);else s=e.slice();if(t==null)return s;if(n+t.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${s.length}`);for(let r=1;r<t.length;++r){const o=t[r],i=s[s.length-t.length+r],a=s[i];if(o>=0)if(a>=0){if(a!==o)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+n}] = ${o} but shape[${r+n}] = ${a}`)}else s[i]=o}return s}function kS(n){const e={FIRST_DIM_SIZE:xr.FIRST_DIM_SIZE,VALUE_ROWIDS:xr.VALUE_ROWIDS,ROW_LENGTHS:xr.ROW_LENGTHS,ROW_SPLITS:xr.ROW_SPLITS,ROW_LIMITS:xr.ROW_LIMITS,ROW_STARTS:xr.ROW_STARTS},t=[];for(const s of n)if(s in e)t.push(e[s]);else break;return t}function CS(n){return n.length===0?0:n[0]===xr.FIRST_DIM_SIZE?n.length-1:n.length}function SS(n,e){if(n==null||e==null)return;const t=n.length,s=e.length;if(t>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(t,s-1);++r){const o=n[r],i=e[r+1];if(o>=0&&i>=0&&o!==1&&o!==i)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-n.length}] = ${o} but ragged tensor input.flatValues.shape[${r-n.length}] = ${i}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ax=30;function kf(n){return n<=Ax?n:gg(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rx(n,e,t){const s=t*(typeof n=="number"?n:n[0]),r=e*(typeof n=="number"?n:n[1]);return[s,r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fc(n,e,t,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(n[0]/t),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const o=e.length;for(let i=0;i<o;++i)r=r.concat([n[i+1]/e[i],e[i]]);r=r.concat(n.slice(o+1))}return r}function Lc(n,e,t=!0){const s=[];if(t){s.push(e);for(let r=e+1;r<n;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],o=[];for(let i=1;i<n;++i)i>=e*2+1||i%2===1?o.push(i):r.push(i);s.push(...r),s.push(0),s.push(...o)}return s}function Pc(n,e,t,s=!0){const r=[];s?r.push(n[0]/t):r.push(n[0]*t);for(let o=1;o<n.length;++o)o<=e.length?s?r.push(e[o-1]*n[o]):r.push(n[o]/e[o-1]):r.push(n[o]);return r}function Dx(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function Ox(n,e,t){const s=n.slice(0,1);for(let r=0;r<t;++r)s.push(n[r+1]-e[r][0]-e[r][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cf=1.7580993408473768,Sf=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fx=.3275911,Lx=.254829592,Px=-.284496736,zx=1.421413741,Mx=-1.453152027,Bx=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wo(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function IS(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function $S(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function NS(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function Vx(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function TS(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function ES(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const o=(e?2:-2)*Math.PI*(r/n);t[r]=Math.cos(o),s[r]=Math.sin(o)}return{real:t,imag:s}}function _S(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),r=Math.cos(s),o=Math.sin(s);return{real:r,imag:o}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Um="->",F3=/->/g,lv=",",uv="...";function Wx(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(F3,"").length)/Um.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${Um}").`);const[s,r]=n.split(Um);A(s.indexOf(uv)===-1,()=>`The ellipsis notation ("${uv}") is not supported yet.`);const o=s.split(lv),i=o.length;if(e!==i)throw new Error(`Expected ${i} input tensors, received ${e}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let d=0;d<r.length;++d){const p=r[d];if(!o.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);a.indexOf(p)===-1&&a.push(p)}for(let d=0;d<s.length;++d){const p=s[d];a.indexOf(p)===-1&&p!==lv&&a.push(p)}const l=new Array(o.length);for(let d=0;d<i;++d){if(new Set(o[d].split("")).size!==o[d].length)throw new Error(`Found duplicate axes in input component ${o[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let p=0;p<o[d].length;++p)l[d].push(a.indexOf(o[d][p]))}const u=a.length,c=r.length,h=[];for(let d=c;d<u;++d)h.push(d);return{allDims:a,summedDims:h,idDims:l}}function Ux(n,e){let t=new Array(n);t.fill(-1);for(let r=0;r<e.length;++r)t[e[r]]=r;const s=[];for(let r=0;r<n;++r)t[r]===-1&&s.push(r);return t=t.filter(r=>r!==-1),{permutationIndices:t,expandDims:s}}function Gx(n,e,t){const s=new Array(n);for(let r=0;r<t.length;++r){const o=t[r].shape;for(let i=0;i<e[r].length;++i)s[e[r][i]]===void 0?s[e[r][i]]=o[i]:A(s[e[r][i]]===o[i],()=>`Expected dimension ${s[e[r][i]]} at axis ${i} of input shaped ${JSON.stringify(o)}, but got dimension ${o[i]}`)}}function Hx(n,e){const t=n,s=[];let r=0;n.length===0&&t.push(-1),r=n.length+1;for(let i=0;i<r;++i)s.push([]);const o=[];for(let i=0;i<t.length;++i){const a=t[i],l=L3(e,a);for(const u of l)o.indexOf(u)===-1&&(s[i].push(u),o.push(u))}return{path:t,steps:s}}function jx(n){return n.every((e,t)=>e===t)}function L3(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function Kx(n,e,t=0){let s=[];if(typeof e=="number")A(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const r=e.reduce((i,a)=>(a===-1&&(i+=1),i),0);A(r<=1,()=>"There should be only one negative value in split array.");const o=e.indexOf(-1);if(o!==-1){const i=e.reduce((a,l)=>l>0?a+l:a);e[o]=n.shape[t]-i}A(n.shape[t]===e.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AS(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function RS(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function DS(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OS(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function FS(n,e){return`size ${n} must be non-negative, not ${e}`}function LS(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function PS(n,e){const t=pe(n),s=pe(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function zS(n,e){const t=pe(n),s=pe(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pg(){return"segment ids must be >= 0"}function MS(){return"segment ids are not increasing"}function BS(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function VS(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WS(n,e){let t=!1,s;for(n<=Ax?(s=n,t=!0):s=gg(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=gg(n,s+1);return s}function US(n,e,t){const s=[],r=n.length;for(let o=0;o<r;o++)o!==e?s.push(n[o]):s.push(t);return s}function qx(n,e,t,s){const r=e.shape.length,o=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>o)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${o}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let h=0;h<s;++h)if(n.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${n.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const i=n.shape[t],a=[];let l=1,u=1,c=1;for(let h=0;h<s;++h)a.push(n.shape[h]),l*=n.shape[h];for(let h=s;h<t;h++)a.push(n.shape[h]),u*=n.shape[h];for(let h=s;h<r;h++)a.push(e.shape[h]);for(let h=t+1;h<o;h++)a.push(n.shape[h]),c*=n.shape[h];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:a}}const P3=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:qx,computeOutShape:US,segOpComputeOptimalWindowSize:WS},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vo(n){try{return n.map(e=>ei(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function GS(n){return n.map(e=>Yo(e))}const z3=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:Lx,ERF_A2:Px,ERF_A3:zx,ERF_A4:Mx,ERF_A5:Bx,ERF_P:Fx,PARALLELIZE_THRESHOLD:Ax,get RowPartitionType(){return xr},SELU_SCALE:Sf,SELU_SCALEALPHA:Cf,applyActivation:xf,assertAndGetBroadcastShape:pt,assertAxesAreInnerMostDims:Un,assertParamsConsistent:_x,assignToTypedArray:TS,axesAreInnerMostDims:Kb,calculateShapes:fa,checkEinsumDimSizes:Gx,checkPadOnDimRoundingMode:ds,combineLocations:xC,combineRaggedTensorToTensorShapes:vS,complexWithEvenIndex:$S,complexWithOddIndex:NS,computeConv2DInfo:On,computeConv3DInfo:gi,computeDefaultPad:Bb,computeDilation2DInfo:Tc,computeOptimalWindowSize:kf,computeOutAndReduceShapes:Fn,computeOutShape:Gr,computePool2DInfo:pr,computePool3DInfo:Io,convertConv2DDataFormat:$o,decodeEinsumEquation:Wx,eitherStridesOrDilationsAreOne:Wn,expandShapeToKeepDim:dn,exponent:_S,exponents:ES,fromStringArrayToUint8:GS,fromUint8ToStringArray:vo,getAxesPermutation:an,getBroadcastDims:el,getComplexWithIndex:Vx,getEinsumComputePath:Hx,getEinsumPermutation:Ux,getFusedBiasGradient:bf,getFusedDyActivation:yf,getImageCenter:Rx,getInnerMostAxes:pn,getPermuted:Lc,getRaggedRank:CS,getReductionAxes:Tn,getReshaped:Fc,getReshapedPermuted:Pc,getRowPartitionTypesHelper:kS,getSliceBeginCoords:Dx,getSliceSize:Ox,getSparseFillEmptyRowsIndicesDenseShapeMismatch:AS,getSparseFillEmptyRowsNegativeIndexErrorMessage:RS,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:DS,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:LS,getSparseReshapeInputOutputMismatchErrorMessage:zS,getSparseReshapeInputOutputMultipleErrorMessage:PS,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:OS,getSparseReshapeNegativeOutputDimErrorMessage:FS,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:VS,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:Pg,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:MS,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:BS,getUndoAxesPermutation:yi,isIdentityPermutation:jx,log:C_,mergeRealAndImagArrays:wo,prepareAndValidate:Sx,prepareSplitSize:Kx,segment_util:P3,shouldFuse:wf,slice_util:R3,splitRealAndImagArrays:IS,stridesOrDilationsArePositive:ta,tupleValuesAreOne:si,upcastType:Ds,validateDefaultValueShape:SS,validateInput:hx,validateUpdateShape:MC,warn:Us},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */l3();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HS={kernelName:qd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>H(n,bl(Ue(t,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M3={kernelName:Ru,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Wt(Ue(t,"float32")),r=Vn(Ke(it(1),s));return Kt(nt(n,r))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B3={kernelName:Du,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Vn(Ke(Wt(Ue(t,"float32")),1));return nt(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V3={kernelName:ml,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=pt(t.shape,s.shape);return{a:()=>{let a=n;const l=Tn(t.shape,r);return l.length>0&&(a=Qe(a,l)),j(a,t.shape)},b:()=>{let a=n;const l=Tn(s.shape,r);return l.length>0&&(a=Qe(a,l)),j(a,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W3={kernelName:Xd,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((s,r)=>{t[r]=()=>n.clone()}),t}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U3={kernelName:Yd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>At(t)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G3={kernelName:Zd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>At(t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H3={kernelName:Ou,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>nt(n,Vn(Ke(it(1),Wt(Ue(t,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j3={kernelName:Fu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Vn(Ne(it(1),Wt(Ue(t,"float32"))));return nt(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K3={kernelName:zu,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=pt(t.shape,s.shape);return{a:()=>{const a=Ne(Wt(t),Wt(s));let l=H(n,nt(s,a));const u=Tn(t.shape,r);return u.length>0&&(l=Qe(l,u)),j(l,t.shape)},b:()=>{const a=Ne(Wt(t),Wt(s));let l=Kt(H(n,nt(t,a)));const u=Tn(s.shape,r);return u.length>0&&(l=Qe(l,u)),j(l,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q3={kernelName:Lu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>nt(n,Ne(Wt(Ue(t,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X3={kernelName:Pu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>nt(n,Ke(it(1),Wt(Ue(t,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y3(n,e,t,s,r,o){const i=O(n,"dy","avgPool3dGrad"),a=O(e,"input","avgPool3dGrad");let l=i,u=a,c=!1;a.rank===4&&(c=!0,l=j(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=j(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),A(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),A(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),ds("avgPool3dGrad",r,o);const h={dy:l,input:u},d={filterSize:t,strides:s,pad:r,dimRoundingMode:o},p=W.runKernel(Oy,h,d);return c?j(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const Z3=B({avgPool3dGrad_:Y3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J3={kernelName:Qd,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:o,pad:i,dimRoundingMode:a}=t;return{x:()=>Z3(n,s,r,o,i,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q3(n,e,t,s,r){const o=O(n,"dy","avgPoolGrad"),i=O(e,"input","avgPoolGrad");A(i.rank===o.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${o.rank})`);let a=i,l=o,u=!1;i.rank===3&&(u=!0,a=j(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=j(o,[1,o.shape[0],o.shape[1],o.shape[2]])),A(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),A(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const c={dy:l,input:a},h={filterSize:t,strides:s,pad:r},d=W.runKernel(Dy,c,h);return u?j(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const ez=B({avgPoolGrad_:Q3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tz={kernelName:Jd,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:o,pad:i}=t;return{x:()=>ez(n,s,r,o,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nz={kernelName:ep,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[s,r]=e,{transposeA:o,transposeB:i}=t;return!o&&!i?{a:()=>It(n,r,!1,!0),b:()=>It(s,n,!0,!1)}:!o&&i?{a:()=>It(n,r,!1,!1),b:()=>It(n,s,!0,!1)}:o&&!i?{a:()=>It(r,n,!1,!0),b:()=>It(s,n,!1,!1)}:{a:()=>It(r,n,!0,!0),b:()=>It(n,s,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sz={kernelName:tp,gradFunc:(n,e,t)=>{const{blockShape:s,crops:r}=t;return{x:()=>uf(n,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rz={kernelName:w_,gradFunc:(n,e,t)=>{const s=t,r=s.inputShape,o=s.shape,i=Array.from(o);for(let l=r.length-1;l>=0;l--)if(r[l]===o[l])i[l]=1;else if(r[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${o}].`);const a=[];for(let l=0;l<i.length;l++)i[l]>1&&a.push(l);return{x:()=>Qe(n,a,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oz={kernelName:Mu,gradFunc:n=>({x:()=>n.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iz={kernelName:Bu,gradFunc:n=>({x:()=>At(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const az={kernelName:Vu,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{clipValueMin:r,clipValueMax:o}=t;return{x:()=>qn(Yr(bi(s,r),ha(s,o)),n,At(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lz={kernelName:sp,inputsToSave:["x"],gradFunc:HS.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uz={kernelName:rp,saveAllInputs:!0,gradFunc:(n,e,t)=>{const s=e.map(l=>l.shape),{axis:r}=t,o=kt(r,e[0].shape)[0],i=s.map(l=>l[o]);return Rs(n,i,o).map(l=>()=>l)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cz={kernelName:op,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{dilations:o,strides:i,pad:a,dataFormat:l}=t;return A(si(o),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`),{x:()=>Wb(s.shape,n,r,i,a,l),filter:()=>gx(s,n,r.shape,i,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hz={kernelName:ip,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{strides:o,pad:i,dataFormat:a,dimRoundingMode:l}=t;return{dy:()=>ri(n,r,o,i,a,1,l),filter:()=>gx(n,s,r.shape,o,i,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dz(n,e,t,s,r){let o=n;n.rank===4&&(o=j(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let i=e;i.rank===4&&(i=j(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),A(o.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${o.shape}.`),A(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),A(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),A(o.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${o.shape[4]}) must match input depth in filter (${t[3]}.`),A(i.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${t[4]}).`);const a={x:o,dy:i},l={strides:s,pad:r,filterShape:t};return W.runKernel(My,a,l)}const pz=B({conv3DBackpropFilter_:dz});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fz={kernelName:ap,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:o}=t;A(si(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[i,a]=e;return{x:()=>pC(i.shape,n,a,r,o),filter:()=>pz(i,n,a.shape,r,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mz={kernelName:Wu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>H(Kt(ix(Ue(t,"float32"))),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gz={kernelName:Uu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>H(ax(Ue(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yz={kernelName:lp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r,exclusive:o,reverse:i}=t;return{x:()=>{const a=an([r],s.rank);let l=Hb(n,r,o,!i);return a!=null&&(l=_t(l,a)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bz={kernelName:up,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:o,dimRoundingMode:i}=t,a=s??[1,1];A(si(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,u]=e;return A(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),A(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),A(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),A(Wn(r,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${a}'.`),ds("depthwiseConv2d",o,i),{x:()=>qC(l.shape,n,u,r,o,a,i),filter:()=>KC(l,n,u.shape,r,o,a,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xz={kernelName:cp,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,o={x:s,filter:r,dy:n},i={x:s,filter:r,dy:n};return{x:()=>W.runKernel(yg,o,t),filter:()=>W.runKernel(bg,i,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wz={kernelName:Hu,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,s={dy:n,y:t};return{x:()=>W.runKernel(Xy,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vz={kernelName:ju,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=H(Fs(Kt(Wt(t))),2/Math.sqrt(Math.PI));return{x:()=>H(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kz={kernelName:Ku,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>H(n,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cz={kernelName:dp,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>j(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sz={kernelName:qu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>H(n,Fs(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iz={kernelName:Xu,gradFunc:n=>({x:()=>At(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $z={kernelName:Yu,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=pt(t.shape,s.shape);return{a:()=>{const a=nt(n,Ue(s,"float32")),l=Tn(t.shape,r);return l.length>0?j(Qe(a,l),t.shape):a},b:()=>{let a=H(n,Ue(t,"float32"));const l=Tn(s.shape,r);l.length>0&&(a=j(Qe(a,l),s.shape));const u=Wt(s);return Kt(nt(a,Ue(u,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nz={kernelName:pp,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:s}=t,[r,o,i,a]=e,l=a??it(1),u=Tn(o.shape,r.shape),c=[];if(o.rank===1){for(let v=0;v<r.shape.length-1;++v)c.push(r.shape[v]);c.push(1)}const h=Ke(r,o),d=H(n,l),p=sx(Ne(i,it(s))),f=H(H(H(p,p),p),it(-.5));return{x:()=>o.rank===1?j(H(H(n,sr(j(p,[1,1,1,o.shape[0]]),c)),l),r.shape):j(H(H(n,p),l),r.shape),mean:()=>{let v=H(H(p,it(-1)),d);return o.rank===1&&(v=Qe(v,u)),j(v,o.shape)},variance:()=>{let v=H(H(f,h),d);return o.rank===1&&(v=Qe(v,u)),j(v,o.shape)},scale:()=>{const v=H(h,p);let I=H(n,v);return o.rank===1&&(I=Qe(I,u)),j(I,o.shape)},offset:()=>{let v=n;return o.rank===1&&(v=Qe(v,u)),j(v,o.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tz={kernelName:fp,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[s,r]=e,{axis:o,batchDims:i}=t,a=kt(o,s.shape)[0],l=(u,c,h)=>()=>{const d=u.shape,p=c.size,f=d.slice(0,a),g=f.length,y=d.slice(o,d.length).slice(1),b=y.length,w=cv(0,g),C=cv(g+1,g+1+b),v=hv([f,[p],y]),I=j(h,v),E=j(c,[p]),R=hv([[g],w,C]),L=_t(I,R);let D=px(L,E,u.shape[a]);const F=yi(R);return D=_t(D,F),D};if(i===1){const u=s.shape[0],c=s.split(u,0);return{x:()=>Ls(c.map((p,f)=>l(p,r.slice(f,1),n.slice(f,1))())).reshape(s.shape),indices:()=>r}}else return{x:l(s,r,n),indices:()=>r}}};function cv(n,e){const t=[];for(let s=n;s<e;++s)t.push(s);return t}function hv(n){const e=[];for(let t=0;t<n.length;++t)for(let s=0;s<n[t].length;++s)e.push(n[t][s]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ez={kernelName:Zu,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>At(t),b:()=>At(s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _z={kernelName:Ju,gradFunc:n=>({x:()=>Ue(n,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Az={kernelName:Qu,gradFunc:n=>({x:()=>At(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rz={kernelName:ec,gradFunc:n=>({x:()=>At(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dz={kernelName:tc,gradFunc:n=>({x:()=>At(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oz={kernelName:gp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{alpha:r}=t,o=Bs(s,0);return{x:()=>qn(o,n,H(n,r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fz={kernelName:sc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>nt(n,Ne(t,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lz={kernelName:nc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>nt(n,Ue(t,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pz={kernelName:k_,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;return{logits:()=>{const i=Fs(s);return Ke(n,H(Qe(n,r,!0),i))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zz(n,e,t,s=5,r=1,o=1,i=.5){const a={x:n,y:e,dy:t},l={depthRadius:s,bias:r,alpha:o,beta:i};return W.runKernel(sb,a,l)}const Mz=B({localResponseNormalizationBackprop_:zz});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bz={kernelName:kp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{depthRadius:o,bias:i,alpha:a,beta:l}=t;return{x:()=>Mz(s,r,n,o,i,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jS(n,e,t,s){return e.rank<t.rank&&(e=j(e,dn(e.shape,s))),n.rank<t.rank&&(n=j(n,dn(n.shape,s))),{x:()=>H(n,Ue(Sr(t,e),n.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dv={kernelName:Cp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{reductionIndices:r}=s,o=e[0],i=e[1],a=kt(r,o.shape),l=jS(n,i,o,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vz={kernelName:rc,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>H(n,Ue(bi(t,s),"float32")),b:()=>H(n,Ue(fu(t,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wz(n,e,t,s,r,o,i){const a=O(n,"dy","maxPool3dGrad"),l=O(e,"input","maxPool3dGrad"),u=O(t,"output","maxPool3dGrad");let c=a,h=l,d=u,p=!1;l.rank===4&&(p=!0,c=j(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),h=j(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=j(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),A(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),A(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),A(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),ds("maxPool3dGrad",o,i);const f={dy:c,input:h,output:d},g={filterSize:s,strides:r,pad:o,dimRoundingMode:i},y=W.runKernel(ob,f,g);return p?j(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}const Uz=B({maxPool3dGrad_:Wz});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gz={kernelName:Ip,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=t;return{x:()=>Uz(n,s,r,o,i,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hz(n,e,t,s,r,o,i){const a=O(n,"dy","maxPoolGrad"),l=O(e,"input","maxPoolGrad"),u=O(t,"output","maxPoolGrad");A(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),A(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),A(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),ds("maxPoolGrad",o,i);const c={dy:a,input:l,output:u},h={filterSize:s,strides:r,pad:o,dimRoundingMode:i};return W.runKernel(rb,c,h)}const jz=B({maxPoolGrad_:Hz});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kz={kernelName:Sp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:o,strides:i,pad:a}=t;return{x:()=>jz(n,s,r,o,i,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qz={kernelName:$p,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t,o=kt(r,s.shape),a=Fn(s.shape,o)[1],l=pe(a);return{x:()=>{const c=s.shape.slice();o.forEach(p=>{c[p]=1});const h=j(n,c);return nt(H(h,As(s.shape,"float32")),l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xz={kernelName:Np,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{axis:r}=s,[o,i]=e,a=kt(r,o.shape),l=jS(n,i,o,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yz={kernelName:oc,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>H(n,Ue(ha(t,s),"float32")),b:()=>H(n,Ue(Bs(t,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zz={kernelName:Tp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,o=r.map(i=>i[0]);return{x:()=>Et(n,o,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jz={kernelName:ic,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=pt(t.shape,s.shape);return{a:()=>{const a=Tn(t.shape,r);return a.length>0?j(Qe(n,a),t.shape):n},b:()=>{const a=H(n,Kt(Dc(nt(t,s)))),l=Tn(s.shape,r);return l.length>0?j(Qe(a,l),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qz={kernelName:ac,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=pt(t.shape,s.shape);return{a:()=>{const a=H(n,Ue(s,"float32")),l=Tn(t.shape,r);return l.length>0?j(Qe(a,l),t.shape):a},b:()=>{const a=H(n,Ue(t,"float32")),l=Tn(s.shape,r);return l.length>0?j(Qe(a,l),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eM={kernelName:Ep,gradFunc:n=>({x:()=>Kt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tM={kernelName:Rp,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>kn(t.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nM={kernelName:Ap,gradFunc:n=>({x:()=>At(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sM={kernelName:Dp,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:s}=t;return dr(n,s).map(o=>()=>o)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pv={kernelName:Op,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,o=r.map(i=>i[0]);return{x:()=>Et(n,o,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rM={kernelName:lc,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,s,r]=e,o=t,i=s,a=pt(o.shape,i.shape);return{a:()=>{const c=Ue(i,"float32");let h=H(n,H(c,bo(o,Ke(c,it(1)))));const d=Tn(o.shape,a);return d.length>0&&(h=Qe(h,d)),j(h,o.shape)},b:()=>{const c=Bs(o,0),h=qn(c,Ks(o),At(o));let d=H(n,H(r,h));const p=Tn(i.shape,a);return p.length>0&&(d=Qe(d,p)),j(d,i.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oM={kernelName:Fp,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,s]=e,r=Bs(t,0);return{x:()=>qn(r,n,H(n,s)),alpha:()=>{let o=qn(r,At(n),H(n,t));const i=Tn(s.shape,n.shape);return i.length>0&&(o=Qe(o,i)),j(o,s.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iM(n,e,t){const s=n.shape.slice();s[t]=1;const r=j(e,s),o=fd(n,t,!0,!1),i=fd(n,t,!0,!0),a=H(o,i);return H(r,a)}function aM(n,e,t){const s=n.shape.length,r=s-t.length,o=an(t,s);let i=n;o!=null&&(i=_t(n,o));const a=i.shape.slice(),u=a.splice(s-t.length,t.length).reduce((d,p)=>d*p,1);a.push(u);const c=i.reshape(a);let h=iM(c,e,r);if(h=h.reshape(i.shape),o!=null){const d=yi(o);h=_t(h,d)}return h}const lM={kernelName:Lp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;let o=[];return r==null?o=s.shape.map((i,a)=>a):typeof r=="number"?o=[r]:o=r,{x:()=>aM(s,n,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uM={kernelName:Gu,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=pt(t.shape,s.shape);return{a:()=>{const a=nt(n,Ue(s,"float32")),l=Tn(t.shape,r);return l.length>0?j(Qe(a,l),t.shape):a},b:()=>{let a=H(n,Ue(t,"float32"));const l=Tn(s.shape,r);l.length>0&&(a=j(Qe(a,l),s.shape));const u=Wt(s);return Kt(nt(a,Ue(u,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cM={kernelName:uc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>nt(n,Kt(Wt(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hM={kernelName:hc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=H(ha(t,6),bl(t));return{x:()=>H(n,Ue(s,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dM={kernelName:cc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>H(n,Ue(bl(t),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pM={kernelName:Pp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>j(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fM={kernelName:Mp,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>W.runKernel(yb,r,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mM={kernelName:zp,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>W.runKernel(gb,r,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gM={kernelName:Bp,gradFunc:(n,e,t)=>{const{dims:s}=t,r=kt(s,n.shape);return{x:()=>hr(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yM={kernelName:dc,gradFunc:n=>({x:()=>At(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bM={kernelName:pc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Kt(nt(n,H(bo(t,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xM={kernelName:Vp,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>Ue(At(t),"float32"),t:()=>H(n,Ue(t,n.dtype)),e:()=>H(n,Ue(of(t),n.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wM={kernelName:fc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Bs(t,it(0)),r=it(Cf),o=it(Sf),i=H(n,o),a=H(H(n,r),Fs(Ue(t,"float32")));return qn(s,i,a)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vM={kernelName:bc,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>H(n,H(t,Ke(it(1),t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kM={kernelName:yc,gradFunc:n=>({x:()=>At(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CM={kernelName:mc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>H(ef(Ue(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SM={kernelName:gc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>H(Gb(Ue(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IM={kernelName:Wp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{begin:r,size:o}=t,i=s.shape,[a,l]=vf(s,r,o),u=[];for(let c=0;c<n.rank;c++)u.push([a[c],i[c]-a[c]-l[c]]);return{x:()=>xi(n,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $M={kernelName:jp,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{dim:r}=t,o=!0,i=H(n,s);return{logits:()=>Ke(i,H(Qe(i,[r],o),s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NM={kernelName:xc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>H(n,Ur(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fv={kernelName:Gp,gradFunc:(n,e,t)=>{const{blockShape:s,paddings:r}=t;return{x:()=>Qp(n,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mv={kernelName:Hp,gradFunc:(n,e,t)=>{const{axis:s}=t;return{x:()=>bn(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TM={kernelName:wc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>nt(n,H(Vn(Ue(t,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EM={kernelName:$b,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>H(n,H(Ue(t,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _M={kernelName:vc,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=it(2);return{a:()=>H(n,H(r,Ke(t,s))),b:()=>H(n,H(r,Ke(s,t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AM={kernelName:$c,gradFunc:n=>({x:()=>At(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RM={kernelName:kc,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=pt(t.shape,s.shape);return{a:()=>{let a=n;const l=Tn(t.shape,r);return l.length>0&&(a=Qe(a,l)),j(a,t.shape)},b:()=>{let a=n;const l=Tn(s.shape,r);return l.length>0&&(a=Qe(a,l)),j(Kt(a),s.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DM={kernelName:Up,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,r=s.shape.slice(),{axis:o}=t;kt(o,s.shape).forEach(u=>{r[u]=1});const a=j(n,r),l=H(a,As(s.shape,"float32"));return{x:()=>l}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OM={kernelName:Cc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>nt(n,Wt(ef(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FM={kernelName:Sc,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>H(Ke(it(1),Wt(t)),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LM={kernelName:Ic,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{reps:r}=t;return{x:()=>{let i=At(s);if(s.rank===1)for(let a=0;a<r[0];++a)i=Ne(i,Et(n,[a*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)i=Ne(i,Et(n,[a*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)for(let u=0;u<r[2];++u)i=Ne(i,Et(n,[a*s.shape[0],l*s.shape[1],u*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)for(let u=0;u<r[2];++u)for(let c=0;c<r[3];++c)i=Ne(i,Et(n,[a*s.shape[0],l*s.shape[1],u*s.shape[2],c*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return i}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PM={kernelName:Ma,gradFunc:(n,e,t)=>{const s=t,{perm:r}=s,o=yi(r);return{x:()=>_t(n,o)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zM={kernelName:qp,gradFunc:(n,e,t)=>{const s=t,{axis:r}=s;return{value:()=>Ls(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MM={kernelName:Xp,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>BM(n,t)}}};function BM(n,e){const t=No(e,At(e)),s=Oc(n,t);let r=bi(e,it(0,"int32"));const o=s.rank-r.rank;for(let a=0;a<o;++a)r=os(r,a+1);r=Yr(r,As(s.shape,"bool"));const i=At(s);return qn(r,s,i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VM={kernelName:Yp,gradFunc:n=>({x:()=>At(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WM=[HS,M3,B3,V3,W3,U3,G3,H3,j3,K3,q3,X3,J3,tz,nz,sz,rz,oz,iz,az,lz,uz,hz,cz,fz,mz,gz,yz,bz,xz,uM,wz,vz,kz,Cz,Sz,$z,Iz,Nz,Tz,Ez,_z,Az,Rz,Dz,Oz,Fz,Lz,Pz,Bz,dv,dv,Vz,Gz,Kz,qz,Xz,Yz,Zz,Jz,Qz,eM,tM,nM,sM,pv,pv,rM,oM,lM,cM,hM,dM,pM,fM,mM,gM,yM,bM,xM,wM,vM,kM,CM,SM,IM,$M,NM,fv,fv,mv,mv,TM,_M,EM,AM,RM,DM,OM,FM,LM,PM,zM,MM,VM];for(const n of WM)S_(n);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.abs=function(){return this.throwIfDisposed(),vn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.acos=function(){return this.throwIfDisposed(),qk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.acosh=function(){return this.throwIfDisposed(),Xk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.add=function(n){return this.throwIfDisposed(),Ne(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.all=function(n,e){return this.throwIfDisposed(),Mb(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.any=function(n,e){return this.throwIfDisposed(),pd(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.argMax=function(n){return this.throwIfDisposed(),Qa(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.argMin=function(n){return this.throwIfDisposed(),Yk(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.asScalar=function(){return this.throwIfDisposed(),A(this.size===1,()=>"The array must have only 1 element."),j(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.asType=function(n){return this.throwIfDisposed(),Ue(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.as1D=function(){return this.throwIfDisposed(),j(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.as2D=function(n,e){return this.throwIfDisposed(),j(this,[n,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),j(this,[n,e,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.as4D=function(n,e,t,s){return this.throwIfDisposed(),j(this,[n,e,t,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.as5D=function(n,e,t,s,r){return this.throwIfDisposed(),j(this,[n,e,t,s,r])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.asin=function(){return this.throwIfDisposed(),Zk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.asinh=function(){return this.throwIfDisposed(),Jk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.atan=function(){return this.throwIfDisposed(),Qk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.atan2=function(n){return this.throwIfDisposed(),eC(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.atanh=function(){return this.throwIfDisposed(),tC(this)};ge().prototype.avgPool=function(n,e,t,s){return this.throwIfDisposed(),Jp(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),Qp(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.batchNorm=function(n,e,t,s,r){return this.throwIfDisposed(),Ec(this,n,e,t,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Wa(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.cast=function(n){return this.throwIfDisposed(),Ue(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.ceil=function(){return this.throwIfDisposed(),aC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),Os(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof sn&&(n=[n]),bn([this,...n],e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.conv1d=function(n,e,t,s,r,o){return this.throwIfDisposed(),Vb(this,n,e,t,s,r,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.conv2dTranspose=function(n,e,t,s,r){return this.throwIfDisposed(),Ub(this,n,e,t,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.conv2d=function(n,e,t,s,r,o){return this.throwIfDisposed(),ri(this,n,e,t,s,r,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.cos=function(){return this.throwIfDisposed(),ef(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.cosh=function(){return this.throwIfDisposed(),Gb(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.cumprod=function(n,e,t){return this.throwIfDisposed(),fd(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),Hb(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),mC(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.depthwiseConv2d=function(n,e,t,s,r,o){return this.throwIfDisposed(),_c(this,n,e,t,s,r,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.dilation2d=function(n,e,t,s,r){return this.throwIfDisposed(),gC(this,n,e,t,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.divNoNan=function(n){return this.throwIfDisposed(),yC(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.div=function(n){return this.throwIfDisposed(),nt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.dot=function(n){return this.throwIfDisposed(),bC(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.elu=function(){return this.throwIfDisposed(),Ac(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.equal=function(n){return this.throwIfDisposed(),Sr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.erf=function(){return this.throwIfDisposed(),jb(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.euclideanNorm=function(n,e){return this.throwIfDisposed(),vC(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.exp=function(){return this.throwIfDisposed(),Fs(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.expandDims=function(n){return this.throwIfDisposed(),os(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.expm1=function(){return this.throwIfDisposed(),kC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.fft=function(){return this.throwIfDisposed(),mf(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.flatten=function(){return this.throwIfDisposed(),j(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.floor=function(){return this.throwIfDisposed(),Dc(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.floorDiv=function(n){return this.throwIfDisposed(),zb(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.gather=function(n,e,t){return this.throwIfDisposed(),Oc(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.greaterEqual=function(n){return this.throwIfDisposed(),bi(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.greater=function(n){return this.throwIfDisposed(),Bs(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.ifft=function(){return this.throwIfDisposed(),yu(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.irfft=function(){return this.throwIfDisposed(),ux(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.isFinite=function(){return this.throwIfDisposed(),CC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.isInf=function(){return this.throwIfDisposed(),SC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.isNaN=function(){return this.throwIfDisposed(),IC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.leakyRelu=function(n){return this.throwIfDisposed(),nf(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.lessEqual=function(n){return this.throwIfDisposed(),ha(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.less=function(n){return this.throwIfDisposed(),fu(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.localResponseNormalization=function(n,e,t,s){return this.throwIfDisposed(),$C(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.logSigmoid=function(){return this.throwIfDisposed(),NC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.logSoftmax=function(n){return this.throwIfDisposed(),Xb(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),rf(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.log=function(){return this.throwIfDisposed(),Ks(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.log1p=function(){return this.throwIfDisposed(),sf(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.logicalAnd=function(n){return this.throwIfDisposed(),Yr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.logicalNot=function(){return this.throwIfDisposed(),of(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.logicalOr=function(n){return this.throwIfDisposed(),Yb(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.logicalXor=function(n){return this.throwIfDisposed(),TC(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),It(this,n,e,t)};ge().prototype.maxPool=function(n,e,t,s){return this.throwIfDisposed(),af(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.max=function(n,e){return this.throwIfDisposed(),ar(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.maximum=function(n){return this.throwIfDisposed(),No(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.mean=function(n,e){return this.throwIfDisposed(),ln(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.min=function(n,e){return this.throwIfDisposed(),pu(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.minimum=function(n){return this.throwIfDisposed(),sa(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),_C(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.mod=function(n){return this.throwIfDisposed(),AC(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.mul=function(n){return this.throwIfDisposed(),H(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.neg=function(){return this.throwIfDisposed(),Kt(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.norm=function(n,e,t){return this.throwIfDisposed(),Rc(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.notEqual=function(n){return this.throwIfDisposed(),tl(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),Jb(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.onesLike=function(){return this.throwIfDisposed(),qs(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.pad=function(n,e){return this.throwIfDisposed(),xi(this,n,e)};ge().prototype.pool=function(n,e,t,s,r,o){return this.throwIfDisposed(),RC(this,n,e,t,s,r,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.pow=function(n){return this.throwIfDisposed(),bo(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.prelu=function(n){return this.throwIfDisposed(),cf(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.prod=function(n,e){return this.throwIfDisposed(),DC(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.reciprocal=function(){return this.throwIfDisposed(),OC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.relu=function(){return this.throwIfDisposed(),to(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.relu6=function(){return this.throwIfDisposed(),tx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.reshapeAs=function(n){return this.throwIfDisposed(),j(this,n.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.reshape=function(n){return this.throwIfDisposed(),j(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),ZC(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),JC(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.reverse=function(n){return this.throwIfDisposed(),hr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.rfft=function(){return this.throwIfDisposed(),gf(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.round=function(){return this.throwIfDisposed(),nx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.rsqrt=function(){return this.throwIfDisposed(),sx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.selu=function(){return this.throwIfDisposed(),rx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.separableConv2d=function(n,e,t,s,r,o){return this.throwIfDisposed(),ox(this,n,e,t,s,r,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.sigmoid=function(){return this.throwIfDisposed(),Ur(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.sign=function(){return this.throwIfDisposed(),FC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.sin=function(){return this.throwIfDisposed(),ix(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.sinh=function(){return this.throwIfDisposed(),ax(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.slice=function(n,e){return this.throwIfDisposed(),Et(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.softmax=function(n){return this.throwIfDisposed(),ff(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.softplus=function(){return this.throwIfDisposed(),yl(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),uf(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.split=function(n,e){return this.throwIfDisposed(),Rs(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.sqrt=function(){return this.throwIfDisposed(),Vn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.square=function(){return this.throwIfDisposed(),Wt(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.squaredDifference=function(n){return this.throwIfDisposed(),cx(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.squeeze=function(n){return this.throwIfDisposed(),pa(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof sn?[this,n]:[this,...n];return Ls(t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.step=function(n){return this.throwIfDisposed(),bl(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.stridedSlice=function(n,e,t,s,r,o,i,a){return this.throwIfDisposed(),LC(this,n,e,t,s,r,o,i,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.sub=function(n){return this.throwIfDisposed(),Ke(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.sum=function(n,e){return this.throwIfDisposed(),Qe(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.tan=function(){return this.throwIfDisposed(),PC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.tanh=function(){return this.throwIfDisposed(),na(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.tile=function(n){return this.throwIfDisposed(),sr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.toBool=function(){return this.throwIfDisposed(),Ue(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.toFloat=function(){return this.throwIfDisposed(),Ue(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.toInt=function(){return this.throwIfDisposed(),Ue(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.topk=function(n,e){return this.throwIfDisposed(),BC(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.transpose=function(n){return this.throwIfDisposed(),_t(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.unique=function(n){return this.throwIfDisposed(),VC(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),px(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.unstack=function(n){return this.throwIfDisposed(),dr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.where=function(n,e){return this.throwIfDisposed(),qn(n,this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ge().prototype.zerosLike=function(){return this.throwIfDisposed(),At(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Lr extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Lr.prototype)}}class rr extends Error{constructor(e){super(e),Object.setPrototypeOf(this,rr.prototype)}}class K extends Error{constructor(e){super(e),Object.setPrototypeOf(this,K.prototype)}}class xt extends Error{constructor(e){super(e),Object.setPrototypeOf(this,xt.prototype)}}class Xx extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Xx.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class KS{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function oa(n,e){if(Array.isArray(n)){let t=[];for(let s=0;s<e;s++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function Pr(n,e){if(!n)throw new Xx(e)}function gv(n,e){let t=0;for(const s of n)s===e&&t++;return t}function xs(n){return n.length===1?n[0]:n}function Pt(n){return Array.isArray(n)?n:[n]}function ao(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Bi(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let Js={};function Yx(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function zg(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>zg(e));else{const e=Object.keys(n);for(const t of e){const s=n[t];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[t]=s.value:zg(s))}}}function zc(n,e={},t={},s="object",r=!1){if(typeof n=="string"){const o=n;let i;if(o in t)i=t[o];else if(o in Js)i=Js[o];else if(i=e[o],i==null)throw new K(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{const o=n;if(o.className==null||o.config==null)throw new K(`${s}: Improper config format: ${JSON.stringify(o)}.
'className' and 'config' must set.`);const i=o.className;let a,l;if(i in t?[a,l]=t[i]:i in Js?[a,l]=Js.className:i in e&&([a,l]=e[i]),a==null)throw new K(`Unknown ${s}: ${i}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const u={};for(const p of Object.keys(Js))u[p]=Js[p];for(const p of Object.keys(t))u[p]=t[p];const c=o.config;c.customObjects=u;const h=Object.assign({},Js);for(const p of Object.keys(t))Js[p]=t[p];zg(o.config);const d=l(a,o.config,t,r);return Js=Object.assign({},h),d}else{const u=Object.assign({},Js);for(const h of Object.keys(t))Js[h]=t[h];const c=new a(o.config);return Js=Object.assign({},u),c}}}function UM(n,e){return n<e?-1:n>e?1:0}function Nh(n,e){return-1*UM(n,e)}function Zo(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function GM(n){if(n==null)throw new K(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function ma(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new K(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function Zx(n,e,t=0,s=1/0){return Pr(t>=0),Pr(s>=t),Array.isArray(n)&&n.length>=t&&n.length<=s&&n.every(r=>typeof r===e)}function Dn(n,e){Array.isArray(n)?(A(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,s)=>Dn(t,`element ${s+1} of ${e}`))):A(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${qS(n)}.`)}function qS(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>qS(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function HM(n,e,t){let s=t!=null?t():bs(),r;return(...i)=>{const a=t!=null?t():bs();return a-s<e||(s=a,r=n(...i)),r}}function XS(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let jM=0;function YS(){return jM++}const Th={};function If(n=""){return n in Th||(Th[n]=0),Th[n]+=1,n+Th[n].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const KM=["channelsFirst","channelsLast"],qM=["nearest","bilinear"],XM=["valid","same","causal"],YM=["max","avg"],ZM=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Ea=new Map;function fn(n){ma(KM,"DataFormat",n)}function JM(n){ma(qM,"InterpolationFormat",n)}function Ys(n){ma(XM,"PaddingMode",n)}function ZS(n){ma(YM,"PoolMode",n)}const nu=[],yv="/";function Hi(n,e){nu.push(n);try{const t=e();return nu.pop(),t}catch(t){throw nu.pop(),t}}function QM(){return nu.length===0?"":nu.join(yv)+yv}function JS(n){if(!eI(n))throw new Error("Not a valid tensor name: '"+n+"'");return QM()+n}function QS(n){if(!eI(n))throw new Error("Not a valid tensor name: '"+n+"'");Ea.has(n)||Ea.set(n,0);const e=Ea.get(n);if(Ea.set(n,Ea.get(n)+1),e>0){const t=`${n}_${e}`;return Ea.set(t,1),t}else return n}const eB=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function eI(n){return!!n.match(eB)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function tB(n){return n===parseInt(n.toString(),10)}function Jo(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let s=1;for(let r=e;r<t;++r)s*=n[r];return s}function sl(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s<e&&(e=s)}return e}function oi(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s>e&&(e=s)}return e}function Ir(n,e){if(e<n)throw new K(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let s=n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Gm;function Cn(){return Gm==null&&(Gm=Rk().epsilon()),Gm}function $r(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Hr(n,e){return Ue(n,e)}function Mc(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),j(n,t)}function nB(n,e){return oe(()=>{if(n.shape.length!==2)throw new K(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=Mc(n,1);return Mg(t,[1,e,1])})}function sB(n){const e=[Jo(n.shape)];return j(n,e)}function rB(n){if(n.rank<=1)throw new K(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],Jo(n.shape,1)];return j(n,e)}function ji(n,e,t){return oe(()=>{switch(n.rank){case 1:return df(n,e,t);case 2:return lx(n,[e,0],[t,n.shape[1]]);case 3:return pf(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return gu(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Et(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Et(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new K(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Hm(n,e,t){return oe(()=>{switch(n.rank){case 1:return df(n,e,t);case 2:return lx(n,[0,e],[n.shape[0],t]);case 3:return pf(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return gu(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new K(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Eh(n,e,t,s){return oe(()=>{switch(n.rank){case 1:return df(n,e,t);case 2:switch(s){case 1:return ji(n,e,t);case 2:return Hm(n,e,t);default:throw new K(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return ji(n,e,t);case 2:return pf(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return Hm(n,e,t);default:throw new K(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return ji(n,e,t);case 2:return gu(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return gu(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return Hm(n,e,t);default:throw new K(`The axis is not within the rank of the tensor ${s}`)}default:throw new K(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Jx(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),bn(n,e)}function bv(n,e){switch(n.rank){case 1:return lC([n,e]);case 2:return uC([n,e],0);case 3:return cC([n,e],0);case 4:return hC([n,e],0);default:throw new K(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function Mg(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new K(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return sr(n,e)}function $f(n,e=0,t=1,s,r){return ex(n,e,t,s,r)}function jr(n,e,t,s){if(n.rank<2||e.rank<2)throw new xt(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const r=n.shape.slice(-1)[0],o=e.shape.slice(-2)[0];if(r!==o)throw new xt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return Og({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?Bg(n.rank,s,$r()):null,activation:t});{const r=n.shape.slice(),o=r.pop();n=j(n,[-1,o]);const i=e.shape.slice(),a=i.pop(),l=i.pop(),u=[...i,a],c=Array.from({length:e.rank},(f,g)=>g===0?e.rank-2:g<=e.rank-2?g-1:g);e=j(_t(e,c),[l,-1]);const h=[...r,...u];return j(Og({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?Bg(n.rank,s,$r()):null,activation:t}),h)}}function tI(n,e,t){return oe(()=>(Array.isArray(e)?e=us(e,"int32"):e=Ue(e,"int32"),Oc(n,e,t)))}function Bc(n){return H(n,n)}function Bg(n,e,t){const s=e.shape;if(e.rank!==1&&e.rank!==n)throw new K(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return s.length===1?j(e,[1,s[0],1,1,1]):j(e,[1,s[3],s[0],s[1],s[2]]);if(t==="channelsLast")return s.length===1?j(e,[1,1,1,1,s[0]]):j(e,[1].concat(s))}else if(n===4){if(t==="channelsFirst")return s.length===1?j(e,[1,s[0],1,1]):j(e,[1,s[2],s[0],s[1]]);if(t==="channelsLast")return s.length===1?j(e,[1,1,1,s[0]]):j(e,[1].concat(s))}else if(n===3){if(t==="channelsFirst")return s.length===1?j(e,[1,s[0],1]):j(e,[1,s[1],s[0]]);if(t==="channelsLast")return s.length===1?j(e,[1,1,s[0]]):j(e,[1].concat(s))}else if(n<3)return e;throw new K(`Unsupported input rank by biasAdd: ${e.rank}`)}function Er(n,e,t){return oe(()=>(t==null&&(t=$r()),fn(t),Ne(n,Bg(n.rank,e,t))))}function oB(n,e=1){if(e!==1)throw new xt(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return Ac(n)}function iB(n){return oe(()=>nt(n,Ne(vn(n),1)))}function nI(n,e,t,s){return oe(()=>GC(n,e,t,s))}function aB(n){return oe(()=>{const e=Ne(.5,H(.2,n));return Os(e,0,1)})}function Vc(n,e,t=!1){return t?n():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const lB=["fanIn","fanOut","fanAvg"],uB=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function cB(n){ma(lB,"FanMode",n)}function hB(n){ma(uB,"Distribution",n)}class fr extends wl{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class sI extends fr{apply(e,t){return kn(e,t)}}sI.className="Zeros";Te(sI);class Qx extends fr{apply(e,t){return As(e,t)}}Qx.className="Ones";Te(Qx);class rI extends fr{constructor(e){if(super(),typeof e!="object")throw new K(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new K(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return oe(()=>H(it(this.value),As(e,t)))}getConfig(){return{value:this.value}}}rI.className="Constant";Te(rI);class oI extends fr{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return da(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}oI.className="RandomUniform";Te(oI);class iI extends fr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new xt(`randomNormal does not support dType ${t}.`);return $f(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}iI.className="RandomNormal";Te(iI);class aI extends fr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new xt(`truncatedNormal does not support dType ${t}.`);return dx(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}aI.className="TruncatedNormal";Te(aI);class lI extends fr{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return oe(()=>{if(e.length!==2||e[0]!==e[1])throw new K("Identity matrix initializer can only be used for 2D square matrices.");return H(this.gain,qb(e[0]))})}getConfig(){return{gain:this.gain}}}lI.className="Identity";Te(lI);function dB(n,e="channelsLast"){let t,s;if(fn(e),n.length===2)t=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const r=Jo(n,2);t=n[1]*r,s=n[0]*r}else if(e==="channelsLast"){const r=Jo(n,0,n.length-2);t=n[n.length-2]*r,s=n[n.length-1]*r}}else{const r=Jo(n);t=Math.sqrt(r),s=Math.sqrt(r)}return[t,s]}class Ps extends fr{constructor(e){if(super(),e.scale<0)throw new K(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,cB(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,hB(this.distribution),this.seed=e.seed}apply(e,t){const s=dB(e),r=s[0],o=s[1];let i=this.scale;if(this.mode==="fanIn"?i/=Math.max(1,r):this.mode==="fanOut"?i/=Math.max(1,o):i/=Math.max(1,(r+o)/2),this.distribution==="normal"){const a=Math.sqrt(i);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new xt(`${this.getClassName()} does not support dType ${t}.`);return dx(e,0,a,t,this.seed)}else{const a=Math.sqrt(3*i);return da(e,-a,a,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Ps.className="VarianceScaling";Te(Ps);class e0 extends Ps{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Ps.className}}e0.className="GlorotUniform";Te(e0);class t0 extends Ps{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Ps.className}}t0.className="GlorotNormal";Te(t0);class n0 extends Ps{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Ps.className}}n0.className="HeNormal";Te(n0);class s0 extends Ps{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Ps.className}}s0.className="HeUniform";Te(s0);class r0 extends Ps{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Ps.className}}r0.className="LeCunNormal";Te(r0);class o0 extends Ps{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Ps.className}}o0.className="LeCunUniform";Te(o0);class uI extends fr{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return oe(()=>{if(e.length<2)throw new xt("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const s=pe(e.slice(0,-1)),r=e[e.length-1],o=s*r;o>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${o}) elements: Slowness may result.`);const i=[Math.max(r,s),Math.min(r,s)],a=$f(i,0,1,t,this.seed),l=QC.qr(a,!1);let u=l[0];const h=l[1].flatten().stridedSlice([0],[Math.min(r,s)*Math.min(r,s)],[Math.min(r,s)+1]);return u=H(u,h.sign()),s<r&&(u=u.transpose()),H(it(this.gain),u.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}uI.className="Orthogonal";Te(uI);const xv={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function wv(n,e={}){return zc(n,nr.getMap().classNameMap,e,"initializer")}function on(n){return Yx(n)}function Zt(n){if(typeof n=="string"){const e=n in xv?xv[n]:n;if(e==="GlorotNormal")return new t0;if(e==="GlorotUniform")return new e0;if(e==="HeNormal")return new n0;if(e==="HeUniform")return new s0;if(e==="LeCunNormal")return new r0;if(e==="LeCunUniform")return new o0;{const t={};return t.className=e,t.config={},wv(t)}}else return n instanceof fr?n:wv(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Vg(n){return Array.isArray(n)&&Array.isArray(n[0])}function md(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function ct(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new K(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function Ot(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new K(`Expected exactly 1 Shape; got ${n.length}`)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function gd(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((s,r)=>s*r);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const vv="Variable";class pB{constructor(e,t="float32",s=vv,r=!0,o=null){this.dtype=t??"float32",this.shape=e.shape,this.id=YS(),s=s??vv,this.originalName=JS(s),this.name=QS(this.originalName),this.trainable_=r,this.constraint=o,this.val=WC(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),fB(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function fB(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function Wg(n){return n.map(e=>e.read())}function i0(n){n.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Sn{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class Zr{constructor(e,t,s,r,o,i,a){this.dtype=e,this.shape=t,this.sourceLayer=s,this.inputs=r,this.callArgs=o,this.outputTensorIndex=a,this.id=YS(),i!=null&&(this.originalName=JS(i),this.name=QS(this.originalName)),this.rank=t.length}}let mB=0;class Nf{constructor(e,t){this.callArgs=t,this.id=mB++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s!=null&&s.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let gB=0;class Ct extends wl{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=gB++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const s=this.getClassName();t=ao(s)+"_"+If(s)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let o=null;e.batchSize!=null&&(o=e.batchSize),s=[o].concat(e.inputShape)}this.batchInputShape=s;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new rr(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new K(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return xs(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return xs(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Lr(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Lr(`Layer ${this.name} is not connected, no input to return.`);return xs(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Lr(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Lr(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return xs(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=Pt(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=Pt(this.inputSpec);if(t.length!==s.length)throw new K(`Layer ${this.name} expects ${s.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const o=t[r],i=s[r];if(i==null)continue;const a=o.rank;if(i.ndim!=null&&a!==i.ndim)throw new K(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${a}`);if(i.maxNDim!=null&&a>i.maxNDim)throw new K(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${a}`);if(i.minNDim!=null&&a<i.minNDim)throw new K(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${a}.`);if(i.dtype!=null&&o.dtype!==i.dtype)throw new K(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${o.dtype}.`);if(i.axes){const l=o.shape;for(const u in i.axes){const c=Number(u),h=i.axes[u],d=c>=0?l[c]:l[l.length+c];if(h!=null&&[h,null].indexOf(d)===-1)throw new K(`Input ${r} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${h} but got shape ${l}.`)}}if(i.shape!=null)for(let l=0;l<i.shape.length;++l){const u=i.shape[l],c=o.shape[l];if(u!=null&&c!=null&&u!==c)throw new K(`Input ${r} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${o.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const s=Pt(e),r=xB(e),o=wB(e);if(r===o)throw new K("Arguments to apply() must be all SymbolicTensors or all Tensors");return Hi(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const i=[];for(const a of Pt(e))i.push(a.shape);this.build(xs(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&o&&(this._refCount=1)}if(this.assertInputCompatibility(e),o){let i=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,i);const a=Pt(i),l=[];for(let u of a)s.indexOf(u)!==-1&&(u=u.clone()),l.push(u);if(i=xs(l),this.activityRegularizer!=null)throw new xt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{const i=yB(e),a=this.computeOutputShape(i);let l;const u=bB(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?i[0]:i),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((c,h)=>new Zr(u,c,this,Pt(e),t,this.name,h)):l=new Zr(u,a,this,Pt(e),t,this.name),this.addInboundNode(e,l,null,null,i,a,t),this._refCount++,this.activityRegularizer!=null)throw new xt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&e[r]!=null&&e[r]!==s&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Lr(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const s=JSON.stringify(t.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new Lr(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new rr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return gd(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Wg(e?this.trainableWeights:this.weights)}setWeights(e){oe(()=>{const t=this.weights;if(t.length!==e.length)throw new K(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const s=[],r=Wg(t);for(let o=0;o<r.length;++o){const i=r[o],a=t[o],l=e[o];if(!Tt(i.shape,l.shape))throw new K(`Layer weight shape ${i.shape} not compatible with provided weight shape ${l.shape}`);s.push([a,l])}i0(s)})}addWeight(e,t,s,r,o,i,a,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new K(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=l!=null?l():Zt("zeros"));const u=r.apply(t,s),c=new pB(u,s,e,i,a);return u.dispose(),o!=null&&this.addLoss(()=>o.apply(c.read())),i==null&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Pt(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,s){if(!this.supportsMasking)return;const r=this.computeMask(e,s),o=Pt(t),i=Pt(r);if(o.length!==i.length)throw new Error(`${this.name} outputs ${o.length} tensors but ${o.length} masks for those tensors`);for(let a=0;a<o.length;a++)o[a].kerasMask=i[a]}addInboundNode(e,t,s,r,o,i,a=null){const l=Pt(e);t=Pt(t),s=Pt(s),r=Pt(r),o=md(o),i=md(i);const u=[],c=[],h=[];for(const d of l)u.push(d.sourceLayer),c.push(d.nodeIndex),h.push(d.tensorIndex);new Nf({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:h,inputTensors:l,outputTensors:t,inputMasks:s,outputMasks:r,inputShapes:o,outputShapes:i},a);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function yB(n){n=Pt(n);const e=[];for(const t of n)e.push(t.shape);return xs(e)}function bB(n){return"float32"}function cI(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const s=e.inboundNodes[t];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let o=0;o<s.inboundLayers.length;o++){const i=s.inputTensors[o],a=s.inboundLayers[o],l=s.nodeIndices[o],u=cI(i,a,l);for(const c of u)r.indexOf(c)===-1&&r.push(c)}return r}}}function xB(n){let e=!0;for(const t of Pt(n))if(!(t instanceof Zr)){e=!1;break}return e}function wB(n){let e=!0;for(const t of Pt(n))if(t instanceof Zr){e=!1;break}return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Wc extends Ct{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:If("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new K("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new K("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new K("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=t,this.dtype=s,this.inputSpec=[{shape:t}];const r=new Zr(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new Nf({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new K(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}Wc.className="InputLayer";Te(Wc);function vB(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new K("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new Wc({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function kB(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return Ue(e,n.dtype)}catch{throw new K(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class Ko{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Ko)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=kB(e,t),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new K(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Zr){if(this.id2Value[e.id]==null)throw new K(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new K(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof Zr){if(this.id2Value[e.id]==null)throw new K(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new K(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&vt(this.id2Mask)}}const yd=new KS,bd=new KS;function CB(n){yd!=null&&yd.setMaxEntries(n),bd!=null&&bd.setMaxEntries(n)}function Yl(n,e,t,s){const r=t==null?!1:t.training,o=Array.isArray(n),i=o?n:[n],a=i.map(f=>f.name),l=[],u=e.names();for(const f of a)u.indexOf(f)!==-1?l.push(e.getValue(f)):l.push(null);const c=a.join(",")+"|"+e.names().sort().join(",");let h=yd.get(c),d;if(h==null){const f=SB(i,e);h=f.sorted,d=f.recipientCounts,yd.put(c,h),bd.put(c,d)}d={},r||Object.assign(d,bd.get(c));const p=new Ko(e);for(let f=0;f<h.length;++f){const g=h[f],y=g.sourceLayer;if(y instanceof Wc)continue;const b=[],w=[],C=[];let v=!1;for(const D of g.inputs){const F=p.getValue(D),T=p.getMask(D);b.push(F),w.push(T),T!=null&&(v=!0),r||(d[D.name]--,d[D.name]===0&&!e.hasKey(D)&&a.indexOf(D.name)===-1&&!F.isDisposed&&D.sourceLayer.stateful!==!0&&C.push(F))}v&&(t=t||{},t.mask=w[0]);const I=Pt(y.apply(b,t));let E=null;y.supportsMasking&&(E=y.computeMask(b,w));const R=$B(g),L=Array.isArray(R)?R:[R];for(let D=0;D<L.length;++D){p.hasKey(L[D])||p.add(L[D],I[D],Array.isArray(E)?E[0]:E);const F=a.indexOf(L[D].name);F!==-1&&(l[F]=I[D])}r||vt(C)}return p.disposeMasks(),o?l:l[0]}function SB(n,e){A(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],s={};if(n.length===1){const r=kv(n[0],e);t=r.sorted,s=r.recipientMap}else{const r=new Set;for(const o of n){const{sorted:i,recipientMap:a}=kv(o,e);for(const l of i)r.has(l.name)||(t.push(l),r.add(l.name));for(const l in a)s[l]==null&&(s[l]=new Set),a[l].forEach(u=>s[l].add(u))}}return{sorted:t,recipientCounts:IB(s)}}function IB(n){const e={};for(const t in n)e[t]=n[t].size;return e}function kv(n,e){const t=new Set,s=[],r={};for(const a of e.names())t.add(a);const o=[],i=[];for(o.push(n);o.length>0;){const a=o[o.length-1];if(t.has(a.name)){o.pop();continue}const l=i[i.length-1]===o.length-1;if(a.inputs.length===0||l)o.pop(),s.push(a),t.add(a.name),l&&i.pop();else{i.push(o.length-1);for(const u of a.inputs)r[u.name]==null&&(r[u.name]=new Set),r[u.name].add(a.name),!t.has(u.name)&&o.push(u)}}return{sorted:s,recipientMap:r}}function $B(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const r of n.sourceLayer.inboundNodes[s].outputTensors)if(r.id===n.id){t=s;break}e=n.sourceLayer.getOutputAt(t)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NB=ue();NB.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,CB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function a0(n,e){return oe(()=>Vn(Qe(H(n,n),e,!0)))}class Uc extends wl{getConfig(){return{}}}class hI extends Uc{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return oe(()=>{const t=a0(e,this.axis),s=Os(t,0,this.maxValue);return H(e,nt(s,Ne(Cn(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}hI.className="MaxNorm";Te(hI);class dI extends Uc{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return oe(()=>nt(e,Ne(Cn(),a0(e,this.axis))))}getConfig(){return{axis:this.axis}}}dI.className="UnitNorm";Te(dI);class pI extends Uc{apply(e){return to(e)}}pI.className="NonNeg";Te(pI);class fI extends Uc{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return oe(()=>{const t=a0(e,this.axis),s=Ne(H(this.rate,Os(t,this.minValue,this.maxValue)),H(1-this.rate,t));return H(e,nt(s,Ne(Cn(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}fI.className="MinMaxNorm";Te(fI);const Cv={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function $n(n){return Yx(n)}function Sv(n,e={}){return zc(n,nr.getMap().classNameMap,e,"constraint")}function Nn(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in Cv?Cv[n]:n,config:{}};return Sv(t)}else return n instanceof Uc?n:Sv(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function Di(n){if(n==null)return;const e=[],t=[],s=[];for(const r in n){const o=n[r];if(typeof o!="number"){const i=o;e.push(i.data()),t.push(r),s.push(i)}}if(e.length>0){const r=await Promise.all(e);for(let o=0;o<r.length;++o)n[t[o]]=r[o][0];vt(s)}}function mI(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var Iv;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(Iv||(Iv={}));const TB=125;class bu{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class EB{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class _B extends bu{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const s=t.size==null?0:t.size;this.seen+=s;for(const r in t){const o=t[r];if(typeof o=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+o*s;else{let i;r in this.totals?i=this.totals[r]:this.totals[r]=0;const a=oe(()=>Ne(this.totals[r],H(o,s)));this.totals[r]=a,i!=null&&i.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?t[s]=this.totals[s]/this.seen:oe(()=>{const r=H(nt(1,this.seen),this.totals[s]);t[s]=r,this.totals[s].dispose(),Rn(t[s])}))}}class AB extends bu{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const s in t)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(t[s])}async syncData(){const e=[],t=[],s=[];for(const o in this.history){const i=this.history[o];for(let a=0;a<i.length;++a)if(typeof i[a]!="number"){const l=i[a];e.push(l.data()),t.push(o),s.push(a)}}const r=await Promise.all(e);for(let o=0;o<r.length;++o)this.history[t[o]][s[o]].dispose(),this.history[t[o]][s[o]]=r[o][0]}}class RB extends bu{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||wS,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=TB),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");fg(this.yieldEvery)&&(this.maybeWait=HM(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,s){const r=[];this.yield!=null&&(await Di(s),r.push(this.yield(e,t,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Di(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const s=[];this.epochEnd!=null&&(await Di(t),s.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Di(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const s=[];this.batchEnd!=null&&(await Di(t),s.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):fg(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await Di(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Di(e),await this.trainEnd(e))}}function gI(n,e){return n==null&&(n={}),n instanceof bu?[n]:Array.isArray(n)&&n[0]instanceof bu?n:Pt(n).map(s=>new RB(s,e))}class er{constructor(){}static registerCallbackConstructor(e,t){A(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),er.checkForDuplicate(t),er.constructors[e]==null&&(er.constructors[e]=[]),er.constructors[e].push(t)}static checkForDuplicate(e){for(const t in er.constructors)er.constructors[+t].forEach(r=>{if(r===e)throw new K("Duplicate callback constructor.")})}static clear(){er.constructors={}}static createCallbacks(e){const t=[];for(const s in er.constructors){const r=+s;e>=r&&t.push(...er.constructors[r])}return t.map(s=>new s)}}er.constructors={};function yI(n,e,t,s,r,o,i,a,l){const u=new AB,c=[new _B,...er.createCallbacks(e)];n!=null&&c.push(...n),c.push(u);const h=new EB(c);return h.setParams({epochs:t,initialEpoch:s,samples:r,steps:o,batchSize:i,verbose:e,doValidation:a,metrics:l}),{callbackList:h,history:u}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function go(n,e={},t=!1){return zc(n,nr.getMap().classNameMap,e,"layer",t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function xd(n,e){return oe(()=>{n.dtype!=="float32"&&(n=Ue(n,"float32"));const t=Qe(Bc(n),e,!0),s=gl(t.shape,Cn()),r=Vn(No(t,s));return nt(n,r)})}function Tf(n,e){return oe(()=>ln(Bc(Ke(e,n)),-1))}function l0(n,e){return oe(()=>ln(vn(Ke(e,n)),-1))}function u0(n,e){return oe(()=>{const t=Ke(n,e),s=Os(vn(n),Cn(),Number.MAX_VALUE),r=vn(nt(t,s));return H(100,ln(r,-1))})}function DB(n,e){return oe(()=>{const t=Os(e,Cn(),Number.MAX_VALUE),s=Ks(Ne(1,t)),r=Os(n,Cn(),Number.MAX_VALUE),o=Ks(Ne(1,r));return ln(Bc(Ke(s,o)),-1)})}function OB(n,e){return oe(()=>{const t=No(0,Ke(1,H(n,e)));return ln(Bc(t),-1)})}function FB(n,e){return oe(()=>{const t=No(0,Ke(1,H(n,e)));return ln(t,-1)})}function LB(n,e){return oe(()=>{const t=Qe(H(n,e),-1),s=ar(H(Ke(1,n),e),-1);return No(0,Ne(1,Ke(s,t)))})}function PB(n,e){return oe(()=>{const t=Math.log(2),s=Ke(e,n),r=Ke(Ne(s,yl(H(-2,s))),t);return ln(r,-1)})}function xu(n,e,t=!1){return oe(()=>{if(t)e=ff(e);else{const s=Qe(e,e.shape.length-1,!0);e=nt(e,s)}return e=Os(e,Cn(),1-Cn()),Kt(Qe(H(Ue(n,"float32"),Ks(e)),e.shape.length-1))})}function wd(n,e,t=!1){return oe(()=>{const s=Ue(Dc(sB(n)),"int32");e=Os(e,Cn(),1-Cn());const r=e.shape,o=j(Jb(s,r[r.length-1]),r);return xu(o,e,t)})}function zB(n,e){if(!Tt(n.shape,e.shape))throw new K(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return oe(()=>{const t=to(e),s=Kt(vn(e));return Ne(Ke(t,H(e,n)),sf(Fs(s)))})}function Ef(n,e){return oe(()=>{let t;return t=Os(e,Cn(),1-Cn()),t=Ks(nt(t,Ke(1,t))),ln(zB(n,t),-1)})}function MB(n,e){return oe(()=>{const t=Os(n,Cn(),1),s=Os(e,Cn(),1);return Qe(H(n,Ks(nt(t,s))),-1)})}function BB(n,e){return oe(()=>{const t=Ks(Ne(Cn(),e));return ln(Ke(e,H(n,t)),-1)})}function bI(n,e){return oe(()=>{const t=xd(n,-1),s=xd(e,-1),r=H(t,s);return Kt(Qe(r,-1))})}const vd={meanSquaredError:Tf,meanAbsoluteError:l0,meanAbsolutePercentageError:u0,meanSquaredLogarithmicError:DB,squaredHinge:OB,hinge:FB,categoricalHinge:LB,logcosh:PB,categoricalCrossentropy:xu,sparseCategoricalCrossentropy:wd,binaryCrossentropy:Ef,kullbackLeiblerDivergence:MB,poisson:BB,cosineProximity:bI};function jm(n){if(typeof n=="string"){if(n in vd)return vd[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new K(e)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function xI(n,e){return oe(()=>{const t=H(.5,qs(e)),s=Hr(Bs(e,t),n.dtype);return ln(Sr(n,s),-1)})}function wI(n,e){return oe(()=>Hr(Sr(Qa(n,-1),Qa(e,-1)),"float32"))}function VB(n,e){return oe(()=>Ue(Qe(Yr(Sr(n,1),Sr(e,1))),"float32"))}function WB(n,e){return oe(()=>Ue(Qe(Yr(Sr(n,0),Sr(e,1))),"float32"))}function UB(n,e){return oe(()=>{const t=VB(n,e),s=WB(n,e),r=Ne(t,s);return Ue(qn(Bs(r,0),nt(t,r),0),"float32")})}function GB(n,e){return Ef(n,e)}function HB(n,e){return n.rank===e.rank&&(n=pa(n,[n.rank-1])),e=Qa(e,-1),e.dtype!==n.dtype&&(e=Ue(e,n.dtype)),Ue(Sr(n,e),"float32")}const jB=Tf,KB=Tf,qB=l0,XB=l0,YB=u0,ZB=u0,vI=xu,JB=bI,kI=wd,kd={binaryAccuracy:xI,categoricalAccuracy:wI,precision:UB,categoricalCrossentropy:vI,sparseCategoricalCrossentropy:kI,mse:jB,MSE:KB,mae:qB,MAE:XB,mape:YB,MAPE:ZB,cosine:JB};function QB(n){if(typeof n=="string"&&n in kd)return kd[n];if(typeof n!="string"&&n!=null)return n;throw new K(`Unknown metric ${n}`)}function _h(n){if(Pr(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(vd))if(vd[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(kd))if(kd[t]===n){e=t;break}return e!==void 0?e:n.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function eV(n){const e={Adagrad:()=>Ta.adagrad(.01),Adadelta:()=>Ta.adadelta(1,.95,Cn()),Adam:()=>Ta.adam(.001,.9,.999,Cn()),Adamax:()=>Ta.adamax(.002,.9,.999,Cn(),0),RMSProp:()=>Ta.rmsprop(.001,.9,0,Cn()),SGD:()=>Ta.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new K(`Unknown Optimizer ${n}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const $v=1*1024*1024;function Nv(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!Ug(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const s=JSON.stringify(n);s.length>$v&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${$v}.`)}}function Ug(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!Ug(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!Ug(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function tV(n,e,t,s=console.log){const r=sV(n),o=["Layer (type)","Input Shape","Output shape","Param #"];r?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(c=>Math.floor(e*c)));let i;if(!r){o.push("Receives inputs"),i=[];for(const c in n.nodesByDepth)i.push(...n.nodesByDepth[c])}s("_".repeat(e)),Cd(o,t,s),s("=".repeat(e));const a=n.layers;for(let c=0;c<a.length;++c)r?rV(a[c],t,s):oV(a[c],t,i,s),s((c===a.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const l=nV(n),u=gd(n.nonTrainableWeights);s(`Total params: ${l+u}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${u}`),s("_".repeat(e))}function nV(n){let e;return n.collectedTrainableWeights!=null?e=gd(n.collectedTrainableWeights):e=gd(n.trainableWeights),e}function sV(n){let e=!0;const t=[],s=[];for(const r in n.nodesByDepth)t.push(n.nodesByDepth[r]);for(const r of t){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of n.layers){let o=!1;for(const i of r.inboundNodes)if(s.indexOf(i)!==-1)if(o){e=!1;break}else o=!0;if(!e)break}return e}function Cd(n,e,t=console.log){let s="";for(let r=0;r<n.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=n[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);t(s)}function rV(n,e,t){let s,r;try{r=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const o=n.name,i=n.getClassName(),a=[`${o} (${i})`,r,s,n.countParams().toString()];Cd(a,e,t)}function oV(n,e,t,s){let r,o;try{o=n.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{o="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const i=[];for(const h of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(h)===-1))for(let d=0;d<h.inboundLayers.length;++d){const p=h.inboundLayers[d].name,f=h.nodeIndices[d],g=h.tensorIndices[d];i.push(`${p}[${f}][${g}]`)}const a=n.name,l=n.getClassName(),u=i.length===0?"":i[0],c=[`${a} (${l})`,o,r,n.countParams().toString(),u];Cd(c,e,s);for(let h=1;h<i.length;++h)Cd(["","","","",i[h]],e,s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function CI(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function Gg(n,e){if(n===null)return null;if(typeof n=="string")return Bi(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const o=n[r];CI(e,r,o)?t.push(o):t.push(Gg(o,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s];if(s==="name"&&typeof r=="string")t[s]=r;else{const o=Bi(s);t[o]=Gg(r,o)}}return t}}function Hg(n,e){if(n==null)return null;if(typeof n=="string")return ao(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const o=n[r];CI(e,r,o)?t.push(o):t.push(Hg(o,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s],o=ao(s);(s==="name"||s==="className")&&typeof r=="string"?t[o]=r:t[o]=Hg(r,s)}return t}}/** @license See the LICENSE file. */const SI="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const iV=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class yr extends Ct{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const w=this.getClassName().toLowerCase();this.name=If(w)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Zo(this.inputs).length!==this.inputs.length)throw new K(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(w=>w.name)}`);Zo(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(w=>w.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const w of this.outputs){const C=w.sourceLayer,v=w.nodeIndex,I=w.tensorIndex;this.outputLayers.push(C),this.outputLayersNodeIndices.push(v),this.outputLayersTensorIndices.push(I)}for(const w of this.inputs){const C=w.sourceLayer,v=w.nodeIndex,I=w.tensorIndex;Pr(v===0,"input layer has >1 nodes"),Pr(I===0,"input layer has >1 tensors"),this.inputLayers.push(C),this.inputLayersNodeIndices.push(v),this.inputLayersTensorIndices.push(I)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let w=0;w<this.inputLayers.length;w++){const C=this.inputLayers[w];if(!(C instanceof Wc))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${w} (0-based) originates from layer type ${C.getClassName()}.`);this.inputNames.push(C.name),this.feedInputShapes.push(C.batchInputShape),this.feedInputNames.push(C.name)}for(const w of this.outputLayers)this.outputNames.push(w.name);this.internalInputShapes=this.inputs.map(w=>w.shape),this.internalOutputShapes=this.outputs.map(w=>w.shape);const t={},s={},r={},o={},i={},a=[],l=(w,C,v,I,E,R)=>{(I==null||E==null||R==null)&&(I=w.sourceLayer,E=w.nodeIndex,R=w.tensorIndex);const L=I.inboundNodes[E];if(v.indexOf(L)!==-1)throw new rr(`The tensor ${w.name} at layer "${I.name}" is part of a cycle.`);if(C.indexOf(L)!==-1)return;this.containerNodes.add(yr.nodeKey(I,E)),I.id in i||(i[I.id]=Object.keys(i).length),v.indexOf(L)===-1&&v.push(L);const D=L.inboundLayers.length;for(let F=0;F<D;F++){const T=L.inputTensors[F],V=L.inboundLayers[F],q=L.nodeIndices[F],se=L.tensorIndices[F];l(T,C,v,V,q,se)}for(C.push(L);v.indexOf(L)>=0;)v.splice(v.indexOf(L),1);a.push(L)},u=[],c=[];for(const w of this.outputs)l(w,u,c);const h=a.slice().reverse();for(const w of h){s[w.id]=w,w.id in t||(t[w.id]=0);let C=t[w.id];const v=r[w.outboundLayer.id]==null?0:r[w.outboundLayer.id];C=Math.max(C,v),r[w.outboundLayer.id]=C,o[w.outboundLayer.id]=w.outboundLayer,t[w.id]=C;for(let I=0;I<w.inboundLayers.length;I++){const E=w.inboundLayers[I],R=w.nodeIndices[I],L=E.inboundNodes[R],D=t[L.id]==null?0:t[L.id];t[L.id]=Math.max(C+1,D),s[L.id]=L}}const d={};for(const w in t){const C=t[w];C in d||(d[C]=[]),d[C].push(s[w])}const p={};for(const w in r){const C=r[w];C in p||(p[C]=[]),p[C].push(o[w])}let f=Object.keys(p).map(w=>parseInt(w,10)).sort(Nh);this.layers=[];for(const w of f){const C=p[w];C.sort((v,I)=>{const E=i[v.id],R=i[I.id];return E<R?-1:E>R?1:0});for(const v of C)v instanceof yr&&this.internalContainerRefs.push(v),this.layers.push(v)}this.layersByDepth=p,f=Object.keys(d).map(w=>parseInt(w,10)).sort(Nh);const g=this.inputs.slice(),y=[];for(const w of f)for(const C of d[w]){const v=C.outboundLayer;if(v!=null){for(const I of C.inputTensors)if(g.indexOf(I)===-1)throw new rr(`Graph disconnected: cannot obtain value for tensor ${I} at layer "${v.name}". The following previous layers were accessed without issue: ${y}`);for(const I of C.outputTensors)g.push(I);y.push(v.name)}}this.nodesByDepth=d;const b=this.layers.map(w=>w.name);for(const w of b){const C=b.filter(v=>v===w).length;if(C!==1)throw new rr(`The name "${w}" is used ${C} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(b))}this.outboundNodes=[],this.inboundNodes=[],new Nf({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(w=>null),outputMasks:this.outputs.map(w=>null),inputShapes:this.inputs.map(w=>w.shape),outputShapes:this.outputs.map(w=>w.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new K("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.layers)t.push(...s.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const s={};let r=0;const o=iV(e);o&&this.parseWeights(e);for(const a of this.layers)for(const[l,u]of a.weights.entries()){const c=o?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(s[c]!=null)throw new K(`Duplicate weight name: ${c}`);s[c]=u,r++}const i=[];for(const a in e){let l=a;if(s[a]==null){const u=a.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(s[l]!=null)i.push([s[l],e[a]]);else if(t)throw new K(`Provided weight data has no target variable: ${a}`);delete s[l]}if(t){const a=[];for(const l in s)a.push(l);if(a.length>0)throw new K(`${a.length} of ${r} weights are not set: ${a}`)}i0(i)}parseWeights(e){for(const t in Object.keys(e)){const s=t.split("/"),r=["vars","layer_checkpoint_dependencies"],o=s.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!r.includes(i)).join("/");o!==t&&(e[o]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${SI}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const s=Hg(this.updatedConfig());return t?JSON.stringify(s):s}call(e,t){return oe(()=>{e=Pt(e);const s=new Ko;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],e[r]);return Yl(this.outputs,s,t)})}computeMask(e,t){return oe(()=>{e=Pt(e);let s;return t==null?s=oa(null,e.length):s=Pt(t),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const t=md(e);if(t.length!==this.inputLayers.length)throw new K(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let a=0;a<t.length;a++){const l=this.inputLayers[a],u=t[a],c=l.name+"_0_0";s[c]=u}const r=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(Nh);if(r.length>1)for(const a of r){const l=this.nodesByDepth[a];for(const u of l){const c=u.outboundLayer;if(this.inputLayers.map(g=>g.id).indexOf(c.id)!==-1)continue;const h=[];for(let g=0;g<u.inboundLayers.length;g++){const y=u.inboundLayers[g],b=u.nodeIndices[g],w=u.tensorIndices[g],C=`${y.name}_${b}_${w}`,v=s[C];h.push(v)}const d=c.computeOutputShape(xs(h)),p=md(d),f=c.inboundNodes.indexOf(u);for(let g=0;g<p.length;g++){const y=`${c.name}_${f}_${g}`;s[y]=p[g]}}}const o=[],i=[];for(let a=0;a<this.outputLayers.length;a++){const l=this.outputLayers[a],u=this.outputLayersNodeIndices[a],c=this.outputLayersTensorIndices[a],h=`${l.name}_${u}_${c}`;i.push(h)}for(let a=0;a<i.length;a++){const l=i[a];Pr(l in s),o.push(s[l])}return xs(o)}runInternalGraph(e,t){t==null&&(t=oa(null,e.length));const s={};for(let l=0;l<this.inputs.length;++l){const u=this.inputs[l],c=e[l],h=t[l];s[u.id]=[c,h]}const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Nh);for(const l of r){const u=this.nodesByDepth[l];for(const c of u){const h=c.outboundLayer,d=c.inputTensors,p=c.outputTensors,f=new Array;for(const g of d)g.id in s&&f.push(s[g.id]);if(f.length===d.length){let g={},y,b,w,C;if(c.callArgs!=null&&(g=c.callArgs),f.length===1){const[v,I]=f[0];g.mask==null&&(g.mask=I),w=Pt(h.call(v,g)),C=Pt(h.computeMask(v,I)),y=[v],b=[I]}else y=f.map(v=>v[0]),b=f.map(v=>v[1]),g.mask==null&&(g.mask=b),w=Pt(h.call(y,g)),C=Pt(h.computeMask(y,b));if(h.activityRegularizer)throw new xt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let v=0;v<p.length;++v){const I=p[v],E=w[v],R=C[v];s[I.id]=[E,R]}}}}const o=[],i=[],a=[];for(const l of this.outputs){Pr(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=s[l.id];a.push(u.shape),o.push(u),i.push(c)}return[o,i,a]}buildNodeConversionMap(e){const t={};let s;for(const r of this.layers){s=r instanceof yr?1:0;for(let o=0;o<r.inboundNodes.length;o++){const i=yr.nodeKey(r,o);this.containerNodes.has(i)&&(t[i]=s,s+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new K("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const s of this.layers)if(s.name===e)return s;throw new K(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new K(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return oe(()=>{const e=[];for(const t of this.layers)for(let s=0;s<t.inboundNodes.length;++s){const r=yr.nodeKey(t,s);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),s=[];for(const i of this.layers){const a=i.getClassName(),l=i.getConfig(),u=[];for(let h=0;h<i.inboundNodes.length;h++){const d=i.inboundNodes[h],p=yr.nodeKey(i,h);let f={};if(this.containerNodes.has(p)){if(d.callArgs)try{JSON.stringify(d.callArgs),f=d.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(d.inboundLayers.length>0){const g=[];for(let y=0;y<d.inboundLayers.length;y++){const b=d.inboundLayers[y],w=d.nodeIndices[y],C=d.tensorIndices[y],v=yr.nodeKey(b,w);let I=t[v];I==null&&(I=0),g.push([b.name,I,C,f])}u.push(g)}}}const c={};c.name=i.name,c.className=a,c.config=l,c.inboundNodes=u,s.push(c)}e.layers=s;const r=[];for(let i=0;i<this.inputLayers.length;i++){const a=this.inputLayers[i],l=this.inputLayersNodeIndices[i],u=yr.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=t[u];c==null&&(c=0);const h=this.inputLayersTensorIndices[i];r.push([a.name,c,h])}e.inputLayers=r;const o=[];for(let i=0;i<this.outputLayers.length;i++){const a=this.outputLayers[i],l=this.outputLayersNodeIndices[i],u=yr.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=t[u];c==null&&(c=0);const h=this.outputLayersTensorIndices[i];o.push([a.name,c,h])}return e.outputLayers=o,e}static fromConfig(e,t,s={},r=!1){const o={},i={};function a(y,b){y.name in i?i[y.name].push(b):i[y.name]=[b]}function l(y,b){const w=[];let C;for(const v of b){const I=v[0],E=v[1],R=v[2];if(C=v[3]==null?{}:v[3],!(I in o)){a(y,b);return}const L=o[I];if(L.inboundNodes.length<=E){a(y,b);return}const D=L.inboundNodes[E];w.push(D.outputTensors[R])}w.length>0&&y.apply(xs(w),C)}function u(y){const b=y.name,w=go(y,t.customObjects!=null?t.customObjects:{});w.setFastWeightInitDuringBuild(r),o[b]=w,y.inboundNodes.forEach(v=>{if(!(v instanceof Array))throw new K(`Corrupted configuration, expected array for nodeData: ${v}`);a(w,v)})}const c=t.name,h=t.layers;for(const y of h)u(y);for(;!GM(i);)for(const y of h){const b=o[y.name];if(b.name in i){const w=i[b.name];delete i[b.name];for(const C of w)l(b,C)}}const d=[],p=[],f=t.inputLayers;for(const y of f){const b=y[0],w=y[1],C=y[2];Pr(b in o);const I=o[b].inboundNodes[w].outputTensors;d.push(I[C])}const g=t.outputLayers;for(const y of g){const b=y[0],w=y[1],C=y[2];Pr(b in o);const I=o[b].inboundNodes[w].outputTensors;p.push(I[C])}return new e({inputs:d,outputs:p,name:c})}get stateful(){if(this._stateful)throw new K("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){oe(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function aV(n,e,t){const s=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(r=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const r=[];return e.forEach(o=>{o in n?r.push(n[o]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${t} must be either an array with ${s} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function II(n,e){return aV(n,e,"classWeight")}async function $I(n,e,t,s){if(t!=null){const r=oe(()=>{if(n.shape.length===1)return mo(n);if(n.shape.length===2){if(n.shape[1]>1)return Qa(n,1);if(n.shape[1]===1)return j(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),o=Array.from(await r.data());vt(r);const i=[];return o.forEach(a=>{if(t[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);i.push(t[a])}),us(i,"float32")}else return null}function lV(n,e){return H(n,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const uV=32;function NI(n,e){let t,s;const r=e;t=r.xs,s=r.ys,A(t!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const o=Tv("input",n.inputNames,t),i=Tv("output",n.outputNames,s),a=o[0].shape[0];A(o.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${o.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),A(i.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<o.length;l++)A(o[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<i.length;l++)A(i[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:o,ys:i}}function Tv(n,e,t){if(t instanceof sn)return[t];if(Array.isArray(t))return A(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const s=[];for(const r of e){if(t[r]==null)throw new K(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);s.push(t[r])}return s}}function cV(n){if(n.length===3)throw new xt("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function hV(n,e,t){const s=t.batchesPerEpoch!=null;if(A(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),A(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),A(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),A(!s||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),A(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=t.validationData!=null;let o,i;if(r)if(Ev(t.validationData))A(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const y=cV(t.validationData);o=y.xs,i=y.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let u;r?u=l.slice().concat(l.map(y=>"val_"+y)):u=l.slice();const c=gI(t.callbacks,t.yieldEvery),h=t.verbose==null?1:t.verbose,{callbackList:d,history:p}=yI(c,h,t.epochs,null,null,dV(e,t),null,r,u);d.setModel(n),n.history=p,await d.onTrainBegin(),n.stopTraining_=!1;let f=t.initialEpoch==null?0:t.initialEpoch,g=await e.iterator();for(;f<t.epochs;){const y={};await d.onEpochBegin(f);let b=0,w=0;for(s||(g=await e.iterator());!s||b<t.batchesPerEpoch;){const C=await g.next();if(s&&C.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${b} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(C.value!=null){const{xs:v,ys:I}=NI(n,C.value),E={};E.batch=w,E.size=v[0].shape[0],await d.onBatchBegin(w,E);const R=[];if(t.classWeight!=null){const F=II(t.classWeight,n.outputNames);for(let T=0;T<F.length;++T)R.push(await $I(I[T],null,F[T]))}const L=v.concat(I).concat(R),D=a(L);vt(L);for(let F=0;F<l.length;++F){const T=l[F],V=D[F];E[T]=V,Rn(V)}await d.onBatchEnd(w,E),mI(E),w++,b++}if(s?b>=t.batchesPerEpoch:C.done){if(r){let v;Ev(t.validationData)?v=Pt(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):v=Pt(n.evaluate(o,i,{batchSize:t.validationBatchSize==null?uV:t.validationBatchSize,verbose:0}));for(let I=0;I<n.metricsNames.length;++I)y[`val_${n.metricsNames[I]}`]=v[I]}break}if(n.stopTraining_)break}if(await d.onEpochEnd(f,y),f++,n.stopTraining_)break}return await d.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function dV(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function Ev(n){return typeof n.iterator=="function"}function pV(n){return typeof n.next=="function"}async function fV(n,e,t){t=t||{};const s=t.batches!=null,r=n.testFunction;let o=[];if(t.verbose>0)throw new xt("Verbose mode is not implemented yet.");A(!s||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const i=pV(e)?e:await e.iterator();let a=0,l=0;for(;!s||l<t.batches;){const u=await i.next();if(o=oe(()=>{if(u.value){const{xs:c,ys:h}=NI(n,u.value),d=c.concat(h),p=oe(()=>r(d));if(vt(d),l===0)for(let g=0;g<p.length;++g)o.push(it(0));const f=d[0].shape[0];for(let g=0;g<p.length;++g){const y=p[g],b=o[g];o[g]=oe(()=>Ne(o[g],H(f,y))),l>0&&vt(b)}vt(p),a+=f,++l}return o}),u.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<o.length;++u){const c=o[u];o[u]=nt(o[u],a),vt(c)}return xs(o)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Km(n){A(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Wl(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(s=>ji(s,e,t-e)):ji(n,e,t-e)}function jg(n,e){return oe(()=>n==null?null:Array.isArray(n)?n.map(t=>jg(t,e)):tI(n,e.dtype==="int32"?e:Ue(e,"int32")))}function qm(n,e){const t=[];let s=0,r=null;for(;s<n;)r=s+e,r>=n&&(r=n),t.push([s,r]),s=r;return t}function TI(n){const e=[];n instanceof sn&&(n=[n]);for(let t=0;t<n.length;++t){const s=n[t];if(s.rank===1)e.push(Mc(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function gr(n,e){if(n==null)return;const t=[];if(e instanceof sn)t.push(e.id);else if(Array.isArray(e))e.forEach(r=>t.push(r.id));else if(e!=null)for(const r in e){const o=e[r];t.push(o.id)}const s=[];if(n instanceof sn)t.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(r=>{t.indexOf(r.id)===-1&&s.push(r)});else if(n!=null)for(const r in n){const o=n[r];t.indexOf(o.id)===-1&&s.push(o)}s.forEach(r=>{r.isDisposed||r.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function mV(n){return n instanceof sn}function Kg(n){return Array.isArray(n)}function _v(n){return!mV(n)&&!Kg(n)}function Av(n,e,t,s=!0,r=""){if(e==null||e.length===0){if(n!=null){let i=!1;if(Kg(n)&&n.length>0)i=!0;else if(_v(n)){for(const a in n)if(n.hasOwnProperty(a)){i=!0;break}}else i=!0;if(i)throw new K(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(i=>null);let o;if(_v(n)){n=n,o=[];for(const i of e){if(n[i]==null)throw new K(`No data provided for "${i}". Need data for each key in: ${e}`);o.push(n[i])}}else if(Kg(n)){if(n=n,n.length!==e.length)throw new K(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);o=n}else{if(n=n,e.length>1)throw new K(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);o=[n]}if(o=TI(o),t!=null)for(let i=0;i<e.length;++i){if(t[i]==null)continue;const a=o[i];if(a.shape.length!==t[i].length)throw new K(`Error when checking ${r}: expected ${e[i]} to have ${t[i].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<t[i].length;++l){if(l===0&&!s)continue;const u=a.shape[l],c=t[i][l];if(c!=null&&c>=0&&u!==c)throw new K(`${r} expected a batch of elements where each example has shape [${t[i].slice(1,t[i].length)}] (i.e.,tensor shape [*,${t[i].slice(1,t[i].length)}]) but the ${r} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return o}function gV(n,e,t){const s=Zo(n.map(o=>o.shape[0]));s.sort();const r=Zo(e.map(o=>o.shape[0]));if(r.sort(),s.length>1)throw new K(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(o=>o.shape))}`);if(r.length>1)throw new K(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(o=>o.shape))}`);if(s.length>0&&r.length>0&&!Tt(s,r))throw new K(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function yV(n,e,t){const s=[Tf,Ef,xu];for(let r=0;r<n.length;++r){const o=n[r],i=e[r],a=t[r];if(i!=null){if(i===xu&&o.shape[o.shape.length-1]===1)throw new K(`You are passing a target array of shape ${o.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(i)!==-1){const l=o.shape.slice(1),u=a.slice(1);for(let c=0;c<l.length;++c){const h=l[c],d=u[c];if(d!=null&&h!==d)throw new K(`A target Tensor with shape ${o.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function Rv(n,e,t,s=!0,r=""){let o;if(Array.isArray(n)){if(n.length!==e.length)throw new K(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);o=n}else{if(e.length>1)throw new K(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);o=[n]}if(t!=null)for(let i=0;i<e.length;++i){if(t[i]==null)continue;const a=o[i];if(a.shape.length!==t[i].length)throw new K(`Error when checking ${r}: expected ${e[i]} to have ${t[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<t[i].length;++l){if(l===0&&!s)continue;const u=a.shape[l],c=t[i][l];if(c!=null&&c!==u)throw new K(`Error when checking ${r}: expected ${e[i]} to have shape ${JSON.stringify(t[i])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function bV(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(s=>t);{const s=[];for(const r of e){let o=t.hasOwnProperty(r)?t[r]:[];Array.isArray(o)||(o=[o]),s.push(o)}return s}}const xV="layers-model";class Ua extends yr{constructor(e){super(e),this.isTraining=!1}summary(e,t,s=console.log){if(!this.built)throw new K("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");tV(this,e,t,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=eV(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof wi))throw new K("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const i in e.loss)if(this.outputNames.indexOf(i)===-1)throw new K(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(const i of this.outputNames)e.loss[i]==null&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),t.push(jm(e.loss[i]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new K(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(a=>jm(a))}else{const i=jm(e.loss);this.outputs.forEach(a=>{t.push(i)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){const a=this.internalOutputShapes[i],l=this.outputNames[i];this.feedOutputNames.push(l),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[i])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Hi("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(s.indexOf(i)!==-1)continue;const a=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([a,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});const r=bV(e.metrics,this.outputNames),o=(i,a,l)=>{this.outputNames.length>1&&(a=this.outputNames[i]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([l,i])};Hi("metric",()=>{for(let i=0;i<this.outputs.length;++i){if(s.indexOf(i)!==-1)continue;const a=r[i];(u=>{const c="";let h,d,p;for(const f of u){if(typeof f=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(f)!==-1){const y=this.internalOutputShapes[i];y[y.length-1]===1||this.lossFunctions[i]===Ef?["accuracy","acc"].indexOf(f)!==-1?d=xI:["crossentropy","ce"].indexOf(f)!==-1&&(d=GB):this.lossFunctions[i]===wd?["accuracy","acc"].indexOf(f)!==-1?d=HB:["crossentropy","ce"].indexOf(f)!==-1&&(d=kI):["accuracy","acc"].indexOf(f)!==-1?d=wI:["crossentropy","ce"].indexOf(f)!==-1&&(d=vI);let b;["accuracy","acc"].indexOf(f)!==-1?b="acc":["crossentropy","ce"].indexOf(f)!==-1&&(b="ce"),p=d,h=c+b}else p=QB(f),h=c+_h(f);let g;Hi(h,()=>{g=p}),o(i,h,g)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,s={}){const r=s.batchSize==null?32:s.batchSize;Km(r);const i=this.standardizeUserDataXY(e,t,!0,r);try{const a=i[0].concat(i[1]);this.makeTestFunction();const l=this.testFunction,u=this.testLoop(l,a,r,s.verbose,s.steps);return xs(u)}finally{gr(i[0],e),gr(i[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),fV(this,e,t)}checkNumSamples(e,t,s,r="steps"){let o;if(s!=null){if(o=null,t!=null)throw new K(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?o=e[0].shape[0]:o=e.shape[0];else throw new K(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return o}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new K("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(t),r=s?t:[t],o=this.retrieveSymbolicTensors(r),i=new Ko;if(e instanceof sn&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new K(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)i.add(this.inputs[l],e[l])}else for(const l of this.inputs){const u=e[l.name];if(u==null)throw new K(`No value is provided for the model's input ${l.name}`);i.add(l,u)}const a=Yl(o,i);return s?a:a[0]}retrieveSymbolicTensors(e){const t=oa(null,e.length);let s=e.length;for(const r of this.layers){const o=Array.isArray(r.output)?r.output:[r.output],i=o.map(a=>a.name);for(let a=0;a<e.length;++a){const l=i.indexOf(e[a]);if(l!==-1&&(t[a]=o[l],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw t.forEach((o,i)=>{o==null&&r.push(e[i])}),new K(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,s=!1){return oe(()=>{const r=this.checkNumSamples(e);if(s)throw new xt("Verbose predictLoop() is not implemented yet.");const o=qm(r,t),i=this.outputs.map(a=>[]);for(let a=0;a<o.length;++a)oe(()=>{const u=o[a][0],c=o[a][1],h=Wl(e,u,c),d=[];if(Array.isArray(h))for(let f=0;f<h.length;++f)d.push({key:this.inputs[f],value:h[f]});else d.push({key:this.inputs[0],value:h});const p=new Ko(d);return Yl(this.outputs,p)}).forEach((u,c)=>i[c].push(u));return xs(i.map(a=>bn(a,0)))})}predict(e,t={}){const s=TI(e);Rv(s,this.inputNames,this.feedInputShapes,!1);try{const r=t.batchSize==null?32:t.batchSize;return Km(r),this.predictLoop(s,r)}finally{gr(s,e)}}predictOnBatch(e){Rv(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,s=!0,r){if(this.optimizer_==null)throw new rr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const o=[];for(let i=0;i<this.feedOutputShapes.length;++i){const a=this.feedOutputShapes[i];this.feedLossFns[i]===wd?o.push(a.slice(0,a.length-1).concat([1])):o.push(a)}if(e=Av(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=Av(t,this.feedOutputNames,o,!1,"target"),gV(e,t),yV(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new K(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,s,r,o=!0,i){const[a,l]=this.standardizeUserDataXY(e,t,o,i);if(s!=null)throw new Error("sample weight is not supported yet.");let u=null;if(r!=null){const c=II(r,this.outputNames);u=[];for(let h=0;h<c.length;++h)u.push(await $I(l[h],null,c[h]))}return[a,l,u]}testLoop(e,t,s,r=0,o){return oe(()=>{const i=this.checkNumSamples(t,s,o,"steps"),a=[];if(r>0)throw new xt("Verbose mode is not implemented yet.");if(o!=null)throw new xt("steps mode in testLoop() is not implemented yet");{const l=qm(i,s),u=us(Ir(0,i));for(let c=0;c<l.length;++c){const h=l[c][0],d=l[c][1],p=ji(u,h,d-h),f=jg(t,p),g=e(f);if(c===0)for(let y=0;y<g.length;++y)a.push(it(0));for(let y=0;y<g.length;++y){const b=g[y];a[y]=Ne(a[y],H(d-h,b))}}for(let c=0;c<a.length;++c)a[c]=nt(a[c],i)}return a})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let s=0;s<e.length;++s){const r=e[s];let o=r;if(gv(e,r)>1){const i=gv(e.slice(0,s),r);o+=`_${i}`}t.push(o)}return t}makeTrainFunction(){return e=>{const t=[],s=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),i=[],a=()=>{const h=[];for(let g=0;g<this.inputs.length;++g)h.push({key:this.inputs[g],value:s[g]});const d=new Ko(h),p=Yl(this.outputs,d,{training:!0});let f;for(let g=0;g<this.lossFunctions.length;++g){const y=this.lossFunctions[g];let b=y(r[g],p[g]);o[g]!=null&&(b=lV(b,o[g]));const w=ln(b);t.push(w),g===0?f=b:f=Ne(f,b)}for(let g=0;g<this.metricsTensors.length;++g){let y;if(this.outputs.length>1&&g<this.outputs.length)y=t[g];else{const b=this.metricsTensors[g][0],w=this.metricsTensors[g][1];y=ln(b(r[w],p[w]))}Rn(y),i.push(y)}return f=ln(f),this.calculateLosses().forEach(g=>{f=Ne(f,g)}),f},l=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(a,!0,l)].concat(i)}}makeTestFunction(){this.testFunction=e=>oe(()=>{const t=[];let s;const r=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let u=0;u<this.inputs.length;++u)i.push({key:this.inputs[u],value:r[u]});const a=new Ko(i),l=Yl(this.outputs,a);for(let u=0;u<this.lossFunctions.length;++u){const c=this.lossFunctions[u],h=ln(c(o[u],l[u]));u===0?s=h:s=Ne(s,h),t.push(s)}for(let u=0;u<this.metricsTensors.length;++u){const c=this.metricsTensors[u][0],h=this.metricsTensors[u][1],d=ln(c(o[h],l[h]));t.push(d)}return t})}async fit(e,t,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,o,i,a,l,u,c,h,d;try{const p=s.batchSize==null?32:s.batchSize;Km(p);const g=await this.standardizeUserData(e,t,s.sampleWeight,s.classWeight,!1,p);r=g[0],o=g[1],d=g[2];let y=!1,b;if(s.validationData!=null&&s.validationData.length>0){if(y=!0,s.validationData.length===2)l=s.validationData[0],u=s.validationData[1];else throw s.validationData.length===3?new xt("validationData including sample weights is not supported yet."):new K(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const F=await this.standardizeUserData(l,u,null,null,!0,p);c=F[0],h=F[1],b=c.concat(h)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){y=!0;const D=Math.floor(r[0].shape[0]*(1-s.validationSplit)),F=r[0].shape[0];c=Wl(r,D,F),i=r,r=Wl(r,0,D),h=Wl(o,D,F),a=o,o=Wl(o,0,D),b=c.concat(h)}else s.validationSteps!=null&&(y=!0);const w=r.concat(o).concat(d);this.checkTrainableWeightsConsistency();const C=this.makeTrainFunction(),v=this.getDedupedMetricsNames();let I,E;y?(this.makeTestFunction(),I=this.testFunction,E=v.slice().concat(v.map(D=>"val_"+D))):(I=null,b=[],E=v.slice());const R=gI(s.callbacks,s.yieldEvery);return await this.fitLoop(C,w,v,p,s.epochs,s.verbose,R,I,b,s.shuffle,E,s.initialEpoch,null,null)}finally{this.isTraining=!1,gr(r,e),gr(o,t),gr(i,e),gr(a,t),gr(c,l),gr(h,u),d!=null&&vt(d)}}async fitLoop(e,t,s,r,o,i,a,l,u,c,h,d,p,f){r==null&&(r=32),o==null&&(o=1),c==null&&(c=!0),d==null&&(d=0);let g=!1;if(l!=null&&u!=null&&(g=!0),f!=null&&(g=!0,p==null))throw new K("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const y=this.checkNumSamples(t,r,p,"steps_per_epoch");let b;y!=null&&(b=Ir(0,y)),i==null&&(i=1);const{callbackList:w,history:C}=yI(a,i,o,d,y,p,r,g,h);w.setModel(this),this.history=C,await w.onTrainBegin(),this.stopTraining_=!1;for(let v=d;v<o;++v){await w.onEpochBegin(v);const I={};if(p!=null)throw new xt("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new xt("batch shuffling is not implemneted yet");c&&i_(b);const E=us(b),R=qm(y,r);for(let L=0;L<R.length;++L){const D={};if(await w.onBatchBegin(L,D),oe(()=>{const F=R[L][0],T=R[L][1],V=ji(E,F,T-F);D.batch=L,D.size=T-F;const q=jg(t,V),se=e(q);for(let ee=0;ee<s.length;++ee){const te=s[ee],le=se[ee];D[te]=le,Rn(le)}if(L===R.length-1&&g){const ee=this.testLoop(l,u,r);for(let te=0;te<s.length;++te){const le=s[te],Q=ee[te];Rn(Q),I["val_"+le]=Q}}}),await w.onBatchEnd(L,D),mI(D),this.stopTraining_)break}E.dispose()}if(await w.onEpochEnd(v,I),this.stopTraining_)break}return await w.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return hV(this,e,t)}async trainOnBatch(e,t){const s=await this.standardizeUserData(e,t),r=s[0],o=s[1],a=this.makeTrainFunction()(r.concat(o)),l=[];for(const u of a){const c=await u.data();l.push(c[0])}return vt(a),gr(s[0],e),gr(s[1],t),xs(l)}getNamedWeights(e){const t=[],s=e!=null&&e.trainableOnly,r=s?this.trainableWeights:this.weights,o=this.getWeights(s);for(let i=0;i<r.length;++i)s&&!r[i].trainable||t.push({name:r[i].originalName,tensor:o[i]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=Gw().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Gw().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=ao(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>ao(t))}else{const t=Object.keys(this.loss);e={};const s=this.loss;for(const r of t)if(typeof s[r]=="string")e[r]=ao(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[ao(_h(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>ao(_h(e)));{const e={};for(const t in this.metrics)e[t]=ao(_h(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=Gg(e.optimizer_config),s=go(t);let r;if(typeof e.loss=="string")r=Bi(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(i=>Bi(i));else if(e.loss!=null){r={};for(const i in e.loss)r[i]=Bi(e.loss[i])}let o;if(Array.isArray(e.metrics))o=e.metrics.map(i=>Bi(i));else if(e.metrics!=null){o={};for(const i in e.metrics)o[i]=Bi(e.metrics[i])}this.compile({loss:r,metrics:o,optimizer:s})}async save(e,t){if(typeof e=="string"){const u=Mk(e);if(u.length===0)throw new K(`Cannot find any save handlers for URL '${e}'`);if(u.length>1)throw new K(`Found more than one (${u.length}) save handlers for URL '${e}'`);e=u[0]}if(e.save==null)throw new K("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await Ng(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:xV,generatedBy:`TensorFlow.js tfjs-layers v${SI}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const u="optimizer",{data:c,specs:h}=await Ng(await this.optimizer.getWeights(),u);s.specs.push(...h),s.data=Lk([s.data,c])}return this.userDefinedMetadata!=null&&(Nv(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=s.data,a.weightSpecs=s.specs,e.save(a)}setUserDefinedMetadata(e){Nv(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Ua.className="Model";Te(Ua);class EI extends Ua{}EI.className="Functional";Te(EI);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class wu extends Ua{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:If("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new K(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof wu||e instanceof Ua;let s;if(t){if(s=e,s.outputs.length!==1)throw new K("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new K("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new K("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=vB({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(t)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new K(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new K("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=cI(this.outputs[0])}this.inboundNodes=[],new Nf({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:oa(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(Ot(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Ua({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,s=console.log){this.built||this.build(),super.summary(e,t,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,s={}){if(!this.built)throw new rr("The model needs to be compiled before being used.");return this.model.evaluate(e,t,s)}async evaluateDataset(e,t){if(!this.built)throw new rr("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,s={}){if(!this.built)throw new rr("The model needs to be compiled before being used.");return this.model.fit(e,t,s)}async fitDataset(e,t){if(!this.built)throw new rr("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,s={},r=!1){let o,i={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new K("Legacy serialization format not supported yet.");o=t}else A(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=t.layers,delete t.layers,i=t;const a=new e(i);if(!(a instanceof wu))throw new xt(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const l of o){const c=go(l,void 0,r);r&&c.setFastWeightInitDuringBuild(!0),a.add(c)}return a}set stopTraining(e){if(this.model==null)throw new K("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new K("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const s={};s.className=t.getClassName(),s.config=t.getConfig(),e.push(s)}return{name:this.name,layers:e}}}wu.className="Sequential";Te(wu);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Zn=class extends wl{getConfig(){return{}}};class _I extends Zn{apply(e,t=1){return oB(e,t)}}_I.className="elu";Te(_I);class AI extends Zn{apply(e){return rx(e)}}AI.className="selu";Te(AI);class RI extends Zn{apply(e){return to(e)}}RI.className="relu";Te(RI);class DI extends Zn{apply(e){return oe(()=>sa(6,to(e)))}}DI.className="relu6";Te(DI);class OI extends Zn{apply(e){return e}}OI.className="linear";Te(OI);class FI extends Zn{apply(e){return Ur(e)}}FI.className="sigmoid";Te(FI);class LI extends Zn{apply(e){return aB(e)}}LI.className="hardSigmoid";Te(LI);class PI extends Zn{apply(e){return yl(e)}}PI.className="softplus";Te(PI);class zI extends Zn{apply(e){return iB(e)}}zI.className="softsign";Te(zI);class MI extends Zn{apply(e){return na(e)}}MI.className="tanh";Te(MI);let c0=class extends Zn{apply(e,t=-1){return ff(e,t)}};c0.className="softmax";Te(c0);class BI extends Zn{apply(e,t=-1){return Xb(e,t)}}BI.className="logSoftmax";Te(BI);class VI extends Zn{apply(e){return oe(()=>oe(()=>{const t=Math.sqrt(2),s=H(.5,Ne(1,jb(nt(e,t))));return H(e,s)}))}}VI.className="gelu";Te(VI);class WI extends Zn{apply(e){return oe(()=>H(.5,H(e,Ne(1,na(H(Vn(nt(2,Math.PI)),Ne(e,H(.044715,bo(e,3)))))))))}}WI.className="gelu_new";Te(WI);class UI extends Zn{apply(e){return oe(()=>H(e,na(yl(e))))}}UI.className="mish";Te(UI);class GI extends Zn{apply(e,t=1){return oe(()=>H(Ur(H(e,t)),e))}}GI.className="swish";Te(GI);function ii(n){return n.getClassName()}function Xm(n,e={}){return zc(n,nr.getMap().classNameMap,e,"activation")}function ai(n){if(n==null){const e={};return e.className="linear",e.config={},Xm(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},Xm(e)}else return n instanceof Zn?n:Xm(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function wV(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class HI extends wl{}class jI extends HI{constructor(e){super(),wV(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return oe(()=>{let t=kn([1]);return this.hasL1&&(t=Ne(t,Qe(H(this.l1,vn(e))))),this.hasL2&&(t=Ne(t,Qe(H(this.l2,Bc(e))))),j(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}jI.className="L1L2";Te(jI);const Dv={l1l2:"L1L2"};function Ut(n){return Yx(n)}function Ov(n,e={}){return zc(n,nr.getMap().classNameMap,e,"regularizer")}function Jt(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in Dv?Dv[n]:n,config:{}};return Ov(t)}else return n instanceof HI?n:Ov(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class KI extends Ct{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=ct(e);let s=to(e);return this.maxValue!=null&&(s=Os(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}KI.className="ReLU";Te(KI);class qI extends Ct{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=ct(e);return nf(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}qI.className="LeakyReLU";Te(qI);class XI extends Ct{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Zt(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Jt(e.alphaRegularizer),this.alphaConstraint=Nn(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new K(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Ot(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)s[r]=e[r];this.inputSpec=[new Sn({ndim:e.length,axes:s})],this.built=!0}call(e,t){return e=ct(e),cf(e,this.alpha.read())}getConfig(){const e={alphaInitializer:on(this.alphaInitializer),alphaRegularizer:Ut(this.alphaRegularizer),alphaConstraint:$n(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}XI.className="PReLU";Te(XI);let YI=class extends Ct{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new xt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=ct(e);return Ac(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};YI.className="ELU";Te(YI);class ZI extends Ct{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const s=ct(e);return H(s,Ue(Bs(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}ZI.className="ThresholdedReLU";Te(ZI);class JI extends Ct{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new c0().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return oe(()=>{let s=ct(e);const r=t.mask;if(r!=null){const o=H(Ke(As(s.shape),Ue(r,s.dtype)),it(-1e9));s=Ne(s,o)}return this.axis instanceof Array?this.axis.length>1?Fs(Ke(s,rf(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}JI.className="Softmax";Te(JI);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Ga(n,e,t){if(typeof n=="number")return oa(n,e);if(n.length!==e)throw new K(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let s=0;s<e;++s){const r=n[s];if(!tB(r))throw new K(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function vr(n,e,t,s,r=1){if(n==null)return n;const o=e+(e-1)*(r-1);let i;return t==="same"?i=n:i=n-o+1,Math.floor((i+s-1)/s)}function zr(n,e,t,s){if(n==null)return null;if(s==="valid")n=n*e+oi([t-e,0]);else if(s==="same")n=n*e;else throw new K(`Unsupport padding mode: ${s}.`);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function h0(n,e){return oe(()=>(fn(e),e==="channelsFirst"?_t(n,[0,2,3,1]):n))}function QI(n,e){return oe(()=>(fn(e),e==="channelsFirst"?_t(n,[0,2,3,4,1]):n))}function vV(n,e,t,s=1,r="valid",o,i=1){return oe(()=>{if(o==null&&(o=$r()),fn(o),n.shape.length!==3)throw new K(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new K(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new K(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(o==="channelsFirst"&&(n=_t(n,[0,2,1])),r==="causal")throw new xt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=Vb(n,e,s,r==="same"?"same":"valid","NWC",i);return t!=null&&(a=Er(a,t)),a})}function Fv(n,e,t,s=[1,1],r="valid",o,i,a=null){return oe(()=>{if(o==null&&(o=$r()),fn(o),n.rank!==3&&n.rank!==4)throw new K(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new K(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=h0(n,o);if(r==="causal")throw new xt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=jC({x:l,filter:e,strides:s,pad:r==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:t,activation:a}),o==="channelsFirst"&&(l=_t(l,[0,3,1,2])),l})}function kV(n,e,t,s=[1,1,1],r="valid",o,i){return oe(()=>{if(o==null&&(o=$r()),fn(o),n.rank!==4&&n.rank!==5)throw new K(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new K(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=QI(n,o);if(r==="causal")throw new xt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=dC(a,e,s,r==="same"?"same":"valid","NDHWC",i),t!=null&&(a=Er(a,t)),o==="channelsFirst"&&(a=_t(a,[0,4,1,2,3])),a})}class _f extends Ct{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",_f.verifyArgs(t),this.rank=e,Dn(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new xt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Ga(t.kernelSize,e,"kernelSize"),this.strides=Ga(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,Ys(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,fn(this.dataFormat),this.activation=ai(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=Zt(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Nn(t.biasConstraint),this.biasRegularizer=Jt(t.biasRegularizer),this.activityRegularizer=Jt(t.activityRegularizer),this.dilationRate=Ga(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new K(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new K(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new K(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(Pr("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!Zx(e.kernelSize,"number",1,3))throw new K(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:ii(this.activation),useBias:this.useBias,biasInitializer:on(this.biasInitializer),biasRegularizer:Ut(this.biasRegularizer),activityRegularizer:Ut(this.activityRegularizer),biasConstraint:$n(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class vl extends _f{constructor(e,t){super(e,t),this.kernel=null,vl.verifyArgs(t),this.filters=t.filters,Dn(this.filters,"filters"),this.kernelInitializer=Zt(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Nn(t.kernelConstraint),this.kernelRegularizer=Jt(t.kernelRegularizer)}build(e){e=Ot(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new K(`The channel dimension of the input should be defined. Found ${e[t]}`);const s=e[t],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:s}}],this.built=!0}call(e,t){return oe(()=>{e=ct(e);let s;const r=this.bias==null?null:this.bias.read(),o=XS(this.activation.getClassName());if(o!=null&&this.rank===2)s=Fv(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,o);else{if(this.rank===1)s=vV(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=Fv(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=kV(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new xt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=Ot(e);const t=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let o=0;o<s.length;++o){const i=vr(s[o],this.kernelSize[o],this.padding,this.strides[o],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[o]);t.push(i)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:on(this.kernelInitializer),kernelRegularizer:Ut(this.kernelRegularizer),kernelConstraint:$n(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new K(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class Gc extends vl{constructor(e){super(2,e),Gc.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Zx(e.kernelSize,"number",1,2))throw new K(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}Gc.className="Conv2D";Te(Gc);class Hc extends vl{constructor(e){super(3,e),Hc.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new K(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}Hc.className="Conv3D";Te(Hc);class e$ extends Gc{constructor(e){if(super(e),this.inputSpec=[new Sn({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new K(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Ot(e),e.length!==4)throw new K("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new K("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Sn({ndim:4,axes:{[t]:s}})],this.built=!0}call(e,t){return oe(()=>{let s=ct(e);if(s.shape.length!==4)throw new K(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,o=r[0];let i,a;this.dataFormat==="channelsFirst"?(i=2,a=3):(i=1,a=2);const l=r[i],u=r[a],c=this.kernelSize[0],h=this.kernelSize[1],d=this.strides[0],p=this.strides[1],f=zr(l,d,c,this.padding),g=zr(u,p,h,this.padding),y=[o,f,g,this.filters];this.dataFormat!=="channelsLast"&&(s=_t(s,[0,2,3,1]));let b=Ub(s,this.kernel.read(),y,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(b=_t(b,[0,3,1,2])),this.bias!=null&&(b=Er(b,this.bias.read(),this.dataFormat)),this.activation!=null&&(b=this.activation.apply(b)),b})}computeOutputShape(e){e=Ot(e);const t=e.slice();let s,r,o;this.dataFormat==="channelsFirst"?(s=1,r=2,o=3):(s=3,r=1,o=2);const i=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],u=this.strides[1];return t[s]=this.filters,t[r]=zr(t[r],l,i,this.padding),t[o]=zr(t[o],u,a,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}e$.className="Conv2DTranspose";Te(e$);class t$ extends Hc{constructor(e){if(super(e),this.inputSpec=[new Sn({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new K(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Ot(e),e.length!==5)throw new K("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new K("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Sn({ndim:5,axes:{[t]:s}})],this.built=!0}call(e,t){return oe(()=>{let s=ct(e);if(s.shape.length!==5)throw new K(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,o=r[0];let i,a,l;this.dataFormat==="channelsFirst"?(l=2,i=3,a=4):(l=1,i=2,a=3);const u=r[l],c=r[i],h=r[a],d=this.kernelSize[0],p=this.kernelSize[1],f=this.kernelSize[2],g=this.strides[0],y=this.strides[1],b=this.strides[2],w=zr(u,g,d,this.padding),C=zr(c,y,p,this.padding),v=zr(h,b,f,this.padding),I=[o,w,C,v,this.filters];this.dataFormat!=="channelsLast"&&(s=_t(s,[0,2,3,4,1]));let E=fC(s,this.kernel.read(),I,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(E=_t(E,[0,4,1,2,3])),this.bias!==null&&(E=Er(E,this.bias.read(),this.dataFormat)),this.activation!==null&&(E=this.activation.apply(E)),E})}computeOutputShape(e){e=Ot(e);const t=e.slice();let s,r,o,i;this.dataFormat==="channelsFirst"?(s=1,r=2,o=3,i=4):(s=4,r=1,o=2,i=3);const a=this.kernelSize[0],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],h=this.strides[1],d=this.strides[2];return t[s]=this.filters,t[r]=zr(t[r],c,a,this.padding),t[o]=zr(t[o],h,l,this.padding),t[i]=zr(t[i],d,u,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}t$.className="Conv3DTranspose";Te(t$);class n$ extends vl{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new K("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new K("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new K(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=Zt(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Jt(t.depthwiseRegularizer),this.depthwiseConstraint=Nn(t.depthwiseConstraint),this.pointwiseInitializer=Zt(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Jt(t.pointwiseRegularizer),this.pointwiseConstraint=Nn(t.pointwiseConstraint)}build(e){if(e=Ot(e),e.length<this.rank+2)throw new K(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new K(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const s=e[t],r=this.kernelSize.concat([s,this.depthMultiplier]),o=[];for(let a=0;a<this.rank;++a)o.push(1);o.push(s*this.depthMultiplier,this.filters);const i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new Sn({ndim:this.rank+2,axes:{[t]:s}})],this.built=!0}call(e,t){return oe(()=>{e=ct(e);let s;if(this.rank===1)throw new xt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=_t(e,[0,2,3,1])),s=ox(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Er(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=_t(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=on(this.depthwiseInitializer),e.pointwiseInitializer=on(this.pointwiseInitializer),e.depthwiseRegularizer=Ut(this.depthwiseRegularizer),e.pointwiseRegularizer=Ut(this.pointwiseRegularizer),e.depthwiseConstraint=$n(this.depthwiseConstraint),e.pointwiseConstraint=$n(this.pointwiseConstraint),e}}n$.className="SeparableConv";class s$ extends n${constructor(e){super(2,e)}}s$.className="SeparableConv2D";Te(s$);class Af extends vl{constructor(e){super(1,e),Af.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Zx(e.kernelSize,"number",1,1))throw new K(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}Af.className="Conv1D";Te(Af);class r$ extends Ct{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return oe(()=>{if(e=ct(e),this.dataFormat==="channelsLast"){const s=Eh(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Eh(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=Eh(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Eh(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}r$.className="Cropping2D";Te(r$);class o$ extends Ct{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,fn(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,JM(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,s]}else{const t=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],t,s,e[3]]}}call(e,t){return oe(()=>{let s=ct(e);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=_t(s,[0,2,3,1]);const o=this.size[0]*r[2],i=this.size[1]*r[3],a=this.interpolation==="nearest"?Br.resizeNearestNeighbor(s,[o,i]):Br.resizeBilinear(s,[o,i]);return _t(a,[0,3,1,2])}else{const o=this.size[0]*r[1],i=this.size[1]*r[2];return this.interpolation==="nearest"?Br.resizeNearestNeighbor(s,[o,i]):Br.resizeBilinear(s,[o,i])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}o$.className="UpSampling2D";Te(o$);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function CV(n,e,t=[1,1],s="valid",r,o){return oe(()=>{r==null&&(r=$r()),fn(r);let i=h0(n,r);if(n.rank!==4)throw new K(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new K(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return i=_c(i,e,t,s==="same"?"same":"valid","NHWC",o),r==="channelsFirst"&&(i=_t(i,[0,3,1,2])),i})}class i$ extends _f{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=Zt(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Nn(e.depthwiseConstraint),this.depthwiseRegularizer=Jt(e.depthwiseRegularizer)}build(e){if(e=Ot(e),e.length<4)throw new K(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new K(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const s=e[t],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return oe(()=>{e=ct(e);let s=CV(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Er(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=Ot(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,o=vr(t,this.kernelSize[0],this.padding,this.strides[0]),i=vr(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,o,i]:[e[0],o,i,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=on(this.depthwiseInitializer),e.depthwiseRegularizer=Ut(this.depthwiseRegularizer),e.depthwiseConstraint=$n(this.depthwiseRegularizer),e}}i$.className="DepthwiseConv2D";Te(i$);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function a$(n,e,t,s){if(Array.isArray(n)){if(e!=null||t!=null)throw new K("When inputs is an array, neither initialState or constants should be provided");s!=null&&(t=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function r(o){return o==null||Array.isArray(o)?o:[o]}return e=r(e),t=r(t),{inputs:n,initialState:e,constants:t}}function l$(n,e,t,s=!1,r,o,i=!1,a=!1){return oe(()=>{const l=e.shape.length;if(l<3)throw new K(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(Ir(2,l));e=_t(e,u),i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=Ue(Ue(r,"bool"),"float32"),r.rank===l-1&&(r=os(r,-1)),r=_t(r,u)),s&&(e=hr(e,0),r!=null&&(r=hr(r,0)));const c=[];let h,d=t;const p=e.shape[0],f=dr(e);let g;r!=null&&(g=dr(r));for(let b=0;b<p;++b){const w=f[b],C=oe(()=>n(w,d));if(r==null)h=C[0],d=C[1];else{const v=oe(()=>{const I=g[b],E=Ke(qs(I),I),R=Ne(H(C[0],I),H(d[0],E)),L=d.map((D,F)=>Ne(H(C[1][F],I),H(D,E)));return{output:R,newStates:L}});h=v.output,d=v.newStates}a&&c.push(h)}let y;return a&&(y=Ls(c,1)),[h,y,d]})}class vi extends Ct{constructor(e){super(e);let t;if(e.cell==null)throw new K("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new f0({cells:e.cell}):t=e.cell,t.stateSize==null)throw new K("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new Sn({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Ir(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Vg(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const s=t[0];let r;if(this.returnSequences?r=[e[0],e[1],s]:r=[e[0],s],this.returnState){const o=[];for(const i of t)o.push([e[0],i]);return[r].concat(o)}else return r}computeMask(e,t){return oe(()=>{Array.isArray(t)&&(t=t[0]);const s=this.returnSequences?t:null;if(this.returnState){const r=this.states.map(o=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let s=0;s<e;++s)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new xt("Constants support is not implemented in RNN yet.");Vg(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new Sn({shape:[t,null,...s]});const r=[e[0]].concat(e.slice(2));this.cell.build(r);let o;if(Array.isArray(this.cell.stateSize)?o=this.cell.stateSize:o=[this.cell.stateSize],this.stateSpec!=null){if(!Tt(this.stateSpec.map(i=>i.shape[i.shape.length-1]),o))throw new K(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=o.map(i=>new Sn({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){oe(()=>{if(!this.stateful)throw new Lr("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new K("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>kn([s,r])):this.states_=[kn([s,this.cell.stateSize])];else if(e==null)vt(this.states_),this.keptStates!=null&&(vt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>kn([s,r])):this.states_[0]=kn([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new K(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):vt(this.states_);for(let r=0;r<this.states_.length;++r){const o=e[r],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,a=[s,i];if(!Tt(o.shape,a))throw new K(`State ${r} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${o.shape}`);this.states_[r]=o}}this.states_=this.states_.map(r=>Rn(r.clone()))})}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const o=a$(e,s,r,this.numConstants);e=o.inputs,s=o.initialState,r=o.constants;let i=[],a=[];if(s!=null){t.initialState=s,i=i.concat(s),this.stateSpec=[];for(const u of s)this.stateSpec.push(new Sn({shape:u.shape}));a=a.concat(this.stateSpec)}if(r!=null&&(t.constants=r,i=i.concat(r),this.numConstants=r.length),i[0]instanceof Zr){const u=[e].concat(i),c=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=c;const d=super.apply(u,t);return this.inputSpec=h,d}else return super.apply(e,t)}call(e,t){return oe(()=>{const s=t==null?null:t.mask,r=t==null?null:t.training;let o=t==null?null:t.initialState;e=ct(e),o==null&&(this.stateful?o=this.states_:o=this.getInitialState(e));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==i)throw new K(`RNN Layer has ${i} state(s) but was passed ${o.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:r},u=l$((f,g)=>{const y=this.cell.call([f].concat(g),a);return[y[0],y.slice(1)]},e,o,this.goBackwards,s,null,this.unroll,this.returnSequences),c=u[0],h=u[1],d=u[2];this.stateful&&this.resetStates(d,r);const p=this.returnSequences?h:c;return this.returnState?[p].concat(d):p})}getInitialState(e){return oe(()=>{let t=kn(e.shape);return t=Qe(t,[1,2]),t=Mc(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?Mg(t,[1,s]):t):this.cell.stateSize>1?[Mg(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===vi.className&&(t.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),t)}static fromConfig(e,t,s={}){const r=t.cell,o=go(r,s);return new e(Object.assign(t,{cell:o}))}}vi.className="RNN";Te(vi);class Rf extends Ct{}class d0 extends Rf{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Dn(this.units,"units"),this.activation=ai(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Zt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Zt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Zt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Jt(e.kernelRegularizer),this.recurrentRegularizer=Jt(e.recurrentRegularizer),this.biasRegularizer=Jt(e.biasRegularizer),this.kernelConstraint=Nn(e.kernelConstraint),this.recurrentConstraint=Nn(e.recurrentConstraint),this.biasConstraint=Nn(e.biasConstraint),this.dropout=sl([1,oi([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=sl([1,oi([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Ot(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return oe(()=>{if(e=e,e.length!==2)throw new K(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=li({ones:()=>qs(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=li({ones:()=>qs(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let o;const i=this.dropoutMask,a=this.recurrentDropoutMask;i!=null?o=jr(H(e,i),this.kernel.read()):o=jr(e,this.kernel.read()),this.bias!=null&&(o=Er(o,this.bias.read())),a!=null&&(s=H(s,a));let l=Ne(o,jr(s,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ii(this.activation),useBias:this.useBias,kernelInitializer:on(this.kernelInitializer),recurrentInitializer:on(this.recurrentInitializer),biasInitializer:on(this.biasInitializer),kernelRegularizer:Ut(this.kernelRegularizer),recurrentRegularizer:Ut(this.recurrentRegularizer),biasRegularizer:Ut(this.biasRegularizer),activityRegularizer:Ut(this.activityRegularizer),kernelConstraint:$n(this.kernelConstraint),recurrentConstraint:$n(this.recurrentConstraint),biasConstraint:$n(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}d0.className="SimpleRNNCell";Te(d0);class u$ extends vi{constructor(e){e.cell=new d0(e),super(e)}call(e,t){return oe(()=>{this.cell.dropoutMask!=null&&(vt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(vt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,o=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:o})})}static fromConfig(e,t){return new e(t)}}u$.className="SimpleRNN";Te(u$);class p0 extends Rf{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new K("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Dn(this.units,"units"),this.activation=ai(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ai(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Zt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Zt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Zt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Jt(e.kernelRegularizer),this.recurrentRegularizer=Jt(e.recurrentRegularizer),this.biasRegularizer=Jt(e.biasRegularizer),this.kernelConstraint=Nn(e.kernelConstraint),this.recurrentConstraint=Nn(e.recurrentConstraint),this.biasConstraint=Nn(e.biasConstraint),this.dropout=sl([1,oi([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=sl([1,oi([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Ot(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return oe(()=>{if(e=e,e.length!==2)throw new K(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training==null?!1:t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=li({ones:()=>qs(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=li({ones:()=>qs(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,i=this.recurrentDropoutMask;let a,l,u;0<this.dropout&&this.dropout<1&&(e=H(e,o[0]));let c=jr(e,this.kernel.read());this.useBias&&(c=Er(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=H(r,i[0]));const h=this.recurrentKernel.read(),[d,p]=Rs(h,[2*this.units,this.units],h.rank-1),f=jr(r,d),[g,y,b]=Rs(c,3,c.rank-1),[w,C]=Rs(f,2,f.rank-1);a=this.recurrentActivation.apply(Ne(g,w)),l=this.recurrentActivation.apply(Ne(y,C));const v=jr(H(l,r),p);u=this.activation.apply(Ne(b,v));const I=Ne(H(a,r),H(Ne(1,Kt(a)),u));return[I,I]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ii(this.activation),recurrentActivation:ii(this.recurrentActivation),useBias:this.useBias,kernelInitializer:on(this.kernelInitializer),recurrentInitializer:on(this.recurrentInitializer),biasInitializer:on(this.biasInitializer),kernelRegularizer:Ut(this.kernelRegularizer),recurrentRegularizer:Ut(this.recurrentRegularizer),biasRegularizer:Ut(this.biasRegularizer),activityRegularizer:Ut(this.activityRegularizer),kernelConstraint:$n(this.kernelConstraint),recurrentConstraint:$n(this.recurrentConstraint),biasConstraint:$n(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}p0.className="GRUCell";Te(p0);class c$ extends vi{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new p0(e),super(e)}call(e,t){return oe(()=>{this.cell.dropoutMask!=null&&(vt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(vt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,o=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:o})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}c$.className="GRU";Te(c$);class Df extends Rf{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Dn(this.units,"units"),this.activation=ai(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ai(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Zt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Zt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Zt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Jt(e.kernelRegularizer),this.recurrentRegularizer=Jt(e.recurrentRegularizer),this.biasRegularizer=Jt(e.biasRegularizer),this.kernelConstraint=Nn(e.kernelConstraint),this.recurrentConstraint=Nn(e.recurrentConstraint),this.biasConstraint=Nn(e.biasConstraint),this.dropout=sl([1,oi([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=sl([1,oi([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=Ot(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const o=this.biasInitializer,i=this.units;r=new(t=class extends fr{apply(l,u){const c=o.apply([i]),h=new Qx().apply([i]),d=o.apply([i*2]);return bv(bv(c,h),d)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return oe(()=>{const s=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new K(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const o=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=li({ones:()=>qs(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=li({ones:()=>qs(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,a=this.recurrentDropoutMask;let l,u,c,h;0<this.dropout&&this.dropout<1&&(e=H(e,i[0]));let d=jr(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=H(r,a[0])),d=Ne(d,jr(r,this.recurrentKernel.read())),this.useBias&&(d=Er(d,this.bias.read()));const[p,f,g,y]=Rs(d,4,d.rank-1);l=this.recurrentActivation.apply(p),u=this.recurrentActivation.apply(f),c=Ne(H(u,o),H(l,this.activation.apply(g))),h=this.recurrentActivation.apply(y);const b=H(h,this.activation.apply(c));return[b,b,c]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ii(this.activation),recurrentActivation:ii(this.recurrentActivation),useBias:this.useBias,kernelInitializer:on(this.kernelInitializer),recurrentInitializer:on(this.recurrentInitializer),biasInitializer:on(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Ut(this.kernelRegularizer),recurrentRegularizer:Ut(this.recurrentRegularizer),biasRegularizer:Ut(this.biasRegularizer),activityRegularizer:Ut(this.activityRegularizer),kernelConstraint:$n(this.kernelConstraint),recurrentConstraint:$n(this.recurrentConstraint),biasConstraint:$n(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}Df.className="LSTMCell";Te(Df);class h$ extends vi{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Df(e),super(e)}call(e,t){return oe(()=>{this.cell.dropoutMask!=null&&(vt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(vt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,o=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:o})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}h$.className="LSTM";Te(h$);class f0 extends Rf{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return oe(()=>{e=e;let s=e.slice(1);const r=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?r.push(s.splice(0,a.stateSize.length)):r.push(s.splice(0,1));r.reverse();const o=[];let i;for(let a=0;a<this.cells.length;++a){const l=this.cells[a];s=r[a],a===0?i=[e[0]].concat(s):i=[i[0]].concat(s),i=l.call(i,t),o.push(i.slice(1))}s=[];for(const a of o.slice().reverse())s.push(...a);return[i[0]].concat(s)})}build(e){Vg(e)&&(e=e[0]),e=e;let t;this.cells.forEach((s,r)=>{Hi(`RNNCell_${r}`,()=>{s.build(e),Array.isArray(s.stateSize)?t=s.stateSize[0]:t=s.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=o=>({className:o.getClassName(),config:o.getConfig()}),r={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),r)}static fromConfig(e,t,s={}){const r=[];for(const o of t.cells)r.push(go(o,s));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.cells)t.push(...s.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return Wg(e)}setWeights(e){const t=[];for(const s of this.cells){const r=s.weights.length,o=e.splice(r);for(let i=0;i<s.weights.length;++i)t.push([s.weights[i],o[i]])}i0(t)}}f0.className="StackedRNNCells";Te(f0);function li(n){const{ones:e,rate:t,training:s=!1,count:r=1,dropoutFunc:o}=n,i=()=>o!=null?o(e(),t):nI(e(),t),a=()=>Vc(i,e,s);return!r||r<=1?Rn(a().clone()):Array(r).fill(void 0).map(a).map(u=>Rn(u.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var SV=function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(t[s[r]]=n[s[r]]);return t};class d$ extends vi{constructor(e){if(e.unroll)throw new xt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new xt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Sn({ndim:5})]}call(e,t){return oe(()=>{if(this.cell.dropoutMask!=null&&(vt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(vt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new K("ConvRNN2D cell does not support constants");const s=t==null?null:t.mask,r=t==null?null:t.training,o=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:o})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return oe(()=>{const{stateSize:t}=this.cell,s=e.shape,r=this.computeSingleOutputShape(s),o=[r[0],...r.slice(2)],i=kn(o);return Array.isArray(t)?Array(t.length).fill(i):[i]})}resetStates(e,t=!1){oe(()=>{if(!this.stateful)throw new Lr("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),o=[r[0],...r.slice(2)];if(s[0]==null)throw new K("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>kn(o)):this.states_=[kn(o)];else if(e==null)vt(this.states_),this.keptStates!=null&&(vt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>kn(o)):this.states_[0]=kn(o);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new K(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):vt(this.states_);for(let a=0;a<this.states_.length;++a){const l=e[a],u=o;if(!Tt(l.shape,u))throw new K(`State ${a} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${l.shape}`);this.states_[a]=l}}this.states_=this.states_.map(a=>Rn(a.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:s,kernelSize:r,padding:o,strides:i,dilationRate:a}=this.cell,l=t==="channelsFirst",u=e[l?3:2],c=e[l?4:3],h=vr(u,r[0],o,i[0],a[0]),d=vr(c,r[1],o,i[1],a[1]);return[...e.slice(0,2),...l?[s,h,d]:[h,d,s]]}}d$.className="ConvRNN2D";class m0 extends Df{constructor(e){const{filters:t,kernelSize:s,strides:r,padding:o,dataFormat:i,dilationRate:a}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Dn(this.filters,"filters"),this.kernelSize=Ga(s,2,"kernelSize"),this.kernelSize.forEach(l=>Dn(l,"kernelSize")),this.strides=Ga(r||1,2,"strides"),this.strides.forEach(l=>Dn(l,"strides")),this.padding=o||"valid",Ys(this.padding),this.dataFormat=i||"channelsLast",fn(this.dataFormat),this.dilationRate=Ga(a||1,2,"dilationRate"),this.dilationRate.forEach(l=>Dn(l,"dilationRate"))}build(e){var t;e=Ot(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new K(`The channel dimension of the input should be defined. Found ${e[s]}`);const r=e[s],o=4,i=this.kernelSize.concat([r,this.filters*o]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*o]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const u=this.biasInitializer,c=this.filters;l=new(t=class extends fr{apply(d,p){const f=u.apply([c]),g=As([c]),y=u.apply([c*2]);return Jx([f,g,y])}},t.className="CustomInit",t)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*o],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return oe(()=>{if(e.length!==3)throw new K(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training||!1,r=e[0],o=e[1],i=e[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=li({ones:()=>qs(r),rate:this.dropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,u=(ye,we,Ce)=>!we||!we[Ce]?ye:H(we[Ce],ye);let c=u(r,l,0),h=u(r,l,1),d=u(r,l,2),p=u(r,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=li({ones:()=>qs(o),rate:this.recurrentDropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const f=this.recurrentDropoutMask;let g=u(o,f,0),y=u(o,f,1),b=u(o,f,2),w=u(o,f,3);const C=3,[v,I,E,R]=Rs(this.kernel.read(),a,C),[L,D,F,T]=this.useBias?Rs(this.bias.read(),a):[null,null,null,null];c=this.inputConv(c,v,L,this.padding),h=this.inputConv(h,I,D,this.padding),d=this.inputConv(d,E,F,this.padding),p=this.inputConv(p,R,T,this.padding);const[V,q,se,ee]=Rs(this.recurrentKernel.read(),a,C);g=this.recurrentConv(g,V),y=this.recurrentConv(y,q),b=this.recurrentConv(b,se),w=this.recurrentConv(w,ee);const te=this.recurrentActivation.apply(Ne(c,g)),le=this.recurrentActivation.apply(Ne(h,y)),Q=Ne(H(le,i),H(te,this.activation.apply(Ne(d,b)))),he=H(this.recurrentActivation.apply(Ne(p,w)),this.activation.apply(Q));return[he,he,Q]})}getConfig(){const e=super.getConfig(),{units:t}=e,s=SV(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),r)}inputConv(e,t,s,r){const o=ri(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?Er(o,s,this.dataFormat):o}recurrentConv(e,t){return ri(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}m0.className="ConvLSTM2DCell";Te(m0);class p$ extends d${constructor(e){const t=new m0(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}p$.className="ConvLSTM2D";Te(p$);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class g0 extends Ct{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return s}call(e,t){return oe(()=>{this.invokeCallHook(e,t);const s=ct(e);if(0<this.rate&&this.rate<1){const r=t.training==null?!1:t.training,o=this.getNoiseShape(s);return Vc(()=>nI(s,this.rate,o,this.seed),()=>s,r)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}g0.className="Dropout";Te(g0);class f$ extends g0{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}f$.className="SpatialDropout1D";Te(f$);class m$ extends Ct{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Dn(this.units,"units"),this.activation=ai(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=Zt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Zt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Nn(e.kernelConstraint),this.biasConstraint=Nn(e.biasConstraint),this.kernelRegularizer=Jt(e.kernelRegularizer),this.biasRegularizer=Jt(e.biasRegularizer),this.activityRegularizer=Jt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Ot(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=Ot(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return oe(()=>{this.invokeCallHook(e,t);const s=ct(e),r=XS(this.activation.getClassName());let o;return r!=null?o=jr(s,this.kernel.read(),r,this.bias?this.bias.read():null):(o=jr(s,this.kernel.read()),this.bias!=null&&(o=Er(o,this.bias.read())),this.activation!=null&&(o=this.activation.apply(o))),o})}getConfig(){const e={units:this.units,activation:ii(this.activation),useBias:this.useBias,kernelInitializer:on(this.kernelInitializer),biasInitializer:on(this.biasInitializer),kernelRegularizer:Ut(this.kernelRegularizer),biasRegularizer:Ut(this.biasRegularizer),activityRegularizer:Ut(this.activityRegularizer),kernelConstraint:$n(this.kernelConstraint),biasConstraint:$n(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}m$.className="Dense";Te(m$);class g$ extends Ct{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Ot(e);for(const t of e.slice(1))if(t==null)throw new K(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Jo(e,1)]}call(e,t){return oe(()=>{this.invokeCallHook(e,t);let s=ct(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let o=2;o<s.rank;++o)r.push(o);r.push(1),s=_t(s,r)}return rB(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}g$.className="Flatten";Te(g$);class y$ extends Ct{constructor(e){super(e),this.supportsMasking=!0,this.activation=ai(e.activation)}call(e,t){return oe(()=>{this.invokeCallHook(e,t);const s=ct(e);return this.activation.apply(s)})}getConfig(){const e={activation:ii(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}y$.className="Activation";Te(y$);class b$ extends Ct{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return oe(()=>(e=ct(e),nB(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}b$.className="RepeatVector";Te(b$);class x$ extends Ct{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const s="Total size of new array must be unchanged.",r=t.slice();let o=1,i=null;for(let l=0;l<r.length;++l){const u=r[l];if(this.isUnknown(u))if(i===null)i=l;else throw new K("Can only specifiy one unknown dimension.");else o*=u}const a=Jo(e);if(i!==null){if(o===0||a%o!==0)throw new K(s);r[i]=a/o}else if(a!==o)throw new K(s);return r}computeOutputShape(e){let t=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return oe(()=>{this.invokeCallHook(e,t);const s=ct(e),r=s.shape,o=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return j(s,o)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}x$.className="Reshape";Te(x$);class w$ extends Ct{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=Ir(1,e.dims.length+1);if(!Tt(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Sn({ndim:this.dims.length+1})]}computeOutputShape(e){e=Ot(e);const t=e.slice();return this.dims.forEach((s,r)=>{t[r+1]=e[s]}),t}call(e,t){return _t(ct(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}w$.className="Permute";Te(w$);class v$ extends Ct{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const s=ct(e);return pd(tl(s,this.maskValue),-1)}call(e,t){return oe(()=>{this.invokeCallHook(e,t);const s=ct(e),i=pd(tl(s,this.maskValue),-1,!0);return H(s,Ue(i,s.dtype))})}}v$.className="Masking";Te(v$);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class k$ extends Ct{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Pt(e.inputLength))}this.inputDim=e.inputDim,Dn(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Dn(this.outputDim,"outputDim"),this.embeddingsInitializer=Zt(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Jt(e.embeddingsRegularizer),this.activityRegularizer=Jt(e.activityRegularizer),this.embeddingsConstraint=Nn(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return oe(()=>this.maskZero?(e=ct(e),tl(e,At(e))):null)}computeOutputShape(e){if(e=Ot(e),this.inputLength==null)return[...e,this.outputDim];const t=Pt(this.inputLength);if(t.length!==e.length-1)throw new K(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let r=0;r<t.length;++r){const o=t[r],i=e[r+1];if(o!=null&&i!=null&&o!==i)throw new K(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);o==null&&(t[s]=i),s++}}return[e[0],...t,this.outputDim]}call(e,t){return oe(()=>{this.invokeCallHook(e,t);let s=ct(e);s.dtype!=="int32"&&(s=Hr(s,"int32"));const r=tI(this.embeddings.read(),j(s,[s.size]));return j(r,Ot(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:on(this.embeddingsInitializer),embeddingsRegularizer:Ut(this.embeddingsRegularizer),activityRegularizer:Ut(this.activityRegularizer),embeddingsConstraint:$n(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}k$.className="Embedding";Te(k$);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ga extends Ct{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new xt}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const s=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const o=e[e.length-t.length+r],i=t[r];if(o==null||i==null||o<0||i<0)s.push(null);else if(o===1)s.push(i);else if(i===1)s.push(o);else{if(o!==i)throw new K("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));s.push(o)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Ot(e)]),e=e,e.length<2)throw new K(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const o of e)o!=null&&o[0]!==null&&t.push(o[0]);if(t=Zo(t),t.length>1)throw new K(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let o=1;o<e.length;++o){const i=e[o]==null?null:e[o].slice(1);s=this.computeElementwiseOpOutputShape(s,i)}const r=e.map(o=>o.length);e.indexOf(null)===-1&&Zo(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return oe(()=>{if(e=e,this.reshapeRequired){const s=[],r=e.map(o=>o.rank);if(r.indexOf(null)===-1){const o=oi(r);for(let i of e){const a=i.rank;for(let l=0;l<o-a;++l)i=Mc(i,1);s.push(i)}return this.mergeFunction(s)}else{let o=!1;for(const l of e){const u=l.rank;if(u==null){const c=l.shape,h=c[0],d=c.slice(1).concat([h]);let p=j(l,[h].concat(Jo(c.slice(1))));p=_t(p,[1,0]),p=j(p,d),s.push(p),o=!0}else if(u>1){const c=Ir(1,u).concat([0]);s.push(_t(l,c)),o=!0}else s.push(l)}let i=this.mergeFunction(s);const a=i.rank;if(o){if(a==null){const l=i.shape,u=l.length,c=l[u-1],h=[c].concat(l.slice(0,l.length-1));i=j(_t(j(i,[-1,c]),[1,0]),h)}else if(a>1){const l=[a-1].concat(Ir(0,a-1));i=_t(i,l)}}return i}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){const o=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,o)}let s=[];for(const r of e)r!=null&&r[0]!==null&&s.push(r[0]);return s=Zo(s),s.length===1?t=s.concat(t):t=[null].concat(t),t}computeMask(e,t){return oe(()=>{if(t==null)return null;if(!Array.isArray(t))throw new K("`mask` should be an Array");if(!Array.isArray(e))throw new K("`inputs` should be an Array");if(t.length!==e.length)throw new K(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:os(r,0));let s=t[0];for(let r=1;r<t.length-1;++r)s=Yr(s,t[r]);return s})}}class C$ extends ga{constructor(e){super(e)}mergeFunction(e){return oe(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=Ne(t,e[s]);return t})}}C$.className="Add";Te(C$);class S$ extends ga{constructor(e){super(e)}mergeFunction(e){return oe(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=H(t,e[s]);return t})}}S$.className="Multiply";Te(S$);class I$ extends ga{constructor(e){super(e)}mergeFunction(e){return oe(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=Ne(t,e[s]);return H(1/e.length,t)})}}I$.className="Average";Te(I$);class $$ extends ga{constructor(e){super(e)}mergeFunction(e){return oe(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=No(t,e[s]);return t})}}$$.className="Maximum";Te($$);class N$ extends ga{constructor(e){super(e)}mergeFunction(e){return oe(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=sa(t,e[s]);return t})}}N$.className="Minimum";Te(N$);class T$ extends ga{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new K("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const r of e)if(r!=null){t=!1;break}if(t)return;const s=[];for(let r=0;r<e.length;++r){const o=e[r].slice();o.splice(this.axis,1);let i=!1;for(const a of s)if(Tt(a,o)){i=!0;break}i||s.push(o)}if(s.length>1)throw new K("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return oe(()=>Jx(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new K("A `Concatenate` layer should be called on a list of inputs.");const t=e,s=t[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const o of t.slice(1)){if(s[r]==null||o[r]==null){s[r]=null;break}s[r]+=o[r]}return s}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new K("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new K("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new K(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return oe(()=>{let s=!0;if(t.forEach(i=>{if(i!=null){s=!1;return}}),s)return null;const r=[];for(let i=0;i<e.length;++i)t[i]==null?r.push(Ue(qs(e[i]),"bool")):t[i].rank<e[i].rank?r.push(os(t[i],-1)):r.push(t[i]);const o=bn(r,this.axis);return Mb(o,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}T$.className="Concatenate";Te(T$);function Ul(n,e){for(;n<0;)n+=e;return n}function IV(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new xt("batchDot is not implemented for tensors of 4D or higher rank yet");if(A(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),A(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new xt("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,r=e.shape.length;t==null&&(t=[s-1,r-2]);const o=t;return oe(()=>{let i;if(s>r){i=s-r;const l=[];for(let u=0;u<i;++u)l.push(1);e=j(e,e.shape.concat(l))}else if(r>s){i=r-s;const l=[];for(let u=0;u<i;++u)l.push(1);n=j(n,n.shape.concat(l))}else i=0;let a;if(n.shape.length===2&&e.shape.length===2)o[0]===o[1]?a=Qe(H(n,e),o[0]):a=Qe(H(_t(n,[1,0]),e),o[1]);else{const l=o[0]!==n.shape.length-1,u=o[1]===e.shape.length-1;a=It(n,e,l,u)}if(i>0){let l;s>r?l=s+r-3:l=s-1;const u=[];for(let c=l;c<l+i;++c)u.push(c);a=pa(a,u)}return a.shape.length===1&&(a=os(a,1)),a})}class E$ extends ga{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){A(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],s=e[1];if(t.length>3||s.length>3)throw new xt("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);if(t[r[0]]!==s[r[1]])throw new K(`Dimension incompatibility: ${t[r[0]]} !== ${s[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new K(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],s=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((o,i)=>Ul(o,e[i].shape.length)):r=[Ul(this.axes,t.shape.length),Ul(this.axes,s.shape.length)],this.normalize&&(t=xd(t,r[0]),s=xd(s,r[1])),IV(t,s,r)}interpretAxes(e,t){let s;return Array.isArray(this.axes)?s=this.axes:s=[Ul(this.axes,e.length),Ul(this.axes,t.length)],s}computeOutputShape(e){A(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),s=e[1].slice();if(t.length>3||s.length>3)throw new xt("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);t.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const o=t.concat(s);return o.length===1&&o.push(1),o}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}E$.className="Dot";Te(E$);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class _$ extends Ct{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return oe(()=>{this.invokeCallHook(e,t);const s=ct(e);return Vc(()=>Ne($f(s.shape,0,this.stddev),s),()=>s,t.training||!1)})}}_$.className="GaussianNoise";Te(_$);class A$ extends Ct{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return oe(()=>{this.invokeCallHook(e,t);const s=ct(e);return this.rate>0&&this.rate<1?Vc(()=>{const o=Math.sqrt(this.rate/(1-this.rate));return H(s,$f(s.shape,1,o))},()=>s,t.training||!1):s})}}A$.className="GaussianDropout";Te(A$);class R$ extends Ct{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||ct(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return oe(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return Vc(()=>{const o=ct(e),a=-1.6732632423543772*1.0507009873554805;let l=bi(da(s),this.rate);l=Hr(l,"float32");const u=((1-this.rate)*(1+this.rate*a**2))**-.5,c=-u*a*this.rate,h=Ne(H(o,l),H(Ne(l,-1),a));return Ne(H(h,u),c)},()=>ct(e),t.training||!1)}return e})}}R$.className="AlphaDropout";Te(R$);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function vu(n,e,t,s,r,o=.001){let i;if(n.rank===2)i=sC(n,e,t,s,r,o);else if(n.rank===3)i=rC(n,e,t,s,r,o);else if(n.rank===4)i=oC(n,e,t,s,r,o);else throw new xt(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return i}function $V(n,e,t,s,r=.001){return oe(()=>{const o=lf(n,s),i=o.mean,a=o.variance;return[vu(n,i,a,t,e,r),i,a]})}function NV(n,e,t,s,r=.001){return oe(()=>{const o=lf(n,s),i=o.mean,a=o.variance,l=[];for(const f of Ir(0,n.rank))s.indexOf(f)!==-1?l.push(1):l.push(n.shape[f]);const u=j(i,l),c=j(a,l),h=e==null?null:j(e,l),d=t==null?null:j(t,l);return[vu(n,u,c,d,h,r),i,a]})}function TV(n,e,t,s,r=.001){return Tt(s.slice().sort(),Ir(0,n.rank-1))?$V(n,e,t,s,r):NV(n,e,t,s,r)}class D$ extends Ct{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Zt(e.betaInitializer||"zeros"),this.gammaInitializer=Zt(e.gammaInitializer||"ones"),this.movingMeanInitializer=Zt(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Zt(e.movingVarianceInitializer||"ones"),this.betaConstraint=Nn(e.betaConstraint),this.gammaConstraint=Nn(e.gammaConstraint),this.betaRegularizer=Jt(e.betaRegularizer),this.gammaRegularizer=Jt(e.gammaRegularizer)}build(e){e=Ot(e);const t=this.axis>=0?this.axis:this.axis+e.length,s=e[t];if(s==null)throw new K(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Sn({ndim:e.length,axes:{[t]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return oe(()=>{const s=t.training==null?!1:t.training,r=ct(e),o=r.shape,i=o.length,a=Ir(0,i),l=this.axis>=0?this.axis:this.axis+i;a.splice(l,1);const u=oa(1,i);u[l]=o[l];const c=a.slice();c.sort();const h=!Tt(c,Ir(0,i).slice(0,i-1)),d=()=>{if(h){const w=j(this.movingMean.read(),u),C=j(this.movingVariance.read(),u),v=this.center?j(this.beta.read(),u):null,I=this.scale?j(this.gamma.read(),u):null;return vu(r,w,C,v,I,this.epsilon)}else return vu(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return d();const[p,f,g]=TV(r,this.gamma.read(),this.beta.read(),a,this.epsilon),y=(w,C,v)=>{oe(()=>{const I=1-v,E=w.read(),R=H(Ke(E,C),I);w.write(Ke(E,R))})};return(()=>{y(this.movingMean,f,this.momentum),y(this.movingVariance,g,this.momentum)})(),p})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:on(this.betaInitializer),gammaInitializer:on(this.gammaInitializer),movingMeanInitializer:on(this.movingMeanInitializer),movingVarianceInitializer:on(this.movingVarianceInitializer),betaRegularizer:Ut(this.betaRegularizer),gammaRegularizer:Ut(this.gammaRegularizer),betaConstraint:$n(this.betaConstraint),gammaConstraint:$n(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}D$.className="BatchNormalization";Te(D$);class O$ extends Ct{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Zt(e.betaInitializer||"zeros"),this.gammaInitializer=Zt(e.gammaInitializer||"ones"),this.betaRegularizer=Jt(e.betaRegularizer),this.gammaRegularizer=Jt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Ot(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let o=0;o<this.axis.length;++o)this.axis[o]<0&&(this.axis[o]+=t);for(const o of this.axis)if(o<0||o>=t)throw new Error(`Invalid axis: ${o}`);if(this.axis.length!==Zo(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(o=>e[o]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const s=ct(e),r=s.shape,o=r.length;return oe(()=>{let{mean:a,variance:l}=lf(s,this.axis,!0);const u=oa(1,o);for(const g of this.axis)u[g]=r[g];const c=g=>g!=null&&g.shape.length!==o?j(g,u):g;let h=this.scale?c(this.gamma.read()):null,d=this.center?c(this.beta.read()):null;const p=[],f=[];for(let g=0;g<o;++g)this.axis.indexOf(g)!==-1?(p.push(r[g]),f.push(1)):(p.push(1),f.push(r[g]));return a=sr(a,p),l=sr(l,p),h!=null&&(h=sr(h,f)),d!=null&&(d=sr(d,f)),vu(s,a,l,d,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:on(this.betaInitializer),gammaInitializer:on(this.gammaInitializer),betaRegularizer:Ut(this.betaRegularizer),gammaRegularizer:Ut(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}O$.className="LayerNormalization";Te(O$);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function EV(n,e,t){return oe(()=>{if(n.rank!==4)throw new K(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new K("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=$r()),t!=="channelsLast"&&t!=="channelsFirst")throw new K(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return t==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],xi(n,s)})}class F$ extends Ct{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?$r():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new K(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,s;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new K(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new K(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[t,s]}this.inputSpec=[new Sn({ndim:4})]}computeOutputShape(e){e=Ot(e);let t,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],t,s]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],t,s,e[3]])}call(e,t){return oe(()=>EV(ct(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}F$.className="ZeroPadding2D";Te(F$);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Of(n,e,t,s,r,o){return oe(()=>{fn(r),ZS(o),Ys(s),t==null&&(t=[1,1]),s==null&&(s="valid"),r==null&&(r=$r()),o==null&&(o="max"),n=h0(n,r);let i;const a=s==="same"?"same":"valid";return o==="max"?i=af(n,e,t,a):i=Jp(n,e,t,a),r==="channelsFirst"&&(i=_t(i,[0,3,1,2])),i})}function L$(n,e,t,s,r,o){return oe(()=>{fn(r),ZS(o),Ys(s),t==null&&(t=[1,1,1]),s==null&&(s="valid"),r==null&&(r=$r()),o==null&&(o="max"),n=QI(n,r);let i;const a=s==="same"?"same":"valid";return o==="max"?i=EC(n,e,t,a):i=nC(n,e,t,a),r==="channelsFirst"&&(i=_t(i,[0,4,1,2,3])),i})}class P$ extends Ct{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new K(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Dn(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new K(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Dn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Ys(this.padding),this.inputSpec=[new Sn({ndim:3})]}computeOutputShape(e){e=Ot(e);const t=vr(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return oe(()=>{this.invokeCallHook(e,t),e=Mc(ct(e),2);const s=this.poolingFunction(ct(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return pa(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class z$ extends P${constructor(e){super(e)}poolingFunction(e,t,s,r,o){return fn(o),Ys(r),Of(e,t,s,r,o,"max")}}z$.className="MaxPooling1D";Te(z$);class M$ extends P${constructor(e){super(e)}poolingFunction(e,t,s,r,o){return fn(o),Ys(r),Of(e,t,s,r,o,"avg")}}M$.className="AveragePooling1D";Te(M$);class B$ extends Ct{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new K(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Dn(this.poolSize,"poolSize"),Dn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,fn(this.dataFormat),Ys(this.padding),this.inputSpec=[new Sn({ndim:4})]}computeOutputShape(e){e=Ot(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=vr(t,this.poolSize[0],this.padding,this.strides[0]),s=vr(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s]:[e[0],t,s,e[3]]}call(e,t){return oe(()=>(this.invokeCallHook(e,t),this.poolingFunction(ct(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class V$ extends B${constructor(e){super(e)}poolingFunction(e,t,s,r,o){return fn(o),Ys(r),Of(e,t,s,r,o,"max")}}V$.className="MaxPooling2D";Te(V$);class W$ extends B${constructor(e){super(e)}poolingFunction(e,t,s,r,o){return fn(o),Ys(r),Of(e,t,s,r,o,"avg")}}W$.className="AveragePooling2D";Te(W$);class U$ extends Ct{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new K(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Dn(this.poolSize,"poolSize"),Dn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,fn(this.dataFormat),Ys(this.padding),this.inputSpec=[new Sn({ndim:5})]}computeOutputShape(e){e=Ot(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=vr(t,this.poolSize[0],this.padding,this.strides[0]),s=vr(s,this.poolSize[1],this.padding,this.strides[1]),r=vr(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s,r]:[e[0],t,s,r,e[4]]}call(e,t){return oe(()=>(this.invokeCallHook(e,t),this.poolingFunction(ct(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class G$ extends U${constructor(e){super(e)}poolingFunction(e,t,s,r,o){return fn(o),Ys(r),L$(e,t,s,r,o,"max")}}G$.className="MaxPooling3D";Te(G$);class H$ extends U${constructor(e){super(e)}poolingFunction(e,t,s,r,o){return fn(o),Ys(r),L$(e,t,s,r,o,"avg")}}H$.className="AveragePooling3D";Te(H$);class j$ extends Ct{constructor(e){super(e),this.inputSpec=[new Sn({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new xt}}class K$ extends j${constructor(e){super(e||{})}call(e,t){return oe(()=>{const s=ct(e);return ln(s,1)})}}K$.className="GlobalAveragePooling1D";Te(K$);class q$ extends j${constructor(e){super(e||{})}call(e,t){return oe(()=>{const s=ct(e);return ar(s,1)})}}q$.className="GlobalMaxPooling1D";Te(q$);class X$ extends Ct{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,fn(this.dataFormat),this.inputSpec=[new Sn({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new xt}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Y$ extends X${call(e,t){return oe(()=>{const s=ct(e);return this.dataFormat==="channelsLast"?ln(s,[1,2]):ln(s,[2,3])})}}Y$.className="GlobalAveragePooling2D";Te(Y$);class Z$ extends X${call(e,t){return oe(()=>{const s=ct(e);return this.dataFormat==="channelsLast"?ar(s,[1,2]):ar(s,[2,3])})}}Z$.className="GlobalMaxPooling2D";Te(Z$);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class J$ extends Ct{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,s={}){const r=t.layer,o=go(r,s);delete t.layer;const i={layer:o};return Object.assign(i,t),new e(i)}}class Q$ extends J${constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Ot(e),e.length<3)throw new K(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Ot(e);const t=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(t),r=e[1];return[s[0],r].concat(s.slice(1))}call(e,t){return oe(()=>(e=ct(e),l$((i,a)=>[ct(this.layer.call(i,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}Q$.className="TimeDistributed";Te(Q$);function _V(n){ma(ZM,"BidirectionalMergeMode",n)}const AV="concat";class eN extends J${constructor(e){super(e);const t=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=t,this.forwardLayer=go(s),t.goBackwards=t.goBackwards!==!0;const r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=go(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?AV:e.mergeMode,_V(this.mergeMode),e.weights)throw new xt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,s=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let s,r,o;return this.returnState&&(o=t.slice(1)),s=t[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(o).concat(o.slice()):[s].concat(o).concat(o.slice()):xs(r)}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const o=a$(e,s,r,this.numConstants);if(e=o.inputs,s=o.initialState,r=o.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&r==null)return super.apply(e,t);const i=[],a=[];if(s!=null){const u=s.length;if(u%2>0)throw new K("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=s,i.push(...s);const c=s.map(h=>new Sn({shape:h.shape}));this.forwardLayer.stateSpec=c.slice(0,u/2),this.backwardLayer.stateSpec=c.slice(u/2),a.push(...c)}if(r!=null)throw new xt("Support for constants in Bidirectional layers is not implemented yet.");const l=i[0]instanceof Zr;for(const u of i)if(u instanceof Zr!==l)throw new K("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const u=[e].concat(i),c=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=c;const d=super.apply(u,t);return this.inputSpec=h,d}else return super.apply(e,t)}call(e,t){return oe(()=>{const s=t.initialState;let r,o;if(s==null)r=this.forwardLayer.call(e,t),o=this.backwardLayer.call(e,t);else{const l=s.slice(0,s.length/2),u=s.slice(s.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:l})),o=this.backwardLayer.call(e,Object.assign(t,{initialState:u}))}let i;this.returnState&&(Array.isArray(r)&&(i=r.slice(1).concat(o.slice(1))),r=r[0],o=o[0]),this.returnSequences&&(o=hr(o,1));let a;return this.mergeMode==="concat"?a=Jx([r,o]):this.mergeMode==="sum"?a=Ne(r,o):this.mergeMode==="ave"?a=H(.5,Ne(r,o)):this.mergeMode==="mul"?a=H(r,o):this.mergeMode==null&&(a=[r,o]),this.returnState?this.mergeMode==null?a.concat(i):[a].concat(i):a})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Hi(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Hi(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[t,t]:s=t:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const o=this.forwardLayer.states.map(i=>null);return Array.isArray(s)?s.concat(o).concat(o):[s].concat(o).concat(o)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const s=go(t.layer);if(delete t.layer,t.numConstants!=null)throw new xt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=s,new e(r)}}eN.className="Bidirectional";Te(eN);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class tN extends Ct{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return oe(()=>(e=ct(e),e.dtype!=="float32"&&(e=Hr(e,"float32")),Ne(H(e,this.scale),this.offset)))}}tN.className="Rescaling";Te(tN);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:RV,cropAndResize:DV}=Br;class nN extends Ct{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,s,r,o,i,a,l){return oe(()=>{let u,c=!1;const h=t/i,d=s/a,p=(r+t)/i,f=(o+s)/a,g=[h,d,p,f],y=[];e.rank===3?(c=!0,u=Ls([e])):u=e;for(let I=0;I<u.shape[0];I++)y.push(g);const b=wr(y,[y.length,4]),w=nl(0,y.length,1,"int32"),v=DV(u,b,w,[r,o],"nearest");return Hr(c?ct(dr(v)):v,l)})}upsize(e,t,s,r){return oe(()=>{const o=RV(e,[t,s]);return Hr(o,r)})}call(e,t){return oe(()=>{const s=ct(e),r=s.dtype,o=s.shape,i=o[o.length-3],a=o[o.length-2];let l=0;i!==this.height&&(l=Math.floor((i-this.height)/2));let u=0;return a!==this.width&&(u=Math.floor((a-this.width)/2),u===0&&(u=1)),l>=0&&u>=0?this.centerCrop(s,l,u,this.height,this.width,i,a,r):this.upsize(e,this.height,this.width,r)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Ot(e);const t=e.length-3,s=e.length-2;return e[t]=this.height,e[s]=this.width,e}}nN.className="CenterCrop";Te(nN);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function OV(n,e,t,s){let r=ct(n);if(r.dtype!=="int32"&&(r=Hr(r,"int32")),e==="int")return r;const o=r.shape;if(r.rank===0&&(r=os(r,-1)),e==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=os(r,-1)),r.rank>2)throw new K(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${o} which would result in output rank ${r.rank}.`);const i=["multiHot","oneHot"].includes(e),a=r;let l;if(typeof s<"u"&&e==="count"?l=Dg(a,s,t,i):l=Dg(a,[],t,i),e!=="tfIdf")return l;if(s)return H(l,s);throw new K("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class sN extends Ct{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=Ot(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return oe(()=>{e=ct(e),e.dtype!=="int32"&&(e=Hr(e,"int32"));let s;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new K(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);s=ct(t.countWeights)}const r=ar(e),o=pu(e),i=Bs(this.numTokens,r).bufferSync().get(0),a=bi(o,0).bufferSync().get(0);if(!(i&&a))throw new K(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return OV(e,this.outputMode,this.numTokens,s)})}}sN.className="CategoryEncoding";Te(sN);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const FV=["bilinear","nearest"],Lv=new Set(FV);class rN extends Ct{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(Lv.has(e.interpolation))this.interpolation=e.interpolation;else throw new K(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=Ot(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return oe(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return Br.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Br.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...Lv]} are supported`)})}}rN.className="Resizing";Te(rN);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class oN{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}oN.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class iN extends Ct{constructor(e){super(e),this.randomGenerator=new oN(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}iN.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const LV=["bilinear","nearest"],Pv=new Set(LV);class aN extends iN{constructor(e){super(e);const{factor:t,interpolation:s="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new K(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new K(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new K(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(Pv.has(s))this.interpolation=s;else throw new K(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Ot(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return oe(()=>{const s=ct(e);this.imgHeight=s.shape[s.shape.length-3];const r=s.shape[s.shape.length-2];this.widthFactor=da([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let o=this.widthFactor.dataSync()[0]*r;o=Math.round(o);const i=[this.imgHeight,o];switch(this.interpolation){case"bilinear":return Br.resizeBilinear(e,i);case"nearest":return Br.resizeNearestNeighbor(e,i);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...Pv]} are supported`)}})}}aN.className="RandomWidth";Te(aN);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PV=ue();PV.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Ns;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(Ns||(Ns={}));var zv;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(zv||(zv={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zV={};function lN(n){return zV[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S(n,e,t,s,r){const o=e.inputParams[n];if(o&&o.inputIndexStart!==void 0){const a=o.inputIndexStart,l=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?a+1:o.inputIndexEnd,u=a<0?e.inputNames.length+a:a;if(o.type==="tensor")return zn(e.inputNames[u],t,s,r);if(o.type==="tensors"){const d=e.inputs.slice(a,l);return e.inputNames.slice(a,l).filter((f,g)=>{var y;return((y=d[g])===null||y===void 0?void 0:y.op)!=="NoOp"}).map(f=>zn(f,t,s,r))}const c=zn(e.inputNames[u],t,s,r),h=c.dataSync();return o.type==="number"?h[0]:ir(c.shape,h)}const i=e.attrParams[n];return i&&i.value}function zn(n,e,t,s){const[r,o]=Ts(n,t);if(s!=null){const a=s.getHashTableHandleByName(r);if(a!=null)return a}const i=t.currentContextIds.find(a=>!!e[Sd(r,a)]);return i!==void 0?e[Sd(r,i)][o]:void 0}function Mv(n,e,t){return e[Sd(n,t.currentContextId)]}function lo(n,e){const[t,s,r]=Ts(n,e);return[Sd(t,e&&e.currentContextId),s,r]}function Sd(n,e){return e?`${n}-${e}`:n}function Ts(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const o=e.parseNodeNameCache.get(n);if(o!=null)return o}const s=n.split(":");let r;if(s.length===1)r=[n,0,void 0];else{const o=s[0],i=s.length===3?s[1]:void 0,a=Number(s[s.length-1]);r=[o,a,i]}return t&&e.parseNodeNameCache.set(n,r),r}function Qh(n,e,t){let s=S("pad",n,e,t);if(s==="explicit"){s=S("explicitPaddings",n,e,t);const r=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)r[o][0]=s[o*2],r[o][1]=s[o*2+1];return r}return s}function uo(n){return n.kept?n:mo(n)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MV=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],BV=Object.freeze(Object.defineProperty({__proto__:null,json:MV},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VV=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],WV=Object.freeze(Object.defineProperty({__proto__:null,json:VV},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UV=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],GV=Object.freeze(Object.defineProperty({__proto__:null,json:UV},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HV=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],jV=Object.freeze(Object.defineProperty({__proto__:null,json:HV},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KV=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],qV=Object.freeze(Object.defineProperty({__proto__:null,json:KV},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XV=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],YV=Object.freeze(Object.defineProperty({__proto__:null,json:XV},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZV=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],JV=Object.freeze(Object.defineProperty({__proto__:null,json:ZV},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QV=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],eW=Object.freeze(Object.defineProperty({__proto__:null,json:QV},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tW=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],nW=Object.freeze(Object.defineProperty({__proto__:null,json:tW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sW=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],rW=Object.freeze(Object.defineProperty({__proto__:null,json:sW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oW=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],iW=Object.freeze(Object.defineProperty({__proto__:null,json:oW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aW=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],lW=Object.freeze(Object.defineProperty({__proto__:null,json:aW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uW=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],cW=Object.freeze(Object.defineProperty({__proto__:null,json:uW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hW=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],dW=Object.freeze(Object.defineProperty({__proto__:null,json:hW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pW=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],fW=Object.freeze(Object.defineProperty({__proto__:null,json:pW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mW=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],gW=Object.freeze(Object.defineProperty({__proto__:null,json:mW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yW=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],bW=Object.freeze(Object.defineProperty({__proto__:null,json:yW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xW=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],wW=Object.freeze(Object.defineProperty({__proto__:null,json:xW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vW=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],kW=Object.freeze(Object.defineProperty({__proto__:null,json:vW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bv{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[BV,WV,GV,jV,qV,YV,JV,eW,nW,rW,iW,lW,cW,dW,fW,gW,bW,wW,kW],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(e,t={}){const s=e.node,r=[],o=[],i=[],a=s.reduce((g,y)=>(g[y.name]=this.mapNode(y),y.op.startsWith("Placeholder")?r.push(g[y.name]):y.op==="Const"?o.push(g[y.name]):(y.input==null||y.input.length===0)&&i.push(g[y.name]),g),{});let l=[];const u=[];let c={},h={};t!=null&&(c=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const d=Object.keys(a);d.forEach(g=>{const y=a[g];y.inputNames.forEach((b,w)=>{const[C,,v]=lo(b),I=a[C];if(I.outputs!=null){const E=I.outputs.indexOf(v);if(E!==-1){const R=`${C}:${E}`;y.inputNames[w]=R}}y.inputs.push(I),I.children.push(y)})}),Object.keys(h).length===0?d.forEach(g=>{const y=a[g];y.children.length===0&&u.push(y)}):Object.keys(h).forEach(g=>{const[y]=lo(g),b=a[y];b!=null&&(b.signatureKey=h[g],u.push(b))}),Object.keys(c).length>0?Object.keys(c).forEach(g=>{const[y]=lo(g),b=a[y];b&&(b.signatureKey=c[g],l.push(b))}):l=r;let p={};e.library!=null&&e.library.function!=null&&(p=e.library.function.reduce((g,y)=>(g[y.signature.name]=this.mapFunction(y),g),{}));const f={nodes:a,inputs:l,outputs:u,weights:o,placeholders:r,signature:t,functions:p};return i.length>0&&(f.initNodes=i),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=lN(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((r,o)=>(r[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},r),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((r,o)=>{const i=o.type;let a;switch(o.type){case"string":a=qg(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=qg(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":a=ty(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=ty(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":a=Yg(e.attr,o.tfName,o.defaultValue||0),a===void 0&&o.tfDeprecatedName&&(a=Yg(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":a=ey(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=ey(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":a=Xg(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Xg(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":a=sy(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=sy(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":a=Qg(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Qg(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":a=ny(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=ny(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":a=Zg(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Zg(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":a=Jg(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Jg(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":a=Vv(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Vv(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${e.op}`)}return r[o.name]={value:a,type:i},r},{})),s}mapFunction(e){const t=e.nodeDef,s=[],r=[];let o={};t!=null&&(o=t.reduce((h,d)=>(h[d.name]=this.mapNode(d),d.op==="Const"&&r.push(h[d.name]),h),{}));const i=[],a=[];e.signature.inputArg.forEach(h=>{const[d]=lo(h.name),p={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:y0(h.type),type:"dtype"}},children:[]};p.signatureKey=h.name,i.push(p),o[d]=p}),Object.keys(o).forEach(h=>{const d=o[h];d.inputNames.forEach((p,f)=>{const[g,,y]=lo(p),b=o[g];if(b.outputs!=null){const w=b.outputs.indexOf(y);if(w!==-1){const C=`${g}:${w}`;d.inputNames[f]=C}}d.inputs.push(b),b.children.push(d)})});const u=e.ret;e.signature.outputArg.forEach(h=>{const[d,p]=lo(u[h.name]),f=o[d];f!=null&&(f.defaultOutput=p,a.push(f))});const c=this.mapArgsToSignature(e);return{nodes:o,inputs:i,outputs:a,weights:r,placeholders:s,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function CW(n){const e=ue().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function uN(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):CW(n);return e?t:t.toLowerCase()}function qg(n,e,t,s=!1){const r=n[e];return r!=null?uN(r.s,s):t}function Xg(n,e,t){const s=n[e];return s?s.b:t}function Yg(n,e,t){const s=n[e]||{},r=s.i!=null?s.i:s.f!=null?s.f:t;return typeof r=="number"?r:parseInt(r,10)}function y0(n){switch(typeof n=="string"&&(n=Ns[n]),n){case Ns.DT_FLOAT:case Ns.DT_HALF:return"float32";case Ns.DT_INT32:case Ns.DT_INT64:case Ns.DT_INT8:case Ns.DT_UINT8:return"int32";case Ns.DT_BOOL:return"bool";case Ns.DT_DOUBLE:return"float32";case Ns.DT_STRING:return"string";case Ns.DT_COMPLEX64:case Ns.DT_COMPLEX128:return"complex64";default:return null}}function Vv(n,e,t){const s=n[e];return s&&s.func?s.func.name:t}function Zg(n,e,t){const s=n[e];return s&&s.type?y0(s.type):t}function Jg(n,e,t){const s=n[e];return s&&s.list&&s.list.type?s.list.type.map(r=>y0(r)):t}function cN(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function Qg(n,e,t){const s=n[e];return s&&s.shape?cN(s.shape):t}function ey(n,e,t){const s=n[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):t}function ty(n,e,t,s=!1){const r=n[e];return r&&r.list&&r.list.s?r.list.s.map(o=>uN(o,s)):t}function ny(n,e,t){const s=n[e];return s&&s.list&&s.list.shape?s.list.shape.map(r=>cN(r)):t}function sy(n,e,t){const s=n[e];return s&&s.list&&s.list.b?s.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SW{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,o)=>(r[o]=this.getAttr(o),r),{}))}getInput(e){return zn(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return zn(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return Yg(this.node.rawAttrs,e,t);if(s.s!=null)return qg(this.node.rawAttrs,e,t);if(s.b!=null)return Xg(this.node.rawAttrs,e,t);if(s.shape!=null)return Qg(this.node.rawAttrs,e,t);if(s.type!=null)return Zg(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return ey(this.node.rawAttrs,e,t);if(s.list.s!=null)return ty(this.node.rawAttrs,e,t);if(s.list.shape!=null)return ny(this.node.rawAttrs,e,t);if(s.list.b!=null)return sy(this.node.rawAttrs,e,t);if(s.list.type!=null)return Jg(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gn=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:_k,abs:vn,acos:qk,acosh:Xk,add:Ne,addN:VA,all:Mb,any:pd,argMax:Qa,argMin:Yk,asin:Zk,asinh:Jk,atan:Qk,atan2:eC,atanh:tC,avgPool:Jp,avgPool3d:nC,basicLSTMCell:cR,batchNorm:Ec,batchNorm2d:sC,batchNorm3d:rC,batchNorm4d:oC,batchToSpaceND:Qp,bincount:iC,bitwiseAnd:xR,booleanMaskAsync:sL,broadcastArgs:vR,broadcastTo:Wa,buffer:wt,cast:Ue,ceil:aC,clipByValue:Os,clone:mo,complex:ti,concat:bn,concat1d:lC,concat2d:uC,concat3d:cC,concat4d:hC,conv1d:Vb,conv2d:ri,conv2dTranspose:Ub,conv3d:dC,conv3dTranspose:fC,cos:ef,cosh:Gb,cosineWindow:mx,cumprod:fd,cumsum:Hb,denseBincount:Dg,depthToSpace:mC,depthwiseConv2d:_c,diag:GR,dilation2d:gC,div:nt,divNoNan:yC,dot:bC,dropout:GC,einsum:La,elu:Ac,enclosingPowerOfTwo:HC,ensureShape:eD,equal:Sr,erf:jb,euclideanNorm:vC,exp:Fs,expandDims:os,expm1:kC,eye:qb,fft:mf,fill:gl,floor:Dc,floorDiv:zb,fused:IL,gather:Oc,gatherND:pL,greater:Bs,greaterEqual:bi,ifft:yu,imag:tf,image:Br,inTopKAsync:yL,irfft:ux,isFinite:CC,isInf:SC,isNaN:IC,leakyRelu:nf,less:fu,lessEqual:ha,linalg:QC,linspace:$D,localResponseNormalization:$C,log:Ks,log1p:sf,logSigmoid:NC,logSoftmax:Xb,logSumExp:rf,logicalAnd:Yr,logicalNot:of,logicalOr:Yb,logicalXor:TC,losses:n3,lowerBound:WD,matMul:It,max:ar,maxPool:af,maxPool3d:EC,maxPoolWithArgmax:jD,maximum:No,mean:ln,meshgrid:XD,min:pu,minimum:sa,mirrorPad:_C,mod:AC,moments:lf,movingAverage:iL,mul:H,multiRNNCell:tO,multinomial:sO,neg:Kt,norm:Rc,notEqual:tl,oneHot:Jb,ones:As,onesLike:qs,op:B,outerProduct:lO,pad:xi,pad1d:hO,pad2d:pO,pad3d:mO,pad4d:yO,pool:RC,pow:bo,prelu:cf,print:Kk,prod:DC,raggedGather:IO,raggedRange:NO,raggedTensorToTensor:EO,rand:AO,randomGamma:QO,randomNormal:ex,randomStandardNormal:nF,randomUniform:da,randomUniformInt:oF,range:nl,real:mu,reciprocal:OC,relu:to,relu6:tx,reshape:j,reverse:hr,reverse1d:dF,reverse2d:fF,reverse3d:gF,reverse4d:bF,rfft:gf,round:nx,rsqrt:sx,scalar:it,scatterND:lL,searchSorted:Zb,selu:rx,separableConv2d:ox,setdiff1dAsync:SF,sigmoid:Ur,sign:FC,signal:t3,sin:ix,sinh:ax,slice:Et,slice1d:df,slice2d:lx,slice3d:pf,slice4d:gu,softmax:ff,softplus:yl,spaceToBatchND:uf,sparse:s3,sparseToDense:hL,spectral:e3,split:Rs,sqrt:Vn,square:Wt,squaredDifference:cx,squeeze:pa,stack:Ls,step:bl,stridedSlice:LC,string:r3,sub:Ke,sum:Qe,tan:PC,tanh:na,tensor:wr,tensor1d:us,tensor2d:tu,tensor3d:zC,tensor4d:GF,tensor5d:HF,tensor6d:jF,tensorScatterUpdate:qF,tile:sr,topk:BC,transpose:_t,truncatedNormal:dx,unique:VC,unsortedSegmentSum:px,unstack:dr,upperBound:eL,variable:WC,where:qn,whereAsync:UC,zeros:kn,zerosLike:At},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IW=(n,e,t,s=Gn)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(S("a",n,e,t),S("b",n,e,t))];case"AddN":return[s.addN(S("tensors",n,e,t))];case"FloorMod":case"Mod":return[s.mod(S("a",n,e,t),S("b",n,e,t))];case"Mul":return[s.mul(S("a",n,e,t),S("b",n,e,t))];case"RealDiv":case"Div":return[s.div(S("a",n,e,t),S("b",n,e,t))];case"DivNoNan":return[s.divNoNan(S("a",n,e,t),S("b",n,e,t))];case"FloorDiv":return[s.floorDiv(S("a",n,e,t),S("b",n,e,t))];case"Sub":return[s.sub(S("a",n,e,t),S("b",n,e,t))];case"Minimum":return[s.minimum(S("a",n,e,t),S("b",n,e,t))];case"Maximum":return[s.maximum(S("a",n,e,t),S("b",n,e,t))];case"Pow":return[s.pow(S("a",n,e,t),S("b",n,e,t))];case"SquaredDifference":return[s.squaredDifference(S("a",n,e,t),S("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $W=(n,e,t,s=Gn)=>{switch(n.op){case"Abs":case"ComplexAbs":return[s.abs(S("x",n,e,t))];case"Acos":return[s.acos(S("x",n,e,t))];case"Acosh":return[s.acosh(S("x",n,e,t))];case"Asin":return[s.asin(S("x",n,e,t))];case"Asinh":return[s.asinh(S("x",n,e,t))];case"Atan":return[s.atan(S("x",n,e,t))];case"Atan2":return[s.atan2(S("x",n,e,t),S("y",n,e,t))];case"Atanh":return[s.atanh(S("x",n,e,t))];case"Ceil":return[s.ceil(S("x",n,e,t))];case"Complex":return[s.complex(S("real",n,e,t),S("imag",n,e,t))];case"Cos":return[s.cos(S("x",n,e,t))];case"Cosh":return[s.cosh(S("x",n,e,t))];case"Elu":return[s.elu(S("x",n,e,t))];case"Erf":return[s.erf(S("x",n,e,t))];case"Exp":return[s.exp(S("x",n,e,t))];case"Expm1":return[s.expm1(S("x",n,e,t))];case"Floor":return[s.floor(S("x",n,e,t))];case"Log":return[s.log(S("x",n,e,t))];case"Log1p":return[s.log1p(S("x",n,e,t))];case"Imag":return[s.imag(S("x",n,e,t))];case"Neg":return[s.neg(S("x",n,e,t))];case"Reciprocal":return[s.reciprocal(S("x",n,e,t))];case"Real":return[s.real(S("x",n,e,t))];case"Relu":return[s.relu(S("x",n,e,t))];case"Round":return[s.round(S("x",n,e,t))];case"Selu":return[s.selu(S("x",n,e,t))];case"Sigmoid":return[s.sigmoid(S("x",n,e,t))];case"Sin":return[s.sin(S("x",n,e,t))];case"Sign":return[s.sign(S("x",n,e,t))];case"Sinh":return[s.sinh(S("x",n,e,t))];case"Softplus":return[s.softplus(S("x",n,e,t))];case"Sqrt":return[s.sqrt(S("x",n,e,t))];case"Square":return[s.square(S("x",n,e,t))];case"Tanh":return[s.tanh(S("x",n,e,t))];case"Tan":return[s.tan(S("x",n,e,t))];case"ClipByValue":return[s.clipByValue(S("x",n,e,t),S("clipValueMin",n,e,t),S("clipValueMax",n,e,t))];case"Relu6":return[s.relu6(S("x",n,e,t))];case"Rsqrt":return[s.rsqrt(zn(n.inputNames[0],e,t))];case"LeakyRelu":return[s.leakyRelu(S("x",n,e,t),S("alpha",n,e,t))];case"Prelu":return[s.prelu(S("x",n,e,t),S("alpha",n,e,t))];case"IsNan":return[s.isNaN(zn(n.inputNames[0],e,t))];case"IsInf":return[s.isInf(zn(n.inputNames[0],e,t))];case"IsFinite":return[s.isFinite(zn(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tr(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){A(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let s=0;s<n.length;s++){const r=n[s],o=e[s];A(r<0||o<0||r===o,()=>t+` Shapes ${n} and ${e} must match`)}}}function Wv(n){return!(typeof n=="number"||n.some(e=>e<0))}function Gl(n,e,t){let s=ry(n,t);const r=!Wv(s);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&e.forEach(o=>{s=ry(o.shape,s)}),!Wv(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function ry(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let s=0;s<n.length;++s){const r=n[s],o=e[s];if(r>=0&&o>=0&&r!==o)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[s]=r>=0?r:o}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NW{constructor(e,t,s,r,o,i,a){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=o,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=it(0),Rn(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),tr(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,Rn(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,r)=>this.write(s,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return wr([],[0].concat(this.elementShape));const s=this.readMany(e);return tr(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),Ls(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return wr([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const s=this.readMany(t);return tr(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),bn(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,dr(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const r=e.map(l=>(s+=l,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const o=s===0?0:t.size/s,i=[];oe(()=>{t=j(t,[1,s,o]);for(let l=0;l<e.length;++l){const c=[0,l===0?0:r[l-1],0],h=[1,e[l],o];i[l]=j(Et(t,c,h),this.elementShape)}return i});const a=[];for(let l=0;l<e.length;l++)a[l]=l;this.writeMany(a,i)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ia{get id(){return this.idTensor.id}constructor(e,t,s,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e!=null&&e.forEach(o=>{if(s!==o.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${o.dtype}`);tr(t,o.shape,"TensorList shape mismatch: "),Rn(o)}),this.idTensor=it(0),this.maxNumElements=r,Rn(this.idTensor)}copy(){return new ia([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);tr(e,this.elementShape,"TensorList shape mismatch: ");const r=Gl(this.elementShape,this.tensors,e);return oe(()=>{const o=this.tensors.map(i=>j(i,r));return Ls(o,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=Gl(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,tr(r.shape,e,"TensorList shape mismatch: "),j(r,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(tr(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Rn(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new ia([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);tr(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=Gl(this.elementShape,this.tensors,t);return j(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);tr(this.elementShape,t.shape,"TensorList shape mismatch: "),Rn(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);tr(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=Gl(this.elementShape,this.tensors,s);return e.length===0?wr([],[0].concat(r)):oe(()=>{const o=e.map(i=>j(this.tensors[i],r));return Ls(o,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);tr(this.elementShape,t,"TensorList shape mismatch: ");const s=Gl(this.elementShape,this.tensors,t);return this.size()===0?wr([],[0].concat(s)):oe(()=>{const r=this.tensors.map(o=>j(o,s));return bn(r,0)})}}function TW(n,e,t){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const r=n.shape.slice(1);tr(r,e,"TensorList shape mismatch: ");const o=dr(n);return new ia(o,e,s)}function EW(n,e,t,s){return new ia([],n,e,s)}function _W(n,e,t,s){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const o=new ia([],t,n.dtype,s),i=dr(n,0);return e.forEach((a,l)=>{o.setItem(a,i[l])}),o}function AW(n,e,t){let s=0;const r=e.map(c=>(s+=c,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);const o=n.shape.slice(1),i=ry(o,t),a=s===0?0:n.size/s,l=oe(()=>{const c=[];n=j(n,[1,s,a]);for(let h=0;h<e.length;++h){const p=[0,h===0?0:r[h-1],0],f=[1,e[h],a];c[h]=j(Et(n,p,f),i)}return n.dispose(),c}),u=new ia([],t,n.dtype,e.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RW=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const s=S("thenBranch",n,e,t),r=S("elseBranch",n,e,t),o=S("cond",n,e,t),i=S("args",n,e,t);return(await o.data())[0]?t.functionMap[s].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap):t.functionMap[r].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=S("body",n,e,t),r=S("cond",n,e,t),o=S("args",n,e,t),i=await t.functionMap[r].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap),a=o.map(c=>c.id);let l=await i[0].data();i.forEach(c=>{!c.kept&&a.indexOf(c.id)===-1&&c.dispose()});let u=o;for(;l[0];){const c=u;u=await t.functionMap[s].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);const h=u.map(p=>p.id);c.forEach(p=>{!p.kept&&a.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()});const d=await t.functionMap[r].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);l=await d[0].data(),d.forEach(p=>{!p.kept&&a.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()})}return u}case"LoopCond":{const s=S("pred",n,e,t);return[uo(s)]}case"Switch":{const s=S("pred",n,e,t);let r=S("data",n,e,t);return r.kept||(r=uo(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=n.inputNames.find(r=>zn(r,e,t)!==void 0);if(s){const r=zn(s,e,t);return[uo(r)]}return}case"Enter":{const s=S("frameName",n,e,t),r=S("tensor",n,e,t);return t.enterFrame(s),[uo(r)]}case"Exit":{const s=S("tensor",n,e,t);return t.exitFrame(),[uo(s)]}case"NextIteration":{const s=S("tensor",n,e,t);return t.nextIteration(),[uo(s)]}case"TensorArrayV3":{const s=S("size",n,e,t),r=S("dtype",n,e,t),o=S("elementShape",n,e,t),i=S("dynamicSize",n,e,t),a=S("clearAfterRead",n,e,t),l=S("identicalElementShapes",n,e,t),u=S("name",n,e,t),c=new NW(u,r,s,o,l,i,a);return t.addTensorArray(c),[c.idTensor,it(1)]}case"TensorArrayWriteV3":{const s=S("tensorArrayId",n,e,t),r=S("index",n,e,t),o=S("tensor",n,e,t),i=t.getTensorArray(s.id);return i.write(r,o),[i.idTensor]}case"TensorArrayReadV3":{const s=S("tensorArrayId",n,e,t),r=S("index",n,e,t);return[t.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=S("tensorArrayId",n,e,t),r=S("indices",n,e,t),o=S("dtype",n,e,t);return[t.getTensorArray(s.id).gather(r,o)]}case"TensorArrayScatterV3":{const s=S("tensorArrayId",n,e,t),r=S("indices",n,e,t),o=S("tensor",n,e,t),i=t.getTensorArray(s.id);return i.scatter(r,o),[i.idTensor]}case"TensorArrayConcatV3":{const s=S("tensorArrayId",n,e,t),r=t.getTensorArray(s.id),o=S("dtype",n,e,t);return[r.concat(o)]}case"TensorArraySplitV3":{const s=S("tensorArrayId",n,e,t),r=S("tensor",n,e,t),o=S("lengths",n,e,t),i=t.getTensorArray(s.id);return i.split(o,r),[i.idTensor]}case"TensorArraySizeV3":{const s=S("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return[it(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=S("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=S("tensorListId",n,e,t),r=S("index",n,e,t),o=S("tensor",n,e,t),i=t.getTensorList(s.id);return i.setItem(r,o),[i.idTensor]}case"TensorListGetItem":{const s=S("tensorListId",n,e,t),r=S("index",n,e,t),o=S("elementShape",n,e,t),i=S("elementDType",n,e,t);return[t.getTensorList(s.id).getItem(r,o,i)]}case"TensorListScatterV2":case"TensorListScatter":{const s=S("indices",n,e,t),r=S("tensor",n,e,t),o=S("elementShape",n,e,t),i=S("numElements",n,e,t),a=_W(r,s,o,i);return t.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=S("elementShape",n,e,t),r=S("elementDType",n,e,t);let o;n.op==="TensorListReserve"?o="numElements":o="maxNumElements";const i=S(o,n,e,t),a=n.op==="TensorListReserve"?-1:i,l=EW(s,r,i,a);return t.addTensorList(l),[l.idTensor]}case"TensorListGather":{const s=S("tensorListId",n,e,t),r=S("indices",n,e,t),o=S("elementShape",n,e,t),i=S("elementDType",n,e,t);return[t.getTensorList(s.id).gather(r,i,o)]}case"TensorListStack":{const s=S("tensorListId",n,e,t),r=S("elementShape",n,e,t),o=S("elementDType",n,e,t),i=S("numElements",n,e,t);return[t.getTensorList(s.id).stack(r,o,i)]}case"TensorListFromTensor":{const s=S("tensor",n,e,t),r=S("elementShape",n,e,t),o=S("elementDType",n,e,t),i=TW(s,r,o);return t.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=S("tensorListId",n,e,t),r=t.getTensorList(s.id),o=S("dtype",n,e,t),i=S("elementShape",n,e,t);return[r.concat(o,i)]}case"TensorListPushBack":{const s=S("tensorListId",n,e,t),r=S("tensor",n,e,t),o=t.getTensorList(s.id);return o.pushBack(r),[o.idTensor]}case"TensorListPopBack":{const s=S("tensorListId",n,e,t),r=S("elementShape",n,e,t),o=S("elementDType",n,e,t);return[t.getTensorList(s.id).popBack(r,o)]}case"TensorListSplit":{const s=S("tensor",n,e,t),r=S("elementShape",n,e,t),o=S("lengths",n,e,t),i=AW(s,o,r);return t.addTensorList(i),[i.idTensor]}case"TensorListLength":{const s=S("tensorListId",n,e,t),r=t.getTensorList(s.id);return[it(r.size(),"int32")]}case"TensorListResize":{const s=S("tensorListId",n,e,t),r=S("size",n,e,t),i=t.getTensorList(s.id).resize(r);return t.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uv(n,e,t){const[s,r]=S("fusedOps",n,e,t),o=s==="biasadd",i=!o,a=r==="prelu",l=s==="fusedbatchnorm",u=S("numArgs",n,e,t);if(o){if(a&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&o&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=S("strides",n,e,t),h=Qh(n,e,t),d=S("dataFormat",n,e,t).toUpperCase(),p=S("dilations",n,e,t);let[f,g]=S("args",n,e,t);i&&(g=f,f=void 0);const y=S("leakyreluAlpha",n,e,t);return{stride:c,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:g,activationFunc:r,leakyreluAlpha:y}}const DW=(n,e,t,s=Gn)=>{switch(n.op){case"Conv1D":{const r=S("stride",n,e,t),o=S("pad",n,e,t),i=S("dataFormat",n,e,t).toUpperCase(),a=S("dilation",n,e,t);return[s.conv1d(S("x",n,e,t),S("filter",n,e,t),r,o,i,a)]}case"Conv2D":{const r=S("strides",n,e,t),o=Qh(n,e,t),i=S("dataFormat",n,e,t).toUpperCase(),a=S("dilations",n,e,t);return[s.conv2d(S("x",n,e,t),S("filter",n,e,t),[r[1],r[2]],o,i,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:r,pad:o,dataFormat:i,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=Uv(n,e,t);return[s.fused.conv2d({x:S("x",n,e,t),filter:S("filter",n,e,t),strides:[r[1],r[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:o,dataFormat:i,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=Uv(n,e,t);return[s.fused.depthwiseConv2d({x:S("x",n,e,t),filter:S("filter",n,e,t),strides:[r[1],r[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=S("outputShape",n,e,t),o=S("strides",n,e,t),i=Qh(n,e,t);return[s.conv2dTranspose(S("x",n,e,t),S("filter",n,e,t),r,[o[1],o[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=S("strides",n,e,t),o=Qh(n,e,t),i=S("dilations",n,e,t),a=S("dataFormat",n,e,t).toUpperCase();return[s.depthwiseConv2d(S("input",n,e,t),S("filter",n,e,t),[r[1],r[2]],o,a,[i[1],i[2]])]}case"Conv3D":{const r=S("strides",n,e,t),o=S("pad",n,e,t),i=S("dataFormat",n,e,t).toUpperCase(),a=S("dilations",n,e,t);return[s.conv3d(S("x",n,e,t),S("filter",n,e,t),[r[1],r[2],r[3]],o,i,[a[1],a[2],a[3]])]}case"AvgPool":{const r=S("strides",n,e,t),o=S("pad",n,e,t),i=S("kernelSize",n,e,t);return[s.avgPool(S("x",n,e,t),[i[1],i[2]],[r[1],r[2]],o)]}case"MaxPool":{const r=S("strides",n,e,t),o=S("pad",n,e,t),i=S("kernelSize",n,e,t);return[s.maxPool(S("x",n,e,t),[i[1],i[2]],[r[1],r[2]],o)]}case"MaxPoolWithArgmax":{const r=S("strides",n,e,t),o=S("pad",n,e,t),i=S("kernelSize",n,e,t),a=S("includeBatchInIndex",n,e,t),{result:l,indexes:u}=s.maxPoolWithArgmax(S("x",n,e,t),[i[1],i[2]],[r[1],r[2]],o,a);return[l,u]}case"AvgPool3D":{const r=S("strides",n,e,t),o=S("pad",n,e,t),i=S("kernelSize",n,e,t);return[s.avgPool3d(S("x",n,e,t),[i[1],i[2],i[3]],[r[1],r[2],r[3]],o)]}case"MaxPool3D":{const r=S("strides",n,e,t),o=S("pad",n,e,t),i=S("kernelSize",n,e,t);return[s.maxPool3d(S("x",n,e,t),[i[1],i[2],i[3]],[r[1],r[2],r[3]],o)]}case"Dilation2D":{const r=S("strides",n,e,t),o=S("pad",n,e,t),i=S("dilations",n,e,t),a=r[1],l=r[2],u=i[1],c=i[2];return[s.dilation2d(S("x",n,e,t),S("filter",n,e,t),[a,l],o,[u,c],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OW=(n,e,t,s=Gn)=>{switch(n.op){case"Fill":{const r=S("shape",n,e,t),o=S("dtype",n,e,t),i=S("value",n,e,t);return[s.fill(r,i,o)]}case"LinSpace":{const r=S("start",n,e,t),o=S("stop",n,e,t),i=S("num",n,e,t);return[s.linspace(r,o,i)]}case"Multinomial":{const r=S("logits",n,e,t),o=S("numSamples",n,e,t),i=S("seed",n,e,t);return[s.multinomial(r,o,i)]}case"OneHot":{const r=S("indices",n,e,t),o=S("depth",n,e,t),i=S("onValue",n,e,t),a=S("offValue",n,e,t),l=S("dtype",n,e,t);return[s.oneHot(r,o,i,a,l)]}case"Ones":return[s.ones(S("shape",n,e,t),S("dtype",n,e,t))];case"OnesLike":return[s.onesLike(S("x",n,e,t))];case"RandomStandardNormal":return[s.randomStandardNormal(S("shape",n,e,t),S("dtype",n,e,t),S("seed",n,e,t))];case"RandomUniform":return[s.randomUniform(S("shape",n,e,t),S("minval",n,e,t),S("maxval",n,e,t),S("dtype",n,e,t))];case"RandomUniformInt":return[s.randomUniformInt(S("shape",n,e,t),S("minval",n,e,t),S("maxval",n,e,t),S("seed",n,e,t))];case"Range":{const r=S("start",n,e,t),o=S("stop",n,e,t),i=S("step",n,e,t);return[s.range(r,o,i,S("dtype",n,e,t))]}case"TruncatedNormal":{const r=S("shape",n,e,t),o=S("mean",n,e,t),i=S("stdDev",n,e,t),a=S("seed",n,e,t);return[s.truncatedNormal(r,o,i,S("dtype",n,e,t),a)]}case"Zeros":return[s.zeros(S("shape",n,e,t),S("dtype",n,e,t))];case"ZerosLike":return[s.zerosLike(S("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ym(n,e,t){const s=S("boxes",n,e,t),r=S("scores",n,e,t),o=S("maxOutputSize",n,e,t),i=S("iouThreshold",n,e,t),a=S("scoreThreshold",n,e,t),l=S("softNmsSigma",n,e,t);return{boxes:s,scores:r,maxOutputSize:o,iouThreshold:i,scoreThreshold:a,softNmsSigma:l}}const FW=async(n,e,t,s,r=Gn)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:l,scoreThreshold:u,softNmsSigma:c}=Ym(n,e,t),h=await r.image.nonMaxSuppressionWithScoreAsync(o,i,a,l,u,c);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:l,scoreThreshold:u}=Ym(n,e,t),c=S("padToMaxOutputSize",n,e,t),h=await r.image.nonMaxSuppressionPaddedAsync(o,i,a,l,u,c);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:l,scoreThreshold:u}=Ym(n,e,t);return[await r.image.nonMaxSuppressionAsync(o,i,a,l,u)]}case"Where":{const o=r.cast(S("condition",n,e,t),"bool"),i=[await r.whereAsync(o)];return o.dispose(),i}case"ListDiff":return r.setdiff1dAsync(S("x",n,e,t),S("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LW=(n,e,t,s=Gn)=>{switch(n.op){case"LowerBound":{const r=S("sortedSequence",n,e,t),o=S("values",n,e,t);return[s.lowerBound(r,o)]}case"TopKV2":{const r=S("x",n,e,t),o=S("k",n,e,t),i=S("sorted",n,e,t),a=s.topk(r,o,i);return[a.values,a.indices]}case"UpperBound":{const r=S("sortedSequence",n,e,t),o=S("values",n,e,t);return[s.upperBound(r,o)]}case"Unique":{const r=S("x",n,e,t),o=s.unique(r);return[o.values,o.indices]}case"UniqueV2":{const r=S("x",n,e,t),o=S("axis",n,e,t),i=s.unique(r,o);return[i.values,i.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PW=(n,e,t,s=Gn)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const r=S("default",n,e,t);return[zn(n.name,e,t)||r];case"Placeholder":return[zn(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=S("x",n,e,t);return[uo(c)]}case"IdentityN":return S("x",n,e,t).map(c=>uo(c));case"Snapshot":const o=S("x",n,e,t);return[uo(o)];case"Shape":return[s.tensor1d(S("x",n,e,t).shape,"int32")];case"ShapeN":return S("x",n,e,t).map(c=>s.tensor1d(c.shape));case"Size":return[s.scalar(S("x",n,e,t).size,"int32")];case"Rank":return[s.scalar(S("x",n,e,t).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const i=S("x",n,e,t),a=S("data",n,e,t),l=S("message",n,e,t),u=S("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<a.length;c++)console.log(Array.prototype.slice.call(a[c].dataSync()).slice(0,u));return[i];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zW{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=it(0),this.tensorMap=new Map,Rn(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return it(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),oe(()=>{const r=dr(t),o=s.length,i=r.length;A(o===i,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${i} elements.`);for(let a=0;a<o;a++){const l=s[a],u=r[a];Rn(u),this.tensorMap.set(l,u)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return oe(()=>{const r=[];for(let o=0;o<s.length;o++){const i=s[o],a=this.findWithDefault(i,t);r.push(a)}return Ls(r)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MW=async(n,e,t,s)=>{switch(n.op){case"HashTable":case"HashTableV2":{const r=s.getHashTableHandleByName(n.name);if(r!=null)return[r];{const o=S("keyDType",n,e,t),i=S("valueDType",n,e,t),a=new zW(o,i);return s.addHashTable(n.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=S("tableHandle",n,e,t,s),o=S("keys",n,e,t),i=S("values",n,e,t);return[await s.getHashTableById(r.id).import(o,i)]}case"LookupTableFind":case"LookupTableFindV2":{const r=S("tableHandle",n,e,t,s),o=S("keys",n,e,t),i=S("defaultValue",n,e,t);return[await s.getHashTableById(r.id).find(o,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=S("tableHandle",n,e,t,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BW=(n,e,t,s=Gn)=>{switch(n.op){case"ResizeBilinear":{const r=S("images",n,e,t),o=S("size",n,e,t),i=S("alignCorners",n,e,t),a=S("halfPixelCenters",n,e,t);return[s.image.resizeBilinear(r,[o[0],o[1]],i,a)]}case"ResizeNearestNeighbor":{const r=S("images",n,e,t),o=S("size",n,e,t),i=S("alignCorners",n,e,t),a=S("halfPixelCenters",n,e,t);return[s.image.resizeNearestNeighbor(r,[o[0],o[1]],i,a)]}case"CropAndResize":{const r=S("image",n,e,t),o=S("boxes",n,e,t),i=S("boxInd",n,e,t),a=S("cropSize",n,e,t),l=S("method",n,e,t),u=S("extrapolationValue",n,e,t);return[s.image.cropAndResize(r,o,i,a,l,u)]}case"ImageProjectiveTransformV3":{const r=S("images",n,e,t),o=S("transforms",n,e,t),i=S("outputShape",n,e,t),a=S("fillValue",n,e,t),l=S("interpolation",n,e,t),u=S("fillMode",n,e,t);return[s.image.transform(r,o,l.toLowerCase(),u.toLowerCase(),a,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VW=(n,e,t,s=Gn)=>{switch(n.op){case"Equal":return[s.equal(S("a",n,e,t),S("b",n,e,t))];case"NotEqual":return[s.notEqual(S("a",n,e,t),S("b",n,e,t))];case"Greater":return[s.greater(S("a",n,e,t),S("b",n,e,t))];case"GreaterEqual":return[s.greaterEqual(S("a",n,e,t),S("b",n,e,t))];case"Less":return[s.less(S("a",n,e,t),S("b",n,e,t))];case"LessEqual":return[s.lessEqual(S("a",n,e,t),S("b",n,e,t))];case"LogicalAnd":return[s.logicalAnd(S("a",n,e,t),S("b",n,e,t))];case"LogicalNot":return[s.logicalNot(S("a",n,e,t))];case"LogicalOr":return[s.logicalOr(S("a",n,e,t),S("b",n,e,t))];case"Select":case"SelectV2":return[s.where(S("condition",n,e,t),S("a",n,e,t),S("b",n,e,t))];case"BitwiseAnd":return[s.bitwiseAnd(S("a",n,e,t),S("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WW=(n,e,t,s=Gn)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(S("a",n,e,t),S("b",n,e,t),S("transposeA",n,e,t),S("transposeB",n,e,t))];case"Einsum":return[s.einsum(S("equation",n,e,t),...S("tensors",n,e,t))];case"Transpose":return[s.transpose(S("x",n,e,t),S("perm",n,e,t))];case"_FusedMatMul":const[r,o]=S("fusedOps",n,e,t),i=r==="biasadd",a=o==="prelu",l=S("numArgs",n,e,t),u=S("leakyreluAlpha",n,e,t);if(i){if(a&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,h]=S("args",n,e,t);return[s.fused.matMul({a:S("a",n,e,t),b:S("b",n,e,t),transposeA:S("transposeA",n,e,t),transposeB:S("transposeB",n,e,t),bias:c,activation:o,preluActivationWeights:h,leakyreluAlpha:u})];case"MatrixBandPart":return[s.linalg.bandPart(S("a",n,e,t),S("numLower",n,e,t),S("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UW=(n,e,t,s=Gn)=>{switch(n.op){case"EuclideanNorm":return[s.euclideanNorm(S("x",n,e,t),S("axis",n,e,t),S("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(S("x",n,e,t),S("mean",n,e,t),S("variance",n,e,t),S("offset",n,e,t),S("scale",n,e,t),S("epsilon",n,e,t))];case"FusedBatchNormV3":return[s.batchNorm(S("x",n,e,t),S("mean",n,e,t),S("variance",n,e,t),S("offset",n,e,t),S("scale",n,e,t),S("epsilon",n,e,t))];case"LRN":return[s.localResponseNormalization(S("x",n,e,t),S("radius",n,e,t),S("bias",n,e,t),S("alpha",n,e,t),S("beta",n,e,t))];case"Softmax":return[s.softmax(S("x",n,e,t))];case"LogSoftmax":return[s.logSoftmax(S("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GW=(n,e,t,s=Gn)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:o}=s.raggedGather(S("paramsNestedSplits",n,e,t),S("paramsDenseValues",n,e,t),S("indices",n,e,t),S("outputRaggedRank",n,e,t));return r.concat(o)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:o}=s.raggedRange(S("starts",n,e,t),S("limits",n,e,t),S("splits",n,e,t));return[r,o]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(S("shape",n,e,t),S("values",n,e,t),S("defaultValue",n,e,t),S("rowPartitionTensors",n,e,t),S("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HW=(n,e,t,s=Gn)=>{switch(n.op){case"Max":{const a=S("axis",n,e,t),l=S("keepDims",n,e,t);return[s.max(S("x",n,e,t),a,l)]}case"Mean":{const a=S("axis",n,e,t),l=S("keepDims",n,e,t);return[s.mean(S("x",n,e,t),a,l)]}case"Min":{const a=S("axis",n,e,t),l=S("keepDims",n,e,t);return[s.min(S("x",n,e,t),a,l)]}case"Sum":{const a=S("axis",n,e,t),l=S("keepDims",n,e,t);return[s.sum(S("x",n,e,t),a,l)]}case"All":{const a=S("axis",n,e,t),l=S("keepDims",n,e,t);return[s.all(S("x",n,e,t),a,l)]}case"Any":{const a=S("axis",n,e,t),l=S("keepDims",n,e,t);return[s.any(S("x",n,e,t),a,l)]}case"ArgMax":{const a=S("axis",n,e,t);return[s.argMax(S("x",n,e,t),a)]}case"ArgMin":{const a=S("axis",n,e,t);return[s.argMin(S("x",n,e,t),a)]}case"Prod":{const a=S("axis",n,e,t),l=S("keepDims",n,e,t);return[s.prod(S("x",n,e,t),a,l)]}case"Cumprod":{const a=S("axis",n,e,t),l=S("exclusive",n,e,t),u=S("reverse",n,e,t);return[s.cumprod(S("x",n,e,t),a,l,u)]}case"Cumsum":{const a=S("axis",n,e,t),l=S("exclusive",n,e,t),u=S("reverse",n,e,t);return[s.cumsum(S("x",n,e,t),a,l,u)]}case"Bincount":const r=S("x",n,e,t),o=S("weights",n,e,t),i=S("size",n,e,t);return[s.bincount(r,o,i)];case"DenseBincount":{const a=S("x",n,e,t),l=S("weights",n,e,t),u=S("size",n,e,t),c=S("binaryOutput",n,e,t);return[s.denseBincount(a,l,u,c)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jW=(n,e,t,s=Gn)=>{switch(n.op){case"ConcatV2":case"Concat":{const r=S("n",n,e,t),o=S("axis",n,e,t);let i=S("tensors",n,e,t);return i=i.slice(0,r),[s.concat(i,o)]}case"Gather":{const r=S("x",n,e,t),o=S("indices",n,e,t);return[s.gather(r,s.cast(o,"int32"),0)]}case"GatherV2":{const r=S("axis",n,e,t),o=S("batchDims",n,e,t),i=S("x",n,e,t),a=S("indices",n,e,t);return[s.gather(i,s.cast(a,"int32"),r,o)]}case"Reverse":{const r=S("dims",n,e,t),o=[];for(let a=0;a<r.length;a++)r[a]&&o.push(a);const i=S("x",n,e,t);return[s.reverse(i,o)]}case"ReverseV2":{const r=S("axis",n,e,t),o=S("x",n,e,t);return[s.reverse(o,r)]}case"Slice":{const r=S("begin",n,e,t),o=S("size",n,e,t);return[s.slice(S("x",n,e,t),r,o)]}case"StridedSlice":{const r=S("begin",n,e,t),o=S("end",n,e,t),i=S("strides",n,e,t),a=S("beginMask",n,e,t),l=S("endMask",n,e,t),u=S("ellipsisMask",n,e,t),c=S("newAxisMask",n,e,t),h=S("shrinkAxisMask",n,e,t),d=S("x",n,e,t);return[s.stridedSlice(d,r,o,i,a,l,u,c,h)]}case"Pack":return oe(()=>{const r=S("axis",n,e,t),o=S("tensors",n,e,t),i=o[0].shape,a=s.squeeze(o[0]).shape,l=o.map(u=>{const c=Tt(u.shape,i);if(!c&&!Tt(s.squeeze(u).shape,a))throw new Error("the input tensors shape does not match");return c?u:s.reshape(u,i)});return[s.stack(l,r)]});case"Unpack":{const r=S("axis",n,e,t),o=S("tensor",n,e,t);return s.unstack(o,r)}case"Tile":{const r=S("reps",n,e,t);return[s.tile(S("x",n,e,t),r)]}case"Split":case"SplitV":{const r=S("axis",n,e,t),o=S("numOrSizeSplits",n,e,t),i=S("x",n,e,t);return s.split(i,o,r)}case"ScatterNd":{const r=S("indices",n,e,t),o=S("values",n,e,t),i=S("shape",n,e,t);return[s.scatterND(r,o,i)]}case"GatherNd":{const r=S("x",n,e,t),o=S("indices",n,e,t);return[s.gatherND(r,o)]}case"SparseToDense":{const r=S("sparseIndices",n,e,t),o=S("outputShape",n,e,t),i=S("sparseValues",n,e,t),a=S("defaultValue",n,e,t);return[s.sparseToDense(r,i,o,i.dtype===a.dtype?a:s.cast(a,i.dtype))]}case"TensorScatterUpdate":{const r=S("indices",n,e,t),o=S("values",n,e,t),i=S("tensor",n,e,t);return[s.tensorScatterUpdate(i,r,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KW=(n,e,t,s=Gn)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:o,emptyRowIndicator:i,reverseIndexMap:a}=s.sparse.sparseFillEmptyRows(S("indices",n,e,t),S("values",n,e,t),S("denseShape",n,e,t),S("defaultValue",n,e,t));return[r,o,i,a]}case"SparseReshape":{const{outputIndices:r,outputShape:o}=s.sparse.sparseReshape(S("inputIndices",n,e,t),S("inputShape",n,e,t),S("newShape",n,e,t));return[r,o]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(S("data",n,e,t),S("indices",n,e,t),S("segmentIds",n,e,t))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(S("data",n,e,t),S("indices",n,e,t),S("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qW=(n,e,t,s=Gn)=>{switch(n.op){case"FFT":return[s.fft(S("x",n,e,t))];case"IFFT":return[s.ifft(S("x",n,e,t))];case"RFFT":return[s.rfft(S("x",n,e,t))];case"IRFFT":return[s.irfft(S("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XW=(n,e,t,s=Gn)=>{switch(n.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(S("input",n,e,t),S("pattern",n,e,t),S("rewrite",n,e,t),S("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:r,nGramsSplits:o}=s.string.stringNGrams(S("data",n,e,t),S("dataSplits",n,e,t),S("separator",n,e,t),S("nGramWidths",n,e,t),S("leftPad",n,e,t),S("rightPad",n,e,t),S("padWidth",n,e,t),S("preserveShortSequences",n,e,t));return[r,o]}case"StringSplit":{const{indices:r,values:o,shape:i}=s.string.stringSplit(S("input",n,e,t),S("delimiter",n,e,t),S("skipEmpty",n,e,t));return[r,o,i]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(S("input",n,e,t),S("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YW=(n,e,t,s=Gn)=>{switch(n.op){case"Cast":return[s.cast(S("x",n,e,t),S("dtype",n,e,t))];case"ExpandDims":{const r=S("axis",n,e,t);return[s.expandDims(S("x",n,e,t),r)]}case"Squeeze":{const r=S("axis",n,e,t);return[s.squeeze(S("x",n,e,t),r)]}case"Reshape":return[s.reshape(S("x",n,e,t),S("shape",n,e,t))];case"EnsureShape":return[s.ensureShape(S("x",n,e,t),S("shape",n,e,t))];case"MirrorPad":return[s.mirrorPad(S("x",n,e,t),S("padding",n,e,t),S("mode",n,e,t))];case"PadV2":case"Pad":return[s.pad(S("x",n,e,t),S("padding",n,e,t),S("constantValue",n,e,t))];case"SpaceToBatchND":{const r=S("blockShape",n,e,t),o=S("paddings",n,e,t);return[s.spaceToBatchND(S("x",n,e,t),r,o)]}case"BatchToSpaceND":{const r=S("blockShape",n,e,t),o=S("crops",n,e,t);return[s.batchToSpaceND(S("x",n,e,t),r,o)]}case"DepthToSpace":{const r=S("blockSize",n,e,t),o=S("dataFormat",n,e,t).toUpperCase();return[s.depthToSpace(S("x",n,e,t),r,o)]}case"BroadcastTo":return[s.broadcastTo(S("x",n,e,t),S("shape",n,e,t))];case"BroadcastArgs":return[s.broadcastArgs(S("s0",n,e,t),S("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gv(n,e,t,s,r=oe){const o=((i,a,l)=>{switch(i.category){case"arithmetic":return r(()=>IW(i,a,l));case"basic_math":return r(()=>$W(i,a,l));case"control":return RW(i,a,l);case"convolution":return r(()=>DW(i,a,l));case"creation":return r(()=>OW(i,a,l));case"dynamic":return FW(i,a,l);case"evaluation":return r(()=>LW(i,a,l));case"image":return r(()=>BW(i,a,l));case"graph":return r(()=>PW(i,a,l));case"logical":return r(()=>VW(i,a,l));case"matrices":return r(()=>WW(i,a,l));case"normalization":return r(()=>UW(i,a,l));case"ragged":return r(()=>GW(i,a,l));case"reduction":return r(()=>HW(i,a,l));case"slice_join":return r(()=>jW(i,a,l));case"sparse":return r(()=>KW(i,a,l));case"spectral":return r(()=>qW(i,a,l));case"string":return r(()=>XW(i,a,l));case"transformation":return r(()=>YW(i,a,l));case"hash_table":return MW(i,a,l,s);case"custom":const u=lN(i.op);if(u&&u.customExecutor)return u.customExecutor(new SW(i,a,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return Yi(o)?o.then(i=>[].concat(i)):[].concat(o)}class Hv{constructor(e={},t={},s={},r={},o){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=r,this.parseNodeNameCache=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jv(n,e,t,s){const r=new Set,o=[];let i=null,a=null;const l=new Set,u=new Set(Object.keys(n).map(d=>Ts(d)[0]));s=s||[];const c=new Set(s.map(d=>Ts(d.name)[0])),h=[...e];for(;h.length>0;){const d=h.pop();if((Vi(d)||r4(d)||o4(d))&&i==null&&(i=d,a=i.children.map(p=>p.name).filter(p=>r.has(p))),r.add(d.name),t[d.name]==null&&!u.has(d.name)&&!c.has(d.name)){if(d.inputs.length===0){o.push(d.name);continue}d.inputs.forEach(p=>{l.has(p.name)||(l.add(p.name),h.push(p))})}}return{inputs:n,outputs:e,usedNodes:r,missingInputs:o,dynamicNode:i,syncInputs:a}}function ZW(n,e){const{usedNodes:t,inputs:s}=e,r=Object.keys(s).map(y=>Ts(y)[0]).map(y=>n.nodes[y]),o=n.initNodes||[],i=y=>t.has(typeof y=="string"?y:y.name);function a(y){return[...new Map(y.map(b=>[b.name,b])).values()]}const l=a([...r,...n.weights,...o]).filter(i),u=a([...l,...Object.values(n.nodes)]).filter(i),c=new Map(u.map(y=>[y.name,y])),h={};for(const y of u){h[y.name]=h[y.name]||0;for(const b of y.children)i(b)||(h[b.name]=Number.POSITIVE_INFINITY),h[b.name]=(h[b.name]||0)+1}const d=Object.entries(h).filter(([,y])=>y===0).map(([y])=>y),p=[...d];for(;d.length>0;){const y=d.pop(),b=c.get(y);for(const w of b.children.filter(i))--h[w.name]===0&&(p.push(w.name),d.push(w.name))}const f=p.map(y=>c.get(y)),g=JW(f,l);return QW(g,l),g}function JW(n,e){const t=new Map(n.map(i=>[i.name,i])),s=e.map(i=>i.name),r=new Set(s);for(;s.length>0;){const i=s.pop(),a=t.get(i);for(const l of a.children)!t.has(l.name)||r.has(l.name)||(r.add(l.name),s.push(l.name))}return n.filter(i=>r.has(i.name))}class Ah extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function QW(n,e){const t=new Map(n.map((a,l)=>[a.name,l])),s=new Set(e.map(a=>a.name)),r=a=>s.has(typeof a=="string"?a:a.name),o=new Set(n.map(a=>a.name)),i=a=>o.has(typeof a=="string"?a:a.name);for(const a of n){for(const l of a.children.filter(i)){if(!t.has(l.name))throw new Ah(`Child ${l.name} of node ${a.name} is unreachable.`);if(t.get(a.name)>t.get(l.name))throw new Ah(`Node ${a.name} is scheduled to run after its child ${l.name}.`)}if(!r(a))for(const l of a.inputs){if(!t.has(l.name))throw new Ah(`Input ${l.name} of node ${a.name} is unreachable.`);if(t.get(l.name)>t.get(a.name))throw new Ah(`Node ${a.name} is scheduled to run before its input ${l.name}.`)}}}function e4(n){const e=new Map(n.map((a,l)=>[a.name,l])),t=Number.MAX_SAFE_INTEGER,s=n.map((a,l)=>Vi(a)?t:l),r=a=>{const l=s[e.get(a.name)];return l??-1},o=n.map((a,l)=>a.children.map(r).reduce((u,c)=>Math.max(u,c),s[l])),i=new Map;for(let a=0;a<n.length;++a){const l=o[a];if(l===t)continue;const u=n[a],c=n[l];i.has(c.name)||i.set(c.name,[]),i.get(c.name).push(u)}return i}const t4=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),n4=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),s4=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Vi(n){return t4.has(n.op)}function r4(n){return n4.has(n.op)}function o4(n){return s4.has(n.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Id{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new Id(e.functions[s],this)})}getCompilationKey(e,t){const s=e.map(o=>o.name).sort(),r=t.map(o=>o.name).sort();return s.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const s=jv(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:o,syncInputs:i}=s;if(o!=null)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(r.length>0){const u=t.map(h=>h.name),c=Object.keys(e);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${c}]. Missing the following inputs: [${r}]`)}const a=ZW(this.graph,s),l=e4(a);return{orderedNodes:a,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return Rn(t),t}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,s])=>[t,this.cloneTensorList(s)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=s.map(d=>this.graph.nodes[Ts(d)[0]]),o=t.map(d=>Ts(d)[0]),i=new Set(o);let a=o.map(d=>this.graph.nodes[d]);a.length===0&&(a=this._outputs);const l=this.getCompilationKey(r,a);let u=this.compiledMap.get(l);u==null&&(u=this.compile(e,a),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=ue().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const c={},h={};return oe(()=>{const d=new Hv(this.weightMap,c,h,this.functionExecutorMap,this.parseNodeNameCache),p=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(b=>{const[w,C]=Ts(b,d),v=[];v[C]=e[b],p[w]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[w]=this.cloneTensorList(v))});const f=this.getFrozenTensorIds(p),{orderedNodes:g,nodeLiveUntilMap:y}=u;for(const b of g){if(p[b.name])continue;const w=Gv(b,p,d,this._resourceManager);if(Yi(w))throw new Error(`The execution of the op '${b.op}' returned a promise. Please use model.executeAsync() instead.`);p[b.name]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[b.name]=this.cloneTensorList(w)),this.checkTensorForDisposalWithNodeLiveUntilInfo(b,p,d,f,i,y.get(b.name))}return this.parent==null&&d.dispose(f),t.map(b=>zn(b,p,d))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,s,r,o,i,a){if(!(Vi(t)||i.has(e))){for(const l of s[e])l!=null&&(a[l.id]=(a[l.id]||0)+t.children.length);for(const l of t.inputs){if(Vi(l))continue;const u=Mv(l.name,s,r);if(u!=null)for(const c of u){if(!c||c.kept||o.has(c.id))continue;const h=a[c.id];h===1?(c.dispose(),delete a[c.id]):h!=null&&a[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,s,r,o,i){function a(l){return Vi(l)||o.has(l.name)}if(!(Vi(e)||i==null))for(const l of i){if(a(l))continue;const u=Mv(l.name,t,s);for(const c of u)!c||c.kept||r.has(c.id)||c.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,s=!1,r={},o={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=ue().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const i=new Hv(this.weightMap,r,o,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const a=await this.executeWithControlFlow(e,i,t,s),l=t.map(d=>zn(d,a,i)),u=l.map(d=>d.id),c=Object.keys(e).map(d=>e[d].id),h=new Set([...u,...c,...this.weightIds]);return Object.values(a).forEach(d=>{d.forEach(p=>{p&&!p.isDisposed&&!h.has(p.id)&&p.dispose()})}),this.parent==null&&i.dispose(h),l}async executeFunctionAsync(e,t,s){const r=e.reduce((o,i,a)=>(o[this.inputs[a].name]=i,o),{});return this._executeAsync(r,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,r){const o=Object.keys(e),i=o.map(v=>this.graph.nodes[Ts(v)[0]]),a=s.map(v=>Ts(v)[0]),l=new Set(a);let u=a.map(v=>this.graph.nodes[v]);u.length===0&&(u=this._outputs);const{usedNodes:c,missingInputs:h,dynamicNode:d,syncInputs:p}=jv(e,u,this.weightMap,this._initNodes),f=[...i,...this.graph.weights,...this._initNodes||[]].map(v=>({node:v,contexts:t.currentContext})),g=Object.assign({},this.weightMap);Object.keys(e).forEach(v=>{const[I,E]=Ts(v),R=[];R[E]=e[v],g[I]=R});const y={},b=this.getFrozenTensorIds(g),w={};for(;f.length>0;){const v=this.processStack(i,f,t,g,w,b,l,y,c);await Promise.all(v)}d==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const C=u.filter(v=>!Vi(v)&&!zn(v.name,g,t)).map(v=>v.name);if(C.length>0){let v="";throw d!=null&&(v=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${C}] from the provided inputs [${o}]. Consider providing the following inputs: [${h}]. ${v}`)}return g}processStack(e,t,s,r,o,i,a,l,u){const c=[];for(;t.length>0;){const h=t.pop();s.currentContext=h.contexts;let d="";if(h.node.op==="Enter"&&S("isConstant",h.node,r,s)&&([d]=lo(h.node.name,s)),r[h.node.name]==null){const p=Gv(h.node,r,s,this._resourceManager);d||([d]=lo(h.node.name,s));const f=s.currentContext;Yi(p)?c.push(p.then(g=>(r[d]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(g)),s.currentContext=f,this.checkTensorForDisposal(d,h.node,r,s,i,a,l),this.processChildNodes(h.node,t,s,r,o,u),g))):(r[d]=p,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(p)),this.checkTensorForDisposal(d,h.node,r,s,i,a,l),this.processChildNodes(h.node,t,s,r,o,u))}else this.processChildNodes(h.node,t,s,r,o,u)}return c}processChildNodes(e,t,s,r,o,i){e.children.forEach(a=>{const[l]=lo(a.name,s);o[l]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(u=>!!zn(u,r,s))&&(o[l]=!0,t.push({contexts:s.currentContext,node:a})):a.inputNames.every(u=>!!zn(u,r,s))&&(o[l]=!0,t.push({contexts:s.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[r]=Ts(t),o=this.graph.nodes[r];if(o.attrParams.shape&&o.attrParams.shape.value){const i=o.attrParams.shape.value,a=i.length===s.shape.length&&s.shape.every((l,u)=>i[u]===-1||i[u]===l);A(a,()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${i}], but was [${s.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&A(s.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var t,s;const r={};for(const o in e){const i=(s=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||s===void 0?void 0:s[o];i!=null?r[i.name]=e[o]:r[o]=e[o]}return r}checkInputs(e){const t=Object.keys(e).filter(s=>{const[r]=Ts(s);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var s,r;const o=(r=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||r===void 0?void 0:r[t];return o!=null?o.name:t},{})}checkOutputs(e){e.forEach(t=>{const[s]=Ts(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class i4{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a4="?tfjs-format=file",l4="model.json";class u4{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},s=hS){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=s,t==null&&(this.loadOptions={}),this.resourceManager=new i4}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Yi(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await Fk(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const s=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const o=this.artifacts.userDefinedMetadata;o.signature!=null&&(r=o.signature),o.structuredOutputKeys!=null&&(this.structuredOutputKeys=o.structuredOutputKeys)}if(this.signature=r,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new Id(Bv.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const o=Bv.Instance.transformGraph(e.modelInitializer);this.initializer=new Id(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof sn?[e]:e,s={};return t.forEach((r,o)=>s[this.structuredOutputKeys[o]]=r),s}return e}predict(e,t){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,t){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var t;if(!(e instanceof sn)&&!Array.isArray(e)){const o=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(o!=null)for(const i in o){const a=o[i];a.resourceId!=null&&(e[i]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((o,i)=>{var a,l,u;const c=(u=(l=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||l===void 0?void 0:l[i])===null||u===void 0?void 0:u.resourceId;return c!=null?o[i]=this.resourceIdToCapturedInput[c]:o[i]=e[r++],o},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,s=Object.keys(t);for(let r=0;r<s.length;r++){const o=s[r],i=t[o];this.resourceIdToCapturedInput[i.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&vt(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function c4(n,e={},t=hS){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=h4(n));const s=new u4(n,e,t);return await s.load(),s}function h4(n){return n.endsWith("/")||(n=n+"/"),`${n}${l4}${a4}`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Kv;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(Kv||(Kv={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function et(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&A(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d4=fx;class Ff extends Ny{nextDataId(){return Ff.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new ak(this,Dr())}write(e,t,s){this.firstUse&&(this.firstUse=!1,ue().get("IS_NODE")&&Us(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:s,refCount:1}),r}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&Au(s[0])){const o=s.map(i=>Yo(i));r=this.write(o,e,t)}else r=this.write(s,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,s,r,o){this.data.set(e,{values:t,dtype:r,refCount:o})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:s}=this.data.get(e);if(t==="complex64"){const r=this.readSync(s.real.dataId),o=this.readSync(s.imag.dataId);return wo(r,o)}return p_(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>ei(r));return wt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return wt(e.shape,e.dtype,t)}makeOutput(e,t,s){return Dr().makeTensorFromTensorInfo(this.makeTensorInfo(t,s,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=bs();return e(),{kernelMs:bs()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){et([e],"where");const t=this.readSync(e.dataId);return d4(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}Ff.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hN(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const p4=n=>{const{x:e}=n.inputs,t=n.backend;et(e,"abs");let s=new Float32Array(pe(e.shape));const r=t.data.get(e.dataId).values;return s=hN(r),t.makeOutput(s,e.shape,e.dtype)},f4={kernelName:qd,backendName:"cpu",kernelFunc:p4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mn(n){return(e,t,s,r,o)=>{const i=pt(e,t),a=i.length,l=rt(i),u=pe(i),c=Bn(o,u),h=e.length,d=t.length,p=rt(e),f=rt(t),g=el(e,i),y=el(t,i);if(g.length+y.length===0)for(let b=0;b<c.length;++b)c[b]=n(s[b%s.length],r[b%r.length]);else for(let b=0;b<c.length;++b){const w=fl(b,a,l),C=w.slice(-h);g.forEach(R=>C[R]=0);const v=Wr(C,h,p),I=w.slice(-d);y.forEach(R=>I[R]=0);const E=Wr(I,d,f);c[b]=n(s[v],r[E])}return[c,i]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _s(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,o=t.data.get(s.dataId).values,i=t.data.get(r.dataId).values,a=t.makeTensorInfo(s.shape,"complex64"),l=t.data.get(a.dataId);return l.complexTensorInfos={real:t.makeTensorInfo(s.shape,"float32",o),imag:t.makeTensorInfo(r.shape,"float32",i)},a}const m4={kernelName:Py,backendName:"cpu",kernelFunc:_s};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $d(n,e,t="float32"){if(t==="complex64"){const r=$d(n,e,"float32"),o=$d(n,e,"float32");return _s({inputs:{real:r,imag:o},backend:n})}const s=Xn(pe(e),t);return n.makeTensorInfo(e,t,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jr(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const g4={kernelName:Ju,backendName:"cpu",kernelFunc:Jr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aa(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.real,o=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,o)}const y4={kernelName:mb,backendName:"cpu",kernelFunc:aa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dN(n,e,t,s){if(s==="int32"){const r=Int32Array.from(n);return[e,"int32",r]}if(s==="bool"){const r=ca([0],t),[o,i]=mn((a,l)=>a!==l?1:0)(e,[],n,r,"bool");return[i,"bool",o]}throw new Error(`Error in Cast: failed to cast ${t} to ${s}`)}function ui(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:o}=s;if(o==="complex64"){if(r.dtype==="complex64")return Jr({inputs:{x:r},backend:t});const c=$d(t,r.shape,r.dtype),h=ui({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),d=_s({inputs:{real:h,imag:c},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),d}if(r.dtype==="complex64"){const c=aa({inputs:{input:r},backend:t}),h=ui({inputs:{x:c},backend:t,attrs:{dtype:o}});return t.disposeIntermediateTensorInfo(c),h}if(!uk(r.dtype,o)){const c=Jr({inputs:{x:r},backend:t});return{dataId:c.dataId,shape:c.shape,dtype:o}}const i=t.data.get(r.dataId).values,[a,l,u]=dN(i,r.shape,r.dtype,o);return t.makeTensorInfo(a,l,u)}const b4={kernelName:Mu,backendName:"cpu",kernelFunc:ui};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function En(n,e,t,s){return t==null?({inputs:r,backend:o})=>{const{a:i,b:a}=r,l=o;et([i,a],n);const u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,h=i.dtype==="string"?vo(u):u,d=i.dtype==="string"?vo(c):c,p=s||i.dtype,[f,g]=e(i.shape,a.shape,h,d,p);return l.makeTensorInfo(g,p,f)}:({inputs:r,backend:o})=>{const{a:i,b:a}=r,l=o;if(i.dtype==="complex64"||a.dtype==="complex64"){const u=ui({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),h=c.complexTensorInfos.real,d=c.complexTensorInfos.imag,p=l.data.get(h.dataId).values,f=l.data.get(d.dataId).values,g=ui({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),y=l.data.get(g.dataId),b=y.complexTensorInfos.real,w=y.complexTensorInfos.imag,C=l.data.get(b.dataId).values,v=l.data.get(w.dataId).values,[I,E,R]=t(i.shape,a.shape,p,f,C,v),L=l.makeTensorInfo(R,"float32",I),D=l.makeTensorInfo(R,"float32",E),F=_s({inputs:{real:L,imag:D},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(L),l.disposeIntermediateTensorInfo(D),F}else{const u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,h=s||i.dtype,[d,p]=e(i.shape,a.shape,u,c,h);return l.makeTensorInfo(p,h,d)}}}function b0(n){return(e,t,s,r,o,i)=>{const a=pt(e,t),l=pe(a),u=a.length,c=rt(a),h=Bn("float32",l),d=Bn("float32",l),p=el(e,a),f=el(t,a),g=wo(s,r),y=wo(o,i),b=e.length,w=rt(e),C=t.length,v=rt(t);if(p.length+f.length===0)for(let I=0;I<h.length;I++){const E=I%g.length,R=I%y.length,L=n(g[E*2],g[E*2+1],y[R*2],y[R*2+1]);h[I]=L.real,d[I]=L.imag}else for(let I=0;I<h.length;I++){const E=fl(I,u,c),R=E.slice(-b);p.forEach(V=>R[V]=0);const L=Wr(R,b,w),D=E.slice(-C);f.forEach(V=>D[V]=0);const F=Wr(D,C,v),T=n(g[L*2],g[L*2+1],y[F*2],y[F*2+1]);h[I]=T.real,d[I]=T.imag}return[h,d,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pN=mn((n,e)=>n+e),x4=b0((n,e,t,s)=>({real:n+t,imag:e+s})),rl=En(ml,pN,x4),w4={kernelName:ml,backendName:"cpu",kernelFunc:rl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x0(n,e,t,s,r){const o=pe(s),i=Xn(r,t);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(o>0?i[l]+=e[a]:i[l]+=1)}return i}function fN(n,e,t,s=!1){const r=n.shape[0],o=n.shape[1],i=wt([r,t],e.dtype);for(let a=0;a<r;a++)for(let l=0;l<o;l++){const u=n.get(a,l);if(u<0)throw new Error("Input x must be non-negative!");u>=t||(s?i.set(1,a,u):e.size>0?i.set(i.get(a,u)+e.get(a,l),a,u):i.set(i.get(a,u)+1,a,u))}return i}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mN=mn((n,e)=>n&e),v4=En(np,mN),k4={kernelName:np,backendName:"cpu",kernelFunc:v4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function no(n){return(e,t,s)=>{const r=hn(t,e.length);for(let o=0;o<e.length;++o)r[o]=n(e[o],s);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bt(n,e,t){const s=no(e);return ki(n,s,t)}function ki(n,e,t){return({inputs:s,attrs:r,backend:o})=>{const{x:i}=s;et(i,n);const a=o,l=a.data.get(i.dataId).values;let u;if(i.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=vo(l)}else u=l;const c=t||i.dtype,h=e(u,c,r);return a.makeTensorInfo(i.shape,c,h)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gN=no(n=>Math.ceil(n)),C4=ki(Bu,gN),S4={kernelName:Bu,backendName:"cpu",kernelFunc:C4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yN(n,e,t,s){const r=hn(t,pe(e));if(s&&t!=="string"){let o=0;n.forEach(i=>{const a=pe(i.shape);r.set(i.vals,o),o+=a})}else{let o=0;n.forEach(i=>{const a=t==="string"?vo(i.vals):i.vals;let l=0;for(let u=0;u<i.shape[0];++u){const c=u*e[1]+o;for(let h=0;h<i.shape[1];++h)r[c+h]=a[l++]}o+=i.shape[1]})}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bN=mn((n,e)=>n===e?1:0),xN=En(hp,bN,null,"bool"),I4={kernelName:hp,backendName:"cpu",kernelFunc:xN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wN=no(n=>Math.exp(n)),vN=ki(Ku,wN,"float32"),$4={kernelName:Ku,backendName:"cpu",kernelFunc:vN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kN=no(n=>Math.expm1(n)),N4=ki(qu,kN),T4={kernelName:qu,backendName:"cpu",kernelFunc:N4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CN=no(n=>Math.floor(n)),E4=ki(Xu,CN),_4={kernelName:Xu,backendName:"cpu",kernelFunc:E4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SN=mn((n,e)=>Math.floor(n/e)),A4=En(Yu,SN,null,"int32"),R4={kernelName:Yu,backendName:"cpu",kernelFunc:A4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IN(n,e,t,s,r,o,i,a,l){const u=wt([s,o],t);for(let c=0;c<s;c++){const h=[];let d=0;for(let p=0;p<r;p++){const f=n[c*r+p];d+=f*i[p],h.push(f)}if(d<0||d>=l/o)throw new Error(`Invalid indices: ${h} does not index into ${a}`);for(let p=0;p<o;p++)u.values[c*o+p]=e.get(...e.indexToLoc(d*o+p))}return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $N(n,e,t){const s=wt(t,n.dtype);for(let r=0;r<s.size;++r){const i=s.indexToLoc(r).slice(),a=i[0],l=i[2],u=e.locToIndex([a,l]);i[2]=e.values[u];const c=n.locToIndex(i);0<=c&&c<n.values.length&&(s.values[r]=n.values[c])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NN=mn((n,e)=>n>e?1:0),D4=En(mp,NN,null,"bool"),O4={kernelName:mp,backendName:"cpu",kernelFunc:D4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TN=mn((n,e)=>n>=e?1:0),F4=En(Zu,TN,null,"bool"),L4={kernelName:Zu,backendName:"cpu",kernelFunc:F4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EN=mn((n,e)=>n<e?1:0),P4=En(yp,EN,null,"bool"),z4={kernelName:yp,backendName:"cpu",kernelFunc:P4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _N=mn((n,e)=>n<=e?1:0),M4=En(bp,_N,null,"bool"),B4={kernelName:bp,backendName:"cpu",kernelFunc:M4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AN(n,e,t){const s=(e-n)/(t-1),r=Xn(t,"float32");r[0]=n;for(let o=1;o<r.length;o++)r[o]=r[o-1]+s;return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RN=no(n=>Math.log(n)),V4=ki(nc,RN),W4={kernelName:nc,backendName:"cpu",kernelFunc:V4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DN(n,e,t,s){const r=Bn(s,pe(t));for(let o=0;o<r.length;++o){const i=o*e;let a=n[i];for(let l=0;l<e;++l){const u=n[i+l];(Number.isNaN(u)||u>a)&&(a=u)}r[o]=a}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ON=mn((n,e)=>Math.max(n,e)),U4=En(rc,ON),G4={kernelName:rc,backendName:"cpu",kernelFunc:U4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FN=mn((n,e)=>Math.min(n,e)),H4=En(oc,FN),j4={kernelName:oc,backendName:"cpu",kernelFunc:H4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w0=mn((n,e)=>n*e),K4=b0((n,e,t,s)=>({real:n*t-e*s,imag:n*s+e*t})),Lf=En(ac,w0,K4),q4={kernelName:ac,backendName:"cpu",kernelFunc:Lf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LN(n,e,t){const s=pi(-1,t);return w0([],e,s,n,t)}function X4(n){const{inputs:e,backend:t}=n,{x:s}=e;et(s,"neg");const r=t.data.get(s.dataId).values,[o,i]=LN(r,s.shape,s.dtype);return t.makeTensorInfo(i,s.dtype,o)}const Y4={kernelName:Ep,backendName:"cpu",kernelFunc:X4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PN=mn((n,e)=>n!==e?1:0),Z4=En(_p,PN,null,"bool"),J4={kernelName:_p,backendName:"cpu",kernelFunc:Z4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v0(n,e,t,s,r){const o=e.length,i=pe(e),a=rt(e),l=rt(r),u=Bn(t,pe(r));for(let c=0;c<i;++c){const h=fl(c,o,a),d=new Array(h.length);for(let f=0;f<d.length;f++)d[f]=h[s[f]];const p=Wr(d,o,l);u[p]=n[c]}return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Is(n){const{inputs:e,attrs:t,backend:s}=n,{x:r}=e,{perm:o}=t;et(r,"transpose");const i=r.shape.length,a=new Array(i);for(let h=0;h<a.length;h++)a[h]=r.shape[o[h]];const l=s.data.get(r.dataId).values,u=v0(l,r.shape,r.dtype,o,a);return{dataId:s.write(u,a,r.dtype),shape:a,dtype:r.dtype}}const Q4={kernelName:Ma,backendName:"cpu",kernelFunc:Is};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zN(n,e,t,s){const[r,o]=Fn(n,s),i=Ds(e,"int32"),a=Xn(pe(r),i),l=pe(o);for(let u=0;u<a.length;++u){const c=u*l;let h=1;for(let d=0;d<l;++d)h*=t[c+d];a[u]=h}return{outVals:a,outShape:r,outDtype:i}}function eU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s;et(r,"prod");const a=r.shape.length,l=kt(o,r.shape),u=an(l,a);let c=l,h=r;const d=[];u!=null&&(h=Is({inputs:{x:r},backend:t,attrs:{perm:u}}),d.push(h),c=pn(c.length,a));const p=t.data.get(h.dataId).values,{outVals:f,outShape:g,outDtype:y}=zN(h.shape,h.dtype,p,c);let b=g;return i&&(b=dn(g,l)),d.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.makeTensorInfo(b,y,f)}const tU={kernelName:Lp,backendName:"cpu",kernelFunc:eU};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nU(n,e,t){n.forEach((s,r)=>{if(s<0||s>=t){const o=fl(r,e.length,rt(e)).join(",");throw new Error(`indices[${o}] = ${s} is not in [0, ${t})`)}})}function sU(n,e){for(let t=0;t<n.length;++t){const s=n[t],r=t===n.length-1?e:n[t+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let o=1;o<s.length;++o)if(s[o-1]>s[o])throw new Error("Ragged splits must be sorted in ascending order")}}function rU(n,e,t,s){const r=[];let o=0;const i=e.length-1+t.length,a=new Array(i).fill(null).map(()=>[0]);sU(t,s);let l=1;for(let u=0;u<e.length-1;++u){l*=e[u];const c=e[u+1];for(let h=1;h<l+1;++h)a[u].push(h*c)}for(let u=0;u<n.length;++u){let c=n[u],h=n[u]+1;for(let d=0;d<t.length;++d){const p=t[d],f=d+e.length-1;if(f>=0){const g=a[f],y=g[g.length-1]-p[c];for(let b=c;b<h;++b)a[f].push(p[b+1]+y)}c=p[c],h=p[h]}h!==c&&(r.push([c,h]),o+=h-c)}return{outSplits:a,valueSlices:r,numValues:o}}function oU(n){const e=[];for(let t=0;t<n.length;++t){const s=n[t].length,r=hn("int32",s);e.push(r),n[t].forEach((o,i)=>r[i]=o)}return e}function qv(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let s=e;s<n.length;s++)t[e-1]*=n[s];return t}function iU(n,e,t,s,r,o){const i=qv(e,2)[1],a=qv(o,2)[1];let l=0;for(const u of t)for(let c=u[0];c<u[1];++c){for(let h=0;h<s;++h)r[l*a+h]=n[c*i+h];++l}}function aU(n,e,t,s,r){const o=e.slice();o[0]=r;const i=hn(t,pe(o)),a=n.length,l=a===0?0:a/e[0];return iU(n,e,s,l,i,o),[i,o]}function MN(n,e,t,s,r,o,i,a){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(nU(o,i,l),s.length===0)throw new Error("params.rank must be nonzero");const u=s[0],{outSplits:c,valueSlices:h,numValues:d}=rU(o,i,n,u),p=oU(c),f=aU(t,s,r,h,d);return[p,f[0],f[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xv=2147483647;function BN(n,e,t,s,r,o,i){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,l=r.length===0,u=i.length===0,c=[];a||c.push(e[0]),l||c.push(r[0]),u||c.push(i[0]);for(let y=1;y<c.length;++y)if(c[y]!==c[y-1])throw new Error("starts, limits, and deltas must have the same shape");const h=c.length===0?1:c[0],d=hn("int32",h+1);d[0]=0;for(let y=0;y<h;++y){const b=a?n[0]:n[y],w=l?s[0]:s[y],C=u?o[0]:o[y];if(C===0)throw new Error("Requires delta != 0");let v;if(C>0&&w<b||C<0&&w>b)v=0;else if(v=Math.ceil(Math.abs((w-b)/C)),v>Xv)throw new Error(`Requires ((limit - start) / delta) <= ${Xv}`);d[y+1]=d[y]+v}const p=d[h],f=hn(t,p);let g=0;for(let y=0;y<h;++y){const b=d[y+1]-d[y];let w=a?n[0]:n[y];const C=u?o[0]:o[y];for(let v=0;v<b;++v)f[g++]=w,w+=C}return[d,f]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Qs=xr;class Nd{constructor(e,t,s,r,o,i,a,l,u,c){this.shape=e,this.shapeShape=t,this.values=s,this.valuesShape=r,this.valuesDType=o,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=kS(c),this.raggedRank=CS(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Qs.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Qs.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Qs.VALUE_ROWIDS:return Nd.getMaxWidthValueRowID(t);case Qs.ROW_SPLITS:return Nd.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Qs[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let s=0;for(let r=0;r<t-1;++r){const o=e[r+1]-e[r];o>s&&(s=o)}return s}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let s=0,r=e[0],o=0;for(let i=1;i<t;++i){const a=e[i];a!==r&&(r=a,o=Math.max(i-s,o),s=i)}return Math.max(t-s,o)}tensorShapeFromTensor(e,t,s=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return Zv(e,s)}calculateOutputSize(e){const t=this.valuesShape,s=this.defaultValueShape;SS(s,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=vS(this.raggedRank,r,t);i[0]<0&&(i[0]=e);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(e,t,s){const r=Math.min(e,s),o=[];let i=0;for(let a=0;a<r;++a,i+=t)o.push(i);for(let a=r;a<e;++a)o.push(-1);return A(o.length===e,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(e,t,s,r){const o=e.length,i=[];for(let a=0;a<o-1;++a){const l=e[a+1]-e[a];let u=Math.min(r,l),c=t[a];c===-1&&(u=0);for(let h=0;h<u;++h)i.push(c),c+=s;for(let h=0;h<l-u;++h)i.push(-1)}if(o>0&&i.length!==e[o-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(e,t,s,r){const o=e.length,i=[];if(o===0)return[];let a=0,l=e[0];if(l>=t.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);let u=t[l];i.push(u);for(let c=1;c<o;++c){const h=e[c];if(h===l)u>=0&&(++a,a<r?u+=s:u=-1);else{if(a=0,l=h,h>=t.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${t.length}`);u=t[h]}i.push(u)}if(i.length!==e.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(e,t,s,r){const o=this.getRowPartitionTensor(e),i=this.getRowPartitionTypeByDimension(e);switch(i){case Qs.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,t,s,r);case Qs.ROW_SPLITS:if(o.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(o,t,s,r);default:throw new Error(`Unsupported partition type: ${Qs[i]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Qs.FIRST_DIM_SIZE:return e[0];case Qs.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Qs.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Qs[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),s=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let l=r.length-2;l>=0;--l)r[l]=r[l+1]*s[l+1];const o=Zv(s,!1),i=hn(this.valuesDType,pe(o));if(r[0]*s[0]>0){let l=this.calculateFirstParentOutputIndex(t,r[0],s[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,r[u],s[u]);this.setOutput(this.raggedRank,l,i,o)}return[o,i]}setOutput(e,t,s,r){if(s.length===0)return;const o=this.values,i=s;let a=r.slice();a=a.slice(e+1);const l=pe(a),u=t.length;let c=this.defaultValue;if(c.length!==l&&c.length!==1){const f=this.defaultValueShape;oe(()=>{const g=j(c,f);c=Wa(g,a).dataSync()})}let h=0,d=0,p=0;for(let f=0;f<=u;++f){let g=f<u?t[f]:-1;if(g===p){++p;continue}if(d<p){const y=o.subarray(h*l),b=i.subarray(d*l),w=(p-d)*l;Yv(b,y,w)}if(f>=u){const y=s.length;g=Math.floor(y/l)}if(g>p)if(this.defaultValue.length===1)i.subarray(p*l,g*l).fill(this.defaultValue[0]),p=g;else for(;g>p;){const y=i.slice(p*l);Yv(y,c,l),++p}g<0?(h=f+1,d=p):(h=f,d=p,p=d+1)}}}function Yv(n,e,t){for(let s=0;s<t;s++)n[s]=e[s]}function Zv(n,e){const t=[];for(let s of n){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}t.push(s)}return t}function VN(n,e,t,s,r,o,i,a,l,u){return new Nd(n,e,t,s,r,o,i,a,l,u).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WN(n,e,t,s){const r=n===e,o=n<e&&t<0,i=e<n&&t>1;if(r||o||i)return Xn(0,s);const a=Math.abs(Math.ceil((e-n)/t)),l=Xn(a,s);e<n&&t===1&&(t=-1),l[0]=n;for(let u=1;u<l.length;u++)l[u]=l[u-1]+t;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UN=no(n=>1/Math.sqrt(n)),lU=ki(pc,UN),uU={kernelName:pc,backendName:"cpu",kernelFunc:lU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gi(n,e,t,s,r,o,i,a,l,u){const c=[s/r,r],h=n.values,d=e.values;if(s===0)return wt(t,e.dtype);const p=l instanceof In?l:wt(c,e.dtype);typeof l=="string"||typeof l=="number"?p.values.fill(l):typeof l=="boolean"&&p.values.fill(+l);for(let f=0;f<o;f++){const g=[];let y=0;for(let b=0;b<i;b++){const w=h[f*i+b];g.push(w),y+=w*a[b]}if(y<0||y>=s/r)throw new Error(`Invalid indices: ${g} does not index into ${t}`);for(let b=0;b<r;b++)u?p.values[y*r+b]+=d[f*r+b]:p.values[y*r+b]=e.rank===0?d[0]:d[f*r+b]}return p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cU=no(n=>1/(1+Math.exp(-n))),GN=Bt(bc,n=>1/(1+Math.exp(-n))),hU={kernelName:bc,backendName:"cpu",kernelFunc:GN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HN(n,e,t,s,r){const o=Nx(s,e,t),i=pe(t),a=rt(s);if(o){const h=Tx(e,a);return r==="string"?n.slice(h,h+i):n.subarray(h,h+i)}const l=r==="string"?vo(n):n,u=wt(s,r,l),c=wt(t,r);for(let h=0;h<c.size;++h){const d=c.indexToLoc(h),p=d.map((f,g)=>f+e[g]);c.set(u.get(...p),...d)}return r==="string"?GS(c.values):c.values}function la(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:o,size:i}=s;et(r,"slice");const[a,l]=vf(r,o,i);Ix(r,a,l);const u=t.data.get(r.dataId).values,c=HN(u,a,l,r.shape,r.dtype);return t.makeTensorInfo(l,r.dtype,c)}const dU={kernelName:Wp,backendName:"cpu",kernelFunc:la};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jN(n,e,t,s,r,o,i){const a=e[0],l=o[0],u=new Array(l),c=new Array(a),h=e[1];if(l===0){if(a!==0)throw new Error(AS(a));const y=hn(t,0),b=hn(r,0);return[y,[0,h],b,u,c]}let d=!0,p=0;const f=new Array(l).fill(0);for(let y=0;y<a;++y){const b=n[y*h];if(b<0)throw new Error(RS(y,b));if(b>=l)throw new Error(DS(y,b,l));++f[b],d=d&&b>=p,p=b}let g=!0;for(let y=0;y<l;++y){const b=f[y]===0;u[y]=b,g=g&&!b,f[y]=Math.max(f[y],1),y>0&&(f[y]+=f[y-1])}if(g&&d){const y=n,b=s;for(let w=0;w<a;++w)c[w]=w;return[y,[a,h],b,u,c]}else{const y=f[l-1],b=hn(t,y*h),w=hn(r,y),C=new Array(l).fill(0);for(let v=0;v<a;++v){const I=n[v*h],E=C[I],R=(I===0?0:f[I-1])+E;C[I]++;for(let L=0;L<h;++L)b[R*h+L]=n[v*h+L];w[R]=s[v],c[v]=R}for(let v=0;v<l;++v)if(C[v]===0){const E=v===0?0:f[v-1];b[E*h+0]=v;for(let R=1;R<h;++R)b[E*h+R]=0;w[E]=i}return[b,[y,h],w,u,c]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KN(n,e,t,s,r){const o=pe(s),i=e[0],a=r.length,l=[];let u=1,c=-1;for(let y=0;y<a;++y){const b=r[y];if(b===-1){if(c!==-1)throw new Error(OS(c,y));c=y,l.push(1)}else{if(b<0)throw new Error(FS(y,b));u*=b,l.push(b)}}if(c!==-1){if(u<=0)throw new Error(LS());const y=Math.trunc(o/u);if(u*y!==o)throw new Error(PS(s,l));l[c]=y}if(pe(l)!==o)throw new Error(zS(s,l));const d=s.length,p=[];if(d>0){p[d-1]=1;for(let y=d-2;y>=0;--y)p[y]=p[y+1]*s[y+1]}const f=[];if(a>0){f[a-1]=1;for(let y=a-2;y>=0;--y)f[y]=f[y+1]*l[y+1]}const g=hn(t,i*a);for(let y=0;y<i;++y){let b=0;for(let w=0;w<d;++w)b+=n[y*d+w]*p[w];for(let w=0;w<a;++w)g[y*a+w]=Math.trunc(b/f[w]),b%=f[w]}return[g,[i,a],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k0(n,e,t,s,r,o=!1,i=0){const a=s.length,l=[e[0],n.length/e[0]],u=l[1],h=a>0?r[a-1]+1:0;if(h<0)throw new Error(Pg());const d=e.slice();d[0]=h;const p=d.reduce((C,v)=>C*v,1),f=hn(t,p);if(a===0)return h>0&&f.fill(i),[f,d];if(h<=0)throw new Error(Pg());let g=0,y=1,b=0,w=r[g];for(;;){let C=0;if(y<a){if(C=r[y],w===C){++y;continue}if(w>=C)throw new Error(MS())}if(w<0||w>=h)throw new Error(BS(w,h));w>b&&f.fill(i,b*u,w*u);for(let v=g;v<y;++v){const I=s[v];if(I<0||I>=l[0])throw new Error(VS(v,s[v],l[0]));for(let E=0;E<u;E++)f[w*u+E]+=n[I*u+E]}if(o)for(let v=0;v<u;v++)f[w*u+v]/=y-g;if(g=y,++y,b=w+1,w=C,y>a)break}return b<h&&f.fill(i,b*u,h*u),[f,d]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pU=no(n=>Math.sqrt(n)),fU=Bt(wc,n=>Math.sqrt(n)),mU={kernelName:wc,backendName:"cpu",kernelFunc:fU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qN=mn((n,e)=>{const t=n-e;return t*t}),gU=En(vc,qN),yU={kernelName:vc,backendName:"cpu",kernelFunc:gU};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XN=no((n,e)=>{const{pattern:t,replaceGlobal:s,rewrite:r}=e;return n.replace(new RegExp(t,s?"g":""),r)}),bU=ki(Kp,XN),xU={kernelName:Kp,backendName:"cpu",kernelFunc:bU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YN(n,e,t,s){const r=wt(n,e.dtype);for(let o=0;o<r.size;o++){const i=r.indexToLoc(o),a=new Array(i.length);for(let l=0;l<a.length;l++)a[l]=i[l]*t[l]+s[l];r.set(e.get(...a),...i)}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wU{constructor(e,t,s,r,o,i){this.separator=Yo(e),this.nGramWidths=t,this.leftPad=Yo(s),this.rightPad=Yo(r),this.padWidth=o,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,r,o,i){for(let a=0;a<o;++a){const l=this.getPadWidth(i),u=Math.max(0,l-a),c=Math.max(0,l-(o-(a+1))),h=i-(u+c),d=t+(u>0?0:a-l);let p=0;p+=u*this.leftPad.length;for(let w=0;w<h;++w)p+=e[d+w].length;p+=c*this.rightPad.length;const f=u+c+h-1;p+=f*this.separator.length,s[r+a]=new Uint8Array(p);const g=s[r+a];let y=0;const b=w=>w.forEach(C=>g[y++]=C);for(let w=0;w<u;++w)b(this.leftPad),b(this.separator);for(let w=0;w<h-1;++w)b(e[d+w]),b(this.separator);if(h>0){b(e[d+h-1]);for(let w=0;w<c;++w)b(this.separator),b(this.rightPad)}else{for(let w=0;w<c-1;++w)b(this.rightPad),b(this.separator);b(this.rightPad)}}}compute(e,t){const s=e.length,r=t.length;if(r>0){let l=t[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<r;++u){let c=t[u]>=l;if(c=c&&t[u]<=s,!c)throw new Error(`Invalid split value ${t[u]}, must be in [${l}, ${s}]`);l=t[u]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const o=r-1,i=hn("int32",r);if(s===0||r===0){const l=new Array(s);for(let u=0;u<=o;++u)i[u]=0;return[l,i]}i[0]=0;for(let l=1;l<=o;++l){const u=t[l]-t[l-1];let c=0;this.nGramWidths.forEach(h=>{c+=this.getNumNGrams(u,h)}),this.preserveShort&&u>0&&c===0&&(c=1),i[l]=i[l-1]+c}const a=new Array(i[o]);for(let l=0;l<o;++l){const u=t[l];let c=i[l];if(this.nGramWidths.forEach(h=>{const d=t[l+1]-t[l],p=this.getNumNGrams(d,h);this.createNGrams(e,u,a,c,p,h),c+=p}),this.preserveShort&&c===i[l]){const h=t[l+1]-t[l];if(h===0)continue;const d=h+2*this.padWidth;this.createNGrams(e,u,a,c,1,d)}}return[a,i]}}function ZN(n,e,t,s,r,o,i,a){return new wU(t,s,r,o,i,a).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vU(n,e,t,s){if(!n.length)return;if(e.length===0){for(let o=0;o<n.length;++o)s.push(n.subarray(o,o+1));return}if(e.length===1){const o=e[0];let i=n.indexOf(o);for(;i!==-1;){const a=n.subarray(0,i);(!t||a.length!==0)&&s.push(a),n=n.subarray(i+1),i=n.indexOf(o)}(!t||n.length!==0)&&s.push(n);return}let r=0;for(let o=0;o<n.length+1;o++)if(o===n.length||e.indexOf(n[o])!==-1){const i=n.subarray(r,o);(!t||i.length!==0)&&s.push(i),r=o+1}}function JN(n,e,t){const s=n.length,r=[];let o=0,i=0;const a=new Array(s);for(let d=0;d<s;++d){const p=r.length;vU(n[d],e,t,r);const f=r.length-p;a[d]=f,o+=f,i=Math.max(i,f)}const l=hn("int32",o*2),u=new Array(o),c=[s,i];let h=0;for(let d=0;d<s;++d)for(let p=0;p<a[d];++p)l[h*2]=d,l[h*2+1]=p,u[h]=r[h],++h;return[l,u,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QN(n,e){const t=hn("int32",n.length);for(let s=0;s<n.length;++s)t[s]=D_(n[s]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eT=mn((n,e)=>n-e),kU=b0((n,e,t,s)=>({real:n-t,imag:e-s})),C0=En(kc,eT,kU),CU={kernelName:kc,backendName:"cpu",kernelFunc:C0};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tT(n,e){const t=new Array(n.rank);for(let r=0;r<t.length;r++)t[r]=n.shape[r]*e[r];const s=wt(t,n.dtype);for(let r=0;r<s.values.length;++r){const o=s.indexToLoc(r),i=new Array(n.rank);for(let l=0;l<i.length;l++)i[l]=o[l]%n.shape[l];const a=n.locToIndex(i);s.values[r]=n.values[a]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zl=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function nT(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const a=s-t+1,l=e-t+1,u=Math.log(a),c=.5*Math.exp(2*u/3),h=.5*Math.sqrt(u*c*(a-c)/a)*Math.sign(l-a/2),d=Math.max(t,Math.floor(e-l*c/a+h)),p=Math.min(s,Math.floor(e+(a-l)*c/a+h));nT(n,e,d,p)}const r=n[e];let o=t,i=s;for(Da(n,t,e),Zl(n[s],r)>0&&Da(n,t,s);o<i;){for(Da(n,o,i),o++,i--;Zl(n[o],r)<0;)o=o+1;for(;Zl(n[i],r)>0;)i=i-1}Zl(n[t],r)===0?Da(n,t,i):(i=i+1,Da(n,i,s)),i<=e&&(t=i+1),e<=i&&(s=i-1)}}function sT(n,e,t,s,r){const o=e[e.length-1],[i,a]=[n.length/o,o],l=Bn(t,i*s),u=Bn("int32",i*s);for(let h=0;h<i;h++){const d=h*a,p=n.subarray(d,d+a);let f=new Array(p.length);p.forEach((w,C)=>f[C]={value:w,index:C}),s<f.length&&(nT(f,s),f=f.slice(0,s)),r&&f.sort(Zl);const g=h*s,y=l.subarray(g,g+s),b=u.subarray(g,g+s);for(let w=0;w<s;w++)y[w]=f[w].value,b[w]=f[w].index}const c=e.slice();return c[c.length-1]=s,[wt(c,t,l),wt(c,"int32",u)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rT(n,e,t,s){const r=kt(e,t)[0],o=[1,t[0],1];for(let f=0;f<r;f++)o[0]*=t[f];o[1]=t[r];for(let f=r+1;f<t.length;f++)o[2]*=t[f];const i=new Map,a=new Int32Array(t[r]),l=new In(o,s,n),u=[],c=o[0]===1&&o[2]===1;for(let f=0;f<t[r];f++){let g;if(c)g=n[f].toString();else{const b=[];for(let w=0;w<o[0];w++)for(let C=0;C<o[2];C++)b.push(l.get(w,f,C));g=b.join(",")}const y=i.get(g);if(y!=null)a[f]=y;else{const b=i.size;i.set(g,b),a[f]=b,u.push(f)}}const h=o.slice();h[1]=i.size;const d=new In(h,s);u.forEach((f,g)=>{for(let y=0;y<o[0];y++)for(let b=0;b<o[2];b++)d.set(l.get(y,f,b),y,g,b)});const p=t.slice();return p[r]=h[1],{outputValues:d.values,outputShape:p,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SU=Object.freeze(Object.defineProperty({__proto__:null,addImpl:pN,bincountImpl:x0,bincountReduceImpl:fN,bitwiseAndImpl:mN,castImpl:dN,ceilImpl:gN,concatImpl:yN,equalImpl:bN,expImpl:wN,expm1Impl:kN,floorDivImpl:SN,floorImpl:CN,gatherNdImpl:IN,gatherV2Impl:$N,greaterEqualImpl:TN,greaterImpl:NN,lessEqualImpl:_N,lessImpl:EN,linSpaceImpl:AN,logImpl:RN,maxImpl:DN,maximumImpl:ON,minimumImpl:FN,multiplyImpl:w0,negImpl:LN,notEqualImpl:PN,prodImpl:zN,raggedGatherImpl:MN,raggedRangeImpl:BN,raggedTensorToTensorImpl:VN,rangeImpl:WN,rsqrtImpl:UN,scatterImpl:Gi,sigmoidImpl:cU,simpleAbsImpl:hN,sliceImpl:HN,sparseFillEmptyRowsImpl:jN,sparseReshapeImpl:KN,sparseSegmentReductionImpl:k0,sqrtImpl:pU,squaredDifferenceImpl:qN,staticRegexReplaceImpl:XN,stridedSliceImpl:YN,stringNGramsImpl:ZN,stringSplitImpl:JN,stringToHashBucketFastImpl:QN,subImpl:eT,tileImpl:tT,topKImpl:sT,transposeImpl:v0,uniqueImpl:rT},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ak("cpu",()=>new Ff,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oT=Bt(Hu,n=>n>=0?n:Math.exp(n)-1),IU={kernelName:Hu,backendName:"cpu",kernelFunc:oT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iT(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:o}=s;et([r],"leakyRelu");const i=pe(r.shape),a=t.data.get(r.dataId).values,l=Bn("float32",i);for(let u=0;u<a.length;u++)l[u]=a[u]<0?o*a[u]:a[u];return t.makeTensorInfo(r.shape,"float32",l)}const $U={kernelName:gp,backendName:"cpu",kernelFunc:iT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NU=mn((n,e)=>n<0?e*n:n);function aT(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e;et([s,r],"prelu");const o=t.data.get(s.dataId).values,i=t.data.get(r.dataId).values,[a,l]=NU(s.shape,r.shape,o,i,"float32");return t.makeTensorInfo(l,"float32",a)}const TU={kernelName:Fp,backendName:"cpu",kernelFunc:aT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lT=Bt(cc,n=>Math.max(0,n)),EU={kernelName:cc,backendName:"cpu",kernelFunc:lT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uT=Bt(hc,n=>Math.min(Math.max(0,n),6)),_U={kernelName:hc,backendName:"cpu",kernelFunc:uT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Td(n,e,t,s,r){if(t==="linear")return Jr({inputs:{x:e},backend:n});if(t==="relu")return lT({inputs:{x:e},backend:n});if(t==="elu")return oT({inputs:{x:e},backend:n});if(t==="relu6")return uT({inputs:{x:e},backend:n});if(t==="prelu")return aT({inputs:{x:e,alpha:s},backend:n});if(t==="leakyrelu")return iT({inputs:{x:e},backend:n,attrs:{alpha:r}});if(t==="sigmoid")return GN({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ht(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:o}=s,i=pe(r.shape),a=lk(o,i),l=pe(a);A(i===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),t.incRef(r.dataId);const u=t.data.get(r.dataId);if(u.complexTensorInfos!=null){const c=u.complexTensorInfos.real,h=u.complexTensorInfos.imag;c.shape=a,h.shape=a}return{dataId:r.dataId,shape:a,dtype:r.dtype}}const AU={kernelName:Pp,backendName:"cpu",kernelFunc:Ht};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cT(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:o}=e,{transposeA:i,transposeB:a}=s;et([r,o],"matMul");const l=r.shape.length,u=o.shape.length,c=i?r.shape[l-2]:r.shape[l-1],h=a?o.shape[u-1]:o.shape[u-2],d=i?r.shape[l-1]:r.shape[l-2],p=a?o.shape[u-2]:o.shape[u-1],f=r.shape.slice(0,-2),g=o.shape.slice(0,-2),y=pe(f),b=pe(g),C=pt(r.shape.slice(0,-2),o.shape.slice(0,-2)).concat([d,p]);A(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${r.shape} and ${o.shape} and transposeA=${i} and transposeB=${a} must match.`);const v=i?[y,c,d]:[y,d,c],I=a?[b,p,h]:[b,h,p],E=Ht({inputs:{x:r},backend:t,attrs:{shape:v}}),R=Ht({inputs:{x:o},backend:t,attrs:{shape:I}}),L=i?E.shape[1]:E.shape[2],D=i?E.shape[2]:E.shape[1],F=a?R.shape[1]:R.shape[2],T=Math.max(y,b),V=t.data.get(E.dataId).values,q=t.data.get(R.dataId).values,se=rt(E.shape),ee=rt(R.shape),[te,le,Q]=i?[se[0],1,se[1]]:[se[0],se[1],1],[he,ye,we]=a?[1,ee[1],ee[0]]:[ee[1],1,ee[0]],Ce=D*F,Se=wt([T,D,F],E.dtype),Le=Se.values,Ae=t.blockSize;for(let Me=0;Me<T;Me++){const Ze=Me%y,ot=Me%b;for(let $e=0;$e<D;$e+=Ae){const at=Math.min($e+Ae,D);for(let ht=0;ht<F;ht+=Ae){const z=Math.min(ht+Ae,F);for(let U=0;U<L;U+=Ae){const de=Math.min(U+Ae,L);for(let xe=$e;xe<at;xe++)for(let be=ht;be<z;be++){let ve=0;for(let _e=U;_e<de;_e++){const Oe=V[Ze*te+xe*le+_e*Q],Ee=q[_e*he+be*ye+ot*we];ve+=Oe*Ee}Le[Me*Ce+(xe*F+be)]+=ve}}}}}return t.disposeIntermediateTensorInfo(E),t.disposeIntermediateTensorInfo(R),t.makeTensorInfo(C,Se.dtype,Se.values)}const RU={kernelName:ep,backendName:"cpu",kernelFunc:cT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DU(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:o,bias:i,preluActivationWeights:a}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;let d,p,f;const g=[];d=cT({inputs:{a:r,b:o},attrs:{transposeA:l,transposeB:u},backend:t}),i&&(p=rl({inputs:{a:d,b:i},backend:t}),g.push(d),d=p),c&&(f=Td(t,d,c,a,h),g.push(d),d=f);for(const b of g)t.disposeIntermediateTensorInfo(b);return d}const OU={kernelName:ad,backendName:"cpu",kernelFunc:DU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FU=Bt(Ru,n=>Math.acos(n)),LU={kernelName:Ru,backendName:"cpu",kernelFunc:FU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PU=Bt(Du,n=>Math.acosh(n)),zU={kernelName:Du,backendName:"cpu",kernelFunc:PU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MU(n){const{inputs:e,backend:t}=n,s=e;et(e,"addN");const r=s.map(a=>t.data.get(a.dataId).values),o=wt(s[0].shape,s[0].dtype),i=o.values;for(let a=0;a<s.length;a++){const l=r[a];for(let u=0;u<i.length;u++)i[u]+=l[u]}return t.makeTensorInfo(o.shape,o.dtype,o.values)}const BU={kernelName:Xd,backendName:"cpu",kernelFunc:MU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s;et(r,"all");const a=kt(o,r.shape);let l=a;const u=an(l,r.shape.length);let c=r;u!=null&&(c=Is({inputs:{x:r},backend:t,attrs:{perm:u}}),l=pn(l.length,r.shape.length)),Un("all",l,c.shape.length);const[h,d]=Fn(c.shape,l),p=pe(d),f=Xn(pe(h),c.dtype),g=t.data.get(c.dataId).values;for(let b=0;b<f.length;++b){const w=b*p;let C=g[w];for(let v=0;v<p;++v){const I=g[w+v];C=C&&I}f[b]=C}u!=null&&t.disposeIntermediateTensorInfo(c);const y=t.makeTensorInfo(h,c.dtype,f);if(i){const b=dn(h,a),w=Ht({inputs:{x:y},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(y),w}return y}const WU={kernelName:Ay,backendName:"cpu",kernelFunc:VU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s;et(r,"any");const a=kt(o,r.shape);let l=a;const u=an(l,r.shape.length);let c=r;u!=null&&(c=Is({inputs:{x:r},backend:t,attrs:{perm:u}}),l=pn(l.length,r.shape.length)),Un("any",l,c.shape.length);const[h,d]=Fn(c.shape,l),p=pe(d),f=Xn(pe(h),c.dtype),g=t.data.get(c.dataId).values;for(let b=0;b<f.length;++b){const w=b*p;let C=g[w];for(let v=0;v<p;++v){const I=g[w+v];C=C||I}f[b]=C}u!=null&&t.disposeIntermediateTensorInfo(c);const y=t.makeTensorInfo(h,c.dtype,f);if(i){const b=dn(h,a),w=Ht({inputs:{x:y},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(y),w}return y}const GU={kernelName:Ry,backendName:"cpu",kernelFunc:UU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o}=s;et(r,"argMax");let i=kt(o,r.shape);const a=an(i,r.shape.length);let l=r;const u=[];a!=null&&(l=Is({inputs:{x:r},backend:t,attrs:{perm:a}}),u.push(l),i=pn(i.length,l.shape.length)),i=[i[0]],Un("argMax",i,l.shape.length);const[c,h]=Fn(l.shape,i),d=pe(c),p=Xn(d,"int32"),f=pe(h),g=t.data.get(l.dataId).values;for(let y=0;y<p.length;++y){const b=y*f;let w=g[b],C=0;for(let v=0;v<f;++v){const I=g[b+v];I>w&&(w=I,C=v)}p[y]=C}return u.forEach(y=>t.disposeIntermediateTensorInfo(y)),t.makeTensorInfo(c,"int32",p)}const jU={kernelName:Yd,backendName:"cpu",kernelFunc:HU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o}=s;et(r,"argMin");let i=kt(o,r.shape);const a=an(i,r.shape.length);let l=r;const u=[];a!=null&&(l=Is({inputs:{x:r},backend:t,attrs:{perm:a}}),u.push(l),i=pn(i.length,l.shape.length)),i=[i[0]],Un("argMin",i,l.shape.length);const[c,h]=Fn(l.shape,i),d=pe(c),p=Xn(d,"int32"),f=pe(h),g=t.data.get(l.dataId).values;for(let y=0;y<p.length;++y){const b=y*f;let w=g[b],C=0;for(let v=0;v<f;++v){const I=g[b+v];I<w&&(w=I,C=v)}p[y]=C}return u.forEach(y=>t.disposeIntermediateTensorInfo(y)),t.makeTensorInfo(c,"int32",p)}const qU={kernelName:Zd,backendName:"cpu",kernelFunc:KU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XU=Bt(Ou,n=>Math.asin(n)),YU={kernelName:Ou,backendName:"cpu",kernelFunc:XU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZU=Bt(Fu,n=>Math.asinh(n)),JU={kernelName:Fu,backendName:"cpu",kernelFunc:ZU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QU=Bt(Lu,n=>Math.atan(n)),eG={kernelName:Lu,backendName:"cpu",kernelFunc:QU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tG=mn((n,e)=>Math.atan2(n,e)),nG=En(zu,tG),sG={kernelName:zu,backendName:"cpu",kernelFunc:nG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rG=Bt(Pu,n=>Math.atanh(n)),oG={kernelName:Pu,backendName:"cpu",kernelFunc:rG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S0(n,e,t,s,r,o){const i=r.strideHeight,a=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,f=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=wt(r.outShape,t),y=g.values,b=r.outShape[1]*r.outShape[2]*r.outShape[3],w=r.outShape[2]*r.outShape[3],C=r.outShape[3];for(let v=0;v<r.batchSize;++v){const I=v*b,E=v*s[0];for(let R=0;R<r.inChannels;++R)for(let L=0;L<r.outHeight;++L){const D=L*i-d,F=Math.max(0,D),T=Math.min(r.inHeight,c+D),V=I+L*w;for(let q=0;q<r.outWidth;++q){const se=q*a-p,ee=Math.max(0,se),te=Math.min(r.inWidth,h+se);let le=f,Q=0,he=0;for(let we=F;we<T;we+=l){const Ce=E+we*s[1];for(let Se=ee;Se<te;Se+=u){const Le=Ce+Se*s[2],Ae=n[Le+R];o==="max"&&Ae>le?le=Ae:o==="avg"&&(Q+=Ae,he++)}if(isNaN(le))break}const ye=V+q*C+R;y[ye]=o==="avg"?Q/he:le}}}return g}function hT(n,e,t,s,r=!1,o=!1){const i=wt(s.outShape,"int32"),a=s.strideHeight,l=s.strideWidth,u=s.dilationHeight,c=s.dilationWidth,h=s.effectiveFilterHeight,d=s.effectiveFilterWidth,p=s.padInfo.top,f=s.padInfo.left,g=wt(e,t,n);for(let y=0;y<s.batchSize;++y)for(let b=0;b<s.inChannels;++b)for(let w=0;w<s.outHeight;++w){const C=w*a-p;let v=C;for(;v<0;)v+=u;const I=Math.min(s.inHeight,h+C);for(let E=0;E<s.outWidth;++E){const R=E*l-f;let L=R;for(;L<0;)L+=c;const D=Math.min(s.inWidth,d+R);let F=Number.NEGATIVE_INFINITY,T=-1;for(let V=v;V<I;V+=u){const q=V-C;for(let se=L;se<D;se+=c){const ee=se-R,te=g.get(y,V,se,b);te>F&&(F=te,r?T=o?((y*s.inHeight+V)*s.inWidth+se)*s.inChannels+b:(V*s.inWidth+se)*s.inChannels+b:T=q*d+ee)}}i.set(T,y,w,E,b)}}return i}function dT(n,e,t,s,r,o){const i=r.strideDepth,a=r.strideHeight,l=r.strideWidth,u=r.dilationDepth,c=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,g=r.padInfo.front,y=r.padInfo.top,b=r.padInfo.left,w=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,C=wt(r.outShape,t),v=C.values,I=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],E=r.outShape[2]*r.outShape[3]*r.outShape[4],R=r.outShape[3]*r.outShape[4],L=r.outShape[4];for(let D=0;D<r.batchSize;++D){const F=D*I,T=D*s[0];for(let V=0;V<r.inChannels;++V)for(let q=0;q<r.outDepth;++q){const se=q*i-g;let ee=se;for(;ee<0;)ee+=u;const te=Math.min(r.inDepth,d+se),le=F+q*E;for(let Q=0;Q<r.outHeight;++Q){const he=Q*a-y;let ye=he;for(;ye<0;)ye+=c;const we=Math.min(r.inHeight,p+he),Ce=le+Q*R;for(let Se=0;Se<r.outWidth;++Se){const Le=Se*l-b;let Ae=Le;for(;Ae<0;)Ae+=h;const Me=Math.min(r.inWidth,f+Le),Ze=Ce+Se*L;let ot=w,$e=0,at=0;for(let z=ee;z<te;z+=u){const U=T+z*s[1];for(let de=ye;de<we;de+=c){const xe=U+de*s[2];for(let be=Ae;be<Me;be+=h){const ve=xe+be*s[3],_e=n[ve+V];if(o==="max"&&_e>ot?ot=_e:o==="avg"&&($e+=_e,at++),isNaN(ot))break}if(isNaN(ot))break}if(isNaN(ot))break}const ht=Ze+V;v[ht]=o==="avg"?$e/Math.max(at,1):ot}}}}return C}function iG(n,e){const t=wt(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left;for(let g=0;g<e.batchSize;++g)for(let y=0;y<e.inChannels;++y)for(let b=0;b<e.outDepth;++b){const w=b*s-d;let C=w;for(;C<0;)C+=i;const v=Math.min(e.inDepth,u+w);for(let I=0;I<e.outHeight;++I){const E=I*r-p;let R=E;for(;R<0;)R+=a;const L=Math.min(e.inHeight,c+E);for(let D=0;D<e.outWidth;++D){const F=D*o-f;let T=F;for(;T<0;)T+=l;const V=Math.min(e.inWidth,h+F);let q=Number.NEGATIVE_INFINITY,se=-1;for(let ee=C;ee<v;ee+=i){const te=ee-w;for(let le=R;le<L;le+=a){const Q=le-E;for(let he=T;he<V;he+=l){const ye=he-F,we=n.get(g,ee,le,he,y);we>=q&&(q=we,se=te*c*h+Q*c+ye)}}}t.set(se,g,b,I,D,y)}}}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;et(r,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=s,u=1;A(Wn(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=pr(r.shape,o,i,u,a,l);let h;if(c.filterWidth===1&&c.filterHeight===1&&Tt(c.inShape,c.outShape))h=Jr({inputs:{x:r},backend:t});else{const d=t.data.get(r.dataId).values,p=rt(r.shape),f=S0(d,r.shape,r.dtype,p,c,"avg");h=t.makeTensorInfo(c.outShape,r.dtype,f.values)}return h}const lG={kernelName:Jd,backendName:"cpu",kernelFunc:aG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=s;et(r,"avgPool3d");const c=Io(r.shape,o,i,1,a,l,u),h=t.data.get(r.dataId).values,d=dT(h,r.shape,r.dtype,rt(r.shape),c,"avg");return t.makeTensorInfo(d.shape,"float32",d.values)}const cG={kernelName:Qd,backendName:"cpu",kernelFunc:uG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hG(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=s;et([r,o],"avgPool3DGrad");const c=Io(o.shape,i,a,1,l,u),h=c.strideDepth,d=c.strideHeight,p=c.strideWidth,f=c.filterDepth,g=c.filterHeight,y=c.filterWidth,b=c.dilationDepth,w=c.dilationHeight,C=c.dilationWidth,v=c.effectiveFilterDepth,I=c.effectiveFilterHeight,E=c.effectiveFilterWidth,R=v-1-c.padInfo.front,L=E-1-c.padInfo.left,D=I-1-c.padInfo.top,F=wt(o.shape,"float32"),T=1/(f*g*y),V=t.bufferSync(r);for(let q=0;q<c.batchSize;++q)for(let se=0;se<c.inChannels;++se)for(let ee=0;ee<c.inDepth;++ee)for(let te=0;te<c.inHeight;++te)for(let le=0;le<c.inWidth;++le){const Q=ee-R,he=te-D,ye=le-L;let we=0;for(let Ce=0;Ce<v;Ce+=b){const Se=(Q+Ce)/h;if(!(Se<0||Se>=c.outDepth||Math.floor(Se)!==Se))for(let Le=0;Le<I;Le+=w){const Ae=(he+Le)/d;if(!(Ae<0||Ae>=c.outHeight||Math.floor(Ae)!==Ae))for(let Me=0;Me<E;Me+=C){const Ze=(ye+Me)/p;if(Ze<0||Ze>=c.outWidth||Math.floor(Ze)!==Ze)continue;const ot=V.get(q,Se,Ae,Ze,se);we+=ot}}}F.set(we*T,q,ee,te,le,se)}return t.makeTensorInfo(F.shape,F.dtype,F.values)}const dG={kernelName:Oy,backendName:"cpu",kernelFunc:hG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pG(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,i=o;et([r,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=s,c=pr(i.shape,a,l,1,u),h=c.strideHeight,d=c.strideWidth,p=c.filterHeight,f=c.filterWidth,g=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterHeight,w=c.effectiveFilterWidth,C=w-1-c.padInfo.left,v=b-1-c.padInfo.top,I=wt(i.shape,"float32"),E=1/(p*f),R=t.data.get(r.dataId).values,L=wt(r.shape,"float32",R);for(let D=0;D<c.batchSize;++D)for(let F=0;F<c.inChannels;++F)for(let T=0;T<c.inHeight;++T)for(let V=0;V<c.inWidth;++V){const q=T-v,se=V-C;let ee=0;for(let te=0;te<b;te+=g){const le=(q+te)/h;if(!(le<0||le>=c.outHeight||Math.floor(le)!==le))for(let Q=0;Q<w;Q+=y){const he=(se+Q)/d;if(he<0||he>=c.outWidth||Math.floor(he)!==he)continue;const ye=L.get(D,le,he,F);ee+=ye}}I.set(ee*E,D,T,V,F)}return t.makeTensorInfo(I.shape,I.dtype,I.values)}const fG={kernelName:Dy,backendName:"cpu",kernelFunc:pG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,scale:o,offset:i,mean:a,variance:l}=e;A(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),A(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),A(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),et([r,a,l,o,i],"batchNorm");let{varianceEpsilon:u}=s;u==null&&(u=.001);const c=t.data.get(r.dataId).values,h=t.data.get(a.dataId).values,d=t.data.get(l.dataId).values,p=o?t.data.get(o.dataId).values:new Float32Array([1]),f=i?t.data.get(i.dataId).values:new Float32Array([0]),g=new Float32Array(c.length),y=f.length,b=p.length,w=d.length,C=h.length;let v=0,I=0,E=0,R=0;for(let L=0;L<c.length;++L)g[L]=f[v++]+(c[L]-h[I++])*p[E++]/Math.sqrt(d[R++]+u),v>=y&&(v=0),I>=C&&(I=0),E>=b&&(E=0),R>=w&&(R=0);return t.makeTensorInfo(r.shape,r.dtype,g)}const gG={kernelName:pp,backendName:"cpu",kernelFunc:mG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:o,crops:i}=s;et([r],"batchToSpaceND");const a=o.reduce((b,w)=>b*w),l=Fc(r.shape,o,a),u=Lc(l.length,o.length),c=Pc(r.shape,o,a),h=Dx(i,o.length),d=Ox(c,i,o.length),p=Ht({inputs:{x:r},backend:t,attrs:{shape:l}}),f=Is({inputs:{x:p},backend:t,attrs:{perm:u}}),g=Ht({inputs:{x:f},backend:t,attrs:{shape:c}}),y=la({inputs:{x:g},backend:t,attrs:{begin:h,size:d}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(g),y}const bG={kernelName:tp,backendName:"cpu",kernelFunc:yG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:o}=e,{size:i}=s,a=t.data.get(r.dataId).values,l=t.data.get(o.dataId).values,u=x0(a,l,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,u)}const wG={kernelName:Fy,backendName:"cpu",kernelFunc:xG};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vG(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,o=t.data.get(s.dataId).values,i=t.data.get(r.dataId).values,a=pt(Array.from(o),Array.from(i));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const kG={kernelName:Ly,backendName:"cpu",kernelFunc:vG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CG=Bt(Vu,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),SG={kernelName:Vu,backendName:"cpu",kernelFunc:CG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IG=n=>{const{x:e}=n.inputs,t=n.backend,s=new Float32Array(pe(e.shape)),r=t.data.get(e.dataId),o=r.complexTensorInfos.real,i=r.complexTensorInfos.imag,a=t.data.get(o.dataId).values,l=t.data.get(i.dataId).values;for(let u=0;u<a.length;u++){const c=a[u],h=l[u];s[u]=Math.hypot(c,h)}return t.makeOutput(s,e.shape,"float32")},$G={kernelName:sp,backendName:"cpu",kernelFunc:IG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ol(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.imag,o=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,o)}const NG={kernelName:tb,backendName:"cpu",kernelFunc:ol};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function il(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,o=kt(r,e[0].shape)[0],i=e.map(g=>g.shape);_x(i,o);let a=Gr(e.map(g=>g.shape),o);if(pe(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(g=>pe(g.shape)>0);if(l.length===1)return Jr({inputs:{x:l[0]},backend:t});if(l[0].dtype==="complex64"){const g=l.map(v=>aa({inputs:{input:v},backend:t})),y=l.map(v=>ol({inputs:{input:v},backend:t})),b=il({inputs:g,backend:t,attrs:{axis:o}}),w=il({inputs:y,backend:t,attrs:{axis:o}}),C=_s({inputs:{real:b,imag:w},backend:t});return g.forEach(v=>t.disposeIntermediateTensorInfo(v)),y.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(w),C}const u=l.map(g=>{const b=[-1,pe(g.shape.slice(o))];return Ht({inputs:{x:g},backend:t,attrs:{shape:b}})}),c=u.map(g=>({vals:t.data.get(g.dataId).values,shape:g.shape}));a=Gr(u.map(g=>g.shape),1);const h=u[0].shape[0]===1,d=yN(c,a,e[0].dtype,h),p=Gr(l.map(g=>g.shape),o),f=t.makeTensorInfo(p,e[0].dtype,d);return u.forEach(g=>t.disposeIntermediateTensorInfo(g)),f}const TG={kernelName:rp,backendName:"cpu",kernelFunc:il};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pT(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=s;et([r,o],"conv2d");const h=$o(l),d=On(r.shape,o.shape,i,u,a,c,!1,h),p=d.filterHeight,f=d.filterWidth,g=d.dilationHeight,y=d.dilationWidth,b=d.padInfo.left,w=d.padInfo.top,C=d.dataFormat==="channelsLast",v=new In(d.outShape,r.dtype),I=rt(r.shape),E=rt(o.shape),R=I[0],L=C?I[1]:I[2],D=C?I[2]:1,F=C?1:I[1],T=v.strides[0],V=C?v.strides[1]:v.strides[2],q=C?v.strides[2]:1,se=C?1:v.strides[1],ee=t.data.get(r.dataId).values,te=t.data.get(o.dataId).values,le=v.values;for(let Q=0;Q<d.batchSize;++Q){const he=Q*R,ye=Q*T;for(let we=0;we<d.outHeight;++we){const Ce=ye+we*V,Se=we*d.strideHeight-w;for(let Le=0;Le<p;++Le){const Ae=Se+Le*g;if(Ae<0||Ae>=d.inHeight)continue;const Me=Le*E[0],Ze=he+Ae*L;for(let ot=0;ot<d.outWidth;++ot){const $e=Ce+ot*q,at=ot*d.strideWidth-b;for(let ht=0;ht<f;++ht){const z=at+ht*y;if(z<0||z>=d.inWidth)continue;const U=Me+ht*E[1],de=Ze+z*D;let xe=U;for(let be=0;be<d.inChannels;++be){const ve=ee[de+be*F];for(let _e=0;_e<d.outChannels;++_e)le[$e+_e*se]+=ve*te[xe+_e];xe+=d.outChannels}}}}}}return t.makeTensorInfo(v.shape,v.dtype,le)}const EG={kernelName:op,backendName:"cpu",kernelFunc:pT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _G(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=s;et([r,o],"conv2dBackpropFilter");const h=$o(l),d=On(r.shape,c,i,1,a,u,!1,h),{strideHeight:p,strideWidth:f,filterHeight:g,filterWidth:y}=d,b=d.dataFormat==="channelsLast",w=new In(d.filterShape,"float32"),C=d.padInfo.left,v=d.padInfo.top,I=t.data.get(r.dataId).values,E=t.data.get(o.dataId).values,R=new In(r.shape,r.dtype,I),L=new In(o.shape,o.dtype,E);for(let D=0;D<g;++D){const F=Math.max(0,Math.ceil((v-D)/p)),T=Math.min(d.outHeight,(d.inHeight+v-D)/p);for(let V=0;V<y;++V){const q=Math.max(0,Math.ceil((C-V)/f)),se=Math.min(d.outWidth,(d.inWidth+C-V)/f);for(let ee=0;ee<d.inChannels;++ee)for(let te=0;te<d.outChannels;++te){let le=0;for(let Q=0;Q<d.batchSize;++Q)for(let he=F;he<T;++he){const ye=D+he*p-v;for(let we=q;we<se;++we){const Ce=V+we*f-C;b?le+=R.get(Q,ye,Ce,ee)*L.get(Q,he,we,te):le+=R.get(Q,ee,ye,Ce)*L.get(Q,te,he,we)}}w.set(le,D,V,ee,te)}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const AG={kernelName:zy,backendName:"cpu",kernelFunc:_G};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RG(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=s;et([r,o],"conv2dBackpropInput");const h=rt(o.shape),d=rt(r.shape);let p=$o(u);const f=On(i,o.shape,a,1,l,c,!1,p),g=new In(f.inShape,"float32"),y=g.values,b=t.data.get(r.dataId).values,w=t.data.get(o.dataId).values,[C,v,I]=h,{batchSize:E,filterHeight:R,filterWidth:L,inChannels:D,inHeight:F,inWidth:T,outChannels:V,outHeight:q,outWidth:se,strideHeight:ee,strideWidth:te}=f;p=f.dataFormat;const le=R-1-f.padInfo.top,Q=L-1-f.padInfo.left,he=p==="channelsLast",ye=g.strides[0],we=he?g.strides[1]:g.strides[2],Ce=he?g.strides[2]:1,Se=he?1:g.strides[1],Le=d[0],Ae=he?d[1]:d[2],Me=he?d[2]:1,Ze=he?1:d[1];for(let ot=0;ot<E;++ot)for(let $e=0;$e<D;++$e)for(let at=0;at<F;++at){const ht=at-le,z=Math.max(0,Math.ceil(ht/ee)),U=Math.min(q,(R+ht)/ee);for(let de=0;de<T;++de){const xe=de-Q,be=Math.max(0,Math.ceil(xe/te)),ve=Math.min(se,(L+xe)/te);let _e=0;for(let Ee=z;Ee<U;++Ee){const Ie=Ee*ee-ht;for(let qe=be;qe<ve;++qe){const Pe=qe*te-xe,Xe=Le*ot+Ae*Ee+Me*qe,st=C*(R-1-Ie)+v*(L-1-Pe)+I*$e;for(let lt=0;lt<V;++lt){const ft=b[Xe+Ze*lt],yt=w[st+lt];_e+=ft*yt}}}const Oe=ye*ot+we*at+Ce*de+Se*$e;y[Oe]=_e}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}const DG={kernelName:ip,backendName:"cpu",kernelFunc:RG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:i,pad:a,dilations:l}=s;et([r,o],"conv3d");const u=gi(r.shape,o.shape,i,l,a),{filterDepth:c,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:g,padInfo:y}=u,b=y.front,w=y.left,C=y.top,v=new In(u.outShape,r.dtype),I=t.data.get(r.dataId).values,E=t.data.get(o.dataId).values,R=v.values,L=rt(r.shape),D=rt(o.shape);for(let F=0;F<u.batchSize;++F){const T=F*L[0],V=F*v.strides[0];for(let q=0;q<u.outDepth;++q){const se=V+q*v.strides[1],ee=q*u.strideDepth-b;for(let te=0;te<c;++te){const le=ee+te*p;if(le<0||le>=u.inDepth)continue;const Q=te*D[0],he=T+le*L[1];for(let ye=0;ye<u.outHeight;++ye){const we=se+ye*v.strides[2],Ce=ye*u.strideHeight-C;for(let Se=0;Se<h;++Se){const Le=Ce+Se*f;if(Le<0||Le>=u.inHeight)continue;const Ae=Q+Se*D[1],Me=he+Le*L[2];for(let Ze=0;Ze<u.outWidth;++Ze){const ot=we+Ze*u.outChannels,$e=Ze*u.strideWidth-w;for(let at=0;at<d;++at){const ht=$e+at*g;if(ht<0||ht>=u.inWidth)continue;const z=Ae+at*D[2],U=Me+ht*u.inChannels;let de=z;for(let xe=0;xe<u.inChannels;++xe){const be=I[U+xe];for(let ve=0;ve<u.outChannels;++ve)R[ot+ve]+=be*E[de+ve];de+=u.outChannels}}}}}}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}const FG={kernelName:ap,backendName:"cpu",kernelFunc:OG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:i,pad:a,filterShape:l}=s;et([r,o],"conv3dBackpropFilterV2");const u=rt(r.shape),c=rt(o.shape),h=gi(r.shape,l,i,1,a),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,g=h.filterDepth,y=h.filterHeight,b=h.filterWidth,w=new In(h.filterShape,"float32"),C=w.values,[v,I,E,R]=w.strides,L=t.data.get(o.dataId).values,[D,F,T,V]=c,q=t.data.get(r.dataId).values,[se,ee,te,le]=u,Q=h.padInfo.front,he=h.padInfo.left,ye=h.padInfo.top;for(let we=0;we<g;++we){const Ce=Math.max(0,Math.ceil((Q-we)/d)),Se=Math.min(h.outDepth,(h.inDepth+Q-we)/d),Le=we*v;for(let Ae=0;Ae<y;++Ae){const Me=Math.max(0,Math.ceil((ye-Ae)/p)),Ze=Math.min(h.outHeight,(h.inHeight+ye-Ae)/p),ot=Ae*I+Le;for(let $e=0;$e<b;++$e){const at=Math.max(0,Math.ceil((he-$e)/f)),ht=Math.min(h.outWidth,(h.inWidth+he-$e)/f),z=$e*E+ot;for(let U=0;U<h.inChannels;++U){const de=U*R+z;for(let xe=0;xe<h.outChannels;++xe){let be=0;for(let ve=0;ve<h.batchSize;++ve){const _e=ve*se,Oe=ve*D;for(let Ee=Ce;Ee<Se;++Ee){const qe=(we+Ee*d-Q)*ee+_e,Pe=Ee*F+Oe;for(let Xe=Me;Xe<Ze;++Xe){const lt=(Ae+Xe*p-ye)*te+qe,ft=Xe*T+Pe;for(let yt=at;yt<ht;++yt){const cn=($e+yt*f-he)*le+lt,_n=yt*V+ft;be+=q[cn+U]*L[_n+xe]}}}}C[de+xe]=be}}}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const PG={kernelName:My,backendName:"cpu",kernelFunc:LG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zG(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{pad:i,strides:a,inputShape:l}=s;et([r],"conv3dBackpropInputV2");const u=rt(r.shape),c=rt(o.shape),h=gi(l,o.shape,a,1,i),d=new In(h.inShape,"float32"),p=d.values,[f,g,y,b]=d.strides,w=t.data.get(r.dataId).values,[C,v,I,E]=u,R=t.data.get(o.dataId).values,[L,D,F,T]=c,{batchSize:V,filterDepth:q,filterHeight:se,filterWidth:ee,inChannels:te,inDepth:le,inHeight:Q,inWidth:he,outChannels:ye,outDepth:we,outHeight:Ce,outWidth:Se,strideDepth:Le,strideHeight:Ae,strideWidth:Me}=h,Ze=q-1-h.padInfo.front,ot=se-1-h.padInfo.top,$e=ee-1-h.padInfo.left;for(let at=0;at<V;++at)for(let ht=0;ht<te;++ht)for(let z=0;z<le;++z){const U=z-Ze,de=Math.max(0,Math.ceil(U/Le)),xe=Math.min(we,(q+U)/Le);for(let be=0;be<Q;++be){const ve=be-ot,_e=Math.max(0,Math.ceil(ve/Ae)),Oe=Math.min(Ce,(se+ve)/Ae);for(let Ee=0;Ee<he;++Ee){const Ie=Ee-$e,qe=Math.max(0,Math.ceil(Ie/Me)),Pe=Math.min(Se,(ee+Ie)/Me);let Xe=0;for(let st=de;st<xe;++st){const lt=st*Le-U;for(let ft=_e;ft<Oe;++ft){const yt=ft*Ae-ve;for(let qt=qe;qt<Pe;++qt){const cn=qt*Me-Ie,_n=C*at+v*st+I*ft+E*qt,wn=L*(q-1-lt)+D*(se-1-yt)+F*(ee-1-cn)+T*ht;for(let fs=0;fs<ye;++fs){const Ro=w[_n+fs],en=R[wn+fs];Xe+=Ro*en}}}}p[f*at+g*z+y*be+b*Ee+ht]=Xe}}}return t.makeTensorInfo(d.shape,d.dtype,d.values)}const MG={kernelName:By,backendName:"cpu",kernelFunc:zG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BG=Bt(Wu,n=>Math.cos(n)),VG={kernelName:Wu,backendName:"cpu",kernelFunc:BG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WG=Bt(Uu,n=>Math.cosh(n)),UG={kernelName:Uu,backendName:"cpu",kernelFunc:WG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GG(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:o,boxInd:i}=e,{cropSize:a,method:l,extrapolationValue:u}=s,[c,h,d,p]=r.shape,f=o.shape[0],[g,y]=a,b=wt([f,g,y,p],"float32"),w=t.data.get(o.dataId).values,C=t.data.get(i.dataId).values,v=t.data.get(r.dataId).values,I=rt(r.shape),E=rt(b.shape);for(let R=0;R<f;R++){const L=R*4,D=w[L],F=w[L+1],T=w[L+2],V=w[L+3],q=C[R];if(q>=c)continue;const se=g>1?(T-D)*(h-1)/(g-1):0,ee=y>1?(V-F)*(d-1)/(y-1):0;for(let te=0;te<g;te++){const le=g>1?D*(h-1)+te*se:.5*(D+T)*(h-1);if(le<0||le>h-1){for(let Q=0;Q<y;Q++)for(let he=0;he<p;he++){const ye=he+Q*E[2]+te*E[1]+R*E[0];b.values[ye]=u}continue}if(l==="bilinear"){const Q=Math.floor(le),he=Math.ceil(le),ye=le-Q;for(let we=0;we<y;we++){const Ce=y>1?F*(d-1)+we*ee:.5*(F+V)*(d-1);if(Ce<0||Ce>d-1){for(let Me=0;Me<p;Me++){const Ze=Me+we*E[2]+te*E[1]+R*E[0];b.values[Ze]=u}continue}const Se=Math.floor(Ce),Le=Math.ceil(Ce),Ae=Ce-Se;for(let Me=0;Me<p;Me++){let Ze=Me+Se*I[2]+Q*I[1]+q*I[0];const ot=v[Ze];Ze=Me+Le*I[2]+Q*I[1]+q*I[0];const $e=v[Ze];Ze=Me+Se*I[2]+he*I[1]+q*I[0];const at=v[Ze];Ze=Me+Le*I[2]+he*I[1]+q*I[0];const ht=v[Ze],z=ot+($e-ot)*Ae,U=at+(ht-at)*Ae;Ze=Me+we*E[2]+te*E[1]+R*E[0],b.values[Ze]=z+(U-z)*ye}}}else for(let Q=0;Q<y;++Q){const he=y>1?F*(d-1)+Q*ee:.5*(F+V)*(d-1);if(he<0||he>d-1){for(let Ce=0;Ce<p;Ce++){const Se=Ce+Q*E[2]+te*E[1]+R*E[0];b.values[Se]=u}continue}const ye=Math.round(he),we=Math.round(le);for(let Ce=0;Ce<p;Ce++){const Se=Ce+ye*I[2]+we*I[1]+q*I[0],Le=Ce+Q*E[2]+te*E[1]+R*E[0];b.values[Le]=v[Se]}}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const HG={kernelName:Wy,backendName:"cpu",kernelFunc:GG};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,exclusive:i,reverse:a}=s;et(r,"cumprod");const l=an([o],r.shape.length);let u=r;l!=null&&(u=Is({inputs:{x:r},backend:t,attrs:{perm:l}}));const c=pn(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=Ds(u.dtype,"int32"),d=Ey(pe(u.shape),h),p=t.data.get(u.dataId).values,f=u.shape[u.shape.length-1],g=a?(b,w)=>b+f-w-1:(b,w)=>b+w;for(let b=0;b<p.length;b+=f)for(let w=0;w<f;w++){const C=g(b,w);if(w===0)d[C]=i?1:p[C];else{const v=g(b,w-1);d[C]=i?p[v]*d[v]:p[C]*d[v]}}const y=t.makeTensorInfo(u.shape,h,d);if(l!=null){const b=yi(l),w=Is({inputs:{x:y},backend:t,attrs:{perm:b}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(u),w}return y}const KG={kernelName:Vy,backendName:"cpu",kernelFunc:jG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,exclusive:i,reverse:a}=s;et(r,"cumsum");const l=an([o],r.shape.length);let u=r;l!=null&&(u=Is({inputs:{x:r},backend:t,attrs:{perm:l}}));const c=pn(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=Ds(u.dtype,"int32"),d=Xn(pe(u.shape),h),p=t.data.get(u.dataId).values,f=u.shape[u.shape.length-1],g=a?(b,w)=>b+f-w-1:(b,w)=>b+w;for(let b=0;b<p.length;b+=f)for(let w=0;w<f;w++){const C=g(b,w);if(w===0)d[C]=i?0:p[C];else{const v=g(b,w-1);d[C]=i?p[v]+d[v]:p[C]+d[v]}}const y=t.makeTensorInfo(u.shape,h,d);if(l!=null){const b=yi(l),w=Is({inputs:{x:y},backend:t,attrs:{perm:b}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(u),w}return y}const XG={kernelName:lp,backendName:"cpu",kernelFunc:qG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:o}=e,{size:i,binaryOutput:a}=s;if(r.shape.length===1){const l=t.data.get(r.dataId).values,u=t.data.get(o.dataId).values,c=x0(l,u,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,c)}else if(r.shape.length===2){const l=t.bufferSync(r),u=t.bufferSync(o),c=fN(l,u,i,a);return t.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const ZG={kernelName:Uy,backendName:"cpu",kernelFunc:YG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:o,dataFormat:i}=s;A(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const a=r.shape[0],l=r.shape[1],u=r.shape[2],c=r.shape[3],h=l*o,d=u*o,p=c/(o*o),f=t.data.get(r.dataId).values,g=new Float32Array(a*h*d*p);let y=0;for(let b=0;b<a;++b)for(let w=0;w<h;++w){const C=Math.floor(w/o),v=w%o;for(let I=0;I<d;++I){const E=Math.floor(I/o),R=I%o,L=(v*o+R)*p;for(let D=0;D<p;++D){const T=D+L+c*(E+u*(C+l*b));g[y++]=f[T]}}}return t.makeTensorInfo([a,h,d,p],r.dtype,g)}const QG={kernelName:Gy,backendName:"cpu",kernelFunc:JG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fT(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=s;et([r,o],"depthwiseConv2DNative");const c=rt(r.shape),h=rt(o.shape);let d=l;d==null&&(d=[1,1]),A(Wn(i,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);const p=On(r.shape,o.shape,i,d,a,u,!0),{filterHeight:f,filterWidth:g,dilationHeight:y,dilationWidth:b,padInfo:w}=p,C=w.left,v=w.top,I=p.outChannels/p.inChannels,E=new In(p.outShape,r.dtype),R=t.data.get(r.dataId).values,L=t.data.get(o.dataId).values,D=E.values;for(let F=0;F<p.batchSize;++F){const T=F*c[0],V=F*E.strides[0];for(let q=0;q<p.outHeight;++q){const se=V+q*E.strides[1],ee=q*p.strideHeight-v;for(let te=0;te<f;++te){const le=ee+te*y;if(le<0||le>=p.inHeight)continue;const Q=te*h[0],he=T+le*c[1];for(let ye=0;ye<p.outWidth;++ye){const we=se+ye*E.strides[2],Ce=ye*p.strideWidth-C;for(let Se=0;Se<g;++Se){const Le=Ce+Se*b;if(Le<0||Le>=p.inWidth)continue;const Ae=Q+Se*h[1],Me=he+Le*p.inChannels;let Ze=we,ot=Ae;for(let $e=0;$e<p.inChannels;++$e){const at=R[Me+$e];for(let ht=0;ht<I;++ht)D[Ze+ht]+=at*L[ot+ht];Ze+=I,ot+=I}}}}}}return t.makeTensorInfo(E.shape,E.dtype,E.values)}const eH={kernelName:up,backendName:"cpu",kernelFunc:fT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tH(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=s;et([r,o],"depthwiseConv2dNativeBackpropFilter");const h=On(r.shape,c,i,a,l,u,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:g}=h,y=new In(h.filterShape,"float32"),b=h.padInfo.left,w=h.padInfo.top,C=h.outChannels/h.inChannels,v=t.data.get(r.dataId).values,I=new In(r.shape,r.dtype,v),E=t.data.get(o.dataId).values,R=new In(o.shape,o.dtype,E);for(let L=0;L<f;++L){const D=Math.max(0,Math.ceil((w-L)/d)),F=Math.min(h.outHeight,(h.inHeight+w-L)/d);for(let T=0;T<g;++T){const V=Math.max(0,Math.ceil((b-T)/p)),q=Math.min(h.outWidth,(h.inWidth+b-T)/p);for(let se=0;se<h.outChannels;++se){const ee=Math.trunc(se/C),te=se%C;let le=0;for(let Q=0;Q<h.batchSize;++Q)for(let he=D;he<F;++he){const ye=L+he*d-w;for(let we=V;we<q;++we){const Ce=T+we*p-b;le+=I.get(Q,ye,Ce,ee)*R.get(Q,he,we,se)}}y.set(le,L,T,ee,te)}}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}const nH={kernelName:Hy,backendName:"cpu",kernelFunc:tH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sH(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=s;et([r,o],"depthwiseConv2DNativeBackpropInput");const h=rt(r.shape),d=rt(o.shape),p=On(c,o.shape,i,a,l,u,!0),f=new In(p.inShape,"float32"),g=f.values,[y,b,w]=f.strides,C=t.data.get(r.dataId).values,[v,I,E]=h,R=t.data.get(o.dataId).values,[L,D,F]=d,{batchSize:T,filterHeight:V,filterWidth:q,inChannels:se,inHeight:ee,inWidth:te,outChannels:le,outHeight:Q,outWidth:he,strideHeight:ye,strideWidth:we}=p,Ce=V-1-p.padInfo.top,Se=q-1-p.padInfo.left,Le=le/se;for(let Ae=0;Ae<T;++Ae)for(let Me=0;Me<se;++Me)for(let Ze=0;Ze<ee;++Ze){const ot=Ze-Ce,$e=Math.max(0,Math.ceil(ot/ye)),at=Math.min(Q,(V+ot)/ye);for(let ht=0;ht<te;++ht){const z=ht-Se,U=Math.max(0,Math.ceil(z/we)),de=Math.min(he,(q+z)/we);let xe=0;for(let be=$e;be<at;++be){const ve=be*ye-ot;for(let _e=U;_e<de;++_e){const Oe=_e*we-z,Ee=v*Ae+I*be+E*_e,Ie=L*(V-1-ve)+D*(q-1-Oe)+F*Me;for(let qe=0;qe<Le;++qe){const Pe=Me*Le+qe,Xe=C[Ee+Pe],st=R[Ie+qe];xe+=Xe*st}}}g[y*Ae+b*Ze+w*ht+Me]=xe}}return t.makeTensorInfo(f.shape,f.dtype,f.values)}const rH={kernelName:jy,backendName:"cpu",kernelFunc:sH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oH(n){const{inputs:e,backend:t}=n,{x:s}=e,r=pe(s.shape),o=t.data.get(s.dataId).values,i=wt([r,r],s.dtype),a=i.values;for(let u=0;u<o.length;u++)a[u*r+u]=o[u];const l=[...s.shape,...s.shape];return t.makeTensorInfo(l,i.dtype,i.values)}const iH={kernelName:Ky,backendName:"cpu",kernelFunc:oH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aH={kernelName:cp,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r}=n,{strides:o,pad:i,dilations:a}=t,l=e,u=l.data.get(s.dataId).values,c=s.shape.length,h=l.data.get(r.dataId).values,d=r.shape.length,{batchSize:p,inHeight:f,inWidth:g,inChannels:y,outHeight:b,outWidth:w,padInfo:C,strideHeight:v,strideWidth:I,filterHeight:E,filterWidth:R,dilationHeight:L,dilationWidth:D,outShape:F}=Tc(s.shape,r.shape,o,i,"NHWC",a),T=pe(F),V=F.length,q=hn(s.dtype,T);for(let ee=0;ee<p;++ee)for(let te=0;te<b;++te){const le=te*v-C.top;for(let Q=0;Q<w;++Q){const he=Q*I-C.left;for(let ye=0;ye<y;++ye){let we=Number.MIN_SAFE_INTEGER;for(let Se=0;Se<E;++Se){const Le=le+Se*L;if(Le>=0&&Le<f)for(let Ae=0;Ae<R;++Ae){const Me=he+Ae*D;if(Me>=0&&Me<g){const Ze=Wr([ee,Le,Me,ye],c,rt(s.shape)),ot=Wr([Se,Ae,ye],d,rt(r.shape)),$e=u[Ze]+h[ot];$e>we&&(we=$e)}}}const Ce=Wr([ee,te,Q,ye],V,rt(F));q[Ce]=we}}}return{dataId:l.write(ca(q,s.dtype),F,s.dtype),shape:F,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lH={kernelName:bg,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:o}=n,{strides:i,pad:a,dilations:l}=t,u=e,c=ir(s.shape,u.data.get(s.dataId).values),h=ir(r.shape,u.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:g,outHeight:y,outWidth:b,padInfo:w,strideHeight:C,strideWidth:v,filterHeight:I,filterWidth:E,dilationHeight:R,dilationWidth:L,outShape:D}=Tc(s.shape,r.shape,i,a,"NHWC",l);A(o.rank===D.length,()=>`Error in ${bg}, dy must have the same rank as output ${D.length}, but got ${o.rank}`);const F=ir(D,u.data.get(o.dataId).values),T=hk(r.shape,r.dtype);for(let q=0;q<d;++q)for(let se=0;se<y;++se){const ee=se*C-w.top;for(let te=0;te<b;++te){const le=te*v-w.left;for(let Q=0;Q<g;++Q){let he=Number.MIN_SAFE_INTEGER,ye=0,we=0;for(let Ce=0;Ce<I;++Ce){const Se=ee+Ce*R;if(Se>=0&&Se<p)for(let Le=0;Le<E;++Le){const Ae=le+Le*L;if(Ae>=0&&Ae<f){const Me=c[q][Se][Ae][Q]+h[Ce][Le][Q];Me>he&&(he=Me,ye=Ce,we=Le)}}}T[ye][we][Q]+=F[q][se][te][Q]}}}return{dataId:u.write(ca(T,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uH={kernelName:yg,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:o}=n,{strides:i,pad:a,dilations:l}=t,u=e,c=ir(s.shape,u.data.get(s.dataId).values),h=ir(r.shape,u.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:g,outHeight:y,outWidth:b,padInfo:w,strideHeight:C,strideWidth:v,filterHeight:I,filterWidth:E,dilationHeight:R,dilationWidth:L,outShape:D}=Tc(s.shape,r.shape,i,a,"NHWC",l);A(o.rank===D.length,()=>`Error in ${yg}, dy must have the same rank as output ${D.length}, but got ${o.rank}`);const F=ir(D,u.data.get(o.dataId).values),T=hk(s.shape,s.dtype);for(let q=0;q<d;++q)for(let se=0;se<y;++se){const ee=se*C-w.top;for(let te=0;te<b;++te){const le=te*v-w.left;for(let Q=0;Q<g;++Q){let he=Number.MIN_SAFE_INTEGER,ye=ee<0?0:ee,we=le<0?0:le;for(let Ce=0;Ce<I;++Ce){const Se=ee+Ce*R;if(Se>=0&&Se<p)for(let Le=0;Le<E;++Le){const Ae=le+Le*L;if(Ae>=0&&Ae<f){const Me=c[q][Se][Ae][Q]+h[Ce][Le][Q];Me>he&&(he=Me,ye=Se,we=Ae)}}}T[q][ye][we][Q]+=F[q][se][te][Q]}}}return{dataId:u.write(ca(T,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cH(n){const{inputs:e,backend:t,attrs:s}=n,{image:r}=e,{canvas:o,options:i}=s,{contextOptions:a,imageOptions:l}=i||{},u=(l==null?void 0:l.alpha)||1,c=(a==null?void 0:a.contextType)||"2d";if(c!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const h=o.getContext(c,(a==null?void 0:a.contextAttributes)||{});if(h==null)throw new Error(`Could not get the context with ${c} type.`);const[d,p]=r.shape.slice(0,2),f=r.shape.length===2?1:r.shape[2],g=t.data.get(r.dataId).values,y=r.dtype==="float32"?255:1,b=new Uint8ClampedArray(p*d*4);for(let C=0;C<d*p;++C){const v=[0,0,0,255*u];for(let E=0;E<f;E++){const R=g[C*f+E];if(r.dtype==="float32"){if(R<0||R>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${R}.`)}else if(r.dtype==="int32"&&(R<0||R>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${R}.`);f===1?(v[0]=R*y,v[1]=R*y,v[2]=R*y):v[E]=R*y}const I=C*4;b[I+0]=Math.round(v[0]),b[I+1]=Math.round(v[1]),b[I+2]=Math.round(v[2]),b[I+3]=Math.round(v[3])}o.width=p,o.height=d;const w=new ImageData(b,p,d);return h.putImageData(w,0,0),r}const hH={kernelName:v_,backendName:"cpu",kernelFunc:cH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jc(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s;et(r,"sum");let a;r.dtype==="bool"?a=ui({inputs:{x:r},backend:t,attrs:{dtype:"int32"}}):a=Jr({inputs:{x:r},backend:t});const l=a.shape.length,u=kt(o,a.shape),c=an(u,l);let h=u,d=a;c!=null&&(d=Is({inputs:{x:a},backend:t,attrs:{perm:c}}),h=pn(h.length,l)),Un("sum",h,d.shape.length);const[p,f]=Fn(d.shape,h),g=Ds(d.dtype,"int32");let y=$d(t,p,g);const b=pe(f),w=t.data.get(y.dataId).values,C=t.data.get(d.dataId).values;for(let v=0;v<w.length;++v){const I=v*b;let E=0;for(let R=0;R<b;++R)E+=C[I+R];w[v]=E}if(i){const v=dn(y.shape,u),I=y;y=Ht({inputs:{x:y},backend:t,attrs:{shape:v}}),t.disposeIntermediateTensorInfo(I)}return t.disposeIntermediateTensorInfo(a),c!=null&&t.disposeIntermediateTensorInfo(d),y}const dH={kernelName:Up,backendName:"cpu",kernelFunc:jc};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pH(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,o=e,{allDims:i,summedDims:a,idDims:l}=Wx(r,o.length);Gx(i.length,l,o);const{path:u,steps:c}=Hx(a,l),h=c.length;let d=null,p=i.length;const f=[];for(let g=0;g<h;++g){for(const y of c[g]){const{permutationIndices:b,expandDims:w}=Ux(p,l[y]);let C;jx(b)?C=o[y]:(C=Is({inputs:{x:o[y]},backend:t,attrs:{perm:b}}),f.push(C));const v=C.shape.slice();for(let I=0;I<w.length;++I)v.splice(w[I],0,1);Tt(C.shape,v)||(C=Ht({inputs:{x:C},backend:t,attrs:{shape:v}}),f.push(C)),d===null?d=C:(d=Lf({inputs:{a:C,b:d},backend:t}),f.push(d))}g<h-1&&(u[g]>=0&&(d=jc({inputs:{x:d},backend:t,attrs:{axis:u[g]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&t.disposeIntermediateTensorInfo(g);return d}const fH={kernelName:qy,backendName:"cpu",kernelFunc:pH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mH(n){const{inputs:e,backend:t}=n,{dy:s,y:r}=e;et([s,r],"eluGrad");const o=new Float32Array(pe(r.shape)),i=t.data.get(r.dataId).values,a=t.data.get(s.dataId).values;for(let l=0;l<i.length;++l){const u=i[l];u>=0?o[l]=a[l]:o[l]=a[l]*(u+1)}return t.makeTensorInfo(r.shape,"float32",o)}const gH={kernelName:Xy,backendName:"cpu",kernelFunc:mH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yH=Fx,bH=Lx,xH=Px,wH=zx,vH=Mx,kH=Bx,CH=Bt(ju,n=>{const e=Math.sign(n),t=Math.abs(n),s=1/(1+yH*t);return e*(1-((((kH*s+vH)*s+wH)*s+xH)*s+bH)*s*Math.exp(-t*t))}),SH={kernelName:ju,backendName:"cpu",kernelFunc:CH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ed(n){const{inputs:e,backend:t,attrs:s}=n,{input:r}=e,{dim:o}=s,i=r.shape.length,a=r.shape.slice();let l=o;return o<0&&(A(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+o+1),a.splice(l,0,1),Ht({inputs:{x:r},backend:t,attrs:{shape:a}})}const IH={kernelName:dp,backendName:"cpu",kernelFunc:Ed};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $H=mn((n,e)=>n/e),I0=En(Gu,$H),oy={kernelName:Gu,backendName:"cpu",kernelFunc:I0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mT(n,e,t){const s=n.shape,r=s[0],o=s[1],i=t.data.get(n.dataId),a=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[r,o],c=pe(u),h=Bn("float32",c),d=Bn("float32",c);for(let y=0;y<r;y++){const b=la({inputs:{x:a},backend:t,attrs:{begin:[y,0],size:[1,o]}}),w=la({inputs:{x:l},backend:t,attrs:{begin:[y,0],size:[1,o]}}),C=_s({inputs:{real:b,imag:w},backend:t}),{real:v,imag:I}=NH(C,e,t),E=wo(v,I);for(let R=0;R<o;R++){const L=Vx(E,R);h[y*o+R]=L.real,d[y*o+R]=L.imag}t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(C)}const p=t.makeTensorInfo(u,"float32",h),f=t.makeTensorInfo(u,"float32",d),g=_s({inputs:{real:p,imag:f},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),g}function NH(n,e,t){const s=pe(n.shape),r=t.data.get(n.dataId),o=t.data.get(r.complexTensorInfos.real.dataId).values,i=t.data.get(r.complexTensorInfos.imag.dataId).values;if(TH(s)){const a=iy(o,i,s,e,t),l=[n.shape[0],n.shape[1]];if(e){const u=t.makeTensorInfo(l,"float32",a.real),c=t.makeTensorInfo(l,"float32",a.imag),h=t.makeTensorInfo([],"float32",pi(s,"float32")),d=Jr({inputs:{x:h},backend:t}),p=oy.kernelFunc({inputs:{a:u,b:h},backend:t}),f=oy.kernelFunc({inputs:{a:c,b:d},backend:t}),g=t.data.get(p.dataId).values,y=t.data.get(f.dataId).values;return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),{real:g,imag:y}}return a}else{const a=wo(o,i),l=EH(a,s,e);return IS(l)}}function TH(n){return(n&n-1)===0}function iy(n,e,t,s,r){if(t===1)return{real:n,imag:e};const o=wo(n,e),i=t/2,a=$S(o),l=a.real,u=a.imag,c=[l.length],h=r.makeTensorInfo(c,"float32",l),d=r.makeTensorInfo(c,"float32",u),p=_s({inputs:{real:h,imag:d},backend:r}),f=NS(o),g=f.real,y=f.imag,b=[g.length],w=r.makeTensorInfo(b,"float32",g),C=r.makeTensorInfo(b,"float32",y),v=_s({inputs:{real:w,imag:C},backend:r}),I=iy(l,u,i,s,r),E=I.real,R=I.imag,L=[E.length],D=r.makeTensorInfo(L,"float32",E),F=r.makeTensorInfo(L,"float32",R),T=_s({inputs:{real:D,imag:F},backend:r}),V=iy(g,y,i,s,r),q=V.real,se=V.imag,ee=[q.length],te=r.makeTensorInfo(ee,"float32",q),le=r.makeTensorInfo(ee,"float32",se),Q=_s({inputs:{real:te,imag:le},backend:r}),he=ES(t,s),ye=[he.real.length],we=r.makeTensorInfo(ye,"float32",he.real),Ce=r.makeTensorInfo(ye,"float32",he.imag),Se=_s({inputs:{real:we,imag:Ce},backend:r}),Le=Lf({inputs:{a:Se,b:Q},backend:r}),Ae=rl({inputs:{a:T,b:Le},backend:r}),Me=C0({inputs:{a:T,b:Le},backend:r}),Ze=aa({inputs:{input:Ae},backend:r}),ot=aa({inputs:{input:Me},backend:r}),$e=ol({inputs:{input:Ae},backend:r}),at=ol({inputs:{input:Me},backend:r}),ht=il({inputs:[Ze,ot],backend:r,attrs:{axis:0}}),z=il({inputs:[$e,at],backend:r,attrs:{axis:0}}),U=r.data.get(ht.dataId).values,de=r.data.get(z.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(C),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(te),r.disposeIntermediateTensorInfo(le),r.disposeIntermediateTensorInfo(Q),r.disposeIntermediateTensorInfo(we),r.disposeIntermediateTensorInfo(Ce),r.disposeIntermediateTensorInfo(Se),r.disposeIntermediateTensorInfo(Le),r.disposeIntermediateTensorInfo(Ae),r.disposeIntermediateTensorInfo(Me),r.disposeIntermediateTensorInfo(Ze),r.disposeIntermediateTensorInfo($e),r.disposeIntermediateTensorInfo(ot),r.disposeIntermediateTensorInfo(at),r.disposeIntermediateTensorInfo(ht),r.disposeIntermediateTensorInfo(z),{real:U,imag:de}}function EH(n,e,t){const s=new Float32Array(e*2);for(let r=0;r<e;r++){let o=0,i=0;for(let a=0;a<e;a++){const l=_S(r*a,e,t),u=Vx(n,a);o+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}t&&(o/=e,i/=e),TS(s,o,i,r)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _H(n){const{inputs:e,backend:t}=n,{input:s}=e,r=pe(s.shape),o=s.shape[s.shape.length-1],i=r/o,a=Ht({inputs:{x:s},backend:t,attrs:{shape:[i,o]}}),l=mT(a,!1,t),u=Ht({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),u}const AH={kernelName:Yy,backendName:"cpu",kernelFunc:_H};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $0(n){const{backend:e,attrs:t}=n,{shape:s,value:r,dtype:o}=t,i=o||pl(r),a=hn(i,pe(s));return DH(a,r,i),e.makeTensorInfo(s,i,a)}const RH={kernelName:Zy,backendName:"cpu",kernelFunc:$0};function DH(n,e,t){n.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OH={kernelName:Jy,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,r=t,o=Bn(s.dtype,pe(s.shape)),[i,a,l,u]=s.shape,c=r.data.get(s.dataId).values;for(let d=0;d<i;d++){const p=d*l*a*u;for(let f=0;f<a;f++){const g=f*(l*u);for(let y=0;y<l;y++){const b=y*u;for(let w=0;w<u;w++){const C=Math.round(l-y-1),v=p+g+b+w;let I=c[v];if(C>=0&&C<l){const E=C*u,R=p+g+E+w;I=c[R]}o[v]=I}}}}return{dataId:r.write(o,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FH(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,bias:i,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let g=pT({inputs:{x:r,filter:o},backend:t,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(i){const y=g;if(c==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){const b=Ht({inputs:{x:i},backend:t,attrs:{shape:[i.shape[0],1,1]}});g=rl({inputs:{a:g,b},backend:t}),t.disposeIntermediateTensorInfo(b)}else g=rl({inputs:{a:g,b:i},backend:t});t.disposeIntermediateTensorInfo(y)}if(p){const y=g;if(c==="NCHW"&&p==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const b=Ht({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});g=Td(t,g,p,b,f),t.disposeIntermediateTensorInfo(b)}else g=Td(t,g,p,a,f);t.disposeIntermediateTensorInfo(y)}return g}const LH={kernelName:ld,backendName:"cpu",kernelFunc:FH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PH(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,bias:i,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let g=fT({inputs:{x:r,filter:o},backend:t,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(i){const y=g;g=rl({inputs:{a:g,b:i},backend:t}),t.disposeIntermediateTensorInfo(y)}if(p){const y=g;g=Td(t,g,p,a,f),t.disposeIntermediateTensorInfo(y)}return g}const zH={kernelName:ud,backendName:"cpu",kernelFunc:PH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MH(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,o=pe(s.shape),i=r.shape,a=i[i.length-1],[l,u,c,h]=Sx(s,r);if(u===0)return t.makeTensorInfo(l,s.dtype,[]);const d=t.data.get(r.dataId).values,p=t.bufferSync(s),f=IN(d,p,s.dtype,u,a,c,h,s.shape,o);return t.makeTensorInfo(l,s.dtype,f.values)}const BH={kernelName:Qy,backendName:"cpu",kernelFunc:MH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VH(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:o}=e,{axis:i,batchDims:a}=s;et([r,o],"gatherV2");const l=kt(i,r.shape)[0],u=t.data.get(o.dataId).values,c=r.shape[l];for(let v=0;v<u.length;++v){const I=u[v];A(I<=c-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${c-1}]`)}let h=a;a==null&&(h=0);const d=pe(o.shape),p=qx(r,o,l,h),f=Ht({inputs:{x:r},backend:t,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),g=Ht({inputs:{x:o},backend:t,attrs:{shape:[p.batchSize,d/p.batchSize]}}),y=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],b=t.bufferSync(g),w=t.bufferSync(f),C=$N(w,b,y);return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(g),t.makeTensorInfo(p.outputShape,C.dtype,C.values)}const WH={kernelName:fp,backendName:"cpu",kernelFunc:VH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UH(n){const{inputs:e,backend:t}=n,{input:s}=e,r=pe(s.shape),o=s.shape[s.shape.length-1],i=r/o,a=Ht({inputs:{x:s},backend:t,attrs:{shape:[i,o]}}),l=mT(a,!0,t),u=Ht({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),u}const GH={kernelName:eb,backendName:"cpu",kernelFunc:UH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HH=Bt(Qu,n=>Number.isFinite(n)?1:0,"bool"),jH={kernelName:Qu,backendName:"cpu",kernelFunc:HH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KH=Bt(ec,n=>Math.abs(n)===1/0?1:0,"bool"),qH={kernelName:ec,backendName:"cpu",kernelFunc:KH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XH=Bt(tc,n=>Number.isNaN(n)?1:0,"bool"),YH={kernelName:tc,backendName:"cpu",kernelFunc:XH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZH(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:o}=t,i=AN(s,r,o);return e.makeTensorInfo([i.length],"float32",i)}const JH={kernelName:nb,backendName:"cpu",kernelFunc:ZH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QH=Bt(sc,n=>Math.log1p(n)),ej={kernelName:sc,backendName:"cpu",kernelFunc:QH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tj=mn((n,e)=>n&&e),nj=En(xp,tj,null,"bool"),sj={kernelName:xp,backendName:"cpu",kernelFunc:nj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rj=Bt(wp,n=>n?0:1,"bool"),oj={kernelName:wp,backendName:"cpu",kernelFunc:rj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ij=mn((n,e)=>n||e),aj=En(vp,ij,null,"bool"),lj={kernelName:vp,backendName:"cpu",kernelFunc:aj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:o,bias:i,alpha:a,beta:l}=s;et(r,"LRN");const u=r.shape[3],c=u-1,h=t.data.get(r.dataId).values,d=pe(r.shape),p=new Float32Array(d);function f(g){const y=g%u;let b=g-y+Math.max(0,y-o);const w=g-y+Math.min(y+o,c);let C=0;for(;b<=w;b++){const v=h[b];C+=v*v}return C}for(let g=0;g<d;g++){const y=f(g),b=h[g]*Math.pow(i+a*y,-l);p[g]=b}return t.makeTensorInfo(r.shape,r.dtype,p)}const cj={kernelName:kp,backendName:"cpu",kernelFunc:uj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,y:o,dy:i}=e,{depthRadius:a,bias:l,alpha:u,beta:c}=s;et(i,"LRNGrad");const h=pe(i.shape),d=i.shape[3],p=t.data.get(i.dataId).values,f=t.data.get(r.dataId).values,g=t.data.get(o.dataId).values,y=new Float32Array(h),b=h;for(let w=0;w<b;w++){const C=w%d,v=w-C+Math.max(0,C-a),I=w-C+Math.min(d,C+a+1);let E=0;for(let R=v;R<I;R++)E+=Math.pow(f[R],2);E=u*E+l;for(let R=v;R<I;R++){let L=-2*u*c*f[R]*g[w]/E;w===R&&(L+=Math.pow(E,-c)),L*=p[w],y[R]+=L}}return t.makeTensorInfo(i.shape,r.dtype,y)}const dj={kernelName:sb,backendName:"cpu",kernelFunc:hj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gT(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:o,keepDims:i}=s,a=t;let l=r.shape;const u=l.length,c=kt(o,l);let h=c;const d=an(h,u);let p=a.data.get(r.dataId).values;if(d!=null){const v=new Array(u);for(let I=0;I<v.length;I++)v[I]=l[d[I]];p=v0(p,l,r.dtype,d,v),h=pn(h.length,u),l=v}et(r,"max"),Un("max",h,u);const[f,g]=Fn(l,h),y=pe(g),b=DN(p,y,f,r.dtype),w=a.write(b,f,r.dtype);let C=f;return i&&(C=dn(f,c)),{dataId:w,shape:C,dtype:r.dtype}}const pj={kernelName:Cp,backendName:"cpu",kernelFunc:gT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;et(r,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=s,u=1;A(Wn(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=pr(r.shape,o,i,u,a,l);let h;if(c.filterWidth===1&&c.filterHeight===1&&Tt(c.inShape,c.outShape))h=Jr({inputs:{x:r},backend:t});else{const d=t.data.get(r.dataId).values,p=rt(r.shape),f=S0(d,r.shape,r.dtype,p,c,"max");h=t.makeTensorInfo(c.outShape,r.dtype,f.values)}return h}const mj={kernelName:Sp,backendName:"cpu",kernelFunc:fj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=s;et(r,"maxPool3d");const c=Io(r.shape,o,i,1,a,l,u),h=t.data.get(r.dataId).values,d=dT(h,r.shape,r.dtype,rt(r.shape),c,"max");return t.makeTensorInfo(d.shape,"float32",d.values)}const yj={kernelName:Ip,backendName:"cpu",kernelFunc:gj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bj(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=s;et([r,o],"maxPool3DGrad");const c=Io(o.shape,i,a,1,l,u),h=t.bufferSync(o),d=iG(h,c),p=c.strideDepth,f=c.strideHeight,g=c.strideWidth,y=c.dilationDepth,b=c.dilationHeight,w=c.dilationWidth,C=c.effectiveFilterDepth,v=c.effectiveFilterHeight,I=c.effectiveFilterWidth,E=C-1-c.padInfo.front,R=I-1-c.padInfo.left,L=v-1-c.padInfo.top,D=wt(o.shape,"float32"),F=t.bufferSync(r);for(let T=0;T<c.batchSize;++T)for(let V=0;V<c.inChannels;++V)for(let q=0;q<c.inDepth;++q)for(let se=0;se<c.inHeight;++se)for(let ee=0;ee<c.inWidth;++ee){const te=q-E,le=se-L,Q=ee-R;let he=0;for(let ye=0;ye<C;ye+=y){const we=(te+ye)/p;if(!(we<0||we>=c.outDepth||Math.floor(we)!==we))for(let Ce=0;Ce<v;Ce+=b){const Se=(le+Ce)/f;if(!(Se<0||Se>=c.outHeight||Math.floor(Se)!==Se))for(let Le=0;Le<I;Le+=w){const Ae=(Q+Le)/g;if(Ae<0||Ae>=c.outWidth||Math.floor(Ae)!==Ae)continue;const Me=C*v*I-1-d.get(T,we,Se,Ae,V),Ze=ye*v*I+Ce*I+Le,ot=Me===Ze?1:0;if(ot===0)continue;const $e=F.get(T,we,Se,Ae,V);he+=$e*ot}}}D.set(he,T,q,se,ee,V)}return t.makeTensorInfo(D.shape,D.dtype,D.values)}const xj={kernelName:ob,backendName:"cpu",kernelFunc:bj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wj(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o,output:i}=e,a=o;et([o,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,d=pr(a.shape,l,u,1,c,h),p=t.data.get(a.dataId).values,f=wt(d.outShape,a.dtype,hT(p,a.shape,a.dtype,d).values),g=d.strideHeight,y=d.strideWidth,b=d.dilationHeight,w=d.dilationWidth,C=d.effectiveFilterHeight,v=d.effectiveFilterWidth,I=v-1-d.padInfo.left,E=C-1-d.padInfo.top,R=wt(a.shape,"float32"),L=t.data.get(r.dataId).values,D=wt(r.shape,"float32",L);for(let F=0;F<d.batchSize;++F)for(let T=0;T<d.inChannels;++T)for(let V=0;V<d.inHeight;++V)for(let q=0;q<d.inWidth;++q){const se=V-E,ee=q-I;let te=0;for(let le=0;le<C;le+=b){const Q=(se+le)/g;if(!(Q<0||Q>=d.outHeight||Math.floor(Q)!==Q))for(let he=0;he<v;he+=w){const ye=(ee+he)/y;if(ye<0||ye>=d.outWidth||Math.floor(ye)!==ye)continue;const we=C*v-1-f.get(F,Q,ye,T),Ce=le*v+he,Se=we===Ce?1:0;if(Se===0)continue;const Le=D.get(F,Q,ye,T);te+=Le*Se}}R.set(te,F,V,q,T)}return t.makeTensorInfo(R.shape,R.dtype,R.values)}const vj={kernelName:rb,backendName:"cpu",kernelFunc:wj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kj(n,e,t,s,r){const o=rt(e),i=S0(n,e,t,o,r,"max"),a=hT(n,e,t,r,!0,s);return[i.values,a.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cj={kernelName:ib,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:o,pad:i,includeBatchInIndex:a}=e,l=t;et(s,"MaxPoolWithArgmax");const u=l.data.get(s.dataId).values,c=pr(s.shape,r,o,[1,1],i),[h,d]=kj(u,s.shape,s.dtype,a,c),p=l.write(h,c.outShape,s.dtype),f=l.write(d,c.outShape,s.dtype);return[{dataId:p,shape:c.outShape,dtype:s.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s,a=kt(o,r.shape),u=Fn(r.shape,a)[1],c=pe(u),h=[],d=t.makeTensorInfo([],"float32",new Float32Array([c]));h.push(d);const p=ui({inputs:{x:r},backend:t,attrs:{dtype:"float32"}});h.push(p);const f=I0({inputs:{a:p,b:d},backend:t});h.push(f);const g=jc({inputs:{x:f},backend:t,attrs:{axis:o,keepDims:i}});return h.forEach(y=>t.disposeIntermediateTensorInfo(y)),g}const Ij={kernelName:$p,backendName:"cpu",kernelFunc:Sj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $j(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s;et(r,"min");const a=kt(o,r.shape);let l=a;const u=an(l,r.shape.length);let c=r;u!=null&&(c=Is({inputs:{x:r},backend:t,attrs:{perm:u}}),l=pn(l.length,r.shape.length)),Un("min",l,c.shape.length);const[h,d]=Fn(c.shape,l),p=pe(d),f=Xn(pe(h),c.dtype),g=t.data.get(c.dataId).values;for(let b=0;b<f.length;++b){const w=b*p;let C=g[w];for(let v=0;v<p;++v){const I=g[w+v];(Number.isNaN(I)||I<C)&&(C=I)}f[b]=C}u!=null&&t.disposeIntermediateTensorInfo(c);const y=t.makeTensorInfo(h,c.dtype,f);if(i){const b=dn(h,a),w=Ht({inputs:{x:y},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(y),w}return y}const Nj={kernelName:Np,backendName:"cpu",kernelFunc:$j};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:o,mode:i}=s;et(r,"mirrorPad");const a=o.map((C,v)=>C[0]+r.shape[v]+C[1]),l=o.map(C=>C[0]),u=o.map((C,v)=>C[0]+r.shape[v]),c=i==="reflect"?0:1,h=t.data.get(r.dataId).values,d=r.shape.length,p=rt(r.shape),f=pe(a),g=a.length,y=rt(a),b=Bn(r.dtype,f);for(let C=0;C<f;C++){let v=fl(C,g,y);for(let E=0;E<g;E++)v[E]<l[E]?v[E]=l[E]*2-v[E]-c:v[E]>=u[E]&&(v[E]=(u[E]-1)*2-v[E]+c);v=v.map((E,R)=>E-l[R]);const I=Wr(v,d,p);b[C]=h[I]}return{dataId:t.write(b,a,r.dtype),shape:a,dtype:r.dtype}}const Ej={kernelName:Tp,backendName:"cpu",kernelFunc:Tj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _j=mn((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e}),Aj=En(ic,_j),Rj={kernelName:ic,backendName:"cpu",kernelFunc:Aj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yT(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:o}=s,i=r.shape.length;let a=o;if(a===-1&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);const l=kt([a],r.shape),u=gT({inputs:{x:r},backend:t,attrs:{reductionIndices:l,keepDims:!1}}),c=dn(u.shape,l),h=Ht({inputs:{x:u},backend:t,attrs:{shape:c}}),d=C0({inputs:{a:r,b:h},backend:t}),p=vN({inputs:{x:d},backend:t}),f=jc({inputs:{x:p},backend:t,attrs:{axis:l,keepDims:!1}}),g=Ht({inputs:{x:f},backend:t,attrs:{shape:c}}),y=I0({inputs:{a:p,b:g},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(g),y}const Dj={kernelName:jp,backendName:"cpu",kernelFunc:yT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oj(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:o,seed:i,normalized:a}=s;et(r,"multinomial");const l=a?r:yT({inputs:{logits:r},backend:t,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],h=t.data.get(l.dataId).values,d=[u,o],p=Xn(pe(d),"int32");for(let f=0;f<u;++f){const g=f*c,y=new Float32Array(c-1);y[0]=h[g];for(let C=1;C<y.length;++C)y[C]=y[C-1]+h[g+C];const b=hf.alea(i.toString()),w=f*o;for(let C=0;C<o;++C){const v=b();p[w+C]=y.length;for(let I=0;I<y.length;I++)if(v<y[I]){p[w+C]=I;break}}}return a||t.disposeIntermediateTensorInfo(l),t.makeTensorInfo(d,"int32",p)}const Fj={kernelName:ab,backendName:"cpu",kernelFunc:Oj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lj=yx;function Pj(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=s;et(r,"NonMaxSuppression");const u=t.data.get(r.dataId).values,c=t.data.get(o.dataId).values,{selectedIndices:h}=Lj(u,c,i,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const zj={kernelName:lb,backendName:"cpu",kernelFunc:Pj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mj=bx;function Bj(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=s;et(r,"NonMaxSuppressionPadded");const c=t.data.get(r.dataId).values,h=t.data.get(o.dataId).values,{selectedIndices:d,validOutputs:p}=Mj(c,h,i,a,l,u);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const Vj={kernelName:ub,backendName:"cpu",kernelFunc:Bj};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wj=xx;function Uj(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=s;et(r,"NonMaxSuppressionWithScore");const c=t.data.get(r.dataId).values,h=t.data.get(o.dataId).values,d=i,p=a,f=l,g=u,{selectedIndices:y,selectedScores:b}=Wj(c,h,d,p,f,g);return[t.makeTensorInfo([y.length],"int32",new Int32Array(y)),t.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const Gj={kernelName:cb,backendName:"cpu",kernelFunc:Uj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hj(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:o,depth:i,onValue:a,offValue:l}=s;et(r,"oneHot");const u=pe(r.shape),c=new Float32Array(u*i);c.fill(l);const h=t.data.get(r.dataId).values;for(let d=0;d<u;++d)h[d]>=0&&h[d]<i&&(c[d*i+h[d]]=a);return t.makeTensorInfo([...r.shape,i],o,c)}const jj={kernelName:Rp,backendName:"cpu",kernelFunc:Hj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _d(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=aa({inputs:{input:s},backend:t}),o=_d({inputs:{x:r},backend:t}),i=ol({inputs:{input:s},backend:t}),a=_d({inputs:{x:i},backend:t}),l=_s({inputs:{real:o,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),l}else return $0({backend:t,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const Kj={kernelName:Yp,backendName:"cpu",kernelFunc:_d};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bT(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=aa({inputs:{input:s},backend:t}),o=bT({inputs:{x:r},backend:t}),i=ol({inputs:{input:s},backend:t}),a=_d({inputs:{x:i},backend:t}),l=_s({inputs:{real:o,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),l}else return $0({backend:t,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const qj={kernelName:Ap,backendName:"cpu",kernelFunc:bT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xT(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return Ed({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const o=e[0].shape,i=e[0].dtype;e.forEach(c=>{Ms(o,c.shape,"All tensors passed to stack must have matching shapes"),A(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(c=>{const h=Ed({inputs:{input:c},backend:t,attrs:{dim:r}});return a.push(h),h}),u=il({inputs:l,backend:t,attrs:{axis:r}});return a.forEach(c=>t.disposeIntermediateTensorInfo(c)),u}const Xj={kernelName:Dp,backendName:"cpu",kernelFunc:xT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:o,constantValue:i}=s;et(r,"pad");const a=o.map((w,C)=>w[0]+r.shape[C]+w[1]),l=o.map(w=>w[0]),u=t.data.get(r.dataId).values,c=pe(r.shape),h=r.shape.length,d=rt(r.shape),p=pe(a),f=a.length,g=rt(a),y=Bn(r.dtype,p);i!==0&&y.fill(i);for(let w=0;w<c;w++){const v=fl(w,h,d).map((E,R)=>E+l[R]),I=Wr(v,f,g);y[I]=u[w]}return{dataId:t.write(y,a,r.dtype),shape:a,dtype:r.dtype}}const wT={kernelName:Op,backendName:"cpu",kernelFunc:Yj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zj=mn((n,e)=>Math.pow(n,e)),Jj=En(lc,Zj),Qj={kernelName:lc,backendName:"cpu",kernelFunc:Jj};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eK(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:o,indices:i}=e,{outputRaggedRank:a}=s,l=r.map(b=>t.data.get(b.dataId).values),u=r.map(b=>b.shape),c=t.data.get(o.dataId).values,h=t.data.get(i.dataId).values,[d,p,f]=MN(l,u,c,o.shape,o.dtype,h,i.shape),g=d.map(b=>t.makeTensorInfo([b.length],"int32",b)),y=t.makeTensorInfo(f,o.dtype,p);return g.concat([y])}const tK={kernelName:hb,backendName:"cpu",kernelFunc:eK};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nK(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:o}=e,i=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,l=t.data.get(o.dataId).values,[u,c]=BN(i,s.shape,s.dtype,a,r.shape,l,o.shape),h=t.makeTensorInfo([u.length],"int32",u),d=t.makeTensorInfo([c.length],s.dtype,c);return[h,d]}const sK={kernelName:db,backendName:"cpu",kernelFunc:nK};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rK(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:o,defaultValue:i,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=s,u=t.data.get(r.dataId).values,c=t.data.get(o.dataId).values,h=t.data.get(i.dataId).values,d=a.map(y=>t.data.get(y.dataId).values),p=a.map(y=>y.shape),[f,g]=VN(u,r.shape,c,o.shape,o.dtype,h,i.shape,d,p,l);return t.makeTensorInfo(f,o.dtype,g)}const oK={kernelName:pb,backendName:"cpu",kernelFunc:rK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iK(n){const{backend:e,attrs:t}=n,{start:s,stop:r,dtype:o,step:i}=t,a=WN(s,r,i,o);return e.makeTensorInfo([a.length],o,a)}const aK={kernelName:fb,backendName:"cpu",kernelFunc:iK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lK=Bt(uc,n=>1/n),uK={kernelName:uc,backendName:"cpu",kernelFunc:lK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cK(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:o,halfPixelCenters:i,size:a}=s;et(r,"resizeBilinear");const l=rt(r.shape),[u,c]=a,[h,d,p,f]=r.shape,g=t.data.get(r.dataId).values,y=new Float32Array(pe([h,u,c,f])),b=[o&&u>1?d-1:d,o&&c>1?p-1:p],w=[o&&u>1?u-1:u,o&&c>1?c-1:c];let C=0;const v=b[0]/w[0],I=b[1]/w[1];for(let E=0;E<h;E++)for(let R=0;R<u;R++){let L;i?L=v*(R+.5)-.5:L=v*R;const D=Math.max(0,Math.floor(L)),F=L-D,T=Math.min(d-1,Math.ceil(L)),V=E*l[0]+D*l[1],q=E*l[0]+T*l[1];for(let se=0;se<c;se++){let ee;i?ee=I*(se+.5)-.5:ee=I*se;const te=Math.max(0,Math.floor(ee)),le=ee-te,Q=Math.min(p-1,Math.ceil(ee)),he=V+te*l[2],ye=q+te*l[2],we=V+Q*l[2],Ce=q+Q*l[2];for(let Se=0;Se<f;Se++){const Le=g[he+Se],Ae=g[ye+Se],Me=g[we+Se],Ze=g[Ce+Se],ot=Le+(Me-Le)*le,$e=Ae+(Ze-Ae)*le,at=ot+($e-ot)*F;y[C++]=at}}}return t.makeTensorInfo([h,u,c,f],"float32",y)}const hK={kernelName:Mp,backendName:"cpu",kernelFunc:cK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dK(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:o}=e,{alignCorners:i}=s;et([o,r],"resizeBilinearGrad");const a=rt(r.shape),[l,u,c,h]=r.shape,[,d,p]=o.shape,f=new Float32Array(l*u*c*h),g=[i&&d>1?u-1:u,i&&p>1?c-1:c],y=[i&&d>1?d-1:d,i&&p>1?p-1:p],b=g[0]/y[0],w=g[1]/y[1],C=t.data.get(o.dataId).values;let v=0;for(let I=0;I<l;I++){const E=I*a[0];for(let R=0;R<d;R++){const L=R*b,D=Math.floor(L),F=Math.min(Math.ceil(L),u-1),T=E+D*a[1],V=E+F*a[1],q=L-D,se=1-q;for(let ee=0;ee<p;ee++){const te=ee*w,le=Math.floor(te),Q=Math.min(Math.ceil(te),c-1),he=te-le,ye=1-he,we=T+le*a[2],Ce=T+Q*a[2],Se=V+le*a[2],Le=V+Q*a[2],Ae=se*ye,Me=se*he,Ze=q*ye,ot=q*he;for(let $e=0;$e<h;$e++){const at=C[v++];f[we+$e]+=at*Ae,f[Ce+$e]+=at*Me,f[Se+$e]+=at*Ze,f[Le+$e]+=at*ot}}}}return t.makeTensorInfo([l,c,u,h],"float32",f)}const pK={kernelName:yb,backendName:"cpu",kernelFunc:dK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fK(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:o,halfPixelCenters:i,size:a}=s;et(r,"resizeNearestNeighbor");const l=rt(r.shape),[u,c]=a,[h,d,p,f]=r.shape,g=t.data.get(r.dataId).values,y=new Float32Array(h*u*c*f),b=[o&&u>1?d-1:d,o&&c>1?p-1:p],w=[o&&u>1?u-1:u,o&&c>1?c-1:c],C=b[0]/w[0],v=b[1]/w[1];let I=0;for(let E=0;E<h;E++){const R=E*l[0];for(let L=0;L<u;L++){const D=i?C*(L+.5):C*L;let F=Math.min(d-1,o?Math.round(D):Math.floor(D));i&&(F=Math.max(0,F));const T=R+F*l[1];for(let V=0;V<c;V++){const q=i?v*(V+.5):v*V;let se=Math.min(p-1,o?Math.round(q):Math.floor(q));i&&(se=Math.max(0,se));const ee=T+se*l[2];for(let te=0;te<f;te++){const le=g[ee+te];y[I++]=le}}}}return t.makeTensorInfo([h,u,c,f],r.dtype,y)}const mK={kernelName:zp,backendName:"cpu",kernelFunc:fK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gK(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:o}=e,{alignCorners:i}=s;et([o,r],"resizeNearestNeighborGrad");const a=rt(r.shape),l=rt(o.shape),[u,c,h,d]=r.shape,[,p,f]=o.shape,g=new Float32Array(u*c*h*d),y=t.data.get(o.dataId).values,b=[i&&p>1?c-1:c,i&&f>1?h-1:h],w=[i&&p>1?p-1:p,i&&f>1?f-1:f],C=b[0]/w[0],v=b[1]/w[1],I=1/C,E=1/v,R=Math.ceil(I)*2+2,L=Math.ceil(E)*2+2;for(let D=0;D<u;D++){const F=D*a[0];for(let T=0;T<c;T++){const V=F+T*a[1],q=Math.floor(T*I),se=Math.floor(q-R/2);for(let ee=0;ee<h;ee++){const te=V+ee*a[2],le=Math.floor(ee*E),Q=Math.floor(le-L/2);for(let he=0;he<d;he++){let ye=0;for(let we=0;we<R;we++){const Ce=we+se;if(Ce<0||Ce>=p)continue;const Se=F+Ce*l[1],Le=Ce*C,Ae=Math.min(c-1,i?Math.round(Le):Math.floor(Le));if(T===Ae)for(let Me=0;Me<L;Me++){const Ze=Me+Q;if(Ze<0||Ze>=f)continue;const ot=Se+Ze*l[2],$e=Ze*v,at=Math.min(h-1,i?Math.round($e):Math.floor($e));ee===at&&(ye+=y[ot+he])}}g[te+he]=ye}}}}return t.makeTensorInfo(r.shape,r.dtype,g)}const yK={kernelName:gb,backendName:"cpu",kernelFunc:gK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bK(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:o}=s;et(r,"reverse");const i=r.shape.length,a=kt(o,r.shape);if(i===0)return Jr({inputs:{x:r},backend:t});const l=new In(r.shape,r.dtype),u=t.bufferSync(r);for(let c=0;c<l.size;c++){const h=l.indexToLoc(c),d=h.slice();a.forEach(p=>d[p]=r.shape[p]-1-d[p]),l.set(u.get(...d),...h)}return t.makeTensorInfo(l.shape,l.dtype,l.values)}const xK={kernelName:Bp,backendName:"cpu",kernelFunc:bK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wK={kernelName:Ob,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:o,center:i}=e,a=t,l=Bn(s.dtype,pe(s.shape)),[u,c,h,d]=s.shape,[p,f]=Rx(i,c,h),g=255,y=Math.sin(r),b=Math.cos(r),w=a.data.get(s.dataId).values;for(let v=0;v<u;v++){const I=v*h*c*d;for(let E=0;E<c;E++){const R=E*(h*d);for(let L=0;L<h;L++){const D=L*d;for(let F=0;F<d;F++){const T=[u,E,L,F],V=T[2],q=T[1];let se=(V-p)*b-(q-f)*y,ee=(V-p)*y+(q-f)*b;se=Math.round(se+p),ee=Math.round(ee+f);let te=o;if(typeof o!="number"&&(F===3?te=g:te=o[F]),se>=0&&se<h&&ee>=0&&ee<c){const Q=ee*(h*d),he=se*d,ye=I+Q+he+F;te=w[ye]}const le=I+R+D+F;l[le]=te}}}}return{dataId:a.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vK=Bt(dc,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),kK={kernelName:dc,backendName:"cpu",kernelFunc:vK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CK(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:o}=e,{shape:i}=s,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=fa(o,r,i),d=!0,p=t.bufferSync(r),f=t.bufferSync(o),g=Gi(p,f,i,h,u,l,a,c,0,d);return t.makeTensorInfo(i,g.dtype,g.values)}const SK={kernelName:bb,backendName:"cpu",kernelFunc:CK};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IK(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<e?t=r+1:s=r;return s}function $K(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<=e?t=r+1:s=r;return s}function NK(n,e,t,s,r,o){const i=hn("int32",t*r);for(let a=0;a<t;++a){const l=n.slice(a*s,(a+1)*s),u=a*r;for(let c=0;c<r;++c)i[u+c]=o==="left"?IK(l,e[c+u]):$K(l,e[c+u])}return i}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TK(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:o}=e,{side:i}=s,a=t.data.get(r.dataId).values,l=t.data.get(o.dataId).values,u=NK(a,l,r.shape[0],r.shape[1],o.shape[1],i);return t.makeTensorInfo(o.shape,"int32",u)}const EK={kernelName:wb,backendName:"cpu",kernelFunc:TK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _K(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:o}=e;et([s,r,o],"select");const i=s.shape.length,a=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,u=t.data.get(o.dataId).values,c=Ds(r.dtype,o.dtype),h=Xn(pe(r.shape),c);let d=0;const p=i===0||i>1||r.shape.length===1?1:pe(r.shape.slice(1));for(let f=0;f<a.length;f++)for(let g=0;g<p;g++)a[f]===1?h[d++]=l[f]:h[d++]=u[f];return t.makeTensorInfo(r.shape,c,h)}const AK={kernelName:Vp,backendName:"cpu",kernelFunc:_K};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RK=Cf,DK=Sf,OK=Bt(fc,n=>n>=0?DK*n:RK*(Math.exp(n)-1)),FK={kernelName:fc,backendName:"cpu",kernelFunc:OK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LK=Bt(yc,n=>n<0?-1:n>0?1:0),PK={kernelName:yc,backendName:"cpu",kernelFunc:LK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zK=Bt(mc,n=>Math.sin(n)),MK={kernelName:mc,backendName:"cpu",kernelFunc:zK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BK=Bt(gc,n=>Math.sinh(n)),VK={kernelName:gc,backendName:"cpu",kernelFunc:BK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WK=11920928955078125e-23,Jv=Math.log(WK)+2,UK=Bt(xc,n=>{const e=n>-Jv,t=n<Jv,s=Math.exp(n);let r;return t?r=s:e?r=n:r=Math.log(1+s),r}),GK={kernelName:xc,backendName:"cpu",kernelFunc:UK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HK(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:o,paddings:i}=s;et([r],"spaceToBatchND");const a=pe(o),l=[[0,0]];l.push(...i);for(let E=1+o.length;E<r.shape.length;++E)l.push([0,0]);const u=wT.kernelFunc({inputs:{x:r},backend:t,attrs:{paddings:l,constantValue:0}}),c=Fc(u.shape,o,a,!1),h=Lc(c.length,o.length,!1),d=Pc(u.shape,o,a,!1),g=Ht({inputs:{x:u},backend:t,attrs:{shape:c}}),w=Is({inputs:{x:g},backend:t,attrs:{perm:h}}),I=Ht({inputs:{x:w},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(w),I}const jK={kernelName:Gp,backendName:"cpu",kernelFunc:HK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KK(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:o,defaultValue:i}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${o.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const a=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,u=t.data.get(o.dataId).values,c=t.data.get(i.dataId).values[0],[h,d,p,f,g]=jN(a,s.shape,s.dtype,l,r.dtype,u,c);return[t.makeTensorInfo(d,s.dtype,h),t.makeTensorInfo([d[0]],r.dtype,p),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(y=>Number(y)))),t.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}const qK={kernelName:vb,backendName:"cpu",kernelFunc:KK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XK(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:o}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(t.data.get(r.dataId).values),a=t.data.get(s.dataId).values,l=Array.from(t.data.get(o.dataId).values),[u,c,h]=KN(a,s.shape,s.dtype,i,l);return[t.makeTensorInfo(c,s.dtype,u),t.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}const YK={kernelName:kb,backendName:"cpu",kernelFunc:XK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZK(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${o.shape}`);if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,l=t.data.get(o.dataId).values,[u,c]=k0(i,s.shape,s.dtype,a,l,!0);return t.makeTensorInfo(c,s.dtype,u)}const JK={kernelName:Cb,backendName:"cpu",kernelFunc:ZK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QK(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${o.shape}`);if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,l=t.data.get(o.dataId).values,[u,c]=k0(i,s.shape,s.dtype,a,l);return t.makeTensorInfo(c,s.dtype,u)}const eq={kernelName:Sb,backendName:"cpu",kernelFunc:QK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tq(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:o,defaultValue:i}=e,{outputShape:a}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=fa(o,r,a),p=!1,f=t.bufferSync(r);let g;switch(o.dtype){case"bool":{const y=t.bufferSync(o),b=!!t.data.get(i.dataId).values[0];g=Gi(f,y,a,d,c,u,l,h,b,p);break}case"float32":{const y=t.bufferSync(o),b=t.data.get(i.dataId).values[0];g=Gi(f,y,a,d,c,u,l,h,b,p);break}case"int32":{const y=t.bufferSync(o),b=t.data.get(i.dataId).values[0];g=Gi(f,y,a,d,c,u,l,h,b,p);break}case"string":{const y=t.bufferSync(o),b=ei(t.data.get(i.dataId).values[0]);g=Gi(f,y,a,d,c,u,l,h,b,p);break}default:throw new Error(`Unsupported type ${o.dtype}`)}return t.makeTensorInfo(a,g.dtype,g.values)}const nq={kernelName:Ib,backendName:"cpu",kernelFunc:tq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sq(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:o,axis:i}=s,a=kt(i,r.shape)[0],l=Kx(r,o,a),u=new Array(r.shape.length).fill(0),c=r.shape.slice();return l.map(h=>{const d=[...c];d[a]=h;const p=la({inputs:{x:r},backend:t,attrs:{begin:u,size:d}});return u[a]+=h,p})}const rq={kernelName:Hp,backendName:"cpu",kernelFunc:sq};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oq={kernelName:$b,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e;et(t,"square");const r=s.data.get(t.dataId).values,o=new Float32Array(r.length);for(let a=0;a<r.length;++a){const l=r[a];o[a]=l*l}return{dataId:s.write(o,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iq=Bt($c,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),aq={kernelName:$c,backendName:"cpu",kernelFunc:iq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lq(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:o,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=s;et(r,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:w,end:C,strides:v}=Ex(r.shape,o,i,a,l,u,c,h,d);let I;if(g)I=Ht({inputs:{x:r},backend:t,attrs:{shape:f}});else if(y||b){A(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const E=$x(w,C,v),R=la({inputs:{x:r},backend:t,attrs:{begin:w,size:E}});I=Ht({inputs:{x:R},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(R)}else{const E=t.bufferSync(r),R=YN(p,E,v,w);I=t.makeTensorInfo(f,R.dtype,R.values)}return I}const uq={kernelName:Nb,backendName:"cpu",kernelFunc:lq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cq(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:h}=e,d=t.data.get(c.dataId).values,p=t.data.get(h.dataId).values,[f,g]=ZN(d,p,r,o,i,a,l,u);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(h.shape,"int32",g)]}const hq={kernelName:Tb,backendName:"cpu",kernelFunc:cq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dq(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:o,delimiter:i}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=t.data.get(o.dataId).values,l=t.data.get(i.dataId).values[0],[u,c,h]=JN(a,l,r),d=c.length;return[t.makeTensorInfo([d,2],"int32",u),t.makeTensorInfo([d],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const pq={kernelName:Eb,backendName:"cpu",kernelFunc:dq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fq(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const i=t.data.get(o.dataId).values,a=QN(i,r);return t.makeTensorInfo(o.shape,"int32",a)}const mq={kernelName:_b,backendName:"cpu",kernelFunc:fq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gq=Bt(Cc,n=>Math.tan(n)),yq={kernelName:Cc,backendName:"cpu",kernelFunc:gq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bq=Bt(Sc,n=>Math.tanh(n)),xq={kernelName:Sc,backendName:"cpu",kernelFunc:bq};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wq(n){const{inputs:e,backend:t}=n,{tensor:s,indices:r,updates:o}=e,{sliceRank:i,numUpdates:a,sliceSize:l,strides:u,outputSize:c}=fa(o,r,s.shape),h=!1,d=t.bufferSync(r),p=t.bufferSync(o),f=t.bufferSync(s),g=Gi(d,p,s.shape,c,l,a,i,u,f,h);return t.makeTensorInfo(s.shape,g.dtype,g.values)}const vq={kernelName:xb,backendName:"cpu",kernelFunc:wq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kq(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:o}=s;et(r,"tile");const i=tT(t.bufferSync(r),o);return t.makeTensorInfo(i.shape,i.dtype,i.values)}const Cq={kernelName:Ic,backendName:"cpu",kernelFunc:kq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sq(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:o,sorted:i}=s;et(r,"topk");const a=t.data.get(r.dataId).values,[l,u]=sT(a,r.shape,r.dtype,o,i);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(u.shape,u.dtype,u.values)]}const Iq={kernelName:Ab,backendName:"cpu",kernelFunc:Sq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $q(n){const{inputs:e,attrs:t,backend:s}=n,{image:r,transforms:o}=e,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=t,[c,h,d,p]=r.shape,[f,g]=u??[h,d],y=[c,f,g,p],b=rt(r.shape),w=b[0],C=b[1],v=b[2],I=rt(y),E=I[0],R=I[1],L=I[2],D=Bn(r.dtype,pe(y));D.fill(l);const F=s.data.get(r.dataId).values,T=s.data.get(o.dataId).values;for(let q=0;q<c;++q){const se=o.shape[0]===1?T:T.subarray(q*8,q*8+8);for(let ee=0;ee<f;++ee)for(let te=0;te<g;++te)for(let le=0;le<p;++le){let Q;const he=se[6]*te+se[7]*ee+1;if(he===0)continue;const ye=(se[0]*te+se[1]*ee+se[2])/he,we=(se[3]*te+se[4]*ee+se[5])/he,Ce=Qv(ye,d,a),Se=Qv(we,h,a);switch(i){case"nearest":Q=Rq(F,h,d,w,C,v,q,Se,Ce,le,l);break;case"bilinear":Q=Dq(F,h,d,w,C,v,q,Se,Ce,le,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}const Le=q*E+ee*R+te*L+le;D[Le]=Q}return s.makeTensorInfo(y,r.dtype,D)}return{dataId:s.write(D,y,r.dtype),shape:r.shape,dtype:r.dtype}}const Nq={kernelName:Rb,backendName:"cpu",kernelFunc:$q};function Qv(n,e,t){switch(t){case"reflect":return Tq(n,e);case"wrap":return Eq(n,e);case"nearest":return Aq(n,e);case"constant":default:return _q(n)}}function Tq(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=2*e;t<s&&(t=s*Math.trunc(-t/s)+t),t=t<-e?t+s:-t-1}else if(t>e-1)if(e<=1)t=0;else{const s=2*e;t-=s*Math.trunc(t/s),t>=e&&(t=s-t-1)}return Xi(0,t,e-1)}function Eq(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=e-1;t+=e*(Math.trunc(-t/s)+1)}else if(t>e-1)if(e<=1)t=0;else{const s=e-1;t-=e*Math.trunc(t/s)}return Xi(0,t,e-1)}function _q(n,e){return n}function Aq(n,e){return Xi(0,n,e-1)}function Jl(n,e,t,s,r,o,i,a,l,u,c){const h=i*s+a*r+l*o+u;return 0<=a&&a<e&&0<=l&&l<t?n[h]:c}function Rq(n,e,t,s,r,o,i,a,l,u,c){const h=Math.round(a),d=Math.round(l);return Jl(n,e,t,s,r,o,i,h,d,u,c)}function Dq(n,e,t,s,r,o,i,a,l,u,c){const h=Math.floor(a),d=Math.floor(l),p=h+1,f=d+1,g=(f-l)*Jl(n,e,t,s,r,o,i,h,d,u,c)+(l-d)*Jl(n,e,t,s,r,o,i,h,f,u,c),y=(f-l)*Jl(n,e,t,s,r,o,i,p,d,u,c)+(l-d)*Jl(n,e,t,s,r,o,i,p,f,u,c);return(p-a)*g+(a-h)*y}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oq(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:o}=e;et(o,"unique");const i=s.data.get(o.dataId).values,{outputValues:a,outputShape:l,indices:u}=rT(i,r,o.shape,o.dtype);return[s.makeTensorInfo(l,o.dtype,a),s.makeTensorInfo([u.length],"int32",u)]}const Fq={kernelName:Db,backendName:"cpu",kernelFunc:Oq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lq(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:o}=s;o<0&&(o+=r.shape.length);const i=r.shape.length,a=r.shape[o],l=new Array(i-1);let u=0;for(let p=0;p<i;p++)p!==o&&(l[u++]=r.shape[p]);const c=new Array(i).fill(0),h=r.shape.slice();h[o]=1;const d=new Array(a);for(let p=0;p<d.length;p++){c[o]=p;const f=la({inputs:{x:r},backend:t,attrs:{begin:c,size:h}});d[p]=Ht({inputs:{x:f},backend:t,attrs:{shape:l}}),t.disposeIntermediateTensorInfo(f)}return d}const Pq={kernelName:qp,backendName:"cpu",kernelFunc:Lq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zq(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:o}=e,{numSegments:i}=s;et(r,"unsortedSegmentSum");const a=r.shape.length,l=o.shape.length,u=[],c=[],h=a-l;let d=o;for(let f=0;f<h;++f){const g=Ed({inputs:{input:d},backend:t,attrs:{dim:f+1}});d=g,c.push(g)}for(let f=0;f<i;++f){const g=pi(f,"int32"),y=t.makeTensorInfo([],"int32",g),b=xN({inputs:{a:y,b:d},backend:t}),w=ui({inputs:{x:b},backend:t,attrs:{dtype:"float32"}}),C=Lf({inputs:{a:w,b:r},backend:t}),v=jc({inputs:{x:C},backend:t,attrs:{axis:0,keepDims:!1}});u.push(v),c.push(y),c.push(b),c.push(w),c.push(C),c.push(v)}const p=xT({inputs:u,backend:t,attrs:{axis:0}});return c.forEach(f=>t.disposeIntermediateTensorInfo(f)),p}const Mq={kernelName:Xp,backendName:"cpu",kernelFunc:zq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bq=[OU,f4,LU,zU,w4,BU,WU,GU,jU,qU,YU,JU,eG,sG,oG,lG,cG,dG,fG,RU,gG,bG,wG,k4,kG,b4,S4,SG,m4,$G,TG,EG,AG,DG,FG,PG,MG,VG,UG,HG,KG,XG,ZG,QG,eH,nH,rH,iH,aH,lH,uH,hH,fH,IU,gH,I4,SH,$4,IH,T4,AH,RH,OH,_4,R4,LH,zH,BH,WH,O4,L4,g4,GH,NG,jH,qH,YH,$U,z4,B4,JH,W4,ej,sj,oj,lj,cj,dj,pj,G4,mj,yj,xj,vj,Cj,Ij,Nj,j4,Ej,Rj,Fj,q4,Y4,zj,Vj,Gj,J4,jj,qj,Xj,wT,Qj,TU,tU,tK,sK,oK,aK,y4,oy,uK,EU,_U,AU,hK,pK,mK,yK,xK,wK,kK,uU,SK,EK,AK,FK,hU,PK,MK,VK,dU,Dj,GK,jK,qK,YK,JK,eq,nq,rq,mU,oq,yU,xU,aq,uq,hq,pq,mq,CU,dH,yq,xq,vq,Cq,Iq,Nq,Q4,Fq,Pq,Mq,Kj];for(const n of Bq)fk(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wi={},Rh={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Vq(n,e){Wi[n]=e}function Nr(n,e){if(!(n in Wi)||e!=null){const s=Uq(n,e);if(s!==null)Wi[n]=s;else return console.log("Could not get context for WebGL version",n),null}const t=Wi[n];return t==null||t.isContextLost()?(delete Wi[n],Nr(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Wi[n])}function Wq(n){if(!ue().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Uq(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??Wq(n);return t.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete Wi[n]},!1),ue().getBool("SOFTWARE_WEBGL_ENABLED")&&(Rh.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",Rh)||t.getContext("experimental-webgl",Rh):t.getContext("webgl2",Rh)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ku;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(ku||(ku={}));var Gs;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(Gs||(Gs={}));var Mn;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Mn||(Mn={}));function Kc(n,e){return[e,n]}function Gq(n,e){return n*e}function Dh(n){const e=pe(n),t=Math.ceil(e/4);return pg(t)}function kl(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function Hq(n,e){const[t,s]=kl(n,e);return t*s*4}function N0(n,e){const t=n;let s,r,o,i,a,l,u,c,h,d;return ue().getNumber("WEBGL_VERSION")===2?(s=t.R32F,r=t.R16F,o=t.RGBA16F,i=t.RGBA32F,a=t.RED,u=4,c=1,h=t.HALF_FLOAT,d=t.FLOAT,l=t.RGBA8):(s=n.RGBA,r=n.RGBA,o=n.RGBA,i=t.RGBA,a=n.RGBA,u=4,c=4,h=e!=null?e.HALF_FLOAT_OES:null,d=n.FLOAT,l=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function He(n,e){const t=e();return ue().getBool("DEBUG")&&jq(n),t}function jq(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+Yq(n,e))}const Kq=596e-10,qq=65504;function Xq(n){return!!(ue().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||Kq<Math.abs(n)&&Math.abs(n)<qq)}function Yq(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Oh(n,e){return Eo(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function Zq(n,e){const t=Eo(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(He(n,()=>n.shaderSource(t,e)),He(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function Jq(n,e){const t=Eo(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(He(n,()=>n.shaderSource(t,e)),He(n,()=>n.compileShader(t)),ue().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw vT(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const Qq=/ERROR: [0-9]+:([0-9]+):/g;function vT(n,e){const t=Qq.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],r=n.split(`
`),o=r.length.toString().length+2,i=r.map((h,d)=>za((d+1).toString(),o)+h);let a=0;for(let h=0;h<i.length;h++)a=Math.max(i[h].length,a);const l=i.slice(0,s-1),u=i.slice(s-1,s),c=i.slice(s);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${za(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function e6(n){return Eo(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function t6(n,e){if(He(n,()=>n.linkProgram(e)),!ue().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Zm(n,e){if(He(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function n6(n,e){const t=Eo(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return He(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),He(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function s6(n,e){const t=Eo(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return He(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),He(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function r6(n){return Eo(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function o6(n,e){const t=ue().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,r=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function i6(n){return Eo(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function e1(n,e,t,s,r,o,i){const a=n.getAttribLocation(e,t);return a===-1?!1:(He(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),He(n,()=>n.vertexAttribPointer(a,r,n.FLOAT,!1,o,i)),He(n,()=>n.enableVertexAttribArray(a)),!0)}function a6(n,e,t){d6(n,t),He(n,()=>n.activeTexture(n.TEXTURE0+t)),He(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function l6(n,e,t){return Eo(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function u6(n,e,t){return n.getUniformLocation(e,t)}function c6(n,e,t,s){He(n,()=>a6(n,e,s)),He(n,()=>n.uniform1i(t,s))}function Jm(n,e,t){He(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),He(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function t1(n,e){He(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),He(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Fh(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+h6(n,e))}function h6(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Eo(n,e,t){const s=He(n,()=>e());if(s==null)throw new Error(t);return s}function d6(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const r=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${r}.`)}}function al(n,e=2){return pe(n.slice(0,n.length-e))}function ll(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Lh(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[al(n),...ll(n)]),e}function p6(n,e=!1){let t=ue().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=ue().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&ue().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=t/2),e&&(t=t*2,s=s*2,n=n.map((a,l)=>l>=n.length-2?Ty(n[l]):n[l]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=di(n).newShape);let r=pe(n),o=null;n.length<=1&&r<=t?o=[1,r]:n.length===2&&n[0]<=t&&n[1]<=t?o=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?o=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?o=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?o=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(o=[n[0],n[1]*n[2]*n[3]]);const i=o!=null&&Math.max(...o)>s&&Math.min(...o)<=(e?2:1)&&Math.min(...o)>0;if(o==null||i)if(e){const a=al(n);let l=2,u=2;n.length&&([l,u]=ll(n)),r=a*(l/2)*(u/2),o=pg(r).map(c=>c*2)}else o=pg(r);return o}function Ph(n){return n%2===0}function Ad(n,e){if(n=n.slice(-2),e=e.slice(-2),Tt(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],s=e[e.length-1];if(t===s||Ph(t)&&Ph(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&Ph(n[0])&&Ph(e[0])}let Qm,eg;function f6(n){if(Qm==null){const e=Nr(n);Qm=e.getParameter(e.MAX_TEXTURE_SIZE)}return Qm}function m6(n){if(eg==null){const e=Nr(n);eg=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,eg)}function g6(n){if(n===0)return 0;let e;const t=Nr(n);return or(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:or(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function or(n,e){return n.getExtension(e)!=null}function n1(n){try{if(Nr(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function y6(n){if(n===0)return!1;const e=Nr(n);if(n===1){if(!or(e,"OES_texture_float"))return!1}else if(!or(e,"EXT_color_buffer_float"))return!1;return ay(e)}function b6(n){if(n===0)return!1;const e=Nr(n);if(n===1){if(!or(e,"OES_texture_float")||!or(e,"WEBGL_color_buffer_float"))return!1}else{if(or(e,"EXT_color_buffer_float"))return ay(e);const s="EXT_color_buffer_half_float";if(or(e,s)){const r=e.getExtension(s);return x6(e,r)}return!1}return ay(e)}function ay(n){const e=N0(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(o),i}function x6(n,e){const t=N0(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(i),a}function w6(n){return n!==2?!1:Nr(n).fenceSync!=null}function qc(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&A(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tt=ue();tt.registerFlag("HAS_WEBGL",()=>tt.getNumber("WEBGL_VERSION")>0);tt.registerFlag("WEBGL_VERSION",()=>n1(2)?2:n1(1)?1:0);tt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);tt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>tt.get("WEBGL_VERSION")===2);tt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);tt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);tt.registerFlag("WEBGL_PACK",()=>tt.getBool("HAS_WEBGL"));tt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>tt.getBool("WEBGL_PACK"));tt.registerFlag("WEBGL_PACK_CLIP",()=>tt.getBool("WEBGL_PACK"));tt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>tt.getBool("WEBGL_PACK"));tt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>tt.getBool("WEBGL_PACK"));tt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>tt.getBool("WEBGL_PACK"));tt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>tt.getBool("WEBGL_PACK"));tt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>tt.getBool("WEBGL_PACK"));tt.registerFlag("WEBGL_PACK_REDUCE",()=>tt.getBool("WEBGL_PACK"));tt.registerFlag("WEBGL_LAZILY_UNPACK",()=>tt.getBool("WEBGL_PACK"));tt.registerFlag("WEBGL_CONV_IM2COL",()=>tt.getBool("WEBGL_PACK"));tt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>tt.getBool("WEBGL_PACK"));tt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>f6(tt.getNumber("WEBGL_VERSION")));tt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>m6(tt.getNumber("WEBGL_VERSION")));tt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=tt.getNumber("WEBGL_VERSION");return n===0?0:g6(n)});tt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>tt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Nk());tt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>y6(tt.getNumber("WEBGL_VERSION")));tt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>tt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:tt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));tt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>b6(tt.getNumber("WEBGL_VERSION")));tt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>w6(tt.getNumber("WEBGL_VERSION")));tt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>tt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);tt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});tt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Nk()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});tt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);tt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);tt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);tt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);tt.registerFlag("WEBGL_EXP_CONV",()=>!1);tt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>tt.getBool("IS_TEST"));tt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);tt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);tt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);tt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ps(){let n,e,t,s,r,o,i,a,l,u;return ue().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",r="texture",o="outputColor",i="out vec4 outputColor;",a=ue().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",r="texture2D",o="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:r,output:o,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:l,defineRound:u}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ya(n,e,t="index"){const s=rt(e);return s.map((r,o)=>{const i=`int ${n[o]} = ${t} / ${r}`,a=o===s.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${r}`:`index -= ${n[o]} * ${r}`;return`${i}; ${a};`}).join("")}function Pf(n,e,t="index"){const s=rt(e);return s.map((r,o)=>{const i=`int ${n[o]} = ${t} / outShapeStrides[${o}]`,a=o===s.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * outShapeStrides[${o}]`:`index -= ${n[o]} * outShapeStrides[${o}]`;return`${i}; ${a};`}).join("")}function v6(n,e){const t=n.length,s=n.map(o=>`${e}[${o}]`),r=new Array(t-1);r[t-2]=s[t-1];for(let o=t-3;o>=0;--o)r[o]=`(${r[o+1]} * ${s[o+1]})`;return r}function k6(n,e,t="index"){const s=n.map((o,i)=>i),r=v6(s,e);return r.map((o,i)=>{const a=`int ${n[i]} = ${t} / ${r[i]}`,l=i===r.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${r[i]}`:`index -= ${n[i]} * ${r[i]}`;return`${a}; ${l};`}).join("")}function T0(n){const e=rt(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function E0(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const kT=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:CT}=z3;function C6(n,e,t){const s=[];if(n.forEach(p=>{const f=pe(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?s.push(`uniform float ${p.name}${f>1?`[${f}]`:""};`):(s.push(`uniform sampler2D ${p.name};`),s.push(`uniform int offset${p.name};`)),t.enableShapeUniforms){const{uniformShape:g}=_0(t.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(g.length){case 1:s.push(`uniform int ${p.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${p.name}Shape;`);break}s.push(`uniform ivec2 ${p.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(p=>{s.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const r=s.join(`
`),o=n.map(p=>S6(p,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),i=e.texShape,a=ps(),l=N6(a);let u,c,h=_6(a);return e.isPacked?(u=I6(e.logicalShape,i,t.enableShapeUniforms),c=E6(a)):(u=$6(e.logicalShape,i,t.enableShapeUniforms),c=T6(a)),t.packedInputs&&(h+=O6),[h,l,c,r,u,o,t.userCode].join(`
`)}function Cl(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return j6(n,e);case 1:return q6(n,e);case 2:return Y6(n,e);case 3:return J6(n,e);case 4:return eX(n,e);case 5:return tX(n);case 6:return nX(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function ST(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return H6(n);case 1:return K6(n,e);case 2:return X6(n,e);case 3:return Z6(n,e);default:return Q6(n,e)}}function S6(n,e,t=!1,s){let r="";t?r+=ST(n,s):r+=Cl(n,s);const o=n.shapeInfo.logicalShape,i=e.logicalShape;return o.length<=i.length&&(t?r+=sX(n,e):r+=rX(n,e)),r}function I6(n,e,t){switch(n.length){case 0:return IT();case 1:return F6(n,e,t);case 2:return U6(n,e,t);case 3:return P6(n,e,t);default:return M6(n,e,t)}}function $6(n,e,t){switch(n.length){case 0:return IT();case 1:return L6(n,e,t);case 2:return G6(n,e,t);case 3:return z6(n,e,t);case 4:return B6(n,e,t);case 5:return V6(n,e);case 6:return W6(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function N6(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function T6(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function E6(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function _6(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${A6}
    ${R6}
    ${D6}
  `}const A6=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,R6=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,D6=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,O6=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function IT(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function F6(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function L6(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function P6(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[2]/2),o=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function z6(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Pf(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=ya(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function M6(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[n.length-1]/2),o=r*Math.ceil(n[n.length-2]/2);let i=o,a="",l="b, r, c";for(let u=2;u<n.length-1;u++)i*=n[n.length-u-1],a=`
      int b${u} = index / ${i};
      index -= b${u} * ${i};
    `+a,l=`b${u}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${a}

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${l});
    }
  `}function B6(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Pf(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=ya(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function V6(n,e){const t=ya(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function W6(n,e){const t=ya(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function U6(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Tt(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function G6(n,e,t){return Tt(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function ba(n){return`offset${n}`}function H6(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=ps();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function j6(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[r,o]=n.shapeInfo.texShape;if(r===1&&o===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const i=ba(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${i});
      return sampleTexture(${t}, uv);
    }
  `;const[a,l]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${i});
      return sampleTexture(${t}, uv);
    }
  `}function K6(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n.shapeInfo.texShape,o=ps();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${o.texture2D}(${t}, uv);
    }
  `;const i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${o.texture2D}(${t}, uv);
    }
  `}function q6(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${Sl(n)}
      }
    `;const r=n.shapeInfo.texShape,o=r[0],i=r[1];if(i===1&&o===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=ba(t);return i===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${o}.0);
        return sampleTexture(${t}, uv);
      }
    `:o===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${o}, ${i}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function X6(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n.shapeInfo.texShape,i=o[0],a=o[1],l=ps();if(o!=null&&Tt(t,o))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function Y6(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n.shapeInfo.texShape;if(o!=null&&Tt(t,o)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const d=o[0],p=o[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:i,keptDims:a}=di(t),l=i;if(l.length<t.length){const d=Il(n,l),p=["row","col"];return`
      ${Cl(d,e)}
      float ${r}(int row, int col) {
        return ${r}(${$l(p,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Sl(n)}
      }
    `;const u=o[0],c=o[1],h=ba(s);return c===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${s}, uv);
    }
  `:u===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${h};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${s}, uv);
  }
`}function Z6(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(t[0]===1){const d=t.slice(1),p=[1,2],f=Il(n,d),g=["b","row","col"];return`
        ${ST(f,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${$l(g,p)});
        }
      `}const a=ps();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `;const l=i[0],u=i[1],c=Math.ceil(t[2]/2),h=c*Math.ceil(t[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${h}, ${c}, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `}function J6(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=t[1]*t[2],i=t[2],{newShape:a,keptDims:l}=di(t),u=a;if(u.length<t.length){const g=Il(n,u),y=["row","col","depth"];return`
        ${Cl(g,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${$l(y,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${o}, ${i}, 1)));
        ${Sl(n)}
      }
    `;const c=n.shapeInfo.texShape,h=c[0],d=c[1],p=n.shapeInfo.flatOffset;if(d===o&&p==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${h}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(d===i&&p==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `;const f=ba(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o} + col * ${i} + depth + ${f};
        vec2 uv = uvFromFlat(${h}, ${d}, index);
        return sampleTexture(${s}, uv);
      }
  `}function Q6(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=ps();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);
    }
  `;const o=n.shapeInfo.logicalShape,i=o.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=l[0],c=l[1],h=Math.ceil(o[i-1]/2);let d=h*Math.ceil(o[i-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let g=2;g<i-1;g++)p=`int b${g}, `+p,d*=o[i-g-1],f=`b${g} * ${d} + `+f;return`
    vec4 ${s}(${p}) {
      int index = ${f};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${r.texture2D}(${t}, uv);
    }
  `}function eX(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=t[3],i=t[2]*o,a=t[1]*i,{newShape:l,keptDims:u}=di(t);if(l.length<t.length){const w=Il(n,l),C=["row","col","depth","depth2"];return`
      ${Cl(w,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${$l(C,u)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${o}, 1)));
        ${Sl(n)}
      }
    `;const c=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],p=h[1],f=`int stride2 = ${s}Shape[3];`,g=`int stride1 = ${s}Shape[2] * stride2;`,y=`int stride0 = ${s}Shape[1] * stride1;`;if(p===a&&c==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${f}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(p===o&&c==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;const b=ba(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${g}
      ${y}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${b});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${o} + depth2;
      vec2 uv = uvFromFlat(${d}, ${p}, index + ${b});
      return sampleTexture(${s}, uv);
    }
  `}function tX(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e[4],o=e[3]*r,i=e[2]*o,a=e[1]*i,{newShape:l,keptDims:u}=di(e);if(l.length<e.length){const g=Il(n,l),y=["row","col","depth","depth2","depth3"];return`
      ${Cl(g)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${$l(y,u)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${o}, ${r})) +
          depth3;
        ${Sl(n)}
      }
    `;const c=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],p=h[1];if(p===a&&c==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${o}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(p===r&&c==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;const f=ba(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${o} +
          depth2 * ${r} + depth3 + ${f};
      vec2 uv = uvFromFlat(${d}, ${p}, index);
      return sampleTexture(${t}, uv);
    }
  `}function nX(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:r,keptDims:o}=di(e);if(r.length<e.length){const y=Il(n,r),b=["row","col","depth","depth2","depth3","depth4"];return`
      ${Cl(y)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${$l(b,o)});
      }
    `}const i=e[5],a=e[4]*i,l=e[3]*a,u=e[2]*l,c=e[1]*u;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Sl(n)}
      }
    `;const h=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,p=d[0],f=d[1];if(f===c&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===i&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;const g=ba(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${g};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Sl(n){const e=n.name,t=pe(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function sX(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",o=n.shapeInfo.logicalShape.length,i=e.logicalShape.length,a=CT(n.shapeInfo.logicalShape,e.logicalShape),l=Vt(i),u=i-o;let c;const h=["x","y","z","w","u","v"];o===0?c="":i<2&&a.length>=1?c="coords = 0;":c=a.map(w=>`coords.${h[w+u]} = 0;`).join(`
`);let d="";i<2&&o>0?d="coords":d=n.shapeInfo.logicalShape.map((w,C)=>`coords.${h[C+u]}`).join(", ");let p="return outputValue;";const g=pe(n.shapeInfo.logicalShape)===1,b=pe(e.logicalShape)===1;if(o===1&&!g&&!b)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(g&&!b)i===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(a.length){const w=o-2,C=o-1;a.indexOf(w)>-1&&a.indexOf(C)>-1?p="return vec4(outputValue.x);":a.indexOf(w)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(C)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${s}(${d});
      ${p}
    }
  `}function rX(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",o=e.texShape,i=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&n.shapeInfo.flatOffset==null&&Tt(i,o))return`
      float ${r}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const u=Vt(l),c=CT(n.shapeInfo.logicalShape,e.logicalShape),h=l-a;let d;const p=["x","y","z","w","u","v"];a===0?d="":l<2&&c.length>=1?d="coords = 0;":d=c.map(g=>`coords.${p[g+h]} = 0;`).join(`
`);let f="";return l<2&&a>0?f="coords":f=n.shapeInfo.logicalShape.map((g,y)=>`coords.${p[y+h]}`).join(", "),`
    float ${r}() {
      ${u} coords = getOutputCoords();
      ${d}
      return get${s}(${f});
    }
  `}function Vt(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function _0(n,e,t){const{newShape:s,keptDims:r}=di(e),o=e.length,i=n&&o===3&&e[0]===1,a=i?e.slice(1):s,l=!n&&o>1&&!Tt(e,t)&&s.length<o||i;return{useSqueezeShape:l,uniformShape:l?a:e,keptDims:r}}function Il(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function $l(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oX(n,e,t,s){const r=t.map((c,h)=>{const d={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(d.flatOffset=c.texData.slice.flatOffset),{name:e.variableNames[h],shapeInfo:d}}),o=r.map(c=>c.shapeInfo),i={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},a=C6(r,i,e),l=Jq(n.gl,a),u=n.createProgram(l);return ue().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:o,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(u),Object.assign({program:e,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:o,outShapeInfo:i},$T(n,e,u)))}function $T(n,e,t){const s=[],r=[];let o,i,a,l=null,u=null;u=n.getUniformLocation(t,"NAN",!1),ue().getNumber("WEBGL_VERSION")===1&&(l=n.getUniformLocation(t,"INFINITY",!1));const c=!1;for(const h of e.variableNames){const d={name:h,uniform:n.getUniformLocation(t,h,c),offset:n.getUniformLocation(t,`offset${h}`,c)};e.enableShapeUniforms&&(d.shape=n.getUniformLocation(t,`${h}Shape`,c),d.texShape=n.getUniformLocation(t,`${h}TexShape`,c)),s.push(d)}if(e.enableShapeUniforms&&(o=n.getUniformLocation(t,"outShape",c),a=n.getUniformLocation(t,"outShapeStrides",c),i=n.getUniformLocation(t,"outTexShape",c)),e.customUniforms)for(const h of e.customUniforms)r.push(n.getUniformLocation(t,h.name,c));return{variablesLocations:s,customUniformLocations:r,infLoc:l,nanLoc:u,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:i}}function s1(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const r=t.logicalShape,o=e[s],i=o.shape;if(!Tt(r,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);if(t.isUniform&&o.isUniform)return;const a=t.texShape,l=o.isUniform?null:o.texData.texShape;if(!Tt(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function iX(n,e,t,s,r){e.program.enableShapeUniforms||(s1(e.inShapeInfos,t),s1([e.outShapeInfo],[s]));const o=s.texData.texture,i=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(o.texture,i[0],i[1]):n.setOutputMatrixTexture(o.texture,i[0],i[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),ue().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<t.length;++l){const u=t[l],{uniform:c,offset:h,shape:d,texShape:p}=e.variablesLocations[l];if(d){const{uniformShape:f}=_0(e.program.packedInputs,u.shape,u.texData.texShape);switch(f.length){case 1:n.gl.uniform1iv(d,new Int32Array(f));break;case 2:n.gl.uniform2iv(d,new Int32Array(f));break;case 3:n.gl.uniform3iv(d,new Int32Array(f));break;case 4:n.gl.uniform4iv(d,new Int32Array(f));break}}if(p&&n.gl.uniform2i(p,u.texData.texShape[0],u.texData.texShape[1]),c!=null){if(u.isUniform){if(pe(u.shape)<2)n.gl.uniform1f(c,u.uniformValues[0]);else{let f=u.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),n.gl.uniform1fv(c,f)}continue}u.texData.slice!=null&&h!=null&&n.gl.uniform1i(h,u.texData.slice.flatOffset),n.setInputMatrixTexture(u.texData.texture.texture,c,l)}}const a=e.outShapeLocation;if(a)switch(s.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const l=rt(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r)for(let l=0;l<e.program.customUniforms.length;++l){const u=e.program.customUniforms[l],c=e.customUniformLocations[l],h=r[l];if(u.type==="float")n.gl.uniform1fv(c,h);else if(u.type==="vec2")n.gl.uniform2fv(c,h);else if(u.type==="vec3")n.gl.uniform3fv(c,h);else if(u.type==="vec4")n.gl.uniform4fv(c,h);else if(u.type==="int")n.gl.uniform1iv(c,h);else if(u.type==="ivec2")n.gl.uniform2iv(c,h);else if(u.type==="ivec3")n.gl.uniform3iv(c,h);else if(u.type==="ivec4")n.gl.uniform4iv(c,h);else throw Error(`uniform type ${u.type} is not supported yet.`)}n.executeProgram()}function aX(n,e,t){let s="";e.concat(t).forEach(i=>{const a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!i.isUniform){const l=i.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:h}=_0(n.packedInputs,i.shape,l);let d="",p="",f="";if(c.length===1&&n.packedInputs){const I=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];d=`${I[0]>1}_${I[1]>1}`}else if(c.length===2&&!n.packedInputs)p=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!n.packedInputs){const I=rt(c);f=`${I[0]===l[1]}_${I[I.length-1]===l[1]}`}const g=i.shape.length,y=c.length===2&&Tt(i.shape,l),b=pe(i.shape)===1,w=el(i.shape,t.shape),C=!n.packedInputs&&g===t.shape.length&&Tt(l,t.texData.texShape),v=n.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;s+=`${g}_${C}_${u?h:""}_${c.length}_${b}_${w}_${y}_${d}_${p}_${f}_${v}_${a}`}else{const l=i.isUniform?"uniform":i.texData.texShape;s+=`${i.shape}_${l}_${a}`}});const r=n.userCode;let o=n.constructor.name;return o+="_"+s+"_"+r+`${ue().getNumber("WEBGL_VERSION")}`,o}function Jn(n){return ue().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lX{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=ku.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=ps();this.outputShape=e,this.enableShapeUniforms=Jn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Pf(["r","c","d"],e):ya(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uX{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=ku.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=ps();this.outputShape=e,this.enableShapeUniforms=Jn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Pf(["r","c","d"],e):ya(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cX{constructor(e){this.variableNames=["A"],this.outTexUsage=Gs.DOWNLOAD;const t=ps();this.outputShape=e,this.userCode=`
      ${kT}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hX{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Gs.DOWNLOAD;const t=ps();this.outputShape=e,this.userCode=`
      ${kT}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dX={R:0,G:1,B:2,A:3};class r1{constructor(e,t=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=ps();this.outputShape=e,this.enableShapeUniforms=Jn(this.outputShape.length);let o="result";t&&(o="floor(result * 255. + 0.5)");let i="";for(let a=0;a<s.length;a++){const l=s[a];i+=`
          if(offset == ${a}) {
            result = values[${dX[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?E0():T0(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${i}
        }
        ${r.output} = vec4(${o}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pX{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=ps();this.outputShape=e,this.enableShapeUniforms=Jn(this.outputShape.length);let r="",o="result";t&&(o="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){const l=i*2+a;r+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?E0():T0(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${o};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fX(n){const e=ps(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return Zq(n,t)}function mX(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return n6(n,e)}function gX(n){const e=new Uint16Array([0,1,2,2,1,3]);return s6(n,e)}function Xc(n,e,t,s,r,o){o6(e,t);const i=r6(n),a=n.TEXTURE_2D;return He(n,()=>n.bindTexture(a,i)),He(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),He(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),He(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),He(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),ue().getNumber("WEBGL_VERSION")===1?He(n,()=>n.texImage2D(a,0,s,e,t,0,r,o,null)):He(n,()=>n.texStorage2D(a,1,s,e,t)),He(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:i,texShape:[t,e]}}function NT(n){return n.internalFormatFloat}function yX(n,e,t,s){const[r,o]=Kc(e,t);return Xc(n,r,o,NT(s),s.textureFormatFloat,n.FLOAT)}function TT(n){return n.internalFormatHalfFloat}function bX(n,e,t,s){const[r,o]=Kc(e,t);return Xc(n,r,o,TT(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function ET(n){return n.downloadTextureFormat}function xX(n,e,t,s){const[r,o]=Kc(e,t);return Xc(n,r,o,ET(s),n.RGBA,n.UNSIGNED_BYTE)}function _T(n){return n.internalFormatPackedFloat}function wX(n,e,t,s){const[r,o]=kl(e,t);return Xc(n,r,o,_T(s),n.RGBA,n.FLOAT)}function AT(n){return n.internalFormatPackedHalfFloat}function vX(n,e,t,s){const[r,o]=kl(e,t);return Xc(n,r,o,AT(s),n.RGBA,s.textureTypeHalfFloat)}function kX(n,e,t){return He(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),e1(n,e,"clipSpacePos",t,3,20,0)&&e1(n,e,"uv",t,2,20,12)}function CX(n,e,t,s,r,o){He(n,()=>n.bindTexture(n.TEXTURE_2D,e));let i,a,l;r instanceof Uint8Array?(i=new Uint8Array(t*s*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(i=new Float32Array(t*s*4),a=n.FLOAT,l=o.internalFormatPackedFloat),i.set(r),ue().getNumber("WEBGL_VERSION")===2?He(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,a,i)):He(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,t,s,0,n.RGBA,a,i)),He(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function SX(n,e,t){He(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?ue().getNumber("WEBGL_VERSION")===2?He(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):He(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):ue().getNumber("WEBGL_VERSION")===2?He(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):He(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),He(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function IX(n,e,t,s){const r=n.createBuffer();He(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const a=4*4*e*t;return He(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),He(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),He(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function $X(n,e,t){const s=n,r=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function NX(n,e,t,s){const[r,o]=Kc(e,t),i=4,a=new Uint8Array(Gq(e*t,i));return He(n,()=>n.readPixels(0,0,r,o,s.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function TX(n,e,t,s,r,o,i,a){const l=n,u=new Float32Array(Hq(o,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function EX(n,e,t){const s=new Float32Array(e*t*4);return He(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tg{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=ue().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,Vq(t,e)):this.gl=Nr(t),e=this.gl,ue().getNumber("WEBGL_VERSION")===2){const o=e;this.createVertexArray=()=>He(o,()=>o.createVertexArray()),this.bindVertexArray=i=>He(o,()=>o.bindVertexArray(i)),this.deleteVertexArray=i=>He(o,()=>o.deleteVertexArray(i)),this.getVertexArray=()=>He(o,()=>o.getParameter(o.VERTEX_ARRAY_BINDING))}else if(e!=null){const o=e.getExtension("OES_vertex_array_object");if(o==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>He(e,()=>o.createVertexArrayOES()),this.bindVertexArray=i=>He(e,()=>o.bindVertexArrayOES(i)),this.deleteVertexArray=i=>He(e,()=>o.deleteVertexArrayOES(i)),this.getVertexArray=()=>He(e,()=>e.getParameter(o.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),ue().getNumber("WEBGL_VERSION")===1){const o="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=Oh(this.gl,o),or(this.gl,i))this.textureHalfFloatExtension=Oh(this.gl,i);else if(ue().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),or(this.gl,r))this.colorBufferHalfFloatExtension=Oh(this.gl,r);else if(ue().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",or(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(or(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=mX(this.gl),this.indexBuffer=gX(this.gl),this.framebuffer=i6(this.gl),this.textureConfig=N0(this.gl,this.textureHalfFloatExtension)}get debug(){return ue().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;He(e,()=>e.finish()),He(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),He(e,()=>e.deleteFramebuffer(this.framebuffer)),He(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),He(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),He(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),yX(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),bX(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),xX(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),SX(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,r){this.throwIfDisposed(),CX(this.gl,e,t,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),vX(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),wX(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(t1(this.gl,this.framebuffer),this.outputTexture=null),He(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>NX(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,r,o,i){return TX(this.gl,e,t,s,r,o,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return $X(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const r=IX(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(ue().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,o=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const i=r.clientWaitSync(o,0,0);return i===r.ALREADY_SIGNALED||i===r.CONDITION_SATISFIED},t=o}else ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>EX(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=fX(t));const s=e6(t);He(t,()=>t.attachShader(s,this.vertexShader)),He(t,()=>t.attachShader(s,e)),t6(t,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&Zm(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;He(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),kX(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(He(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Zm(this.gl,this.program),He(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?l6(this.gl,e,t):u6(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),He(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),c6(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[r,o]=kl(t,s);this.setOutputMatrixTextureDriver(e,r,o)}setOutputMatrixWriteRegion(e,t,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Zm(this.gl,this.program),Fh(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}He(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),He(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Oh(this.gl,ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,o),o}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Ow(()=>this.disposed||this.isQueryAvailable(e,ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=_X(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in ue().platform&&(s=ue().platform.setTimeoutCustom.bind(ue().platform)),Ow(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Jm(this.gl,e,this.framebuffer),this.debug&&Fh(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Jm(this.gl,this.outputTexture,this.framebuffer),this.debug&&Fh(this.gl)):t1(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const r=this.gl;Jm(r,e,this.framebuffer),this.debug&&Fh(r),this.outputTexture=e,He(r,()=>r.viewport(0,0,t,s)),He(r,()=>r.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,r){this.throwIfDisposed(),He(this.gl,()=>this.gl.scissor(e,t,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function _X(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:AX,bincountImpl:RT,bincountReduceImpl:RX,bitwiseAndImpl:DX,castImpl:OX,ceilImpl:FX,concatImpl:LX,equalImpl:PX,expImpl:zX,expm1Impl:MX,floorImpl:BX,gatherNdImpl:VX,gatherV2Impl:WX,greaterImpl:UX,greaterEqualImpl:GX,lessImpl:HX,lessEqualImpl:jX,linSpaceImpl:KX,logImpl:qX,maxImpl:XX,maximumImpl:YX,minimumImpl:ZX,multiplyImpl:JX,negImpl:QX,notEqualImpl:e5,prodImpl:t5,raggedGatherImpl:n5,raggedRangeImpl:s5,raggedTensorToTensorImpl:r5,rangeImpl:o5,rsqrtImpl:i5,scatterImpl:a5,sigmoidImpl:l5,simpleAbsImpl:DT,sliceImpl:u5,sparseFillEmptyRowsImpl:c5,sparseReshapeImpl:h5,sparseSegmentReductionImpl:OT,sqrtImpl:d5,staticRegexReplaceImpl:p5,stridedSliceImpl:f5,stringNGramsImpl:m5,stringSplitImpl:g5,stringToHashBucketFastImpl:y5,subImpl:b5,tileImpl:x5,topKImpl:w5,transposeImpl:A0,uniqueImpl:v5}=SU;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FT(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function as(n,e){return e===1?[n]:FT(n,e)}function k5(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class C5{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Jn(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=as("rc",this.rank),s=Vt(this.rank),r=this.getOutOfBoundsCondition(t),o=this.getSetup(t),i=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${o}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let o=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)o=`${e[e.length-1-i]},`+o;t.push(o)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LT{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Jn(this.outputShape.length);let s="";for(let r=0;r<4;r++){let o="thisRC = rc;";r%2===1&&(o+="thisRC.z += 1;"),r>1&&(o+="thisRC.y += 1;"),s+=`
        ${o}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${S5(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?E0():T0(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function S5(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?k6(["r","c","d"],"inputShape"):ya(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class I5{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,s){const r=i1(t,s),o=a1(e,r,s);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const i=o1(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const l=this.freeTextures[o].pop();return this.usedTextures[o].push(l),l}let a;return r===Mn.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===Mn.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===Mn.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===Mn.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===Mn.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(e,t,s,r){if(this.freeTextures==null)return;const o=i1(s,r),i=a1(t,o,r);i in this.freeTextures||(this.freeTextures[i]=[]);const a=o1(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=ue().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const u=this.usedTextures[i],c=u&&u.indexOf(e);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function $5(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function o1(n,e,t,s,r){const o=N5(e,s);let i;if(r){const[l,u]=kl(n[0],n[1]);i=l*u}else{const[l,u]=Kc(n[0],n[1]);i=l*u}const a=$5(t,o);return i*a}function N5(n,e){switch(n){case Mn.PACKED_2X2_FLOAT32:return _T(e);case Mn.PACKED_2X2_FLOAT16:return AT(e);case Mn.UNPACKED_FLOAT32:return NT(e);case Mn.UNPACKED_FLOAT16:return TT(e);case Mn.PACKED_4X1_UNSIGNED_BYTE:return ET(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function T5(n){return ue().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Mn.PACKED_2X2_FLOAT32:Mn.UNPACKED_FLOAT32:n?Mn.PACKED_2X2_FLOAT16:Mn.UNPACKED_FLOAT16}function i1(n,e){if(n===Gs.UPLOAD)return Mn.PACKED_2X2_FLOAT32;if(n===Gs.RENDER||n==null)return T5(e);if(n===Gs.DOWNLOAD||n===Gs.PIXELS)return Mn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function a1(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vr{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Jn(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const mr="if (isnan(x)) return x;",E5="return x;",l1="return abs(x);",_5="return (x >= 0.0) ? x : (exp(x) - 1.0);",A5=mr+`
  return (x < 0.0) ? 0.0 : x;
`,R5=mr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Vo="return x;",D5="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O5="return x;",F5=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,L5=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,P5=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,z5="return 1.0 / (1.0 + exp(-1.0 * x));";class qo{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Jn(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class M5{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Jn(this.outputShape.length);const t=e.length,s=as("rc",t),r=Vt(t),o=k5(t,s),i=s.slice(-2),a=t<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${o});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B5=fx,V5=1e-7,W5=1e-4,zh={};function U5(n){return n in zh||(zh[n]={}),zh[n]}const G5=ue().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),H5=600;function j5(){return ue().global.screen==null?1024:ue().global.screen.height*ue().global.screen.width*window.devicePixelRatio*H5/1024/1024}class zf extends Ny{nextDataId(){return zf.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ue().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof tg)t=e;else{const s=Nr(ue().getNumber("WEBGL_VERSION"),e);t=new tg(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Nr(ue().getNumber("WEBGL_VERSION"));t=new tg(s),this.binaryCache=U5(ue().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new I5(this.gpgpu),this.numMBBeforeWarning=j5(),this.texData=new ak(this,Dr())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,r,o,i){const a=this.makeTensorInfo(t,s),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[r,o]},l.texShape=[r,o];const u=Lh(t),c=new r1(u,!1,i),h=this.runWebGLProgram(c,[a],s,[[r,o]]);return h.shape=t,l.texture=null,this.disposeIntermediateTensorInfo(a),h.dataId}write(e,t,s){if((ue().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ue().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:s,values:e,usage:Gs.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,r,o){if(ue().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:t,usage:Gs.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:o,slice:i,shape:a,isPacked:l}=t;if(i!=null){let d;l?d=new qo(a,Vo):d=new Vr(a,Vo);const p=this.runWebGLProgram(d,[{dataId:e,shape:a,dtype:r}],r),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const u=this.activeTimers!=null;let c;u&&(c=bs());let h;if(r==="complex64"){const d=this.readSync(o.real.dataId),p=this.readSync(o.imag.dataId);h=wo(d,p)}else h=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=bs()-c),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const f=this.pendingRead.get(e);return new Promise(g=>f.push(g))}const t=this.texData.get(e),{values:s,shape:r,slice:o,dtype:i,complexTensorInfos:a,isPacked:l}=t;if(o!=null){let f;l?f=new qo(r,Vo):f=new Vr(r,Vo);const g=this.runWebGLProgram(f,[{dataId:e,shape:r,dtype:i}],i),y=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),y}if(s!=null)return this.convertAndCacheOnCPU(e);if(ue().getBool("DEBUG")&&!ue().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&ue().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(i!=="complex64"&&ue().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const f=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(f.texture.texture,...Dh(r))}this.pendingRead.set(e,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(i==="complex64"){const f=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),g=f[0],y=f[1];h=wo(g,y)}else if(u==null)h=this.getValuesFromTexture(e);else{const f=pe(r);h=this.gpgpu.downloadFloat32MatrixFromBuffer(u,f)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){const f=this.gpgpu.gl;He(f,()=>f.deleteBuffer(u))}const d=this.convertAndCacheOnCPU(e,h),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(f=>f(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Dr().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,t={}){const s=this.texData.get(e),{values:r,shape:o,slice:i,dtype:a,isPacked:l,texture:u}=s;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let p;l?p=new qo(o,Vo):p=new Vr(o,Vo);const f=this.runWebGLProgram(p,[{dataId:e,shape:o,dtype:a}],a),g=this.readToGPU(f,t);return this.disposeIntermediateTensorInfo(f),g}if(u==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(e,t.customTexShape),h=Dr().makeTensorFromTensorInfo(c),d=this.texData.get(c.dataId);return Object.assign({tensorRef:h},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>ei(r));return wt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return wt(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!Xq(s))throw ue().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:r}=this.texData.get(e),o=pe(t);if(ue().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const d=this.decode(e),p=this.texData.get(d.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...Dh(t)).subarray(0,o);return this.disposeIntermediateTensorInfo(d),f}const i=ue().getBool("WEBGL_PACK")&&r===!0,a=i?Lh(t):t,l=i?new hX(a):new cX(a),u=this.runWebGLProgram(l,[{shape:a,dtype:s,dataId:e}],"float32"),c=this.texData.get(u.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(u),h}timerAvailable(){return ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const o=Zi(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=Zi(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(o);a.kernelMs=a_(l),a.getExtraProfileInfo=()=>l.map((u,c)=>({name:i[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:bs(),endMs:null}}endTimer(e){return ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=bs(),e)}async getQueryTime(e){if(ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:r,usage:o,isPacked:i,slice:a}=this.texData.get(e),l=a&&a.origDataId||e,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(t,r,o,i)));const c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=G5){return ue().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&pe(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){Us("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return B5(e.shape,t)}packedUnaryOp(e,t,s){const r=new qo(e.shape,t),o=this.compileAndRun(r,[e],s);return Dr().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=DT(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(ue().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,l1,e.dtype);const t=new Vr(e.shape,l1),s=this.compileAndRun(t,[e]);return Dr().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&Au(s[0])){const o=s.map(i=>Yo(i));r=this.write(o,e,t)}else r=this.write(s,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,s){return Dr().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){const t=new M5(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new C5(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const s=[al(e.shape),...ll(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},o=[al(t),...ll(t)],i=new LT(o,s),a=!0,l=[s],u=this.runWebGLProgram(i,[r],e.dtype,l,a);return{dataId:u.dataId,shape:t,dtype:u.dtype}}decode(e,t){const s=this.texData.get(e),{isPacked:r,shape:o,dtype:i}=s;if(t!=null){const d=pe(o),p=t[0]*t[1]*4;A(d<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=Lh(o);let l;r?l=new uX(a):l=new lX(a);const u=!0,c=[t??Dh(a)],h=this.runWebGLProgram(l,[{shape:a,dtype:i,dataId:e}],i,c,u,t);return{dtype:i,shape:o,dataId:h.dataId}}runWebGLProgram(e,t,s,r,o=!1,i){const a=this.makeTensorInfo(e.outputShape,s),l=this.texData.get(a.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===ku.DENSE){const b=i??Dh(e.outputShape);l.texShape=b.map(w=>w*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),pe(a.shape)===0)return l.values=Bn(a.dtype,0),a;const u=[],c=t.map(b=>{if(b.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let w=this.texData.get(b.dataId);if(w.texture==null){if(!e.packedInputs&&pe(b.shape)<=ue().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:w.values};e.packedInputs&&(w.isPacked=!0,w.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!w.isPacked!=!!e.packedInputs)b=w.isPacked?this.unpackTensor(b):this.packTensor(b),u.push(b),w=this.texData.get(b.dataId);else if(w.isPacked&&!Ad(w.shape,b.shape)){const C=b,v=b.shape;b.shape=w.shape,b=this.packedReshape(b,v),u.push(b),w=this.texData.get(b.dataId),C.shape=v}return{shape:b.shape,texData:w,isUniform:!1}});this.uploadToGPU(a.dataId);const h={shape:a.shape,texData:l,isUniform:!1},d=aX(e,c,h),p=this.getAndSaveBinary(d,()=>oX(this.gpgpu,e,c,h)),f=this.activeTimers!=null;let g;f&&(g=this.startTimer()),ue().get("ENGINE_COMPILE_ONLY")||iX(this.gpgpu,p,c,h,r),u.forEach(b=>this.disposeIntermediateTensorInfo(b)),f&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));const y=ue().getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){const b=bs();b-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!ue().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&o===!1){const b=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),b}return a}compileAndRun(e,t,s,r,o=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,r,o)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ue().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=oe(()=>{if(!ue().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ue().getBool("DEBUG");ue().set("DEBUG",!1);const t=this.abs(it(1e-8)).dataSync()[0];if(ue().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?V5:W5}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:r,values:o,texture:i,usage:a,isPacked:l}=t;if(i!=null)return;const u=this.activeTimers!=null;let c;u&&(c=bs());let h=t.texShape;if(h==null&&(h=p6(s,l),t.texShape=h),o!=null){const d=Lh(s);let p,f=h[1],g=h[0];const y=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(l||!y)&&([f,g]=kl(h[0],h[1])),l?p=new pX(d,y):p=new r1(d,y);const b=y?[g,f]:h,w=this.makeTensorInfo(b,r),C=this.texData.get(w.dataId);y?C.usage=Gs.PIXELS:C.usage=Gs.UPLOAD,C.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(w.dataId),f,g,o);const v=[[g,f]],E=this.runWebGLProgram(p,[w],r,v,!0),R=this.texData.get(E.dataId);t.texShape=R.texShape,t.isPacked=R.isPacked,t.usage=R.usage,ue().get("ENGINE_COMPILE_ONLY")?this.disposeData(E.dataId):(t.texture=R.texture,t.values=null,this.texData.delete(E.dataId)),this.disposeIntermediateTensorInfo(w),u&&(this.uploadWaitMs+=bs()-c)}else{const d=this.acquireTexture(h,a,r,l);t.texture=d}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:r}=s;return t!=null&&(s.values=K5(t,r)),s.values}acquireTexture(e,t,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*id(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(o){throw o}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await wS(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(vT(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:s,infLoc:r,nanLoc:o,outShapeLocation:i,outShapeStridesLocation:a,outTexShapeLocation:l}=$T(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=s,e.infLoc=r,e.nanLoc=o,e.outShapeLocation=i,e.outShapeStridesLocation=a,e.outTexShapeLocation=l}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";const{texture:r,height:o,width:i,channels:a}=e,l=Dr().backend;if(!l.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=l.writeTexture(r,t,s,o,i,a);return Dr().makeTensorFromDataId(u,t,s,l)}}zf.nextDataId=0;function K5(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Tk()&&Ak("webgl",()=>new zf,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R0=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class ua{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=pt(t,s),this.enableShapeUniforms=Jn(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xa=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Nl{constructor(e,t,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=pt(t,s);const o=this.outputShape.length;this.enableShapeUniforms=Jn(o);let i="";if(r)if(o===0||pe(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${Vt(o)} coords = getOutputCoords();
        `,o===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=as("coords",o);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${l[o-2]} + 1) >= outShape[${o} - 2];
            bool nextColOutOfBounds =
              (${l[o-1]} + 1) >= outShape[${o} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${l[o-2]} + 1) >= ${this.outputShape[o-2]};
            bool nextColOutOfBounds =
              (${l[o-1]} + 1) >= ${this.outputShape[o-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zs(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const q5={kernelName:Ju,backendName:"webgl",kernelFunc:zs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ci(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,o=t.makeTensorInfo(s.shape,"complex64"),i=t.texData.get(o.dataId),a=zs({inputs:{x:s},backend:t}),l=zs({inputs:{x:r},backend:t});return i.complexTensorInfos={real:a,imag:l},o}const X5={kernelName:Py,backendName:"webgl",kernelFunc:Ci};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PT="return (a < 0.) ? b * a : a;",zT=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Y5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:o}=s,i=t.makeTensorInfo([],"float32",pi(o,"float32")),a=ue().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Nl(zT,r.shape,i.shape):new ua(PT,r.shape,i.shape),l=t.runWebGLProgram(a,[r,i],"float32");return t.disposeIntermediateTensorInfo(i),l}const Z5={kernelName:gp,backendName:"webgl",kernelFunc:Y5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MT="return (a < 0.) ? b * a : a;",BT=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function J5(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,o=ue().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Nl(BT,s.shape,r.shape):new ua(MT,s.shape,r.shape);return t.runWebGLProgram(o,[s,r],"float32")}const Q5={kernelName:Fp,backendName:"webgl",kernelFunc:J5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tl="if (isnan(x)) return x;";function Dt({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:r,backend:o})=>{const{x:i}=r,a=o,l=s||i.dtype;if(a.shouldExecuteOnCPU([i])&&t!=null){const h=a.texData.get(i.dataId),d=t(h.values,l);return a.makeTensorInfo(i.shape,l,d)}const u=ue().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let c;return u?c=new qo(i.shape,e):c=new Vr(i.shape,n),a.runWebGLProgram(c,[i],l)}}function Hn({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:o}){return({inputs:i,backend:a})=>{const{a:l,b:u}=i,c=a;if(s&&l.dtype==="complex64"){const f=c.texData.get(l.dataId),g=c.texData.get(u.dataId),[y,b]=[[f.complexTensorInfos.real,g.complexTensorInfos.real],[f.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(C=>{const[v,I]=C,E={dataId:v.dataId,dtype:v.dtype,shape:l.shape},R={dataId:I.dataId,dtype:I.dtype,shape:u.shape},L=new ua(n,l.shape,u.shape);return c.runWebGLProgram(L,[E,R],Ds(v.dtype,I.dtype))}),w=Ci({inputs:{real:y,imag:b},backend:c});return c.disposeIntermediateTensorInfo(y),c.disposeIntermediateTensorInfo(b),w}const h=o||Ds(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&r!=null){const f=c.texData.get(l.dataId).values,g=c.texData.get(u.dataId).values,y=l.dtype==="string"?vo(f):f,b=l.dtype==="string"?vo(g):g,[w,C]=r(l.shape,u.shape,y,b,h),v=c.makeTensorInfo(C,h),I=c.texData.get(v.dataId);return I.values=w,v}const d=ue().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let p;return d?p=new Nl(e,l.shape,u.shape,t):p=new ua(n,l.shape,u.shape),c.runWebGLProgram(p,[l,u],h)}}function Cu(n,e=!1){if(n==="linear")return e?O5:E5;if(n==="relu")return e?L5:A5;if(n==="elu")return e?F5:_5;if(n==="relu6")return e?P5:R5;if(n==="prelu")return e?BT:MT;if(n==="leakyrelu")return e?zT:PT;if(n==="sigmoid")return e?z5:D5;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VT{constructor(e,t,s,r=!1,o=!1,i=!1,a=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=Jn(this.outputShape.length);const c=r?e[1]:e[2],h=Math.ceil(c/2),d=r?"i * 2, rc.y":"rc.y, i * 2",p=o?"rc.z, i * 2":"i * 2, rc.z",f=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let y="",b="";a&&(l?y=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:u?y=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:y=`vec4 activation(vec4 x) {
          ${a}
        }`,b="result = activation(result);");const w=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let C="rc.x",v="rc.x";e[0]<t[0]?C=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(v=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${y}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${C};
        int batchB = ${v};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${g[0]});
          result += (${f[1]} * ${g[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${w}

        ${b}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u1={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class c1{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=pt(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h1="return a * b;";function D0(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,o=Ds(s.dtype,r.dtype);if(s.dtype==="complex64"){const a=t.texData.get(s.dataId),l=t.texData.get(r.dataId),u=new c1(u1.REAL,s.shape,r.shape),c=new c1(u1.IMAG,s.shape,r.shape),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:s.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],d=t.runWebGLProgram(u,h,"float32"),p=t.runWebGLProgram(c,h,"float32"),f=Ci({inputs:{real:d,imag:p},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),f}if(t.shouldExecuteOnCPU([s,r])){const a=t.texData.get(s.dataId),l=t.texData.get(r.dataId),[u,c]=JX(s.shape,r.shape,a.values,l.values,o),h=t.makeTensorInfo(c,o),d=t.texData.get(h.dataId);return d.values=u,h}let i;return ue().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Nl(h1,s.shape,r.shape):i=new ua(h1,s.shape,r.shape),t.runWebGLProgram(i,[s,r],o)}const e8={kernelName:ac,backendName:"webgl",kernelFunc:D0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t8(n,e,t){const s=[al(n.shape),...ll(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},o=[al(e),...ll(e)],i=new LT(o,s),a=!0,l=[s],u=t.runWebGLProgram(i,[r],n.dtype,l,a);return{dataId:u.dataId,shape:e,dtype:u.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function We(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:o}=s,i=t,a=pe(r.shape),l=lk(o,a),u=pe(l);A(a===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(r.dataId);return c.isPacked&&!Ad(r.shape,l)&&!(c.texture!==null&&Ad(c.shape,l))?t8(r,l,i):(i.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}const n8={kernelName:Pp,backendName:"webgl",kernelFunc:We};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class d1{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:o,outSize:i}=e;this.outputShape=[r,i];const a=Math.floor(s/4)*4,l=s%4;let u="sumValue += dot(values, ones);";if(t!=null){const h=1/t;u=`sumValue += dot(values * ${Za(h)?h.toPrecision(2):h}, ones);`}let c="";o%s>0&&(c=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class s8{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:o,outSize:i}=e;this.outputShape=[r,i];let a="0.0",l="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",l="min"):t==="max"&&(a="-1.0 / 1e-20",l="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?u="sumValue":t==="prod"?u="prodValue":t==="all"?u="allValue":t==="any"&&(u="anyValue");const c=Math.floor(s/4)*4,h=s%4;let d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";t==="all"?(a="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):t==="any"&&(a="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let f="";o%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${u});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r8(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=kf(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function wa(n,e,t,s){const r=r8(n.shape);let o=n;for(let i=0;i<r.length;i++){const{inSize:a,windowSize:l,outSize:u}=r[i];let c,h;t==="mean"?c=i===0?new d1({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u},a):new d1({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u}):c=new s8({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u},t),h=o,o=s.runWebGLProgram(c,[o],e),h.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(h)}return o}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o8{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let i=0;i<s.length;i++)s[i]=e[t[i]];this.outputShape=s,this.rank=s.length;const r=Vt(this.rank),o=i8(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${o}));
    }
    `}}function i8(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<n.length;r++)s[n[r]]=t[r];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class a8{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let c=0;c<s.length;c++)s[c]=e[t[c]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Vt(this.rank),o=FT("rc",this.rank),i=new Array(this.rank);for(let c=0;c<t.length;c++)i[t[c]]=o[c];const a=`vec2(${i.slice(-2).join()})`,l=`++${o[this.rank-1]} < ${s[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${o[this.rank-1]};
      if(++${o[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mf(n,e,t){const s=ue().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new a8(n.shape,e):new o8(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l8(n,e,t,s){const r=e,o=n.shape.length,i=kt(r,n.shape);let a=i;const l=an(a,o),u=l!=null;let c=n;u&&(c=Mf(n,l,s),a=pn(a.length,o)),Un("sum",a,o);const[h,d]=Fn(c.shape,a);let p=h;t&&(p=dn(h,i));const f=pe(d),y=pe(n.shape)/f,b=We({inputs:{x:c},attrs:{shape:[y,f]},backend:s}),w=Fb(n.dtype),C=wa(b,w,"sum",s),v=We({inputs:{x:C},attrs:{shape:p},backend:s});return s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(C),u&&s.disposeIntermediateTensorInfo(c),v}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bf(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s;return l8(r,o,i,t)}const u8={kernelName:Up,backendName:"webgl",kernelFunc:Bf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hs(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:o}=s,i=t,a=r.shape.length,l=new Array(a);for(let c=0;c<l.length;c++)l[c]=r.shape[o[c]];let u;if(i.shouldExecuteOnCPU([r])){const h=i.texData.get(r.dataId).values,d=A0(h,r.shape,r.dtype,o,l);u=i.makeTensorInfo(l,r.dtype);const p=i.texData.get(u.dataId);p.values=d}else u=Mf(r,o,i);return u}const c8={kernelName:Ma,backendName:"webgl",kernelFunc:hs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WT=1e3;function Rd({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){const u=n.shape.length,c=e.shape.length,h=t?n.shape[u-2]:n.shape[u-1],d=s?e.shape[c-1]:e.shape[c-2],p=t?n.shape[u-1]:n.shape[u-2],f=s?e.shape[c-2]:e.shape[c-1],g=n.shape.slice(0,-2),y=e.shape.slice(0,-2),b=pe(g),w=pe(y),v=pt(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,f]);A(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const I=t?[b,h,p]:[b,p,h],E=s?[w,f,d]:[w,d,f],R=We({inputs:{x:n},backend:r,attrs:{shape:I}}),L=We({inputs:{x:e},backend:r,attrs:{shape:E}}),D=[R,L],F=Math.max(b,w),T=t?R.shape[1]:R.shape[2],V=o!=null,q=i!=null,se=l==="leakyrelu",ee=l!=null?Cu(l,!0):null,te=V||q||se||ee!=null;let le;if((p===1||f===1)&&T>WT&&te===!1){let he=R,ye=L;t&&(he=hs({inputs:{x:R},backend:r,attrs:{perm:[0,2,1]}}),D.push(he)),s&&(ye=hs({inputs:{x:L},backend:r,attrs:{perm:[0,2,1]}}),D.push(ye));const we=f!==1,Ce=f===1;let Se=he;we&&(Se=We({inputs:{x:he},backend:r,attrs:{shape:[F,T,1]}}),D.push(Se));const Le=f===1?2:1;let Ae=ye;Ce&&(Ae=We({inputs:{x:ye},backend:r,attrs:{shape:[F,1,T]}}),D.push(Ae));const Me=D0({inputs:{a:Se,b:Ae},backend:r});le=Bf({inputs:{x:Me},backend:r,attrs:{axis:Le,keepDims:!0}}),D.push(Me)}else{const he=Ds(n.dtype,e.dtype),ye=new VT(I,E,[F,p,f],t,s,V,ee,q,se),we=[R,L];if(o!=null&&we.push(o),q&&we.push(i),se){const Ce=r.makeTensorInfo([],"float32",pi(a,"float32"));we.push(Ce),D.push(Ce)}le=r.runWebGLProgram(ye,we,he)}const Q=We({inputs:{x:le},backend:r,attrs:{shape:v}});D.push(le);for(const he of D)r.disposeIntermediateTensorInfo(he);return Q}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h8(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:o,bias:i,preluActivationWeights:a}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;return Rd({a:r,b:o,transposeA:l,transposeB:u,backend:t,bias:i,preluActivationWeights:a,leakyreluAlpha:h,activation:c})}const d8={kernelName:ad,backendName:"webgl",kernelFunc:h8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p1="return abs(x);";function p8(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const o=t.texData.get(s.dataId),i=DT(o.values);return t.makeTensorInfo(s.shape,s.dtype,i)}let r;return ue().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new qo(s.shape,p1):r=new Vr(s.shape,p1),t.runWebGLProgram(r,[s],s.dtype)}const f8={kernelName:qd,backendName:"webgl",kernelFunc:p8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m8=mr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,g8=Dt({opSnippet:m8}),y8={kernelName:Ru,backendName:"webgl",kernelFunc:g8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b8=mr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,x8=Dt({opSnippet:b8}),w8={kernelName:Du,backendName:"webgl",kernelFunc:x8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f1="return a + b;",v8=Hn({opSnippet:f1,packedOpSnippet:f1,supportsComplex:!0,cpuKernelImpl:AX}),k8={kernelName:ml,backendName:"webgl",kernelFunc:v8};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class C8{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((o,i)=>`T${i}`);const s=[];this.variableNames.forEach(o=>{s.push(`float v${o} = get${o}AtOutCoords();`)});const r=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class S8{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((o,i)=>`T${i}`);const s=[];this.variableNames.forEach(o=>{s.push(`vec4 v${o} = get${o}AtOutCoords();`)});const r=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ed(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return zs({inputs:{x:s[0]},backend:t});if(s.length>ue().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(s.length/2),u=ed({inputs:s.slice(0,l),backend:t}),c=ed({inputs:s.slice(l),backend:t});return ed({inputs:[u,c],backend:t})}const r=s.map(l=>l.dtype).reduce((l,u)=>Ds(l,u)),o=s.map(l=>l.shape),a=ue().getBool("WEBGL_PACK")?new S8(s[0].shape,o):new C8(s[0].shape,o);return t.runWebGLProgram(a,s,r)}const I8={kernelName:Xd,backendName:"webgl",kernelFunc:ed};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s,a=r.shape.length,l=kt(o,r.shape);let u=l;const c=an(u,a);let h=r;c!=null&&(h=hs({inputs:{x:r},backend:t,attrs:{perm:c}}),u=pn(u.length,a)),Un("all",u,a);const[d,p]=Fn(h.shape,u),f=pe(p),g=We({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),y=wa(g,g.dtype,"all",t);let b;if(i){const w=dn(d,l);b=We({inputs:{x:y},backend:t,attrs:{shape:w}})}else b=We({inputs:{x:y},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),c!=null&&t.disposeIntermediateTensorInfo(h),b}const N8={kernelName:Ay,backendName:"webgl",kernelFunc:$8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s,a=r.shape.length,l=kt(o,r.shape);let u=l;const c=an(u,a);let h=r;c!=null&&(h=hs({inputs:{x:r},backend:t,attrs:{perm:c}}),u=pn(u.length,a)),Un("any",u,a);const[d,p]=Fn(h.shape,u),f=pe(p),g=We({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),y=wa(g,g.dtype,"any",t);let b;if(i){const w=dn(d,l);b=We({inputs:{x:y},backend:t,attrs:{shape:w}})}else b=We({inputs:{x:y},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),c!=null&&t.disposeIntermediateTensorInfo(h),b}const E8={kernelName:Ry,backendName:"webgl",kernelFunc:T8};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _8{constructor(e,t,s){this.variableNames=["A"];const{windowSize:r,batchSize:o,outSize:i}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i];const a=t==="max"?">":"<",l=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class A8{constructor(e,t,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,A(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const o=e[e.length-1],i=Math.ceil(o/t);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),r||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,u=Vt(l),c=as("coords",l);let h,d;if(i===1){d=l+1;const L=Vt(d);h=`
        ${L} sourceLocR = ${L}(${c.join()}, 0);
        ++${c[l-1]};
        ${L} sourceLocG = ${L}(${c.join()}, 0);
        ++${c[l-2]};
        ${L} sourceLocA = ${L}(${c.join()}, 0);
        --${c[l-1]};
        ${L} sourceLocB = ${L}(${c.join()}, 0);
        --${c[l-2]};`}else d=l,h=`
        ${u} sourceLocR = coords;
        ++${c[l-1]};
        ${u} sourceLocG = coords;
        ++${c[l-2]};
        ${u} sourceLocA = coords;
        --${c[l-1]};
        ${u} sourceLocB = coords;
        --${c[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,d),f="."+p[d-1],g=p.map(L=>"int "+L),y=as("sourceLocR",d-1).concat("inIdx.r"),b=as("sourceLocG",d-1).concat("inIdx.g"),w=as("sourceLocB",d-1).concat("inIdx.b"),C=as("sourceLocA",d-1).concat("inIdx.a"),v=s==="max"?"greaterThan":"lessThan",I=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${C.join()})));`,E=`vec4(
            getAChannel(${y.join()}),
            hasNextCol ? getAChannel(${b.join()}) : 0.,
            hasNextRow ? getAChannel(${w.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${C.join()}) : 0.)`,R=r?"":`
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${g.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${R}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${c[l-2]} < ${a[l-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${E};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${I}
          vec4 candidate = ${E};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UT(n,e,t,s=null){let r=e.shape[0],o=e.shape[1];s!=null&&(r=s.shape[0],o=s.shape[1]);const i=kf(o),a={windowSize:i,inSize:o,batchSize:r,outSize:Math.ceil(o/i)},l=new _8(a,t,s==null),u=[e];s!=null&&u.push(s);const c=n.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;const h=UT(n,e,t,c);return n.disposeIntermediateTensorInfo(c),h}function GT(n,e,t,s=null){const r=s!=null?s.shape:e.shape,o=r[r.length-1],i=kf(o),a=new A8(r,i,t,s==null),l=s==null?[e]:[e,s],u=n.runWebGLProgram(a,l,"int32");if(u.shape.length===e.shape.length){const c=GT(n,e,t,u);return n.disposeIntermediateTensorInfo(u),c}return u}function HT(n,e,t,s){const r=[t];if(Un("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!ue().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const o=[],i=n.texData.get(e.dataId),a=i!==null&&i.isPacked;let l=e;a&&(l=n.unpackTensor(e),o.push(l));const[u,c]=Fn(l.shape,r),h=pe(c),d=We({inputs:{x:l},backend:n,attrs:{shape:[-1,h]}});o.push(d);const p=UT(n,d,s);o.push(p);const f=We({inputs:{x:p},backend:n,attrs:{shape:u}});return o.forEach(g=>n.disposeIntermediateTensorInfo(g)),f}return GT(n,e,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o}=s;let i=kt(o,r.shape);const a=an(i,r.shape.length);let l=r;const u=[];a!=null&&(l=hs({inputs:{x:r},backend:t,attrs:{perm:a}}),u.push(l),i=pn(i.length,l.shape.length)),Un("argMax",[i[0]],l.shape.length);const c=HT(t,l,i[0],"max");return u.forEach(h=>t.disposeIntermediateTensorInfo(h)),c}const D8={kernelName:Yd,backendName:"webgl",kernelFunc:R8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o}=s;let i=kt(o,r.shape);const a=an(i,r.shape.length);let l=r;const u=[];a!=null&&(l=hs({inputs:{x:r},backend:t,attrs:{perm:a}}),u.push(l),i=pn(i.length,l.shape.length)),Un("argMin",[i[0]],l.shape.length);const c=HT(t,l,i[0],"min");return u.forEach(h=>t.disposeIntermediateTensorInfo(h)),c}const F8={kernelName:Zd,backendName:"webgl",kernelFunc:O8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L8=mr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,P8=Dt({opSnippet:L8}),z8={kernelName:Ou,backendName:"webgl",kernelFunc:P8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M8=mr+"return log(x + sqrt(x * x + 1.0));",B8=Dt({opSnippet:M8}),V8={kernelName:Fu,backendName:"webgl",kernelFunc:B8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W8=mr+`
  return atan(x);
`,U8=Dt({opSnippet:W8}),G8={kernelName:Lu,backendName:"webgl",kernelFunc:U8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H8=R0+`
  return atan(a, b);
`,j8=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+xa+`
  return result;
`,K8=Hn({opSnippet:H8,packedOpSnippet:j8}),q8={kernelName:zu,backendName:"webgl",kernelFunc:K8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X8=mr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Y8=Dt({opSnippet:X8}),Z8={kernelName:Pu,backendName:"webgl",kernelFunc:Y8};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Su{constructor(e,t,s,r=!1,o=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.top,f=e.padInfo.left;this.outputShape=e.outShape;const g=t==="avg",y=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,b=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let w="0.0";if(g||(w="-1.0 / 1e-20"),s){const L=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${p}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${L} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?o?y:b:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const C="max";let v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(v="avgValue / max(count, 1.0)");const I=Math.floor(i/4)*4,E=i%4,R=`
      if (${g}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${C}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${p}, ${f});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${I}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${R}
          }

          int xC = xCCorner + ${I};
          if (${E===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${E===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${E===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${R}
          }
        }
        setOutput(${v});
      }
    `}}class O0{constructor(e,t,s,r=!1,o=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideDepth,l=e.strideHeight,u=e.strideWidth,c=e.dilationDepth,h=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,f=e.effectiveFilterHeight,g=e.effectiveFilterWidth,y=e.padInfo.front,b=e.padInfo.top,w=e.padInfo.left;this.outputShape=e.outShape;const C=t==="avg";let v="0.0";if(C||(v="-1.0 / 1e-20"),s){const F=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${u});
        const ivec3 pads = ivec3(${y}, ${b}, ${w});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${g};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${F} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?o?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${f} * ${g} +
                      wR * ${g} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const I="max";let E=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(E="avgValue / max(count, 1.0)");const R=Math.floor(i/4)*4,L=i%4,D=`
      if (${C}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${I}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${u});
      const ivec3 pads = ivec3(${y}, ${b}, ${w});
      const float initializationValue = ${v};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${R}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${D}
            }

            int xC = xCCorner + ${R};
            if (${L===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${D}
            } else if (${L===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${D}
            } else if (${L===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${D}
            }
          }
        }
        setOutput(${E});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;qc(r,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=s,u=1;A(Wn(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=pr(r.shape,o,i,u,a,l);if(c.filterWidth===1&&c.filterHeight===1&&Tt(c.inShape,c.outShape))return zs({inputs:{x:r},backend:t});const h=new Su(c,"avg",!1);return t.runWebGLProgram(h,[r],"float32")}const Q8={kernelName:Jd,backendName:"webgl",kernelFunc:J8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=s,c=[1,1,1],h=Io(r.shape,o,i,c,a,l,u),d=new O0(h,"avg",!1);return t.runWebGLProgram(d,[r],"float32")}const tY={kernelName:Qd,backendName:"webgl",kernelFunc:eY};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nY{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,i=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=l-1-e.padInfo.top,h=u-1-e.padInfo.left,d=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${h});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class sY{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,h=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,f=h-1-e.padInfo.front,g=d-1-e.padInfo.top,y=p-1-e.padInfo.left,b=1/(t*s*r);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${g}, ${y});
      const float avgMultiplier = float(${b});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rY(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,i=o,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=s,h=[1,1,1],d=Io(i.shape,a,l,h,u,c),p=new sY(d);return t.runWebGLProgram(p,[r],i.dtype)}const oY={kernelName:Oy,backendName:"webgl",kernelFunc:rY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iY(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,i=o;qc([r,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=s,c=pr(i.shape,a,l,1,u),h=new nY(c);return t.runWebGLProgram(h,[r],i.dtype)}const aY={kernelName:Dy,backendName:"webgl",kernelFunc:iY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lY(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:o}=e,{transposeA:i,transposeB:a}=s;return Rd({a:r,b:o,transposeA:i,transposeB:a,backend:t})}const uY={kernelName:ep,backendName:"webgl",kernelFunc:lY};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cY{constructor(e,t,s,r,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],pt(e,t),pt(e,s);let a="0.0";r!=null&&(pt(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";o!=null&&(pt(e,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hY{constructor(e,t,s,r,o,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],pt(e,t),pt(e,s);let a="vec4(0.0)";r!=null&&(pt(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";o!=null&&(pt(e,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dY=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:r,variance:o,offset:i,scale:a}=n;A(r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),A(i==null||r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),A(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);const u=[s,r,o];let c=null;i!=null&&(c=i.shape,u.push(i));let h=null;a!=null&&(h=a.shape,u.push(a));const d=ue().getBool("WEBGL_PACK_NORMALIZATION")?new hY(s.shape,r.shape,o.shape,c,h,l):new cY(s.shape,r.shape,o.shape,c,h,l);return e.runWebGLProgram(d,u,u[0].dtype)},pY={kernelName:pp,backendName:"webgl",kernelFunc:dY};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fY{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Vt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=mY(this.rank);let r;const o=e.map((i,a)=>`sourceLoc.${ly[a]} = start[${a}] + coords.${ly[a]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${o.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const ly=["x","y","z","w","u","v"];function mY(n){if(n===1)return"sourceLoc";if(n<=6)return ly.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gY{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Vt(this.rank),s=as("coords",this.rank),r=as("sourceLoc",this.rank),o=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,i=`getChannel(getSource(${r.join()}), ${o})`,a=`
      result.x = ${i};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${i};
        --${r[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${i};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${i};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((c,h)=>`start[${h}]`).join()});`:e.map((c,h)=>`${r[h]} = ${s[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yY(n,e,t,s){const r=s.texData.get(n.dataId),o=s.makeTensorInfo(t,n.dtype),i=s.texData.get(o.dataId);Object.assign(i,r),i.refCount=1,i.shape=t,i.dtype=n.dtype;let a=Tx(e,rt(n.shape));r.slice&&(a+=r.slice.flatOffset),i.slice={flatOffset:a,origDataId:r.slice&&r.slice.origDataId||n.dataId};const l=s.dataRefCount.get(i.slice.origDataId)||1;return s.dataRefCount.set(i.slice.origDataId,l+1),o}function El(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:o,size:i}=s,[a,l]=vf(r,o,i);if(Ix(r,a,l),pe(l)===0)return t.makeTensorInfo(l,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||r.dtype==="string"){const h=t.texData.get(r.dataId),d=u5(h.values,a,l,r.shape,r.dtype);return t.makeTensorInfo(l,r.dtype,d)}const{isPacked:u}=t.texData.get(r.dataId),c=Nx(r.shape,a,l);if(u||!c){const h=ue().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new gY(l):new fY(l),d=[a];return t.runWebGLProgram(h,[r],r.dtype,d)}return t.uploadToGPU(r.dataId),yY(r,a,l,t)}const bY={kernelName:Wp,backendName:"webgl",kernelFunc:El};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xY=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:o,crops:i}=s;A(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((w,C)=>w*C),l=Fc(r.shape,o,a),u=Lc(l.length,o.length),c=Pc(r.shape,o,a),h=Dx(i,o.length),d=Ox(c,i,o.length),p=[],f=We({inputs:{x:r},backend:t,attrs:{shape:l}}),g=hs({inputs:{x:f},backend:t,attrs:{perm:u}}),y=We({inputs:{x:g},backend:t,attrs:{shape:c}}),b=El({inputs:{x:y},backend:t,attrs:{begin:h,size:d}});return p.push(f),p.push(g),p.push(y),p.forEach(w=>t.disposeIntermediateTensorInfo(w)),b},wY={kernelName:tp,backendName:"webgl",kernelFunc:xY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:o}=e,{size:i}=s,a=t.readSync(r.dataId),l=t.readSync(o.dataId),u=RT(a,l,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,u)}const kY={kernelName:Fy,backendName:"webgl",kernelFunc:vY};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CY=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,SY=`
  return float(int(a.r) & int(b.r));
`;function IY(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,o=ue().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=ue().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([s,r])||i===1){const l=t.texData.get(s.dataId).values,u=t.texData.get(r.dataId).values,[c,h]=DX(s.shape,r.shape,l,u,s.dtype),d=t.makeTensorInfo(h,s.dtype),p=t.texData.get(d.dataId);return p.values=c,d}let a;return o?a=new Nl(CY,s.shape,r.shape,!1):a=new ua(SY,s.shape,r.shape),t.runWebGLProgram(a,[s,r],s.dtype)}const $Y={kernelName:np,backendName:"webgl",kernelFunc:IY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NY(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,o=t.readSync(s.dataId),i=t.readSync(r.dataId),a=pt(Array.from(o),Array.from(i));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const TY={kernelName:Ly,backendName:"webgl",kernelFunc:NY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EY="return float(a != b);",jT=Hn({opSnippet:EY,cpuKernelImpl:e5,dtype:"bool"}),_Y={kernelName:_p,backendName:"webgl",kernelFunc:jT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yc(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return zs({inputs:{x:r.complexTensorInfos.real},backend:t})}const AY={kernelName:mb,backendName:"webgl",kernelFunc:Yc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RY="return float(int(x));";function DY(n,e){const t=new Vr(n.shape,RY),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uy(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:o}=s;if(o==="complex64"){if(r.dtype==="complex64")return zs({inputs:{x:r},backend:t});const i=kn(r.shape),a=uy({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),l=Ci({inputs:{real:a,imag:i},backend:t});return i.dispose(),t.disposeIntermediateTensorInfo(a),l}if(r.dtype==="complex64"){const i=Yc({inputs:{input:r},backend:t}),a=uy({inputs:{x:i},backend:t,attrs:{dtype:o}});return t.disposeIntermediateTensorInfo(i),a}if(!uk(r.dtype,o)){const i=zs({inputs:{x:r},backend:t});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(t.shouldExecuteOnCPU([r])){const i=t.texData.get(r.dataId).values,[a,l,u]=OX(i,r.shape,r.dtype,o);return t.makeTensorInfo(a,l,u)}if(o==="int32")return DY(r,t);if(o==="bool"){const i=t.makeTensorInfo([],"bool",Bn("bool",1)),l=jT({inputs:{a:r,b:i},backend:t});return t.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${o}`)}const OY={kernelName:Mu,backendName:"webgl",kernelFunc:uy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m1="return ceil(x);",FY=Dt({opSnippet:m1,packedOpSnippet:m1,cpuKernelImpl:FX}),LY={kernelName:Bu,backendName:"webgl",kernelFunc:FY};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PY{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zY{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:o,clipValueMax:i}=s;let a;ue().getBool("WEBGL_PACK_CLIP")?a=new zY(r.shape):a=new PY(r.shape);const l=[[o],[i]];return t.runWebGLProgram(a,[r],r.dtype,l)}const BY={kernelName:Vu,backendName:"webgl",kernelFunc:MY};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VY{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g1(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function WY(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.texData.get(s.dataId),o=new VY(s.shape),i=[g1(s,r.complexTensorInfos.real),g1(s,r.complexTensorInfos.imag)];return t.runWebGLProgram(o,i,i[0].dtype)}const UY={kernelName:sp,backendName:"webgl",kernelFunc:WY};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GY{constructor(e){this.outputShape=[],this.outputShape=Gr(e,1),this.variableNames=e.map((i,a)=>`T${a}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let i=1;i<t.length;i++)t[i]=t[i-1]+e[i][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<t.length;i++){const a=t[i-1];s.push(`else if (yC < ${t[i]}) setOutput(getT${i}(yR, yC-${a}));`)}const r=t.length,o=t[t.length-1];s.push(`else setOutput(getT${r}(yR, yC-${o}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HY{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Gr(e,t);const s=this.outputShape,r=s.length,o=Vt(r),i=as("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((g,y)=>`T${y}`);const l=new Array(e.length-1);l[0]=e[0][t];for(let g=1;g<l.length;g++)l[g]=l[g-1]+e[g][t];const u=a[t],c=a.slice(-2),h=a.join();let d=`if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${h}), vec2(${c.join()}));
        }`;for(let g=1;g<l.length;g++){const y=l[g-1];d+=`
        if (${u} < ${l[g]}  && ${u} >= ${l[g-1]}) {
          return getChannel(
            getT${g}(${Mh(a,u,y)}),
            vec2(${Mh(c,u,y)}));
        }`}const p=l.length,f=l[l.length-1];d+=`
        return getChannel(
          getT${p}(${Mh(a,u,f)}),
          vec2(${Mh(c,u,f)}));`,this.userCode=`
      float getValue(${a.map(g=>"int "+g)}) {
        ${d}
      }

      void main() {
        ${o} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[r-1]} = ${i[r-1]} + 1;
        if (${i[r-1]} < ${s[r-1]}) {
          result.g = getValue(${i});
        }

        ${i[r-2]} = ${i[r-2]} + 1;
        if (${i[r-2]} < ${s[r-2]}) {
          result.a = getValue(${i});
        }

        ${i[r-1]} = ${i[r-1]} - 1;
        if (${i[r-2]} < ${s[r-2]} &&
            ${i[r-1]} < ${s[r-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}}function Mh(n,e,t){const s=n.indexOf(e);return n.map((o,i)=>i===s?`${o} - ${t}`:o).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vf(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return zs({inputs:{x:r.complexTensorInfos.imag},backend:t})}const jY={kernelName:tb,backendName:"webgl",kernelFunc:Vf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ql(n,e,t){const s=n[0].dtype;if(s==="complex64"){const p=n.map(w=>Yc({inputs:{input:w},backend:t})),f=n.map(w=>Vf({inputs:{input:w},backend:t})),g=Ql(p,e,t),y=Ql(f,e,t),b=Ci({inputs:{real:g,imag:y},backend:t});return p.forEach(w=>t.disposeIntermediateTensorInfo(w)),f.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),b}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const p=n.map(v=>{const E=[-1,pe(v.shape.slice(e))];return We({inputs:{x:v},backend:t,attrs:{shape:E}})}),f=p.map(v=>({vals:t.readSync(v.dataId),shape:v.shape})),g=Gr(p.map(v=>v.shape),1),y=p[0].shape[0]===1,b=LX(f,g,s,y),w=Gr(n.map(v=>v.shape),e),C=t.makeTensorInfo(w,s,b);return p.forEach(v=>t.disposeIntermediateTensorInfo(v)),C}const o=n.filter(p=>pe(p.shape)>0),i=ue().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(o.length===1){const p=i?new Vr(n[0].shape,Vo):new qo(n[0].shape,Vo);return t.runWebGLProgram(p,n,s)}const a=ue().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>a){const p=[];for(let g=0;g<o.length;g+=a){const y=o.slice(g,g+a);p.push(Ql(y,e,t))}const f=Ql(p,e,t);for(const g of p)t.disposeIntermediateTensorInfo(g);return f}if(i){const p=new HY(o.map(f=>f.shape),e);return t.runWebGLProgram(p,o,s)}const{tensors2D:l,outShape:u}=KY(o,e,t),c=new GY(l.map(p=>p.shape)),h=t.runWebGLProgram(c,l,s);l.forEach(p=>t.disposeIntermediateTensorInfo(p));const d=We({inputs:{x:h},attrs:{shape:u},backend:t});return t.disposeIntermediateTensorInfo(h),d}function KY(n,e,t){const s=Gr(n.map(o=>o.shape),e);return{tensors2D:n.map(o=>We({inputs:{x:o},attrs:{shape:[-1,pe(o.shape.slice(e))]},backend:t})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KT(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,o=kt(r,e[0].shape)[0],i=e.map(u=>u.shape);_x(i,o);const a=Gr(e.map(u=>u.shape),o);if(pe(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(u=>pe(u.shape)>0);return l.length===1?zs({inputs:{x:l[0]},backend:t}):Ql(l,o,t)}const qY={kernelName:rp,backendName:"webgl",kernelFunc:KT};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qT{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const i=e.padInfo.top,a=e.padInfo.left,l=e.strideHeight,u=e.strideWidth,c=e.dilationHeight,h=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,g=e.inChannels%4,y=e.dataFormat==="channelsLast",b=y?1:2,w=y?2:3,C=y?3:1;let v="",I="";s&&(r?v=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?v=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:v=`
          float activation(float x) {
            ${s}
          }
        `,I="result = activation(result);");const E=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${v}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${C}];

        ivec2 xRCCorner =
            ivec2(coords[${b}], coords[${w}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${y}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${g===1}) {

              if (${y}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${g===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${y}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${g===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${y}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${E}
        ${I}
        setOutput(result);
      }
    `}}class XY{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,h=e.filterDepth,d=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,g=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${o}, ${i}, ${a});
      const ivec3 pads = ivec3(${t}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${g===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${g===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${g===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XT{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Jn(this.outputShape.length);const i=e.padInfo.left,a=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,h=c;let d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<c;y++)d+=`
           vec4 xTexelC${y*2};
           int xTexelC${y*2}Ready;
           vec4 xTexelC${y*2+1};
           int xTexelC${y*2+1}Ready;
           vec4 xC${y};`;d+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let y=0;y<c;y++)d+=`
           xTexelC${y*2} = vec4(0.0);
           xTexelC${y*2}Ready = 0;
           xTexelC${y*2+1} = vec4(0.0);
           xTexelC${y*2+1}Ready = 0;
           xC${y} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let y=0;y<(h+1)/2;y++){const b=y*2;if(d+=`
           xC = xCCorner + ${b*l};
           `,a===1){if(b<c&&(i%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }
               `,l===1&&b>0?d+=`
                 xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                   } else {
                     xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xC${b} = xTexelC${b};
                 `,b+1<c)){const w=i%2===0?Ty(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${w};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                     xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${b+1}.zw = vec2(0.0);
                     }
                     xTexelC${b+1}Ready = 1;
                   }
                   `,l>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                     } else {
                      xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                     }
                     `:d+=`
                     xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                     `):w===1?d+=`
                     xC${b+1} = xTexelC${b};
                     `:d+=`
                     xCOffset = xC + ${w};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                       xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${b+1}.zw = vec2(0.0);
                       }
                       xTexelC${b+1}Ready = 1;
                     }

                     xC${b+1} = xTexelC${b+1};
                     `}}else b<c&&(i%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.0);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
               `,b+1<c&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(
                   xTexelC${b}.xy, xTexelC${b+1}.xy);
               `,b+1<c&&(d+=`
                   xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                 `)));b<c&&(d+=`
             wTexel = getW(r, ${b}, d1, d2);
             dotProd += xC${b}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${b}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,b+1<c&&(d+=`
               wTexel = getW(r, ${b+1}, d1, d2);
               dotProd += xC${b+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${b+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let p="",f="";s&&(r?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:o?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:p=`vec4 activation(vec4 x) {
           ${s}
         }`,f="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${g}
         ${f}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YY{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Jn(this.outputShape.length);const{dataFormat:s}=t,r=ps(),o=s==="channelsLast",i=o?1:2,a=o?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let u="";for(let c=0;c<=1;c++)for(let h=0;h<=1;h++)u+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${c};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${o}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${r.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dd(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function YT({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const l=n.shape,u=s.texData.get(n.dataId),c=t.inChannels,h=l[0]*l[1]*l[2],d=t.outChannels,p=t.dataFormat==="channelsLast",f=!1,g=!1;let y;const b=[];if(o!=null){const v=Dd(o.shape,p);v!=null&&(o=We({inputs:{x:o},backend:s,attrs:{shape:v}}),b.push(o))}if(r!=null){const v=Dd(r.shape,p);v!=null&&(r=We({inputs:{x:r},backend:s,attrs:{shape:v}}),b.push(r))}if(!((h===1||d===1)&&c>WT)&&u.isPacked&&p&&u.texture!=null&&l[2]%2!==0&&Tt(u.shape.slice(-3),l.slice(-3))){const v=l[0]*l[1]*(l[2]+1),I={dataId:n.dataId,shape:[1,v,t.inChannels],dtype:n.dtype},E=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,A(Ad(u.shape,I.shape),()=>`packed reshape ${u.shape} to ${I.shape} isn't free`);const R=We({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});b.push(R);const L=Rd({a:I,b:R,backend:s,transposeA:f,transposeB:g,bias:r,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),D=s.texData.get(L.dataId);A(D.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=E,D.shape=t.outShape,y=zs({inputs:{x:L},backend:s}),y.shape=t.outShape,b.push(L)}else{const v=t.outHeight*t.outWidth,I=We({inputs:{x:n},backend:s,attrs:{shape:p?[t.batchSize,v,t.inChannels]:[t.batchSize,t.inChannels,v]}}),E=We({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),R=Rd({a:p?I:E,b:p?E:I,transposeA:!p,transposeB:g,backend:s,bias:r,activation:a,preluActivationWeights:o,leakyreluAlpha:i});y=We({inputs:{x:R},backend:s,attrs:{shape:t.outShape}}),b.push(I),b.push(E),b.push(R)}for(const v of b)s.disposeIntermediateTensorInfo(v);return y}function ZT({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:h,outHeight:d,dataFormat:p}=t,f=p==="channelsLast",g=l*u*c,y=d*h,b=[t.batchSize,g,y],w=!0,C=!1,v=[];if(o!=null){const Q=Dd(o.shape,f);Q!=null&&(o=We({inputs:{x:o},backend:s,attrs:{shape:Q}}),v.push(o))}if(r!=null){const Q=Dd(r.shape,f);Q!=null&&(r=We({inputs:{x:r},backend:s,attrs:{shape:Q}}),v.push(r))}const I=We({inputs:{x:e},backend:s,attrs:{shape:[1,g,pe(e.shape)/g]}});v.push(I);const E=new YY(b,t),R=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],L=s.runWebGLProgram(E,[n],"float32",R),D=We({inputs:{x:L},backend:s,attrs:{shape:b}});v.push(L),v.push(D);const F=r!=null,T=o!=null,V=a==="leakyrelu",q=a?Cu(a,!0):null,se=new VT(f?D.shape:I.shape,f?I.shape:D.shape,f?[t.batchSize,y,t.outChannels]:[t.batchSize,t.outChannels,y],w,C,F,q,T,V),ee=f?[D,I]:[I,D];if(r&&ee.push(r),T&&ee.push(o),V){const Q=s.makeTensorInfo([],"float32",pi(i,"float32"));ee.push(Q),v.push(Q)}const te=s.runWebGLProgram(se,ee,"float32"),le=We({inputs:{x:te},backend:s,attrs:{shape:t.outShape}});v.push(te);for(const Q of v)s.disposeIntermediateTensorInfo(Q);return le}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=s,h=$o(l),d=On(r.shape,o.shape,i,u,a,c,!1,h);let p;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))p=YT({x:r,filter:o,convInfo:d,backend:t});else if(d.strideWidth<=2&&h==="channelsLast"&&ue().getBool("WEBGL_EXP_CONV")){const g=new XT(d),y=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=t.runWebGLProgram(g,[r,o],"float32",y)}else if(ue().getBool("WEBGL_CONV_IM2COL"))p=ZT({x:r,filter:o,convInfo:d,backend:t});else{const g=new qT(d);p=t.runWebGLProgram(g,[r,o],"float32")}const f=We({inputs:{x:p},backend:t,attrs:{shape:d.outShape}});return t.disposeIntermediateTensorInfo(p),f}const JY={kernelName:op,backendName:"webgl",kernelFunc:ZY};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QY{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,i=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class e7{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,i=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,l=s-1-e.padInfo.left,u=i?1:2,c=i?2:3,h=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class t7{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,o=e.padInfo.front,i=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${o};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${i};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class n7{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,l=t-1-e.padInfo.front,u=s-1-e.padInfo.top,c=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${o}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=s,h=$o(l),d=On(r.shape,c,i,1,a,u,!1,h),p=new QY(d);return t.runWebGLProgram(p,[r,o],"float32")}const r7={kernelName:zy,backendName:"webgl",kernelFunc:s7};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o7{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Jn(this.outputShape.length);const t=e.filterHeight,s=e.filterWidth,r=t-1-e.padInfo.top,o=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i7(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=s,h=$o(u),d=On(i,o.shape,a,1,l,c,!1,h);if(ue().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&h==="channelsLast"){const p=[[d.strideHeight,d.strideWidth]],f=new o7(d);return t.runWebGLProgram(f,[r,o],"float32",p)}else{const p=new e7(d);return t.runWebGLProgram(p,[r,o],"float32")}}const a7={kernelName:ip,backendName:"webgl",kernelFunc:i7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:i,pad:a,dilations:l}=s,u=gi(r.shape,o.shape,i,l,a),c=new XY(u);return t.runWebGLProgram(c,[r,o],"float32")}const u7={kernelName:ap,backendName:"webgl",kernelFunc:l7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:i,pad:a,filterShape:l}=s,u=gi(r.shape,l,i,1,a),c=new t7(u);return t.runWebGLProgram(c,[r,o],"float32")}const h7={kernelName:My,backendName:"webgl",kernelFunc:c7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d7(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{pad:i,strides:a,inputShape:l}=s,u=gi(l,o.shape,a,1,i),c=new n7(u);return t.runWebGLProgram(c,[r,o],"float32")}const p7={kernelName:By,backendName:"webgl",kernelFunc:d7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f7=Tl+`
  return cos(x);
`,m7=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${xa}
  return result;
`,g7=Dt({opSnippet:f7,packedOpSnippet:m7}),y7={kernelName:Wu,backendName:"webgl",kernelFunc:g7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b7=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,x7=Dt({opSnippet:b7}),w7={kernelName:Uu,backendName:"webgl",kernelFunc:x7};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class v7{constructor(e,t,s,r,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,l,u]=e,[c]=t,[h,d]=s;this.outputShape=[c,h,d,u];const p=r==="bilinear"?1:0,[f,g]=[`${a-1}.0`,`${l-1}.0`],[y,b,w]=h>1?[`${(a-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[C,v,I]=d>1?[`${(l-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`
      const float height_ratio = float(${y});
      const float width_ratio = float(${C});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${b};
        float width_scale = ${v};

        float in_y = ${w};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${o}));
          return;
        }
        float in_x = ${I};
        if( in_x < 0.0 || in_x > ${g} ) {
          setOutput(float(${o}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k7=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:o,boxInd:i}=e,{cropSize:a,method:l,extrapolationValue:u}=s,c=new v7(r.shape,o.shape,a,l,u);return t.runWebGLProgram(c,[r,o,i],"float32")},C7={kernelName:Wy,backendName:"webgl",kernelFunc:k7};var Iu;(function(n){n.Prod="*",n.Sum="+"})(Iu||(Iu={}));class y1{constructor(e,t,s,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,i=this.op===Iu.Prod?"1.0":"0.0",a=s?i:`getX(${b1(o,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let u="",c="";s?(u=r?`end != ${l-1}`:"end != 0",c=r?"end + 1":"end - 1"):(u=r?`end + pow2 < ${l}`:"end >= pow2",c=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Vt(o)} coords = getOutputCoords();
        int end = ${x1(o,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${x1(o,"coords",this.op)} = idx;
          val ${this.op}= getX(${b1(o,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function b1(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function x1(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JT(n,e,t,s,r,o){const i=e.shape.length,a=an([s],i);let l=e;a!=null&&(l=hs({inputs:{x:e},backend:t,attrs:{perm:a}}));const u=pn(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const c=l.shape[u];let h=zs({inputs:{x:l},backend:t});for(let d=0;d<=Math.ceil(Math.log2(c))-1;d++){const p=new y1(n,l.shape,!1,o),f=[[d]],g=h;h=t.runWebGLProgram(p,[h],h.dtype,f),t.disposeIntermediateTensorInfo(g)}if(r){const d=new y1(n,l.shape,r,o),p=h;h=t.runWebGLProgram(d,[h],h.dtype),t.disposeIntermediateTensorInfo(p)}if(a!=null){const d=yi(a),p=hs({inputs:{x:h},backend:t,attrs:{perm:d}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(l),p}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,exclusive:i,reverse:a}=s;return JT(Iu.Prod,r,t,o,i,a)}const I7={kernelName:Vy,backendName:"webgl",kernelFunc:S7};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,exclusive:i,reverse:a}=s;return JT(Iu.Sum,r,t,o,i,a)}const N7={kernelName:lp,backendName:"webgl",kernelFunc:$7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:o}=e,{size:i,binaryOutput:a}=s;if(r.shape.length===1){const l=t.readSync(r.dataId),u=t.readSync(o.dataId),c=RT(l,u,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,c)}else if(r.shape.length===2){const l=t.bufferSync(r),u=t.bufferSync(o),c=RX(l,u,i,a);return t.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const E7={kernelName:Uy,backendName:"webgl",kernelFunc:T7};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _7{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:o,dataFormat:i}=s,a=r.shape[0],l=i==="NHWC"?r.shape[1]:r.shape[2],u=i==="NHWC"?r.shape[2]:r.shape[3],c=i==="NHWC"?r.shape[3]:r.shape[1],h=l*o,d=u*o,p=c/(o*o),f=i==="NHWC"?[a,h,d,p]:[a,p,h,d],g=new _7(f,o,i);return t.runWebGLProgram(g,[r],r.dtype)}const R7={kernelName:Gy,backendName:"webgl",kernelFunc:A7};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QT{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Jn(this.outputShape.length);const i=e.filterHeight,a=e.filterWidth,l=e.outChannels/e.inChannels;let u="",c="";s&&(r?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:u=`
          float activation(float x) {
            ${s}
          }
        `,c="result = activation(result);");const h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${c}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class e2{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Jn(this.outputShape.length);const i=e.outChannels/e.inChannels,a=e.padInfo.left,l=e.strideWidth,u=e.dilationWidth,c=e.filterHeight,h=e.filterWidth,d=h;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let b=0;b<h;b++)p+=`
          vec4 xTexelC${b*2};
          int xTexelC${b*2}Ready;
          vec4 xTexelC${b*2+1};
          int xTexelC${b*2+1}Ready;
          vec4 xC${b};`;p+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let b=0;b<h;b++)p+=`
          xTexelC${b*2} = vec4(0.0);
          xTexelC${b*2}Ready = 0;
          xTexelC${b*2+1} = vec4(0.0);
          xTexelC${b*2+1}Ready = 0;
          xC${b} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let b=0;b<(d+1)/2;b++){const w=b*2;if(p+=`
          xC = xCCorner + ${w*u};
          `,l===1){if(w<h&&(a%2===1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }
              `,u===1&&w>0?p+=`
                xC${w} = vec4(xTexelC${w-2}.zw, xTexelC${w}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${w} = vec4(previous.zw, xTexelC${w}.xy);
                  } else {
                    xC${w} = vec4(0.0, 0.0, xTexelC${w}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                xC${w} = xTexelC${w};
                `,w+1<h)){const C=a%2===0?Ty(u):u;u%2===0&&a%2===1||u%2!==0&&a%2!==1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${C};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                    xTexelC${w+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${w+1}.zw = vec2(0.0);
                    }
                    xTexelC${w+1}Ready = 1;
                  }
                  `,u>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${w+1} = vec4(previous.zw, xTexelC${w+1}.xy);
                    } else {
                     xC${w+1} = vec4(0.0, 0.0, xTexelC${w+1}.xy);
                    }
                    `:p+=`
                    xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.xy);
                    `):C===1?p+=`
                    xC${w+1} = xTexelC${w};
                    `:p+=`
                    xCOffset = xC + ${C};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                      xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${w+1}.zw = vec2(0.0);
                      }
                      xTexelC${w+1}Ready = 1;
                    }

                    xC${w+1} = xTexelC${w+1};
                    `}}else w<h&&(a%2===1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${w+1}Ready == 0) {
                  xTexelC${w+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${w+1}.zw = vec2(0.0);
                  }
                  xTexelC${w+1}Ready = 1;
                }

                xC${w} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
              `,w+1<h&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${w+1} = vec4(xTexelC${w+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                  xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w+1}.zw = vec2(0.);
                  }
                  xTexelC${w+1}Ready = 1;
                }

                xC${w} = vec4(
                  xTexelC${w}.xy, xTexelC${w+1}.xy);
              `,w+1<h&&(p+=`
                  xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
                `)));w<h&&(p+=`
            wTexel = getW(r, ${w}, d1, q);
            dotProd += xC${w} * vec4(wTexel.xz, wTexel.xz);
          `,w+1<h&&(p+=`
              wTexel = getW(r, ${w+1}, d1, q);
              dotProd += xC${w+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let f="",g="";s&&(r?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:f=`vec4 activation(vec4 x) {
          ${s}
        }`,g="result = activation(result);");const y=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${y}
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=s;let c=l;c==null&&(c=[1,1]),A(Wn(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const h=On(r.shape,o.shape,i,c,a,u,!0);let d;ue().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?d=new e2(h):d=new QT(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return t.runWebGLProgram(d,[r,o],"float32",p)}const O7={kernelName:up,backendName:"webgl",kernelFunc:D7};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F7{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class L7{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,i=t-1-e.padInfo.top,a=s-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=s,h=On(r.shape,c,i,a,l,u,!0),d=new F7(h);return t.runWebGLProgram(d,[r,o],"float32")}const z7={kernelName:Hy,backendName:"webgl",kernelFunc:P7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M7(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=s,h=On(c,o.shape,i,a,l,u,!0),d=new L7(h);return t.runWebGLProgram(d,[r,o],"float32")}const B7={kernelName:jy,backendName:"webgl",kernelFunc:M7};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class V7{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W7(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],o=pe(s.shape),i=We({inputs:{x:s},backend:t,attrs:{shape:[o]}}),a=new V7(o),l=t.runWebGLProgram(a,[i],i.dtype),u=We({inputs:{x:l},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(l),u}const U7={kernelName:Ky,backendName:"webgl",kernelFunc:W7};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class G7{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:r,strideHeight:o,strideWidth:i,filterHeight:a,filterWidth:l,dilationHeight:u,dilationWidth:c}=e,{top:h,left:d}=r;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${i});
      const ivec2 pads = ivec2(${h}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:i,pad:a,dilations:l}=s,u=Tc(r.shape,o.shape,i,a,"NHWC",l);let c;const h=new G7(u);c=t.runWebGLProgram(h,[r,o],"float32");const d=We({inputs:{x:c},backend:t,attrs:{shape:u.outShape}});return t.disposeIntermediateTensorInfo(c),d}const j7={kernelName:cp,backendName:"webgl",kernelFunc:H7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K7(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,o=e,{allDims:i,summedDims:a,idDims:l}=Wx(r,o.length);Gx(i.length,l,o);const{path:u,steps:c}=Hx(a,l),h=c.length;let d=null,p=i.length;const f=[];for(let g=0;g<h;++g){for(const y of c[g]){const{permutationIndices:b,expandDims:w}=Ux(p,l[y]);let C;jx(b)?C=o[y]:(C=hs({inputs:{x:o[y]},backend:t,attrs:{perm:b}}),f.push(C));const v=C.shape.slice();for(let I=0;I<w.length;++I)v.splice(w[I],0,1);Tt(C.shape,v)||(C=We({inputs:{x:C},backend:t,attrs:{shape:v}}),f.push(C)),d===null?d=C:(d=D0({inputs:{a:C,b:d},backend:t}),f.push(d))}g<h-1&&(u[g]>=0&&(d=Bf({inputs:{x:d},backend:t,attrs:{axis:u[g]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&t.disposeIntermediateTensorInfo(g);return d}const q7={kernelName:qy,backendName:"webgl",kernelFunc:K7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X7="return (x >= 0.0) ? x : (exp(x) - 1.0);",Y7=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Z7=Dt({opSnippet:X7,packedOpSnippet:Y7}),J7={kernelName:Hu,backendName:"webgl",kernelFunc:Z7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q7="return (b >= 0.0) ? a : a * (b + 1.0);",e9=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,t9=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,o=ue().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Nl(e9,s.shape,r.shape):new ua(Q7,s.shape,r.shape);return t.runWebGLProgram(o,[s,r],s.dtype)},n9={kernelName:Xy,backendName:"webgl",kernelFunc:t9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s9=`
  return vec4(equal(a, b));
`,r9="return float(a == b);",o9=Hn({opSnippet:r9,packedOpSnippet:s9,dtype:"bool",cpuKernelImpl:PX}),i9={kernelName:hp,backendName:"webgl",kernelFunc:o9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a9=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${Fx};
  float a1 = ${Lx};
  float a2 = ${Px};
  float a3 = ${zx};
  float a4 = ${Mx};
  float a5 = ${Bx};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,l9=Dt({opSnippet:a9}),u9={kernelName:ju,backendName:"webgl",kernelFunc:l9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c9=Tl+`
  return exp(x);
`,h9=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,t2=Dt({opSnippet:c9,packedOpSnippet:h9,cpuKernelImpl:zX,dtype:"float32"}),d9={kernelName:Ku,backendName:"webgl",kernelFunc:t2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cy(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:o}=e,i=o.shape.length,a=o.shape.slice();let l=r;return r<0&&(A(-(i+1)<=r,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+r+1),a.splice(l,0,1),We({inputs:{x:o},backend:s,attrs:{shape:a}})}const p9={kernelName:dp,backendName:"webgl",kernelFunc:cy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w1="return exp(x) - 1.0;",f9=Dt({opSnippet:w1,packedOpSnippet:w1,cpuKernelImpl:MX}),m9={kernelName:qu,backendName:"webgl",kernelFunc:f9};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class v1{constructor(e,t,s){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const o=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=s?`${r}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${o};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n2(n,e,t){const s=t.texData.get(n.dataId),r=pe(n.shape),o=n.shape[n.shape.length-1],i=r/o,a=We({inputs:{x:n},backend:t,attrs:{shape:[i,o]}}),l=a.shape,u=new v1("real",l,e),c=new v1("imag",l,e),h=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],d=t.runWebGLProgram(u,h,"float32"),p=t.runWebGLProgram(c,h,"float32"),f=Ci({inputs:{real:d,imag:p},backend:t});t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p);const g=We({inputs:{x:f},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(f),g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g9(n){const{inputs:e,backend:t}=n,{input:s}=e;return n2(s,!1,t)}const y9={kernelName:Yy,backendName:"webgl",kernelFunc:g9};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class b9{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zc(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:o}=t;if(o=o||pl(r),o==="string"){const i=hn(o,pe(s));return i.fill(r),e.makeTensorInfo(s,o,i)}else{const i=new b9(s,r),a=[[r]];return e.runWebGLProgram(i,[],o,a)}}const x9={kernelName:Zy,backendName:"webgl",kernelFunc:Zc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class w9{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v9={kernelName:Jy,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new w9(t.shape);return s.runWebGLProgram(r,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k1="return floor(x);",k9=Dt({opSnippet:k1,packedOpSnippet:k1,cpuKernelImpl:BX}),C9={kernelName:Xu,backendName:"webgl",kernelFunc:k9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S9=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,I9=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,$9=Hn({opSnippet:S9,packedOpSnippet:I9,dtype:"int32"}),N9={kernelName:Yu,backendName:"webgl",kernelFunc:$9};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class T9{constructor(e){this.variableNames=["A"];const t=ps(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class E9{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=ps(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _9={kernelName:xg,backendName:"webgl",kernelFunc:A9};let _a,ng=ue().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function A9(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:o}=s,i=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[l,u]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[u,l],h=[u,l,o];if(a||i){const g=ue().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(_a==null||g!==ng)&&(ng=g,_a=document.createElement("canvas").getContext("2d",{willReadFrequently:ng})),_a.canvas.width=l,_a.canvas.height=u,_a.drawImage(r,0,0,l,u),r=_a.canvas}const d=t.makeTensorInfo(c,"int32");t.texData.get(d.dataId).usage=Gs.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(d.dataId),r);const p=ue().getBool("WEBGL_PACK")?new E9(h):new T9(h),f=t.runWebGLProgram(p,[d],"int32");return t.disposeData(d.dataId),f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R9(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,bias:i,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s,g=$o(c),y=On(r.shape,o.shape,l,h,u,d,!1,g);let b;const w=[],C=i!=null,v=a!=null,I=p==="leakyrelu",E=()=>{const L=[r,o],D=(F,T)=>{if(T==="NCHW"&&F.shape.length===1&&F.shape[0]!==1){const V=We({inputs:{x:F},backend:t,attrs:{shape:[F.shape[0],1,1]}});return w.push(V),V}return F};if(C&&L.push(D(i,c)),v&&L.push(D(a,c)),I){const F=t.makeTensorInfo([],"float32",pi(f,"float32"));L.push(F),w.push(F)}return L};if(y.filterHeight===1&&y.filterWidth===1&&y.dilationHeight===1&&y.dilationWidth===1&&y.strideHeight===1&&y.strideWidth===1&&(y.padInfo.type==="SAME"||y.padInfo.type==="VALID"))b=YT({x:r,filter:o,convInfo:y,backend:t,bias:i,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else if(y.strideWidth<=2&&g==="channelsLast"&&ue().getBool("WEBGL_EXP_CONV")){const L=p?Cu(p,!0):null,D=new XT(y,C,L,v,I),F=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],T=E();b=t.runWebGLProgram(D,T,"float32",F)}else if(ue().getBool("WEBGL_CONV_IM2COL"))b=ZT({x:r,filter:o,convInfo:y,backend:t,bias:i,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else{const L=p?Cu(p,!1):null,D=new qT(y,C,L,v,I),F=E();b=t.runWebGLProgram(D,F,"float32")}const R=We({inputs:{x:b},backend:t,attrs:{shape:y.outShape}});return w.push(b),w.forEach(L=>t.disposeIntermediateTensorInfo(L)),R}const D9={kernelName:ld,backendName:"webgl",kernelFunc:R9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O9(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,bias:i,preluActivationWeights:a}=e,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=s,f=[];let g=c;g==null&&(g=[1,1]),A(Wn(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);const y=On(r.shape,o.shape,l,g,u,h,!0),b=ue().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,w=d?Cu(d,b):null,C=[r,o],v=i!=null,I=a!=null,E=d==="leakyrelu";if(v&&C.push(i),I&&C.push(a),E){const F=t.makeTensorInfo([],"float32",pi(p,"float32"));C.push(F),f.push(F)}let R;b?R=new e2(y,v,w,I,E):R=new QT(y,v,w,I,E);const L=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],D=t.runWebGLProgram(R,C,"float32",L);return f.forEach(F=>t.disposeIntermediateTensorInfo(F)),D}const F9={kernelName:ud,backendName:"webgl",kernelFunc:O9};class L9{constructor(e,t,s,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const o=Vt(s.length);let i=`
    int index;`;for(let a=0;a<this.sliceDim;a++)i+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${o} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P9(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,o=r.shape,i=o[o.length-1],a=pe(s.shape),[l,u,c,h]=Sx(s,r),d=We({inputs:{x:r},backend:t,attrs:{shape:[u,i]}}),p=We({inputs:{x:s},backend:t,attrs:{shape:[pe(s.shape)/c,c]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const b=t.readSync(r.dataId),w=t.bufferSync(s),C=VX(b,w,s.dtype,u,i,c,h,s.shape,a);return t.makeTensorInfo(l,s.dtype,C.values)}const f=new L9(i,h,[u,c],s.shape),g=t.runWebGLProgram(f,[p,d],p.dtype),y=We({inputs:{x:g},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),y}const z9={kernelName:Qy,backendName:"webgl",kernelFunc:P9};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class M9{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=Vt(this.rank),r=B9(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function B9(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("index"):s.push(`${t[r]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s2(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:o}=e,{axis:i,batchDims:a}=s,l=kt(i,r.shape)[0];if(ue().get("DEBUG")){const w=t.readSync(o.dataId),C=r.shape[l];for(let v=0;v<w.length;++v){const I=w[v];A(I<=C-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${C-1}]`)}}const u=qx(r,o,l,a),c=pe(o.shape),h=[],d=We({inputs:{x:r},backend:t,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=We({inputs:{x:o},backend:t,attrs:{shape:[u.batchSize,c/u.batchSize]}});h.push(d),h.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(t.shouldExecuteOnCPU([r,o])||r.dtype==="string"){const w=t.bufferSync(p),C=t.bufferSync(d),v=WX(C,w,f);return h.forEach(I=>t.disposeIntermediateTensorInfo(I)),t.makeTensorInfo(u.outputShape,v.dtype,v.values)}const g=new M9(d.shape,f),y=t.runWebGLProgram(g,[d,p],d.dtype);h.push(y);const b=We({inputs:{x:y},backend:t,attrs:{shape:u.outputShape}});return h.forEach(w=>t.disposeIntermediateTensorInfo(w)),b}const V9={kernelName:fp,backendName:"webgl",kernelFunc:s2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W9="return float(a > b);",U9=`
  return vec4(greaterThan(a, b));
`,G9=Hn({opSnippet:W9,packedOpSnippet:U9,cpuKernelImpl:UX,dtype:"bool"}),H9={kernelName:mp,backendName:"webgl",kernelFunc:G9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j9="return float(a >= b);",K9=`
  return vec4(greaterThanEqual(a, b));
`,q9=Hn({opSnippet:j9,packedOpSnippet:K9,dtype:"bool",cpuKernelImpl:GX}),X9={kernelName:Zu,backendName:"webgl",kernelFunc:q9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y9(n){const{inputs:e,backend:t}=n,{input:s}=e;return n2(s,!0,t)}const Z9={kernelName:eb,backendName:"webgl",kernelFunc:Y9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J9="return float(!isnan(x) && !isinf(x));",Q9=Dt({opSnippet:J9,dtype:"bool"}),eZ={kernelName:Qu,backendName:"webgl",kernelFunc:Q9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tZ="return float(isinf(x));",nZ=Dt({opSnippet:tZ,dtype:"bool"}),sZ={kernelName:ec,backendName:"webgl",kernelFunc:nZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rZ="return float(isnan(x));",oZ=Dt({opSnippet:rZ,dtype:"bool"}),iZ={kernelName:tc,backendName:"webgl",kernelFunc:oZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aZ="return float(a < b);",lZ=`
  return vec4(lessThan(a, b));
`,uZ=Hn({opSnippet:aZ,packedOpSnippet:lZ,cpuKernelImpl:HX,dtype:"bool"}),cZ={kernelName:yp,backendName:"webgl",kernelFunc:uZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hZ="return float(a <= b);",dZ=`
  return vec4(lessThanEqual(a, b));
`,pZ=Hn({opSnippet:hZ,packedOpSnippet:dZ,cpuKernelImpl:jX,dtype:"bool"}),fZ={kernelName:bp,backendName:"webgl",kernelFunc:pZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mZ(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:o}=t,i=KX(s,r,o);return e.makeTensorInfo([i.length],"float32",i)}const gZ={kernelName:nb,backendName:"webgl",kernelFunc:mZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yZ=Tl+`
  return x < 0.0 ? 0./0. : log(x);
`,bZ=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,xZ=Dt({opSnippet:yZ,packedOpSnippet:bZ,cpuKernelImpl:qX}),wZ={kernelName:nc,backendName:"webgl",kernelFunc:xZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vZ=Tl+`
  return log(1.0 + x);
`,kZ=Dt({opSnippet:vZ}),CZ={kernelName:sc,backendName:"webgl",kernelFunc:kZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SZ="return float(a >= 1.0 && b >= 1.0);",IZ=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,$Z=Hn({opSnippet:SZ,packedOpSnippet:IZ,dtype:"bool"}),NZ={kernelName:xp,backendName:"webgl",kernelFunc:$Z};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TZ="return float(!(x >= 1.0));",EZ=Dt({opSnippet:TZ}),_Z={kernelName:wp,backendName:"webgl",kernelFunc:EZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AZ="return float(a >= 1.0 || b >= 1.0);",RZ=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,DZ=Hn({opSnippet:AZ,packedOpSnippet:RZ,dtype:"bool"}),OZ={kernelName:vp,backendName:"webgl",kernelFunc:DZ};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FZ{constructor(e,t,s,r,o){this.variableNames=["x"],this.outputShape=[];const i=t,a=e[3]-1;this.outputShape=e;let l;const u=`float(${s}) + float(${r}) * sum`;o===.5?l=`inversesqrt(${u})`:o===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LZ{constructor(e,t,s,r,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=t,a=e[3]-1;this.outputShape=e;let l;const u=`float(${s}) + float(${r}) * sum`;o===.5?l=`inversesqrt(${u})`:o===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PZ=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:o,bias:i,alpha:a,beta:l}=s,u=ue().getBool("WEBGL_PACK_NORMALIZATION")?new LZ(r.shape,o,i,a,l):new FZ(r.shape,o,i,a,l);return t.runWebGLProgram(u,[r],r.dtype)},zZ={kernelName:kp,backendName:"webgl",kernelFunc:PZ};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MZ{constructor(e,t,s,r,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=r,this.beta=o,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${o})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${o});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BZ=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r,y:o,dy:i}=e,{depthRadius:a,bias:l,alpha:u,beta:c}=s,h=new MZ(r.shape,a,l,u,c);return t.runWebGLProgram(h,[r,o,i],r.dtype)},VZ={kernelName:sb,backendName:"webgl",kernelFunc:BZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WZ(n,e,t,s){const r=pe(e),i=pe(n.shape)/r,a=We({inputs:{x:n},attrs:{shape:[i,r]},backend:s}),l=wa(a,n.dtype,"max",s),u=We({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r2(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:o,keepDims:i}=s,a=r.shape.length,l=kt(o,r.shape);let u=l;const c=an(u,a),h=c!=null,d=t.shouldExecuteOnCPU([r]);let p=r;if(h){if(d){const C=t.texData.get(p.dataId).values,v=new Array(a);for(let R=0;R<v.length;R++)v[R]=r.shape[c[R]];const I=A0(C,r.shape,r.dtype,c,v);p=t.makeTensorInfo(v,r.dtype);const E=t.texData.get(p.dataId);E.values=I}else p=Mf(r,c,t);u=pn(u.length,a)}Un("max",u,a);const[f,g]=Fn(p.shape,u);let y=f;i&&(y=dn(f,l));let b;if(d){const C=t.texData.get(p.dataId).values,v=XX(C,pe(g),y,r.dtype);b=t.makeTensorInfo(y,r.dtype);const I=t.texData.get(b.dataId);I.values=v}else b=WZ(p,g,y,t);return h&&t.disposeIntermediateTensorInfo(p),b}const UZ={kernelName:Cp,backendName:"webgl",kernelFunc:r2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GZ=R0+`
  return max(a, b);
`,HZ=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+xa+`
  return result;
`,jZ=Hn({opSnippet:GZ,packedOpSnippet:HZ,cpuKernelImpl:YX}),KZ={kernelName:rc,backendName:"webgl",kernelFunc:jZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qZ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;qc(r,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=s,u=1;A(Wn(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=pr(r.shape,o,i,u,a,l);if(c.filterWidth===1&&c.filterHeight===1&&Tt(c.inShape,c.outShape))return zs({inputs:{x:r},backend:t});const h=new Su(c,"max",!1);return t.runWebGLProgram(h,[r],r.dtype)}const XZ={kernelName:Sp,backendName:"webgl",kernelFunc:qZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YZ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:i,pad:a,dataFormat:l,dimRoundingMode:u}=s,c=[1,1,1],h=Io(r.shape,o,i,c,a,u,l),d=new O0(h,"max",!1);return t.runWebGLProgram(d,[r],r.dtype)}const ZZ={kernelName:Ip,backendName:"webgl",kernelFunc:YZ};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JZ{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,o=e.effectiveFilterHeight,i=e.effectiveFilterWidth,a=o-1-e.padInfo.top,l=i-1-e.padInfo.left,u=o*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class QZ{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,o=e.dilationDepth,i=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterDepth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,h=l-1-e.padInfo.front,d=u-1-e.padInfo.top,p=c-1-e.padInfo.left,f=l*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${d}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eJ(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,i=o,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=s,h=[1,1,1],d=Io(i.shape,a,l,h,u,c),p=new O0(d,"max",!0),f=t.runWebGLProgram(p,[i],i.dtype),g=new QZ(d),y=t.runWebGLProgram(g,[r,f],i.dtype);return t.disposeIntermediateTensorInfo(f),y}const tJ={kernelName:ob,backendName:"webgl",kernelFunc:eJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nJ(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o,output:i}=e,a=o;qc([o,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,d=pr(a.shape,l,u,1,c,h),p=!0,f=new Su(d,"max",p),g=t.runWebGLProgram(f,[a],a.dtype),y=new JZ(d),b=t.runWebGLProgram(y,[r,g],a.dtype);return t.disposeIntermediateTensorInfo(g),b}const sJ={kernelName:rb,backendName:"webgl",kernelFunc:nJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rJ(n,e,t,s){let r=new Su(t,"max",!1);const o=s.runWebGLProgram(r,[n],"float32");r=new Su(t,"max",!0,!0,e);const i=s.runWebGLProgram(r,[n],"float32");return[o,i]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oJ={kernelName:ib,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:o,pad:i,includeBatchInIndex:a}=e,l=t;A(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const u=[1,1];A(Wn(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=pr(s.shape,r,o,u,i),[h,d]=rJ(s,a,c,l);return[h,d]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iJ(n,e,t,s){const r=pe(e),i=pe(n.shape)/r,a=We({inputs:{x:n},attrs:{shape:[i,r]},backend:s}),l=wa(a,"float32","mean",s),u=We({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aJ={kernelName:$p,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:r,axis:o}=e,i=t,a=s.shape.length,l=kt(o,s.shape);let u=l;const c=an(u,a),h=c!=null,d=i.shouldExecuteOnCPU([s]),p=[];let f=s;if(h){if(d){const v=i.texData.get(f.dataId).values,I=new Array(a);for(let L=0;L<I.length;L++)I[L]=s.shape[c[L]];const E=A0(v,s.shape,s.dtype,c,I);f=i.makeTensorInfo(I,s.dtype);const R=i.texData.get(f.dataId);R.values=E}else f=Mf(s,c,i);p.push(f),u=pn(u.length,a)}Un("sum",u,a);const[g,y]=Fn(f.shape,u);let b=g;r&&(b=dn(g,l));const w=iJ(f,y,b,i);for(const C of p)i.disposeIntermediateTensorInfo(C);return w}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s,a=r.shape.length,l=kt(o,r.shape);let u=l;const c=an(u,a);let h=r;c!=null&&(h=hs({inputs:{x:r},backend:t,attrs:{perm:c}}),u=pn(u.length,r.shape.length)),Un("min",u,a);const[d,p]=Fn(h.shape,u),f=pe(p),g=We({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),y=wa(g,g.dtype,"min",t);let b;if(i){const w=dn(d,l);b=We({inputs:{x:y},backend:t,attrs:{shape:w}})}else b=We({inputs:{x:y},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),c!=null&&t.disposeIntermediateTensorInfo(h),b}const uJ={kernelName:Np,backendName:"webgl",kernelFunc:lJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cJ=R0+`
  return min(a, b);
`,hJ=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+xa+`
  return result;
`,dJ=Hn({opSnippet:cJ,packedOpSnippet:hJ,cpuKernelImpl:ZX}),pJ={kernelName:oc,backendName:"webgl",kernelFunc:dJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fJ{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((c,h)=>c[0]+e[h]+c[1]);const r=e.length,o=Vt(r),i=t.map(c=>c[0]).join(","),a=t.map((c,h)=>c[0]+e[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${i});
      ${o} end = ${o}(${a});

      void main() {
        ${o} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${o} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mJ{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((f,g)=>f[0]+e[g]+f[1]);const r=e.length,o=Vt(r),i=t.map(f=>f[0]).join(","),a=t.map((f,g)=>f[0]+e[g]).join(","),l=as("rc",r),u=as("source",r),c=`${l[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${u.slice(-2).join()})`,d=s==="reflect"?0:1;let p="";if(r===1){const f=`
        ${o} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;p=`
        ${o} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${l[r-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
      `}else{const f=`
        ${o} source = rc;
        ${o} lt = ${o}(lessThan(source, start));
        ${o} gte = ${o}(greaterThanEqual(source, end));
        ${o} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;p=`
        ${o} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${l[r-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
        rc = outputLoc;
        ${l[r-2]} += 1;
        if(${l[r-2]} < ${this.outputShape[r-2]}) {
          ${f}
          result[2] = getChannel(getX(${u.join()}), ${h});
          ${l[r-1]} += 1;
          if(${c}) {
            ${f}
            result[3] = getChannel(getX(${u.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${o} start = ${o}(${i});
      const ${o} end = ${o}(${a});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gJ=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:r,mode:o}=t,i=ue().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new mJ(s.shape,r,o):new fJ(s.shape,r,o);return e.runWebGLProgram(i,[s],s.dtype)},yJ={kernelName:Tp,backendName:"webgl",kernelFunc:gJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bJ=`if (b == 0.0) return NAN;
  return mod(a, b);`,xJ=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+xa+`
  return result;
`,wJ=Hn({opSnippet:bJ,packedOpSnippet:xJ}),vJ={kernelName:ic,backendName:"webgl",kernelFunc:wJ};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kJ{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CJ=`
if (a == b) {
  return 1.0;
};
return a / b;`,SJ=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,o2=Hn({opSnippet:CJ,packedOpSnippet:SJ,checkOutOfBounds:!0}),IJ={kernelName:Gu,backendName:"webgl",kernelFunc:o2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C1="return a - b;",i2=Hn({opSnippet:C1,packedOpSnippet:C1,supportsComplex:!0,cpuKernelImpl:b5}),$J={kernelName:kc,backendName:"webgl",kernelFunc:i2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a2(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:o}=s,i=kt([o],r.shape),a=r2({inputs:{x:r},backend:t,attrs:{reductionIndices:i,keepDims:!1}}),l=dn(a.shape,i),u=We({inputs:{x:a},backend:t,attrs:{shape:l}}),c=i2({inputs:{a:r,b:u},backend:t}),h=t2({inputs:{x:c},backend:t}),d=Bf({inputs:{x:h},backend:t,attrs:{axis:i,keepDims:!1}}),p=We({inputs:{x:d},backend:t,attrs:{shape:l}}),f=o2({inputs:{a:h,b:p},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),f}const NJ={kernelName:jp,backendName:"webgl",kernelFunc:a2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TJ(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:o,seed:i,normalized:a}=s,l=a?r:a2({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),u=l.shape[0],c=l.shape[1],h=new kJ(u,c,o),d=[[i]],p=t.runWebGLProgram(h,[l],"int32",d);return a||t.disposeIntermediateTensorInfo(l),p}const EJ={kernelName:ab,backendName:"webgl",kernelFunc:TJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _J=mr+`
  return -x;
`,AJ=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function RJ(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const o=t.texData.get(s.dataId),[i,a]=QX(o.values,s.shape,s.dtype);return t.makeTensorInfo(a,s.dtype,i)}let r;return ue().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new qo(s.shape,AJ):r=new Vr(s.shape,_J),t.runWebGLProgram(r,[s],s.dtype)}const DJ={kernelName:Ep,backendName:"webgl",kernelFunc:RJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OJ=yx;function FJ(n){Us("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=s,u=t.readSync(r.dataId),c=t.readSync(o.dataId),{selectedIndices:h}=OJ(u,c,i,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const LJ={kernelName:lb,backendName:"webgl",kernelFunc:FJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PJ=bx;function zJ(n){Us("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=s,c=t.readSync(r.dataId),h=t.readSync(o.dataId),{selectedIndices:d,validOutputs:p}=PJ(c,h,i,a,l,u);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const MJ={kernelName:ub,backendName:"webgl",kernelFunc:zJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BJ=xx;function VJ(n){Us("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=s,c=t.readSync(r.dataId),h=t.readSync(o.dataId),d=i,p=a,f=l,g=u,{selectedIndices:y,selectedScores:b}=BJ(c,h,d,p,f,g);return[t.makeTensorInfo([y.length],"int32",new Int32Array(y)),t.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const WJ={kernelName:cb,backendName:"webgl",kernelFunc:VJ};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UJ{constructor(e,t,s,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GJ=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:o,depth:i,onValue:a,offValue:l}=s,u=pe(r.shape),c=new UJ(u,i,a,l),h=We({inputs:{x:r},backend:t,attrs:{shape:[u]}}),d=t.runWebGLProgram(c,[h],o);t.disposeIntermediateTensorInfo(h);const p=[...r.shape,i],f=We({inputs:{x:d},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(d),f},HJ={kernelName:Rp,backendName:"webgl",kernelFunc:GJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Od(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=Yc({inputs:{input:s},backend:t}),o=Od({inputs:{x:r},backend:t}),i=Vf({inputs:{input:s},backend:t}),a=Od({inputs:{x:i},backend:t}),l=Ci({inputs:{real:o,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),l}else return Zc({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const jJ={kernelName:Yp,backendName:"webgl",kernelFunc:Od};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l2(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=Yc({inputs:{input:s},backend:t}),o=l2({inputs:{x:r},backend:t}),i=Vf({inputs:{input:s},backend:t}),a=Od({inputs:{x:i},backend:t}),l=Ci({inputs:{real:o,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),l}else return Zc({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const KJ={kernelName:Ap,backendName:"webgl",kernelFunc:l2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qJ(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return cy({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const o=e[0].shape,i=e[0].dtype;e.forEach(c=>{Ms(o,c.shape,"All tensors passed to stack must have matching shapes"),A(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(c=>{const h=cy({inputs:{input:c},backend:t,attrs:{dim:r}});return a.push(h),h}),u=KT({inputs:l,backend:t,attrs:{axis:r}});return a.forEach(c=>t.disposeIntermediateTensorInfo(c)),u}const XJ={kernelName:Dp,backendName:"webgl",kernelFunc:qJ};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YJ{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((u,c)=>u[0]+e[c]+u[1]);const r=e.length,o=Vt(r),i=t.map(u=>u[0]).join(","),a=t.map((u,c)=>u[0]+e[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${i});
      ${o} end = ${o}(${a});

      void main() {
        ${o} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${o} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZJ{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((g,y)=>g[0]+e[y]+g[1]);const r=e.length,o=Vt(r),i=t.map(g=>g[0]).join(","),a=t.map((g,y)=>g[0]+e[y]).join(","),l=as("rc",r),u=as("source",r),c=`${l[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${u.slice(-2).join()})`,d=[`${o} rc = outputLoc;`,`${l[r-1]} += 1;
       if(${c}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${l[r-2]} += 1;
       if(${l[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${l[r-1]} += 1;
         if(${c}) {`],p=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let g=0,y=r===1?2:4;g<y;g++)f+=`
        ${d[g]}
        if (${p}) {
          result[${g}] = float(value);
        } else {
          ${o} source = rc - start;
          result[${g}] = getChannel(getX(${u.join()}), ${h});
        }
      `;f+=r===1?"} ":"}}",this.userCode=`
      const ${o} start = ${o}(${i});
      const ${o} end = ${o}(${a});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u2=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:o,constantValue:i}=s;if(pe(r.shape)===0){const u=o.map((c,h)=>c[0]+r.shape[h]+c[1]);return Zc({backend:t,attrs:{shape:u,value:i,dtype:r.dtype}})}const a=ue().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ZJ(r.shape,o,i):new YJ(r.shape,o,i),l=[[i]];return t.runWebGLProgram(a,[r],r.dtype,l)},JJ={kernelName:Op,backendName:"webgl",kernelFunc:u2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QJ=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,eQ=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+xa+`
  return result;
`,tQ=Hn({opSnippet:QJ,packedOpSnippet:eQ}),nQ={kernelName:lc,backendName:"webgl",kernelFunc:tQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s,a=r.shape.length,l=[],u=kt(o,r.shape);let c=u;const h=an(c,a);let d=r;h!=null&&(d=hs({inputs:{x:r},backend:t,attrs:{perm:h}}),c=pn(c.length,a),l.push(d)),Un("prod",c,a);let p;if(t.shouldExecuteOnCPU([d])){const f=t.texData.get(d.dataId).values,{outVals:g,outShape:y,outDtype:b}=t5(d.shape,d.dtype,f,c);p=t.makeTensorInfo(y,b,g)}else{const[f,g]=Fn(d.shape,c),y=pe(g),b=We({inputs:{x:d},backend:t,attrs:{shape:[-1,y]}}),w=Fb(r.dtype),C=wa(b,w,"prod",t);p=We({inputs:{x:C},backend:t,attrs:{shape:f}}),l.push(b),l.push(C)}if(i){l.push(p);const f=dn(p.shape,u);p=We({inputs:{x:p},backend:t,attrs:{shape:f}})}return l.forEach(f=>t.disposeIntermediateTensorInfo(f)),p}const rQ={kernelName:Lp,backendName:"webgl",kernelFunc:sQ};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oQ(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:o,indices:i}=e,{outputRaggedRank:a}=s,l=r.map(b=>t.readSync(b.dataId)),u=r.map(b=>b.shape),c=t.readSync(o.dataId),h=t.readSync(i.dataId),[d,p,f]=n5(l,u,c,o.shape,o.dtype,h,i.shape,a),g=d.map(b=>t.makeTensorInfo([b.length],"int32",b)),y=t.makeTensorInfo(f,o.dtype,p);return g.concat([y])}const iQ={kernelName:hb,backendName:"webgl",kernelFunc:oQ};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aQ(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:o}=e,i=t.readSync(s.dataId),a=t.readSync(r.dataId),l=t.readSync(o.dataId),[u,c]=s5(i,s.shape,s.dtype,a,r.shape,l,o.shape),h=t.makeTensorInfo([u.length],"int32",u),d=t.makeTensorInfo([c.length],s.dtype,c);return[h,d]}const lQ={kernelName:db,backendName:"webgl",kernelFunc:aQ};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uQ(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:o,defaultValue:i,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=s,u=t.readSync(r.dataId),c=t.readSync(o.dataId),h=t.readSync(i.dataId),d=a.map(y=>t.readSync(y.dataId)),p=a.map(y=>y.shape),[f,g]=r5(u,r.shape,c,o.shape,o.dtype,h,i.shape,d,p,l);return t.makeTensorInfo(f,o.dtype,g)}const cQ={kernelName:pb,backendName:"webgl",kernelFunc:uQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c2=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:o,dtype:i}=t,a=o5(s,r,o,i);return e.makeTensorInfo([a.length],i,a)},hQ={kernelName:fb,backendName:"webgl",kernelFunc:c2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dQ="return 1.0 / x;",pQ=Dt({opSnippet:dQ}),fQ={kernelName:uc,backendName:"webgl",kernelFunc:pQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mQ=mr+`
  return (x < 0.0) ? 0.0 : x;
`,gQ=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,yQ=Dt({opSnippet:mQ,packedOpSnippet:gQ}),bQ={kernelName:cc,backendName:"webgl",kernelFunc:yQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xQ=mr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,wQ=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,vQ=Dt({opSnippet:xQ,packedOpSnippet:wQ}),kQ={kernelName:hc,backendName:"webgl",kernelFunc:vQ};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CQ{constructor(e,t,s,r,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,u]=e;this.outputShape=[i,t,s,u];const c=[r&&t>1?a-1:a,r&&s>1?l-1:l],h=[r&&t>1?t-1:t,r&&s>1?s-1:s];let d;o?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/h[0]},
          ${c[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SQ{constructor(e,t,s,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,u]=e;this.outputShape=[i,t,s,u];const c=[r&&t>1?a-1:a,r&&s>1?l-1:l],h=[r&&t>1?t-1:t,r&&s>1?s-1:s];let d;o?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IQ(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:o,halfPixelCenters:i,size:a}=s,[l,u]=a,c=ue().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new SQ(r.shape,l,u,o,i):new CQ(r.shape,l,u,o,i);return t.runWebGLProgram(c,[r],"float32")}const $Q={kernelName:Mp,backendName:"webgl",kernelFunc:IQ};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NQ{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,o]=t,[,i,a]=e,l=[s&&i>1?r-1:r,s&&a>1?o-1:o],u=[s&&i>1?i-1:i,s&&a>1?a-1:a],c=l[0]/u[0],h=l[1]/u[1],d=1/c,p=1/h,f=Math.ceil(d)*2+2,g=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TQ(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:o}=e,{alignCorners:i}=s,a=new NQ(o.shape,r.shape,i);return t.runWebGLProgram(a,[o],o.dtype)}const EQ={kernelName:yb,backendName:"webgl",kernelFunc:TQ};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _Q{constructor(e,t,s,r,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,u]=e;this.outputShape=[i,t,s,u];const c=[r&&t>1?a-1:a,r&&s>1?l-1:l],h=[r&&t>1?t-1:t,r&&s>1?s-1:s],d=r?"0.5":"0.0";let p;o?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/h[0]},
          ${c[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AQ{constructor(e,t,s,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,u]=e;this.outputShape=[i,t,s,u];const c=[r&&t>1?a-1:a,r&&s>1?l-1:l],h=[r&&t>1?t-1:t,r&&s>1?s-1:s],d=r?"0.5":"0.0";let p;o?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RQ(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:o,halfPixelCenters:i,size:a}=s,[l,u]=a,c=ue().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new AQ(r.shape,l,u,o,i):new _Q(r.shape,l,u,o,i);return t.runWebGLProgram(c,[r],r.dtype)}const DQ={kernelName:zp,backendName:"webgl",kernelFunc:RQ};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OQ{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,o]=t,[,i,a]=e,l=[s&&i>1?r-1:r,s&&a>1?o-1:o],u=[s&&i>1?i-1:i,s&&a>1?a-1:a],c=l[0]/u[0],h=l[1]/u[1],d=1/c,p=1/h,f=Math.ceil(d)*2+2,g=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${o}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FQ(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:o}=e,{alignCorners:i}=s,a=new OQ(o.shape,r.shape,i);return t.runWebGLProgram(a,[o],o.dtype)}const LQ={kernelName:gb,backendName:"webgl",kernelFunc:FQ};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PQ{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,o=e.map((a,l)=>r(l)).join(","),i=Vt(s);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zQ{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=as("rc",s),o=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,i=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,a=Vt(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${o}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(r.slice())};
          if(${o}){
            result.g = ${u(r.slice())};
          }
          if(${i}) {
            result.b = ${c(r.slice())};
            if(${o}) {
              result.a = ${h(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(f){return d(f)}function u(f){return f[s-1]="("+f[s-1]+" + 1)",d(f)}function c(f){return f[s-2]="("+f[s-2]+" + 1)",d(f)}function h(f){return f[s-1]="("+f[s-1]+" + 1)",f[s-2]="("+f[s-2]+" + 1)",d(f)}function d(f){const g=e.map((w,C)=>p(C,f)),y=g.join(","),b=g.slice(-2).join(",");return`getChannel(getX(${y}), vec2(${b}))`}function p(f,g){return t.indexOf(f)!==-1&&e[f]!==1?`${e[f]} - ${g[f]} - 1`:`${g[f]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:o}=s,i=r.shape.length,a=kt(o,r.shape);if(i===0)return zs({inputs:{x:r},backend:t});const l=ue().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zQ(r.shape,a):new PQ(r.shape,a);return t.runWebGLProgram(l,[r],r.dtype)}const BQ={kernelName:Bp,backendName:"webgl",kernelFunc:MQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VQ{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let o="";typeof t=="number"?o=`float outputValue = ${t.toFixed(2)};`:o=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${o}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WQ={kernelName:Ob,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:o,center:i}=e,a=t,l=new VQ(s.shape,o),[u,c]=Rx(i,s.shape[1],s.shape[2]),h=[[u,c,Math.sin(r),Math.cos(r)]];return a.runWebGLProgram(l,[s],s.dtype,h)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UQ=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,GQ=Dt({opSnippet:UQ}),HQ={kernelName:dc,backendName:"webgl",kernelFunc:GQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jQ="return inversesqrt(x);",KQ=Dt({opSnippet:jQ,cpuKernelImpl:i5}),qQ={kernelName:pc,backendName:"webgl",kernelFunc:KQ};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F0{constructor(e,t,s,r,o,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const u=Vt(o.length),c=Vt(i.length);let h="";s===1?h="i":s===2&&(h="i, j");const d=`getIndices(${h})`;let p="";r===1?p="i":r===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let g="";l&&(g="coords[0], coords[1]");const y=`getDefaultValue(${g})`,b=t>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${o});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${b};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(${y}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XQ{constructor(e,t,s,r,o,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const u=Vt(o.length),c=Vt(i.length);let h="";s===1?h="i":s===2&&(h="i, j");const d=`getIndices(${h})`;let p="";r===1?p="i":r===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let g="";l&&(g="coords[0], coords[1]");const y=`getDefaultValue(${g})`,b=t>1?"strides[j]":"strides",w=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${u} strides = ${u}(${o});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${b};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${w};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${f};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${y}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YQ(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:o}=e,{shape:i}=s,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=fa(o,r,i),d=[h/u,u];if(h===0)return t.makeTensorInfo(i,r.dtype);const p=We({inputs:{x:r},backend:t,attrs:{shape:[l,a]}}),f=We({inputs:{x:o},backend:t,attrs:{shape:[l,u]}}),g=t.makeTensorInfo([],"float32",new Float32Array([0]));let y;ue().getBool("WEBGL_PACK")?y=new XQ(l,a,p.shape.length,f.shape.length,c,d):y=new F0(l,a,p.shape.length,f.shape.length,c,d);const b=t.runWebGLProgram(y,[f,p,g],f.dtype),w=We({inputs:{x:b},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(g),w}const ZQ={kernelName:bb,backendName:"webgl",kernelFunc:YQ};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JQ{constructor(e,t,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const o="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=ue().getNumber("WEBGL_VERSION")===2?o:i,l=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QQ(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:o}=e,{side:i}=s,a=new JQ(r.shape[0],r.shape[1],o.shape[1],i),l=[[r.shape[1]]];return t.runWebGLProgram(a,[r,o],"int32",l)}const eee={kernelName:wb,backendName:"webgl",kernelFunc:QQ};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tee{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let r,o;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)o="resRC",r="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<t.length;c++)u.push(`${a[c]}`),c<e&&l.push(`${a[c]}`);r=l.join(),o=u.join()}const i=Vt(s);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${o}));
        } else {
          setOutput(getB(${o}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nee(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:o}=e,i=new tee(s.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(i,[s,r,o],Ds(r.dtype,o.dtype))}const see={kernelName:Vp,backendName:"webgl",kernelFunc:nee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ree=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${Cf};
  float scale = ${Sf};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,oee=Dt({opSnippet:ree}),iee={kernelName:fc,backendName:"webgl",kernelFunc:oee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aee=Tl+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,lee=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,uee=Dt({opSnippet:aee,packedOpSnippet:lee,cpuKernelImpl:l5}),cee={kernelName:bc,backendName:"webgl",kernelFunc:uee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hee=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,dee=Dt({opSnippet:hee}),pee={kernelName:yc,backendName:"webgl",kernelFunc:dee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fee=Tl+`
  return sin(x);
`,mee=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${xa}
  return result;
`,gee=Dt({opSnippet:fee,packedOpSnippet:mee}),yee={kernelName:mc,backendName:"webgl",kernelFunc:gee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bee=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,xee=Dt({opSnippet:bee}),wee={kernelName:gc,backendName:"webgl",kernelFunc:xee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vee=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,kee=Dt({opSnippet:vee}),Cee={kernelName:xc,backendName:"webgl",kernelFunc:kee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const See=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:o,paddings:i}=s;A(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((b,w)=>b*w),l=[[0,0]];l.push(...i);for(let b=1+o.length;b<r.shape.length;++b)l.push([0,0]);const u=[],c=u2({inputs:{x:r},backend:t,attrs:{paddings:l,constantValue:0}}),h=Fc(c.shape,o,a,!1),d=Lc(h.length,o.length,!1),p=Pc(c.shape,o,a,!1),f=We({inputs:{x:c},backend:t,attrs:{shape:h}}),g=hs({inputs:{x:f},backend:t,attrs:{perm:d}}),y=We({inputs:{x:g},backend:t,attrs:{shape:p}});return u.push(c),u.push(f),u.push(g),u.forEach(b=>t.disposeIntermediateTensorInfo(b)),y},Iee={kernelName:Gp,backendName:"webgl",kernelFunc:See};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ee(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:o,defaultValue:i}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${o.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const a=t.readSync(s.dataId),l=t.readSync(r.dataId),u=t.readSync(o.dataId),c=t.readSync(i.dataId)[0],[h,d,p,f,g]=c5(a,s.shape,s.dtype,l,r.dtype,u,c);return[t.makeTensorInfo(d,s.dtype,h),t.makeTensorInfo([d[0]],r.dtype,p),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(y=>Number(y)))),t.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}const Nee={kernelName:vb,backendName:"webgl",kernelFunc:$ee};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tee(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:o}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(t.readSync(r.dataId)),a=t.readSync(s.dataId),l=Array.from(t.readSync(o.dataId)),[u,c,h]=h5(a,s.shape,s.dtype,i,l);return[t.makeTensorInfo(c,s.dtype,u),t.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}const Eee={kernelName:kb,backendName:"webgl",kernelFunc:Tee};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ee(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${o.shape}`);const i=t.readSync(s.dataId),a=t.readSync(r.dataId),l=t.readSync(o.dataId),[u,c]=OT(i,s.shape,s.dtype,a,l,!0);return t.makeTensorInfo(c,s.dtype,u)}const Aee={kernelName:Cb,backendName:"webgl",kernelFunc:_ee};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ree(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${o.shape}`);const i=t.readSync(s.dataId),a=t.readSync(r.dataId),l=t.readSync(o.dataId),[u,c]=OT(i,s.shape,s.dtype,a,l);return t.makeTensorInfo(c,s.dtype,u)}const Dee={kernelName:Sb,backendName:"webgl",kernelFunc:Ree};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oee(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:o,defaultValue:i}=e,{outputShape:a}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=fa(o,r,a),p=!1;if(o.dtype==="string"){const b=t.bufferSync(r),w=t.bufferSync(o),C=ei(t.readSync(i.dataId)[0]),v=a5(b,w,a,d,c,u,l,h,C,p);return t.makeTensorInfo(a,v.dtype,v.values)}const f=new F0(u,l,r.shape.length,o.shape.length,h,[d,1],p),g=t.runWebGLProgram(f,[o,r,i],o.dtype),y=We({inputs:{x:g},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(g),y}const Fee={kernelName:Ib,backendName:"webgl",kernelFunc:Oee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lee(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:o,axis:i}=s,a=kt(i,r.shape)[0],l=Kx(r,o,a),u=r.shape.length,c=new Array(u).fill(0),h=r.shape.slice();return l.map(d=>{const p=[...h];p[a]=d;const f=El({inputs:{x:r},backend:t,attrs:{begin:c,size:p}});return c[a]+=d,f})}const Pee={kernelName:Hp,backendName:"webgl",kernelFunc:Lee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S1="return sqrt(x);",zee=Dt({opSnippet:S1,packedOpSnippet:S1,cpuKernelImpl:d5}),Mee={kernelName:wc,backendName:"webgl",kernelFunc:zee};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bee="return x * x;",Vee=Dt({opSnippet:Bee}),Wee={kernelName:$b,backendName:"webgl",kernelFunc:Vee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I1="return (a - b) * (a - b);",Uee=Hn({opSnippet:I1,packedOpSnippet:I1}),Gee={kernelName:vc,backendName:"webgl",kernelFunc:Uee};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hee(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const o=t.readSync(r.dataId),i=vo(o),a=p5(i,"string",s);return t.makeTensorInfo(r.shape,"string",a)}const jee={kernelName:Kp,backendName:"webgl",kernelFunc:Hee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kee({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=mr+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,o=new Vr(s.shape,r);return t.runWebGLProgram(o,[s],s.dtype)}const qee={kernelName:$c,backendName:"webgl",kernelFunc:Kee};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xee{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,o=Vt(s.length),i=Vt(s.length);let a="";if(r===1)a="coords * strides + begin";else{let l=0;a=s.map((u,c)=>(l++,s.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${o} begin = ${o}(${e});
      ${o} strides = ${o}(${t});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yee(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:o,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=s,{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:w,end:C,strides:v}=Ex(r.shape,o,i,a,l,u,c,h,d);let I;if(g)I=We({inputs:{x:r},backend:t,attrs:{shape:f}});else if(y||b){A(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const R=$x(w,C,v),L=El({inputs:{x:r},backend:t,attrs:{begin:w,size:R}});I=We({inputs:{x:L},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(L)}else if(t.shouldExecuteOnCPU([r])){const L=t.readSync(r.dataId),D=wt(r.shape,r.dtype,L),F=f5(p,D,v,w);I=t.makeTensorInfo(f,r.dtype,F.values)}else{const L=new Xee(w,v,p);I=t.runWebGLProgram(L,[r],r.dtype)}const E=We({inputs:{x:I},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(I),E}const Zee={kernelName:Nb,backendName:"webgl",kernelFunc:Yee};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jee(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:h}=e,d=t.readSync(c.dataId),p=t.readSync(h.dataId),[f,g]=m5(d,p,r,o,i,a,l,u);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(h.shape,"int32",g)]}const Qee={kernelName:Tb,backendName:"webgl",kernelFunc:Jee};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ete(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:o,delimiter:i}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=t.readSync(o.dataId),l=t.readSync(i.dataId)[0],[u,c,h]=g5(a,l,r),d=c.length;return[t.makeTensorInfo([d,2],"int32",u),t.makeTensorInfo([d],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const tte={kernelName:Eb,backendName:"webgl",kernelFunc:ete};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nte(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const i=t.readSync(o.dataId),a=y5(i,r);return t.makeTensorInfo(o.shape,"int32",a)}const ste={kernelName:_b,backendName:"webgl",kernelFunc:nte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rte="return tan(x);",ote=Dt({opSnippet:rte}),ite={kernelName:Cc,backendName:"webgl",kernelFunc:ote};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ate=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,lte=Dt({opSnippet:ate}),ute={kernelName:Sc,backendName:"webgl",kernelFunc:lte};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cte(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:r,indices:o,updates:i}=e,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=fa(i,o,r.shape),d=[h/u,u];if(h===0)return t.makeTensorInfo(r.shape,o.dtype);const p=We({inputs:{x:o},backend:t,attrs:{shape:[l,a]}}),f=We({inputs:{x:i},backend:t,attrs:{shape:[l,u]}}),g=We({inputs:{x:r},backend:t,attrs:{shape:d}}),y=new F0(l,a,p.shape.length,f.shape.length,c,d,!1,!0),b=t.runWebGLProgram(y,[f,p,g],g.dtype),w=We({inputs:{x:b},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(b),w}const hte={kernelName:xb,backendName:"webgl",kernelFunc:cte};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dte{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let i=0;i<s.length;i++)s[i]=e[i]*t[i];this.outputShape=s,this.rank=s.length;const r=Vt(this.rank),o=pte(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}}function pte(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${t[r]}, ${n[r]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h2(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:o}=s;if(r.dtype==="string"||r.shape.length>5){const l=t.readSync(r.dataId),u=r.dtype==="string"?l.map(d=>ei(d)):l,c=wt(r.shape,r.dtype,u),h=x5(c,o);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const i=new dte(r.shape,o);return t.runWebGLProgram(i,[r],r.dtype)}const fte={kernelName:Ic,backendName:"webgl",kernelFunc:h2};class mte{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class gte{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oi(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function $1(n){let e=1;for(;e<n;)e*=2;return e}function yte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:o,sorted:i}=s,a=ue().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=ue().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=r.shape,c=u[u.length-1];if(t.shouldExecuteOnCPU([r])||c<a||o>l){const F=t.readSync(r.dataId),[T,V]=w5(F,u,r.dtype,o,i);return[t.makeTensorInfo(T.shape,T.dtype,T.values),t.makeTensorInfo(V.shape,V.dtype,V.values)]}if(o===0)return u[u.length-1]=0,[t.makeTensorInfo(u,r.dtype,[]),t.makeTensorInfo(u,"int32",[])];if(c===1)return[r,Zc({attrs:{shape:u,dtype:"int32",value:0},backend:t})];const h=t.texData.get(r.dataId),d=h!==null&&h.isPacked,p=d?t.unpackTensor(r):r,g=pe(u)/c,y=We({inputs:{x:p},attrs:{shape:[g,c]},backend:t});d&&Oi(t,p);const b=$1(o),w=$1(c);let C=null;const v=()=>C===null?[y,y]:[y,C],I=(F,T,V)=>{const q=v(),se=new mte(V),te=[[c],[C===null?1:0],[Number.NEGATIVE_INFINITY],[F],[T]],le=C;C=t.runWebGLProgram(se,q,"int32",te),Oi(t,le)};for(let F=1;F<b;F*=2){const T=F*2;for(let V=F;V>=1;V/=2)I(T,V,[g,w])}for(let F=w;F>b;F/=2){const T=v(),V=new gte([g,F/2]),se=[[c],[C===null?1:0],[b]],ee=C;C=t.runWebGLProgram(V,T,"int32",se),Oi(t,ee);const te=b/2,le=te*2;for(let Q=te;Q>=1;Q/=2)I(le,Q,C.shape)}let E=C;C=El({inputs:{x:C},backend:t,attrs:{begin:0,size:[g,o]}}),Oi(t,E);let R=s2({inputs:{x:y,indices:C},backend:t,attrs:{axis:1,batchDims:1}});Oi(t,y);const L=u.slice(0,-1);L.push(o),E=C,C=We({inputs:{x:C},attrs:{shape:L},backend:t}),Oi(t,E);const D=R;return R=We({inputs:{x:R},attrs:{shape:L},backend:t}),Oi(t,D),[R,C]}const bte={kernelName:Ab,backendName:"webgl",kernelFunc:yte};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xte{constructor(e,t,s,r,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a=s==="nearest"?1:2;let l;switch(r){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${o});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${o});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wte(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:o}=e,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=s,[c,h,d,p]=r.shape,[f,g]=u??[h,d],y=[c,f,g,p],b=new xte(h,d,i,a,l,y);return t.runWebGLProgram(b,[r,o],"float32")}const vte={kernelName:Rb,backendName:"webgl",kernelFunc:wte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kte(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:o}=e;qc(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=s.readSync(o.dataId),{outputValues:a,outputShape:l,indices:u}=v5(i,r,o.shape,o.dtype);return[s.makeTensorInfo(l,o.dtype,a),s.makeTensorInfo([u.length],"int32",u)]}const Cte={kernelName:Db,backendName:"webgl",kernelFunc:kte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ste(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:o}=s;o<0&&(o+=r.shape.length);const i=r,a=i.shape.length,l=r.shape[o],u=new Array(a-1);let c=0;for(let g=0;g<a;g++)g!==o&&(u[c++]=i.shape[g]);const h=[],d=new Array(a).fill(0),p=i.shape.slice();p[o]=1;const f=new Array(l);for(let g=0;g<f.length;g++){d[o]=g;const y=El({inputs:{x:i},backend:t,attrs:{begin:d,size:p}}),b=We({inputs:{x:y},backend:t,attrs:{shape:u}});f[g]=b,h.push(y)}return h.forEach(g=>t.disposeIntermediateTensorInfo(g)),f}const Ite={kernelName:qp,backendName:"webgl",kernelFunc:Ste};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $te{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,o=e.inSize,i=e.numSegments,a=i*Math.ceil(o/s);this.outputShape=[r,a];const l="0.0",u="sumValue",c=Math.floor(s/4)*4,h=s%4,d=`
        sumValue += dot(values, segFilter);
    `;let p="";o%s>0&&(p=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `);let f="";o%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${u});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:o}=e,{numSegments:i}=s,a=r.shape.length,l=[];let u=0;const c=an([u],a);let h=r;c!=null&&(h=hs({inputs:{x:r},backend:t,attrs:{perm:c}}),l.push(h),u=pn(1,a)[0]);const d=US(h.shape,u,i),p=pe([h.shape[u]]),f=We({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}});l.push(f);const g=Fb(r.dtype),y=(v,I,E,R,L)=>{const D=v.shape[0],F=v.shape[1],T=WS(F,L),V={windowSize:T,inSize:F,batchSize:D,numSegments:L},q=new $te(V,I),se=t.compileAndRun(q,[v,E],R);if(l.push(se),se.shape[1]===L)return se;const ee=c2({backend:t,attrs:{start:0,stop:L,step:1,dtype:"float32"}}),te=h2({inputs:{x:ee},backend:t,attrs:{reps:[F/T]}});return l.push(ee),l.push(te),y(se,I,te,R,L)},b=y(f,"unsortedSegmentSum",o,g,i),w=We({inputs:{x:b},backend:t,attrs:{shape:d}});let C=w;if(c!=null){l.push(w);const v=yi(c);C=hs({inputs:{x:C},backend:t,attrs:{perm:v}})}return l.forEach(v=>t.disposeIntermediateTensorInfo(v)),C}const Tte={kernelName:Xp,backendName:"webgl",kernelFunc:Nte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ete=[d8,f8,y8,w8,k8,I8,N8,E8,D8,F8,z8,V8,G8,q8,Z8,Q8,tY,oY,aY,uY,pY,wY,kY,$Y,TY,OY,LY,BY,X5,UY,qY,JY,r7,a7,u7,h7,p7,y7,w7,C7,I7,N7,E7,R7,O7,z7,B7,U7,j7,q7,J7,n9,i9,u9,d9,p9,m9,y9,x9,v9,C9,N9,_9,D9,F9,z9,V9,H9,X9,q5,Z9,jY,eZ,sZ,iZ,Z5,cZ,fZ,gZ,wZ,CZ,NZ,_Z,OZ,zZ,VZ,UZ,KZ,XZ,ZZ,tJ,sJ,oJ,aJ,uJ,pJ,yJ,vJ,EJ,e8,DJ,LJ,MJ,WJ,_Y,HJ,KJ,XJ,JJ,nQ,Q5,rQ,iQ,lQ,cQ,hQ,AY,IJ,fQ,bQ,kQ,n8,$Q,EQ,DQ,LQ,BQ,WQ,HQ,qQ,ZQ,eee,see,iee,cee,pee,yee,wee,bY,NJ,Cee,Iee,Nee,Eee,Aee,Dee,Fee,Pee,Mee,Wee,Gee,jee,qee,Zee,Qee,tte,ste,$J,u8,ite,ute,hte,fte,bte,vte,c8,Cte,Ite,Tte,jJ];for(const n of Ete)fk(n);var _te=class{constructor(n){Bo(this,"model");Bo(this,"dict",[]);Bo(this,"canvas");Bo(this,"ctx");Bo(this,"modelPath");Bo(this,"dictPath");Bo(this,"backend");this.modelPath=n.modelPath,this.dictPath=n.dictPath,this.backend=n.backend||"cpu",this.canvas=document.createElement("canvas"),this.canvas.width=this.canvas.height=64,this.ctx=this.canvas.getContext("2d",{willReadFrequently:!0})}async initialize(){const n=await fetch(this.dictPath).then(e=>e.text());return this.dict=n.split(`
`),this.model=await c4(this.modelPath),this.backend==="webgl"?(await Hw("webgl"),await J_(),await this.recognize([10,10,0,20,20,1])):await Hw("cpu"),!0}async recognize(n){if(!this.model)throw new Error("Model not initialized");const{canvas:e,ctx:t,model:s,dict:r}=this;t.fillStyle="white",t.fillRect(0,0,e.width,e.height);const o=n.length/3,i=Array.from({length:o},(b,w)=>({x:n[3*w],y:n[3*w+1],isEnd:n[3*w+2]===1}));let a=1/0,l=1/0,u=-1/0,c=-1/0;for(const{x:b,y:w}of i)b<a&&(a=b),b>u&&(u=b),w<l&&(l=w),w>c&&(c=w);const h=u-a||1,d=c-l||1,p=(a+u)/2,f=(l+c)/2,g=Math.min(e.width*.9/h,e.height*.9/d);t.strokeStyle="black",t.lineWidth=2,t.lineCap="round",t.lineJoin="round";let y=null;for(const b of i){const w=e.width/2+(b.x-p)*g,C=e.height/2+(b.y-f)*g;y&&!y.isEnd?(t.beginPath(),t.moveTo(e.width/2+(y.x-p)*g,e.height/2+(y.y-f)*g),t.lineTo(w,C),t.stroke()):(t.beginPath(),t.moveTo(w,C)),y=b}return oe(()=>{const b=N3(e,3).toFloat().div(255).expandDims(),w=s.predict(b).dataSync(),C=Array.from(w.keys()).sort((v,I)=>w[I]-w[v]).slice(0,10);return vt(b),C.map(v=>v<r.length?r[v]:"").filter(Boolean)})}async close(){var n;(n=this.model)==null||n.dispose(),this.model=void 0}};/**
* @vue/shared v3.5.15
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function L0(n){const e=Object.create(null);for(const t of n.split(","))e[t]=1;return t=>t in e}const Lt={},Ha=[],Kr=()=>{},Ate=()=>!1,Wf=n=>n.charCodeAt(0)===111&&n.charCodeAt(1)===110&&(n.charCodeAt(2)>122||n.charCodeAt(2)<97),P0=n=>n.startsWith("onUpdate:"),Yn=Object.assign,z0=(n,e)=>{const t=n.indexOf(e);t>-1&&n.splice(t,1)},Rte=Object.prototype.hasOwnProperty,Mt=(n,e)=>Rte.call(n,e),ut=Array.isArray,ja=n=>Jc(n)==="[object Map]",Uf=n=>Jc(n)==="[object Set]",N1=n=>Jc(n)==="[object Date]",gt=n=>typeof n=="function",xn=n=>typeof n=="string",Qr=n=>typeof n=="symbol",Qt=n=>n!==null&&typeof n=="object",d2=n=>(Qt(n)||gt(n))&&gt(n.then)&&gt(n.catch),p2=Object.prototype.toString,Jc=n=>p2.call(n),Dte=n=>Jc(n).slice(8,-1),f2=n=>Jc(n)==="[object Object]",M0=n=>xn(n)&&n!=="NaN"&&n[0]!=="-"&&""+parseInt(n,10)===n,su=L0(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),Gf=n=>{const e=Object.create(null);return t=>e[t]||(e[t]=n(t))},Ote=/-(\w)/g,ko=Gf(n=>n.replace(Ote,(e,t)=>t?t.toUpperCase():"")),Fte=/\B([A-Z])/g,Si=Gf(n=>n.replace(Fte,"-$1").toLowerCase()),m2=Gf(n=>n.charAt(0).toUpperCase()+n.slice(1)),sg=Gf(n=>n?`on${m2(n)}`:""),Es=(n,e)=>!Object.is(n,e),td=(n,...e)=>{for(let t=0;t<n.length;t++)n[t](...e)},g2=(n,e,t,s=!1)=>{Object.defineProperty(n,e,{configurable:!0,enumerable:!1,writable:s,value:t})},hy=n=>{const e=parseFloat(n);return isNaN(e)?n:e};let T1;const Hf=()=>T1||(T1=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});function jf(n){if(ut(n)){const e={};for(let t=0;t<n.length;t++){const s=n[t],r=xn(s)?Mte(s):jf(s);if(r)for(const o in r)e[o]=r[o]}return e}else if(xn(n)||Qt(n))return n}const Lte=/;(?![^(]*\))/g,Pte=/:([^]+)/,zte=/\/\*[^]*?\*\//g;function Mte(n){const e={};return n.replace(zte,"").split(Lte).forEach(t=>{if(t){const s=t.split(Pte);s.length>1&&(e[s[0].trim()]=s[1].trim())}}),e}function Qo(n){let e="";if(xn(n))e=n;else if(ut(n))for(let t=0;t<n.length;t++){const s=Qo(n[t]);s&&(e+=s+" ")}else if(Qt(n))for(const t in n)n[t]&&(e+=t+" ");return e.trim()}const Bte="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",Vte=L0(Bte);function y2(n){return!!n||n===""}function Wte(n,e){if(n.length!==e.length)return!1;let t=!0;for(let s=0;t&&s<n.length;s++)t=ul(n[s],e[s]);return t}function ul(n,e){if(n===e)return!0;let t=N1(n),s=N1(e);if(t||s)return t&&s?n.getTime()===e.getTime():!1;if(t=Qr(n),s=Qr(e),t||s)return n===e;if(t=ut(n),s=ut(e),t||s)return t&&s?Wte(n,e):!1;if(t=Qt(n),s=Qt(e),t||s){if(!t||!s)return!1;const r=Object.keys(n).length,o=Object.keys(e).length;if(r!==o)return!1;for(const i in n){const a=n.hasOwnProperty(i),l=e.hasOwnProperty(i);if(a&&!l||!a&&l||!ul(n[i],e[i]))return!1}}return String(n)===String(e)}function b2(n,e){return n.findIndex(t=>ul(t,e))}const x2=n=>!!(n&&n.__v_isRef===!0),ks=n=>xn(n)?n:n==null?"":ut(n)||Qt(n)&&(n.toString===p2||!gt(n.toString))?x2(n)?ks(n.value):JSON.stringify(n,w2,2):String(n),w2=(n,e)=>x2(e)?w2(n,e.value):ja(e)?{[`Map(${e.size})`]:[...e.entries()].reduce((t,[s,r],o)=>(t[rg(s,o)+" =>"]=r,t),{})}:Uf(e)?{[`Set(${e.size})`]:[...e.values()].map(t=>rg(t))}:Qr(e)?rg(e):Qt(e)&&!ut(e)&&!f2(e)?String(e):e,rg=(n,e="")=>{var t;return Qr(n)?`Symbol(${(t=n.description)!=null?t:e})`:n};/**
* @vue/reactivity v3.5.15
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let ns;class Ute{constructor(e=!1){this.detached=e,this._active=!0,this._on=0,this.effects=[],this.cleanups=[],this._isPaused=!1,this.parent=ns,!e&&ns&&(this.index=(ns.scopes||(ns.scopes=[])).push(this)-1)}get active(){return this._active}pause(){if(this._active){this._isPaused=!0;let e,t;if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].pause();for(e=0,t=this.effects.length;e<t;e++)this.effects[e].pause()}}resume(){if(this._active&&this._isPaused){this._isPaused=!1;let e,t;if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].resume();for(e=0,t=this.effects.length;e<t;e++)this.effects[e].resume()}}run(e){if(this._active){const t=ns;try{return ns=this,e()}finally{ns=t}}}on(){++this._on===1&&(this.prevScope=ns,ns=this)}off(){this._on>0&&--this._on===0&&(ns=this.prevScope,this.prevScope=void 0)}stop(e){if(this._active){this._active=!1;let t,s;for(t=0,s=this.effects.length;t<s;t++)this.effects[t].stop();for(this.effects.length=0,t=0,s=this.cleanups.length;t<s;t++)this.cleanups[t]();if(this.cleanups.length=0,this.scopes){for(t=0,s=this.scopes.length;t<s;t++)this.scopes[t].stop(!0);this.scopes.length=0}if(!this.detached&&this.parent&&!e){const r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0}}}function v2(){return ns}function Gte(n,e=!1){ns&&ns.cleanups.push(n)}let jt;const og=new WeakSet;class k2{constructor(e){this.fn=e,this.deps=void 0,this.depsTail=void 0,this.flags=5,this.next=void 0,this.cleanup=void 0,this.scheduler=void 0,ns&&ns.active&&ns.effects.push(this)}pause(){this.flags|=64}resume(){this.flags&64&&(this.flags&=-65,og.has(this)&&(og.delete(this),this.trigger()))}notify(){this.flags&2&&!(this.flags&32)||this.flags&8||S2(this)}run(){if(!(this.flags&1))return this.fn();this.flags|=2,E1(this),I2(this);const e=jt,t=kr;jt=this,kr=!0;try{return this.fn()}finally{$2(this),jt=e,kr=t,this.flags&=-3}}stop(){if(this.flags&1){for(let e=this.deps;e;e=e.nextDep)W0(e);this.deps=this.depsTail=void 0,E1(this),this.onStop&&this.onStop(),this.flags&=-2}}trigger(){this.flags&64?og.add(this):this.scheduler?this.scheduler():this.runIfDirty()}runIfDirty(){dy(this)&&this.run()}get dirty(){return dy(this)}}let C2=0,ru,ou;function S2(n,e=!1){if(n.flags|=8,e){n.next=ou,ou=n;return}n.next=ru,ru=n}function B0(){C2++}function V0(){if(--C2>0)return;if(ou){let e=ou;for(ou=void 0;e;){const t=e.next;e.next=void 0,e.flags&=-9,e=t}}let n;for(;ru;){let e=ru;for(ru=void 0;e;){const t=e.next;if(e.next=void 0,e.flags&=-9,e.flags&1)try{e.trigger()}catch(s){n||(n=s)}e=t}}if(n)throw n}function I2(n){for(let e=n.deps;e;e=e.nextDep)e.version=-1,e.prevActiveLink=e.dep.activeLink,e.dep.activeLink=e}function $2(n){let e,t=n.depsTail,s=t;for(;s;){const r=s.prevDep;s.version===-1?(s===t&&(t=r),W0(s),Hte(s)):e=s,s.dep.activeLink=s.prevActiveLink,s.prevActiveLink=void 0,s=r}n.deps=e,n.depsTail=t}function dy(n){for(let e=n.deps;e;e=e.nextDep)if(e.dep.version!==e.version||e.dep.computed&&(N2(e.dep.computed)||e.dep.version!==e.version))return!0;return!!n._dirty}function N2(n){if(n.flags&4&&!(n.flags&16)||(n.flags&=-17,n.globalVersion===$u)||(n.globalVersion=$u,!n.isSSR&&n.flags&128&&(!n.deps&&!n._dirty||!dy(n))))return;n.flags|=2;const e=n.dep,t=jt,s=kr;jt=n,kr=!0;try{I2(n);const r=n.fn(n._value);(e.version===0||Es(r,n._value))&&(n.flags|=128,n._value=r,e.version++)}catch(r){throw e.version++,r}finally{jt=t,kr=s,$2(n),n.flags&=-3}}function W0(n,e=!1){const{dep:t,prevSub:s,nextSub:r}=n;if(s&&(s.nextSub=r,n.prevSub=void 0),r&&(r.prevSub=s,n.nextSub=void 0),t.subs===n&&(t.subs=s,!s&&t.computed)){t.computed.flags&=-5;for(let o=t.computed.deps;o;o=o.nextDep)W0(o,!0)}!e&&!--t.sc&&t.map&&t.map.delete(t.key)}function Hte(n){const{prevDep:e,nextDep:t}=n;e&&(e.nextDep=t,n.prevDep=void 0),t&&(t.prevDep=e,n.nextDep=void 0)}let kr=!0;const T2=[];function Co(){T2.push(kr),kr=!1}function So(){const n=T2.pop();kr=n===void 0?!0:n}function E1(n){const{cleanup:e}=n;if(n.cleanup=void 0,e){const t=jt;jt=void 0;try{e()}finally{jt=t}}}let $u=0;class jte{constructor(e,t){this.sub=e,this.dep=t,this.version=t.version,this.nextDep=this.prevDep=this.nextSub=this.prevSub=this.prevActiveLink=void 0}}class Kf{constructor(e){this.computed=e,this.version=0,this.activeLink=void 0,this.subs=void 0,this.map=void 0,this.key=void 0,this.sc=0}track(e){if(!jt||!kr||jt===this.computed)return;let t=this.activeLink;if(t===void 0||t.sub!==jt)t=this.activeLink=new jte(jt,this),jt.deps?(t.prevDep=jt.depsTail,jt.depsTail.nextDep=t,jt.depsTail=t):jt.deps=jt.depsTail=t,E2(t);else if(t.version===-1&&(t.version=this.version,t.nextDep)){const s=t.nextDep;s.prevDep=t.prevDep,t.prevDep&&(t.prevDep.nextDep=s),t.prevDep=jt.depsTail,t.nextDep=void 0,jt.depsTail.nextDep=t,jt.depsTail=t,jt.deps===t&&(jt.deps=s)}return t}trigger(e){this.version++,$u++,this.notify(e)}notify(e){B0();try{for(let t=this.subs;t;t=t.prevSub)t.sub.notify()&&t.sub.dep.notify()}finally{V0()}}}function E2(n){if(n.dep.sc++,n.sub.flags&4){const e=n.dep.computed;if(e&&!n.dep.subs){e.flags|=20;for(let s=e.deps;s;s=s.nextDep)E2(s)}const t=n.dep.subs;t!==n&&(n.prevSub=t,t&&(t.nextSub=n)),n.dep.subs=n}}const py=new WeakMap,Ki=Symbol(""),fy=Symbol(""),Nu=Symbol("");function is(n,e,t){if(kr&&jt){let s=py.get(n);s||py.set(n,s=new Map);let r=s.get(t);r||(s.set(t,r=new Kf),r.map=s,r.key=t),r.track()}}function ho(n,e,t,s,r,o){const i=py.get(n);if(!i){$u++;return}const a=l=>{l&&l.trigger()};if(B0(),e==="clear")i.forEach(a);else{const l=ut(n),u=l&&M0(t);if(l&&t==="length"){const c=Number(s);i.forEach((h,d)=>{(d==="length"||d===Nu||!Qr(d)&&d>=c)&&a(h)})}else switch((t!==void 0||i.has(void 0))&&a(i.get(t)),u&&a(i.get(Nu)),e){case"add":l?u&&a(i.get("length")):(a(i.get(Ki)),ja(n)&&a(i.get(fy)));break;case"delete":l||(a(i.get(Ki)),ja(n)&&a(i.get(fy)));break;case"set":ja(n)&&a(i.get(Ki));break}}V0()}function Aa(n){const e=zt(n);return e===n?e:(is(e,"iterate",Nu),lr(n)?e:e.map(Kn))}function qf(n){return is(n=zt(n),"iterate",Nu),n}const Kte={__proto__:null,[Symbol.iterator](){return ig(this,Symbol.iterator,Kn)},concat(...n){return Aa(this).concat(...n.map(e=>ut(e)?Aa(e):e))},entries(){return ig(this,"entries",n=>(n[1]=Kn(n[1]),n))},every(n,e){return oo(this,"every",n,e,void 0,arguments)},filter(n,e){return oo(this,"filter",n,e,t=>t.map(Kn),arguments)},find(n,e){return oo(this,"find",n,e,Kn,arguments)},findIndex(n,e){return oo(this,"findIndex",n,e,void 0,arguments)},findLast(n,e){return oo(this,"findLast",n,e,Kn,arguments)},findLastIndex(n,e){return oo(this,"findLastIndex",n,e,void 0,arguments)},forEach(n,e){return oo(this,"forEach",n,e,void 0,arguments)},includes(...n){return ag(this,"includes",n)},indexOf(...n){return ag(this,"indexOf",n)},join(n){return Aa(this).join(n)},lastIndexOf(...n){return ag(this,"lastIndexOf",n)},map(n,e){return oo(this,"map",n,e,void 0,arguments)},pop(){return Hl(this,"pop")},push(...n){return Hl(this,"push",n)},reduce(n,...e){return _1(this,"reduce",n,e)},reduceRight(n,...e){return _1(this,"reduceRight",n,e)},shift(){return Hl(this,"shift")},some(n,e){return oo(this,"some",n,e,void 0,arguments)},splice(...n){return Hl(this,"splice",n)},toReversed(){return Aa(this).toReversed()},toSorted(n){return Aa(this).toSorted(n)},toSpliced(...n){return Aa(this).toSpliced(...n)},unshift(...n){return Hl(this,"unshift",n)},values(){return ig(this,"values",Kn)}};function ig(n,e,t){const s=qf(n),r=s[e]();return s!==n&&!lr(n)&&(r._next=r.next,r.next=()=>{const o=r._next();return o.value&&(o.value=t(o.value)),o}),r}const qte=Array.prototype;function oo(n,e,t,s,r,o){const i=qf(n),a=i!==n&&!lr(n),l=i[e];if(l!==qte[e]){const h=l.apply(n,o);return a?Kn(h):h}let u=t;i!==n&&(a?u=function(h,d){return t.call(this,Kn(h),d,n)}:t.length>2&&(u=function(h,d){return t.call(this,h,d,n)}));const c=l.call(i,u,s);return a&&r?r(c):c}function _1(n,e,t,s){const r=qf(n);let o=t;return r!==n&&(lr(n)?t.length>3&&(o=function(i,a,l){return t.call(this,i,a,l,n)}):o=function(i,a,l){return t.call(this,i,Kn(a),l,n)}),r[e](o,...s)}function ag(n,e,t){const s=zt(n);is(s,"iterate",Nu);const r=s[e](...t);return(r===-1||r===!1)&&j0(t[0])?(t[0]=zt(t[0]),s[e](...t)):r}function Hl(n,e,t=[]){Co(),B0();const s=zt(n)[e].apply(n,t);return V0(),So(),s}const Xte=L0("__proto__,__v_isRef,__isVue"),_2=new Set(Object.getOwnPropertyNames(Symbol).filter(n=>n!=="arguments"&&n!=="caller").map(n=>Symbol[n]).filter(Qr));function Yte(n){Qr(n)||(n=String(n));const e=zt(this);return is(e,"has",n),e.hasOwnProperty(n)}class A2{constructor(e=!1,t=!1){this._isReadonly=e,this._isShallow=t}get(e,t,s){if(t==="__v_skip")return e.__v_skip;const r=this._isReadonly,o=this._isShallow;if(t==="__v_isReactive")return!r;if(t==="__v_isReadonly")return r;if(t==="__v_isShallow")return o;if(t==="__v_raw")return s===(r?o?ine:F2:o?O2:D2).get(e)||Object.getPrototypeOf(e)===Object.getPrototypeOf(s)?e:void 0;const i=ut(e);if(!r){let l;if(i&&(l=Kte[t]))return l;if(t==="hasOwnProperty")return Yte}const a=Reflect.get(e,t,cs(e)?e:s);return(Qr(t)?_2.has(t):Xte(t))||(r||is(e,"get",t),o)?a:cs(a)?i&&M0(t)?a:a.value:Qt(a)?r?L2(a):G0(a):a}}class R2 extends A2{constructor(e=!1){super(!1,e)}set(e,t,s,r){let o=e[t];if(!this._isShallow){const l=ci(o);if(!lr(s)&&!ci(s)&&(o=zt(o),s=zt(s)),!ut(e)&&cs(o)&&!cs(s))return l?!1:(o.value=s,!0)}const i=ut(e)&&M0(t)?Number(t)<e.length:Mt(e,t),a=Reflect.set(e,t,s,cs(e)?e:r);return e===zt(r)&&(i?Es(s,o)&&ho(e,"set",t,s):ho(e,"add",t,s)),a}deleteProperty(e,t){const s=Mt(e,t);e[t];const r=Reflect.deleteProperty(e,t);return r&&s&&ho(e,"delete",t,void 0),r}has(e,t){const s=Reflect.has(e,t);return(!Qr(t)||!_2.has(t))&&is(e,"has",t),s}ownKeys(e){return is(e,"iterate",ut(e)?"length":Ki),Reflect.ownKeys(e)}}class Zte extends A2{constructor(e=!1){super(!0,e)}set(e,t){return!0}deleteProperty(e,t){return!0}}const Jte=new R2,Qte=new Zte,ene=new R2(!0);const my=n=>n,Bh=n=>Reflect.getPrototypeOf(n);function tne(n,e,t){return function(...s){const r=this.__v_raw,o=zt(r),i=ja(o),a=n==="entries"||n===Symbol.iterator&&i,l=n==="keys"&&i,u=r[n](...s),c=t?my:e?Fd:Kn;return!e&&is(o,"iterate",l?fy:Ki),{next(){const{value:h,done:d}=u.next();return d?{value:h,done:d}:{value:a?[c(h[0]),c(h[1])]:c(h),done:d}},[Symbol.iterator](){return this}}}}function Vh(n){return function(...e){return n==="delete"?!1:n==="clear"?void 0:this}}function nne(n,e){const t={get(r){const o=this.__v_raw,i=zt(o),a=zt(r);n||(Es(r,a)&&is(i,"get",r),is(i,"get",a));const{has:l}=Bh(i),u=e?my:n?Fd:Kn;if(l.call(i,r))return u(o.get(r));if(l.call(i,a))return u(o.get(a));o!==i&&o.get(r)},get size(){const r=this.__v_raw;return!n&&is(zt(r),"iterate",Ki),Reflect.get(r,"size",r)},has(r){const o=this.__v_raw,i=zt(o),a=zt(r);return n||(Es(r,a)&&is(i,"has",r),is(i,"has",a)),r===a?o.has(r):o.has(r)||o.has(a)},forEach(r,o){const i=this,a=i.__v_raw,l=zt(a),u=e?my:n?Fd:Kn;return!n&&is(l,"iterate",Ki),a.forEach((c,h)=>r.call(o,u(c),u(h),i))}};return Yn(t,n?{add:Vh("add"),set:Vh("set"),delete:Vh("delete"),clear:Vh("clear")}:{add(r){!e&&!lr(r)&&!ci(r)&&(r=zt(r));const o=zt(this);return Bh(o).has.call(o,r)||(o.add(r),ho(o,"add",r,r)),this},set(r,o){!e&&!lr(o)&&!ci(o)&&(o=zt(o));const i=zt(this),{has:a,get:l}=Bh(i);let u=a.call(i,r);u||(r=zt(r),u=a.call(i,r));const c=l.call(i,r);return i.set(r,o),u?Es(o,c)&&ho(i,"set",r,o):ho(i,"add",r,o),this},delete(r){const o=zt(this),{has:i,get:a}=Bh(o);let l=i.call(o,r);l||(r=zt(r),l=i.call(o,r)),a&&a.call(o,r);const u=o.delete(r);return l&&ho(o,"delete",r,void 0),u},clear(){const r=zt(this),o=r.size!==0,i=r.clear();return o&&ho(r,"clear",void 0,void 0),i}}),["keys","values","entries",Symbol.iterator].forEach(r=>{t[r]=tne(r,n,e)}),t}function U0(n,e){const t=nne(n,e);return(s,r,o)=>r==="__v_isReactive"?!n:r==="__v_isReadonly"?n:r==="__v_raw"?s:Reflect.get(Mt(t,r)&&r in s?t:s,r,o)}const sne={get:U0(!1,!1)},rne={get:U0(!1,!0)},one={get:U0(!0,!1)};const D2=new WeakMap,O2=new WeakMap,F2=new WeakMap,ine=new WeakMap;function ane(n){switch(n){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function lne(n){return n.__v_skip||!Object.isExtensible(n)?0:ane(Dte(n))}function G0(n){return ci(n)?n:H0(n,!1,Jte,sne,D2)}function une(n){return H0(n,!1,ene,rne,O2)}function L2(n){return H0(n,!0,Qte,one,F2)}function H0(n,e,t,s,r){if(!Qt(n)||n.__v_raw&&!(e&&n.__v_isReactive))return n;const o=lne(n);if(o===0)return n;const i=r.get(n);if(i)return i;const a=new Proxy(n,o===2?s:t);return r.set(n,a),a}function Ka(n){return ci(n)?Ka(n.__v_raw):!!(n&&n.__v_isReactive)}function ci(n){return!!(n&&n.__v_isReadonly)}function lr(n){return!!(n&&n.__v_isShallow)}function j0(n){return n?!!n.__v_raw:!1}function zt(n){const e=n&&n.__v_raw;return e?zt(e):n}function cne(n){return!Mt(n,"__v_skip")&&Object.isExtensible(n)&&g2(n,"__v_skip",!0),n}const Kn=n=>Qt(n)?G0(n):n,Fd=n=>Qt(n)?L2(n):n;function cs(n){return n?n.__v_isRef===!0:!1}function Yt(n){return P2(n,!1)}function Ld(n){return P2(n,!0)}function P2(n,e){return cs(n)?n:new hne(n,e)}class hne{constructor(e,t){this.dep=new Kf,this.__v_isRef=!0,this.__v_isShallow=!1,this._rawValue=t?e:zt(e),this._value=t?e:Kn(e),this.__v_isShallow=t}get value(){return this.dep.track(),this._value}set value(e){const t=this._rawValue,s=this.__v_isShallow||lr(e)||ci(e);e=s?e:zt(e),Es(e,t)&&(this._rawValue=e,this._value=s?e:Kn(e),this.dep.trigger())}}function Cr(n){return cs(n)?n.value:n}function qa(n){return gt(n)?n():Cr(n)}const dne={get:(n,e,t)=>e==="__v_raw"?n:Cr(Reflect.get(n,e,t)),set:(n,e,t,s)=>{const r=n[e];return cs(r)&&!cs(t)?(r.value=t,!0):Reflect.set(n,e,t,s)}};function z2(n){return Ka(n)?n:new Proxy(n,dne)}class pne{constructor(e){this.__v_isRef=!0,this._value=void 0;const t=this.dep=new Kf,{get:s,set:r}=e(t.track.bind(t),t.trigger.bind(t));this._get=s,this._set=r}get value(){return this._value=this._get()}set value(e){this._set(e)}}function fne(n){return new pne(n)}class mne{constructor(e,t,s){this.fn=e,this.setter=t,this._value=void 0,this.dep=new Kf(this),this.__v_isRef=!0,this.deps=void 0,this.depsTail=void 0,this.flags=16,this.globalVersion=$u-1,this.next=void 0,this.effect=this,this.__v_isReadonly=!t,this.isSSR=s}notify(){if(this.flags|=16,!(this.flags&8)&&jt!==this)return S2(this,!0),!0}get value(){const e=this.dep.track();return N2(this),e&&(e.version=this.dep.version),this._value}set value(e){this.setter&&this.setter(e)}}function gne(n,e,t=!1){let s,r;return gt(n)?s=n:(s=n.get,r=n.set),new mne(s,r,t)}const Wh={},Pd=new WeakMap;let zi;function yne(n,e=!1,t=zi){if(t){let s=Pd.get(t);s||Pd.set(t,s=[]),s.push(n)}}function bne(n,e,t=Lt){const{immediate:s,deep:r,once:o,scheduler:i,augmentJob:a,call:l}=t,u=v=>r?v:lr(v)||r===!1||r===0?po(v,1):po(v);let c,h,d,p,f=!1,g=!1;if(cs(n)?(h=()=>n.value,f=lr(n)):Ka(n)?(h=()=>u(n),f=!0):ut(n)?(g=!0,f=n.some(v=>Ka(v)||lr(v)),h=()=>n.map(v=>{if(cs(v))return v.value;if(Ka(v))return u(v);if(gt(v))return l?l(v,2):v()})):gt(n)?e?h=l?()=>l(n,2):n:h=()=>{if(d){Co();try{d()}finally{So()}}const v=zi;zi=c;try{return l?l(n,3,[p]):n(p)}finally{zi=v}}:h=Kr,e&&r){const v=h,I=r===!0?1/0:r;h=()=>po(v(),I)}const y=v2(),b=()=>{c.stop(),y&&y.active&&z0(y.effects,c)};if(o&&e){const v=e;e=(...I)=>{v(...I),b()}}let w=g?new Array(n.length).fill(Wh):Wh;const C=v=>{if(!(!(c.flags&1)||!c.dirty&&!v))if(e){const I=c.run();if(r||f||(g?I.some((E,R)=>Es(E,w[R])):Es(I,w))){d&&d();const E=zi;zi=c;try{const R=[I,w===Wh?void 0:g&&w[0]===Wh?[]:w,p];w=I,l?l(e,3,R):e(...R)}finally{zi=E}}}else c.run()};return a&&a(C),c=new k2(h),c.scheduler=i?()=>i(C,!1):C,p=v=>yne(v,!1,c),d=c.onStop=()=>{const v=Pd.get(c);if(v){if(l)l(v,4);else for(const I of v)I();Pd.delete(c)}},e?s?C(!0):w=c.run():i?i(C.bind(null,!0),!0):c.run(),b.pause=c.pause.bind(c),b.resume=c.resume.bind(c),b.stop=b,b}function po(n,e=1/0,t){if(e<=0||!Qt(n)||n.__v_skip||(t=t||new Set,t.has(n)))return n;if(t.add(n),e--,cs(n))po(n.value,e,t);else if(ut(n))for(let s=0;s<n.length;s++)po(n[s],e,t);else if(Uf(n)||ja(n))n.forEach(s=>{po(s,e,t)});else if(f2(n)){for(const s in n)po(n[s],e,t);for(const s of Object.getOwnPropertySymbols(n))Object.prototype.propertyIsEnumerable.call(n,s)&&po(n[s],e,t)}return n}/**
* @vue/runtime-core v3.5.15
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function Qc(n,e,t,s){try{return s?n(...s):n()}catch(r){Xf(r,e,t)}}function eo(n,e,t,s){if(gt(n)){const r=Qc(n,e,t,s);return r&&d2(r)&&r.catch(o=>{Xf(o,e,t)}),r}if(ut(n)){const r=[];for(let o=0;o<n.length;o++)r.push(eo(n[o],e,t,s));return r}}function Xf(n,e,t,s=!0){const r=e?e.vnode:null,{errorHandler:o,throwUnhandledErrorInProduction:i}=e&&e.appContext.config||Lt;if(e){let a=e.parent;const l=e.proxy,u=`https://vuejs.org/error-reference/#runtime-${t}`;for(;a;){const c=a.ec;if(c){for(let h=0;h<c.length;h++)if(c[h](n,l,u)===!1)return}a=a.parent}if(o){Co(),Qc(o,null,10,[n,l,u]),So();return}}xne(n,t,r,s,i)}function xne(n,e,t,s=!0,r=!1){if(r)throw n;console.error(n)}const ws=[];let Or=-1;const Xa=[];let Wo=null,Pa=0;const M2=Promise.resolve();let zd=null;function Yf(n){const e=zd||M2;return n?e.then(this?n.bind(this):n):e}function wne(n){let e=Or+1,t=ws.length;for(;e<t;){const s=e+t>>>1,r=ws[s],o=Tu(r);o<n||o===n&&r.flags&2?e=s+1:t=s}return e}function K0(n){if(!(n.flags&1)){const e=Tu(n),t=ws[ws.length-1];!t||!(n.flags&2)&&e>=Tu(t)?ws.push(n):ws.splice(wne(e),0,n),n.flags|=1,B2()}}function B2(){zd||(zd=M2.then(W2))}function vne(n){ut(n)?Xa.push(...n):Wo&&n.id===-1?Wo.splice(Pa+1,0,n):n.flags&1||(Xa.push(n),n.flags|=1),B2()}function A1(n,e,t=Or+1){for(;t<ws.length;t++){const s=ws[t];if(s&&s.flags&2){if(n&&s.id!==n.uid)continue;ws.splice(t,1),t--,s.flags&4&&(s.flags&=-2),s(),s.flags&4||(s.flags&=-2)}}}function V2(n){if(Xa.length){const e=[...new Set(Xa)].sort((t,s)=>Tu(t)-Tu(s));if(Xa.length=0,Wo){Wo.push(...e);return}for(Wo=e,Pa=0;Pa<Wo.length;Pa++){const t=Wo[Pa];t.flags&4&&(t.flags&=-2),t.flags&8||t(),t.flags&=-2}Wo=null,Pa=0}}const Tu=n=>n.id==null?n.flags&2?-1:1/0:n.id;function W2(n){try{for(Or=0;Or<ws.length;Or++){const e=ws[Or];e&&!(e.flags&8)&&(e.flags&4&&(e.flags&=-2),Qc(e,e.i,e.i?15:14),e.flags&4||(e.flags&=-2))}}finally{for(;Or<ws.length;Or++){const e=ws[Or];e&&(e.flags&=-2)}Or=-1,ws.length=0,V2(),zd=null,(ws.length||Xa.length)&&W2()}}let Hs=null,U2=null;function Md(n){const e=Hs;return Hs=n,U2=n&&n.type.__scopeId||null,e}function kne(n,e=Hs,t){if(!e||n._n)return n;const s=(...r)=>{s._d&&W1(-1);const o=Md(e);let i;try{i=n(...r)}finally{Md(o),s._d&&W1(1)}return i};return s._n=!0,s._c=!0,s._d=!0,s}function Fr(n,e){if(Hs===null)return n;const t=nm(Hs),s=n.dirs||(n.dirs=[]);for(let r=0;r<e.length;r++){let[o,i,a,l=Lt]=e[r];o&&(gt(o)&&(o={mounted:o,updated:o}),o.deep&&po(i),s.push({dir:o,instance:t,value:i,oldValue:void 0,arg:a,modifiers:l}))}return n}function Fi(n,e,t,s){const r=n.dirs,o=e&&e.dirs;for(let i=0;i<r.length;i++){const a=r[i];o&&(a.oldValue=o[i].value);let l=a.dir[s];l&&(Co(),eo(l,t,8,[n.el,a,n,e]),So())}}const G2=Symbol("_vte"),Cne=n=>n.__isTeleport,iu=n=>n&&(n.disabled||n.disabled===""),R1=n=>n&&(n.defer||n.defer===""),D1=n=>typeof SVGElement<"u"&&n instanceof SVGElement,O1=n=>typeof MathMLElement=="function"&&n instanceof MathMLElement,gy=(n,e)=>{const t=n&&n.to;return xn(t)?e?e(t):null:t},H2={name:"Teleport",__isTeleport:!0,process(n,e,t,s,r,o,i,a,l,u){const{mc:c,pc:h,pbc:d,o:{insert:p,querySelector:f,createText:g,createComment:y}}=u,b=iu(e.props);let{shapeFlag:w,children:C,dynamicChildren:v}=e;if(n==null){const I=e.el=g(""),E=e.anchor=g("");p(I,t,s),p(E,t,s);const R=(D,F)=>{w&16&&(r&&r.isCE&&(r.ce._teleportTarget=D),c(C,D,F,r,o,i,a,l))},L=()=>{const D=e.target=gy(e.props,f),F=j2(D,e,g,p);D&&(i!=="svg"&&D1(D)?i="svg":i!=="mathml"&&O1(D)&&(i="mathml"),b||(R(D,F),nd(e,!1)))};b&&(R(t,E),nd(e,!0)),R1(e.props)?(e.el.__isMounted=!1,ys(()=>{L(),delete e.el.__isMounted},o)):L()}else{if(R1(e.props)&&n.el.__isMounted===!1){ys(()=>{H2.process(n,e,t,s,r,o,i,a,l,u)},o);return}e.el=n.el,e.targetStart=n.targetStart;const I=e.anchor=n.anchor,E=e.target=n.target,R=e.targetAnchor=n.targetAnchor,L=iu(n.props),D=L?t:E,F=L?I:R;if(i==="svg"||D1(E)?i="svg":(i==="mathml"||O1(E))&&(i="mathml"),v?(d(n.dynamicChildren,v,D,r,o,i,a),Z0(n,e,!0)):l||h(n,e,D,F,r,o,i,a,!1),b)L?e.props&&n.props&&e.props.to!==n.props.to&&(e.props.to=n.props.to):Uh(e,t,I,u,1);else if((e.props&&e.props.to)!==(n.props&&n.props.to)){const T=e.target=gy(e.props,f);T&&Uh(e,T,null,u,0)}else L&&Uh(e,E,R,u,1);nd(e,b)}},remove(n,e,t,{um:s,o:{remove:r}},o){const{shapeFlag:i,children:a,anchor:l,targetStart:u,targetAnchor:c,target:h,props:d}=n;if(h&&(r(u),r(c)),o&&r(l),i&16){const p=o||!iu(d);for(let f=0;f<a.length;f++){const g=a[f];s(g,e,t,p,!!g.dynamicChildren)}}},move:Uh,hydrate:Sne};function Uh(n,e,t,{o:{insert:s},m:r},o=2){o===0&&s(n.targetAnchor,e,t);const{el:i,anchor:a,shapeFlag:l,children:u,props:c}=n,h=o===2;if(h&&s(i,e,t),(!h||iu(c))&&l&16)for(let d=0;d<u.length;d++)r(u[d],e,t,2);h&&s(a,e,t)}function Sne(n,e,t,s,r,o,{o:{nextSibling:i,parentNode:a,querySelector:l,insert:u,createText:c}},h){const d=e.target=gy(e.props,l);if(d){const p=iu(e.props),f=d._lpa||d.firstChild;if(e.shapeFlag&16)if(p)e.anchor=h(i(n),e,a(n),t,s,r,o),e.targetStart=f,e.targetAnchor=f&&i(f);else{e.anchor=i(n);let g=f;for(;g;){if(g&&g.nodeType===8){if(g.data==="teleport start anchor")e.targetStart=g;else if(g.data==="teleport anchor"){e.targetAnchor=g,d._lpa=e.targetAnchor&&i(e.targetAnchor);break}}g=i(g)}e.targetAnchor||j2(d,e,c,u),h(f&&i(f),e,d,t,s,r,o)}nd(e,p)}return e.anchor&&i(e.anchor)}const Ine=H2;function nd(n,e){const t=n.ctx;if(t&&t.ut){let s,r;for(e?(s=n.el,r=n.anchor):(s=n.targetStart,r=n.targetAnchor);s&&s!==r;)s.nodeType===1&&s.setAttribute("data-v-owner",t.uid),s=s.nextSibling;t.ut()}}function j2(n,e,t,s){const r=e.targetStart=t(""),o=e.targetAnchor=t("");return r[G2]=o,n&&(s(r,n),s(o,n)),o}function q0(n,e){n.shapeFlag&6&&n.component?(n.transition=e,q0(n.component.subTree,e)):n.shapeFlag&128?(n.ssContent.transition=e.clone(n.ssContent),n.ssFallback.transition=e.clone(n.ssFallback)):n.transition=e}/*! #__NO_SIDE_EFFECTS__ */function _o(n,e){return gt(n)?Yn({name:n.name},e,{setup:n}):n}function K2(n){n.ids=[n.ids[0]+n.ids[2]+++"-",0,0]}function Bd(n,e,t,s,r=!1){if(ut(n)){n.forEach((f,g)=>Bd(f,e&&(ut(e)?e[g]:e),t,s,r));return}if(au(s)&&!r){s.shapeFlag&512&&s.type.__asyncResolved&&s.component.subTree.component&&Bd(n,e,t,s.component.subTree);return}const o=s.shapeFlag&4?nm(s.component):s.el,i=r?null:o,{i:a,r:l}=n,u=e&&e.r,c=a.refs===Lt?a.refs={}:a.refs,h=a.setupState,d=zt(h),p=h===Lt?()=>!1:f=>Mt(d,f);if(u!=null&&u!==l&&(xn(u)?(c[u]=null,p(u)&&(h[u]=null)):cs(u)&&(u.value=null)),gt(l))Qc(l,a,12,[i,c]);else{const f=xn(l),g=cs(l);if(f||g){const y=()=>{if(n.f){const b=f?p(l)?h[l]:c[l]:l.value;r?ut(b)&&z0(b,o):ut(b)?b.includes(o)||b.push(o):f?(c[l]=[o],p(l)&&(h[l]=c[l])):(l.value=[o],n.k&&(c[n.k]=l.value))}else f?(c[l]=i,p(l)&&(h[l]=i)):g&&(l.value=i,n.k&&(c[n.k]=i))};i?(y.id=-1,ys(y,t)):y()}}}Hf().requestIdleCallback;Hf().cancelIdleCallback;const au=n=>!!n.type.__asyncLoader,q2=n=>n.type.__isKeepAlive;function $ne(n,e){X2(n,"a",e)}function Nne(n,e){X2(n,"da",e)}function X2(n,e,t=ls){const s=n.__wdc||(n.__wdc=()=>{let r=t;for(;r;){if(r.isDeactivated)return;r=r.parent}return n()});if(Zf(e,s,t),t){let r=t.parent;for(;r&&r.parent;)q2(r.parent.vnode)&&Tne(s,e,t,r),r=r.parent}}function Tne(n,e,t,s){const r=Zf(e,n,s,!0);Jf(()=>{z0(s[e],r)},t)}function Zf(n,e,t=ls,s=!1){if(t){const r=t[n]||(t[n]=[]),o=e.__weh||(e.__weh=(...i)=>{Co();const a=eh(t),l=eo(e,t,n,i);return a(),So(),l});return s?r.unshift(o):r.push(o),o}}const Ao=n=>(e,t=ls)=>{(!_u||n==="sp")&&Zf(n,(...s)=>e(...s),t)},Ene=Ao("bm"),_l=Ao("m"),_ne=Ao("bu"),Ane=Ao("u"),Rne=Ao("bum"),Jf=Ao("um"),Dne=Ao("sp"),One=Ao("rtg"),Fne=Ao("rtc");function Lne(n,e=ls){Zf("ec",n,e)}const Pne=Symbol.for("v-ndc");function qr(n,e,t,s){let r;const o=t,i=ut(n);if(i||xn(n)){const a=i&&Ka(n);let l=!1,u=!1;a&&(l=!lr(n),u=ci(n),n=qf(n)),r=new Array(n.length);for(let c=0,h=n.length;c<h;c++)r[c]=e(l?u?Fd(Kn(n[c])):Kn(n[c]):n[c],c,void 0,o)}else if(typeof n=="number"){r=new Array(n);for(let a=0;a<n;a++)r[a]=e(a+1,a,void 0,o)}else if(Qt(n))if(n[Symbol.iterator])r=Array.from(n,(a,l)=>e(a,l,void 0,o));else{const a=Object.keys(n);r=new Array(a.length);for(let l=0,u=a.length;l<u;l++){const c=a[l];r[l]=e(n[c],c,l,o)}}else r=[];return r}const yy=n=>n?yE(n)?nm(n):yy(n.parent):null,lu=Yn(Object.create(null),{$:n=>n,$el:n=>n.vnode.el,$data:n=>n.data,$props:n=>n.props,$attrs:n=>n.attrs,$slots:n=>n.slots,$refs:n=>n.refs,$parent:n=>yy(n.parent),$root:n=>yy(n.root),$host:n=>n.ce,$emit:n=>n.emit,$options:n=>Z2(n),$forceUpdate:n=>n.f||(n.f=()=>{K0(n.update)}),$nextTick:n=>n.n||(n.n=Yf.bind(n.proxy)),$watch:n=>ise.bind(n)}),lg=(n,e)=>n!==Lt&&!n.__isScriptSetup&&Mt(n,e),zne={get({_:n},e){if(e==="__v_skip")return!0;const{ctx:t,setupState:s,data:r,props:o,accessCache:i,type:a,appContext:l}=n;let u;if(e[0]!=="$"){const p=i[e];if(p!==void 0)switch(p){case 1:return s[e];case 2:return r[e];case 4:return t[e];case 3:return o[e]}else{if(lg(s,e))return i[e]=1,s[e];if(r!==Lt&&Mt(r,e))return i[e]=2,r[e];if((u=n.propsOptions[0])&&Mt(u,e))return i[e]=3,o[e];if(t!==Lt&&Mt(t,e))return i[e]=4,t[e];xy&&(i[e]=0)}}const c=lu[e];let h,d;if(c)return e==="$attrs"&&is(n.attrs,"get",""),c(n);if((h=a.__cssModules)&&(h=h[e]))return h;if(t!==Lt&&Mt(t,e))return i[e]=4,t[e];if(d=l.config.globalProperties,Mt(d,e))return d[e]},set({_:n},e,t){const{data:s,setupState:r,ctx:o}=n;return lg(r,e)?(r[e]=t,!0):s!==Lt&&Mt(s,e)?(s[e]=t,!0):Mt(n.props,e)||e[0]==="$"&&e.slice(1)in n?!1:(o[e]=t,!0)},has({_:{data:n,setupState:e,accessCache:t,ctx:s,appContext:r,propsOptions:o}},i){let a;return!!t[i]||n!==Lt&&Mt(n,i)||lg(e,i)||(a=o[0])&&Mt(a,i)||Mt(s,i)||Mt(lu,i)||Mt(r.config.globalProperties,i)},defineProperty(n,e,t){return t.get!=null?n._.accessCache[e]=0:Mt(t,"value")&&this.set(n,e,t.value,null),Reflect.defineProperty(n,e,t)}};function Vd(n){return ut(n)?n.reduce((e,t)=>(e[t]=null,e),{}):n}function by(n,e){return!n||!e?n||e:ut(n)&&ut(e)?n.concat(e):Yn({},Vd(n),Vd(e))}let xy=!0;function Mne(n){const e=Z2(n),t=n.proxy,s=n.ctx;xy=!1,e.beforeCreate&&F1(e.beforeCreate,n,"bc");const{data:r,computed:o,methods:i,watch:a,provide:l,inject:u,created:c,beforeMount:h,mounted:d,beforeUpdate:p,updated:f,activated:g,deactivated:y,beforeDestroy:b,beforeUnmount:w,destroyed:C,unmounted:v,render:I,renderTracked:E,renderTriggered:R,errorCaptured:L,serverPrefetch:D,expose:F,inheritAttrs:T,components:V,directives:q,filters:se}=e;if(u&&Bne(u,s,null),i)for(const le in i){const Q=i[le];gt(Q)&&(s[le]=Q.bind(t))}if(r){const le=r.call(t,t);Qt(le)&&(n.data=G0(le))}if(xy=!0,o)for(const le in o){const Q=o[le],he=gt(Q)?Q.bind(t,t):gt(Q.get)?Q.get.bind(t,t):Kr,ye=!gt(Q)&&gt(Q.set)?Q.set.bind(t):Kr,we=Cs({get:he,set:ye});Object.defineProperty(s,le,{enumerable:!0,configurable:!0,get:()=>we.value,set:Ce=>we.value=Ce})}if(a)for(const le in a)Y2(a[le],s,t,le);if(l){const le=gt(l)?l.call(t):l;Reflect.ownKeys(le).forEach(Q=>{jne(Q,le[Q])})}c&&F1(c,n,"c");function te(le,Q){ut(Q)?Q.forEach(he=>le(he.bind(t))):Q&&le(Q.bind(t))}if(te(Ene,h),te(_l,d),te(_ne,p),te(Ane,f),te($ne,g),te(Nne,y),te(Lne,L),te(Fne,E),te(One,R),te(Rne,w),te(Jf,v),te(Dne,D),ut(F))if(F.length){const le=n.exposed||(n.exposed={});F.forEach(Q=>{Object.defineProperty(le,Q,{get:()=>t[Q],set:he=>t[Q]=he})})}else n.exposed||(n.exposed={});I&&n.render===Kr&&(n.render=I),T!=null&&(n.inheritAttrs=T),V&&(n.components=V),q&&(n.directives=q),D&&K2(n)}function Bne(n,e,t=Kr){ut(n)&&(n=wy(n));for(const s in n){const r=n[s];let o;Qt(r)?"default"in r?o=sd(r.from||s,r.default,!0):o=sd(r.from||s):o=sd(r),cs(o)?Object.defineProperty(e,s,{enumerable:!0,configurable:!0,get:()=>o.value,set:i=>o.value=i}):e[s]=o}}function F1(n,e,t){eo(ut(n)?n.map(s=>s.bind(e.proxy)):n.bind(e.proxy),e,t)}function Y2(n,e,t,s){let r=s.includes(".")?lE(t,s):()=>t[s];if(xn(n)){const o=e[n];gt(o)&&Xr(r,o)}else if(gt(n))Xr(r,n.bind(t));else if(Qt(n))if(ut(n))n.forEach(o=>Y2(o,e,t,s));else{const o=gt(n.handler)?n.handler.bind(t):e[n.handler];gt(o)&&Xr(r,o,n)}}function Z2(n){const e=n.type,{mixins:t,extends:s}=e,{mixins:r,optionsCache:o,config:{optionMergeStrategies:i}}=n.appContext,a=o.get(e);let l;return a?l=a:!r.length&&!t&&!s?l=e:(l={},r.length&&r.forEach(u=>Wd(l,u,i,!0)),Wd(l,e,i)),Qt(e)&&o.set(e,l),l}function Wd(n,e,t,s=!1){const{mixins:r,extends:o}=e;o&&Wd(n,o,t,!0),r&&r.forEach(i=>Wd(n,i,t,!0));for(const i in e)if(!(s&&i==="expose")){const a=Vne[i]||t&&t[i];n[i]=a?a(n[i],e[i]):e[i]}return n}const Vne={data:L1,props:P1,emits:P1,methods:eu,computed:eu,beforeCreate:gs,created:gs,beforeMount:gs,mounted:gs,beforeUpdate:gs,updated:gs,beforeDestroy:gs,beforeUnmount:gs,destroyed:gs,unmounted:gs,activated:gs,deactivated:gs,errorCaptured:gs,serverPrefetch:gs,components:eu,directives:eu,watch:Une,provide:L1,inject:Wne};function L1(n,e){return e?n?function(){return Yn(gt(n)?n.call(this,this):n,gt(e)?e.call(this,this):e)}:e:n}function Wne(n,e){return eu(wy(n),wy(e))}function wy(n){if(ut(n)){const e={};for(let t=0;t<n.length;t++)e[n[t]]=n[t];return e}return n}function gs(n,e){return n?[...new Set([].concat(n,e))]:e}function eu(n,e){return n?Yn(Object.create(null),n,e):e}function P1(n,e){return n?ut(n)&&ut(e)?[...new Set([...n,...e])]:Yn(Object.create(null),Vd(n),Vd(e??{})):e}function Une(n,e){if(!n)return e;if(!e)return n;const t=Yn(Object.create(null),n);for(const s in e)t[s]=gs(n[s],e[s]);return t}function J2(){return{app:null,config:{isNativeTag:Ate,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let Gne=0;function Hne(n,e){return function(s,r=null){gt(s)||(s=Yn({},s)),r!=null&&!Qt(r)&&(r=null);const o=J2(),i=new WeakSet,a=[];let l=!1;const u=o.app={_uid:Gne++,_component:s,_props:r,_container:null,_context:o,_instance:null,version:Sse,get config(){return o.config},set config(c){},use(c,...h){return i.has(c)||(c&&gt(c.install)?(i.add(c),c.install(u,...h)):gt(c)&&(i.add(c),c(u,...h))),u},mixin(c){return o.mixins.includes(c)||o.mixins.push(c),u},component(c,h){return h?(o.components[c]=h,u):o.components[c]},directive(c,h){return h?(o.directives[c]=h,u):o.directives[c]},mount(c,h,d){if(!l){const p=u._ceVNode||ur(s,r);return p.appContext=o,d===!0?d="svg":d===!1&&(d=void 0),n(p,c,d),l=!0,u._container=c,c.__vue_app__=u,nm(p.component)}},onUnmount(c){a.push(c)},unmount(){l&&(eo(a,u._instance,16),n(null,u._container),delete u._container.__vue_app__)},provide(c,h){return o.provides[c]=h,u},runWithContext(c){const h=Ya;Ya=u;try{return c()}finally{Ya=h}}};return u}}let Ya=null;function jne(n,e){if(ls){let t=ls.provides;const s=ls.parent&&ls.parent.provides;s===t&&(t=ls.provides=Object.create(s)),t[n]=e}}function sd(n,e,t=!1){const s=ls||Hs;if(s||Ya){let r=Ya?Ya._context.provides:s?s.parent==null||s.ce?s.vnode.appContext&&s.vnode.appContext.provides:s.parent.provides:void 0;if(r&&n in r)return r[n];if(arguments.length>1)return t&&gt(e)?e.call(s&&s.proxy):e}}const Q2={},eE=()=>Object.create(Q2),tE=n=>Object.getPrototypeOf(n)===Q2;function Kne(n,e,t,s=!1){const r={},o=eE();n.propsDefaults=Object.create(null),nE(n,e,r,o);for(const i in n.propsOptions[0])i in r||(r[i]=void 0);t?n.props=s?r:une(r):n.type.props?n.props=r:n.props=o,n.attrs=o}function qne(n,e,t,s){const{props:r,attrs:o,vnode:{patchFlag:i}}=n,a=zt(r),[l]=n.propsOptions;let u=!1;if((s||i>0)&&!(i&16)){if(i&8){const c=n.vnode.dynamicProps;for(let h=0;h<c.length;h++){let d=c[h];if(em(n.emitsOptions,d))continue;const p=e[d];if(l)if(Mt(o,d))p!==o[d]&&(o[d]=p,u=!0);else{const f=ko(d);r[f]=vy(l,a,f,p,n,!1)}else p!==o[d]&&(o[d]=p,u=!0)}}}else{nE(n,e,r,o)&&(u=!0);let c;for(const h in a)(!e||!Mt(e,h)&&((c=Si(h))===h||!Mt(e,c)))&&(l?t&&(t[h]!==void 0||t[c]!==void 0)&&(r[h]=vy(l,a,h,void 0,n,!0)):delete r[h]);if(o!==a)for(const h in o)(!e||!Mt(e,h))&&(delete o[h],u=!0)}u&&ho(n.attrs,"set","")}function nE(n,e,t,s){const[r,o]=n.propsOptions;let i=!1,a;if(e)for(let l in e){if(su(l))continue;const u=e[l];let c;r&&Mt(r,c=ko(l))?!o||!o.includes(c)?t[c]=u:(a||(a={}))[c]=u:em(n.emitsOptions,l)||(!(l in s)||u!==s[l])&&(s[l]=u,i=!0)}if(o){const l=zt(t),u=a||Lt;for(let c=0;c<o.length;c++){const h=o[c];t[h]=vy(r,l,h,u[h],n,!Mt(u,h))}}return i}function vy(n,e,t,s,r,o){const i=n[t];if(i!=null){const a=Mt(i,"default");if(a&&s===void 0){const l=i.default;if(i.type!==Function&&!i.skipFactory&&gt(l)){const{propsDefaults:u}=r;if(t in u)s=u[t];else{const c=eh(r);s=u[t]=l.call(null,e),c()}}else s=l;r.ce&&r.ce._setProp(t,s)}i[0]&&(o&&!a?s=!1:i[1]&&(s===""||s===Si(t))&&(s=!0))}return s}const Xne=new WeakMap;function sE(n,e,t=!1){const s=t?Xne:e.propsCache,r=s.get(n);if(r)return r;const o=n.props,i={},a=[];let l=!1;if(!gt(n)){const c=h=>{l=!0;const[d,p]=sE(h,e,!0);Yn(i,d),p&&a.push(...p)};!t&&e.mixins.length&&e.mixins.forEach(c),n.extends&&c(n.extends),n.mixins&&n.mixins.forEach(c)}if(!o&&!l)return Qt(n)&&s.set(n,Ha),Ha;if(ut(o))for(let c=0;c<o.length;c++){const h=ko(o[c]);z1(h)&&(i[h]=Lt)}else if(o)for(const c in o){const h=ko(c);if(z1(h)){const d=o[c],p=i[h]=ut(d)||gt(d)?{type:d}:Yn({},d),f=p.type;let g=!1,y=!0;if(ut(f))for(let b=0;b<f.length;++b){const w=f[b],C=gt(w)&&w.name;if(C==="Boolean"){g=!0;break}else C==="String"&&(y=!1)}else g=gt(f)&&f.name==="Boolean";p[0]=g,p[1]=y,(g||Mt(p,"default"))&&a.push(h)}}const u=[i,a];return Qt(n)&&s.set(n,u),u}function z1(n){return n[0]!=="$"&&!su(n)}const X0=n=>n[0]==="_"||n==="$stable",Y0=n=>ut(n)?n.map(Mr):[Mr(n)],Yne=(n,e,t)=>{if(e._n)return e;const s=kne((...r)=>Y0(e(...r)),t);return s._c=!1,s},rE=(n,e,t)=>{const s=n._ctx;for(const r in n){if(X0(r))continue;const o=n[r];if(gt(o))e[r]=Yne(r,o,s);else if(o!=null){const i=Y0(o);e[r]=()=>i}}},oE=(n,e)=>{const t=Y0(e);n.slots.default=()=>t},iE=(n,e,t)=>{for(const s in e)(t||!X0(s))&&(n[s]=e[s])},Zne=(n,e,t)=>{const s=n.slots=eE();if(n.vnode.shapeFlag&32){const r=e._;r?(iE(s,e,t),t&&g2(s,"_",r,!0)):rE(e,s)}else e&&oE(n,e)},Jne=(n,e,t)=>{const{vnode:s,slots:r}=n;let o=!0,i=Lt;if(s.shapeFlag&32){const a=e._;a?t&&a===1?o=!1:iE(r,e,t):(o=!e.$stable,rE(e,r)),i=e}else e&&(oE(n,e),i={default:1});if(o)for(const a in r)!X0(a)&&i[a]==null&&delete r[a]},ys=dse;function Qne(n){return ese(n)}function ese(n,e){const t=Hf();t.__VUE__=!0;const{insert:s,remove:r,patchProp:o,createElement:i,createText:a,createComment:l,setText:u,setElementText:c,parentNode:h,nextSibling:d,setScopeId:p=Kr,insertStaticContent:f}=n,g=(z,U,de,xe=null,be=null,ve=null,_e=void 0,Oe=null,Ee=!!U.dynamicChildren)=>{if(z===U)return;z&&!jl(z,U)&&(xe=Ze(z),Ce(z,be,ve,!0),z=null),U.patchFlag===-2&&(Ee=!1,U.dynamicChildren=null);const{type:Ie,ref:qe,shapeFlag:Pe}=U;switch(Ie){case tm:y(z,U,de,xe);break;case hi:b(z,U,de,xe);break;case cg:z==null&&w(U,de,xe,_e);break;case rn:V(z,U,de,xe,be,ve,_e,Oe,Ee);break;default:Pe&1?I(z,U,de,xe,be,ve,_e,Oe,Ee):Pe&6?q(z,U,de,xe,be,ve,_e,Oe,Ee):(Pe&64||Pe&128)&&Ie.process(z,U,de,xe,be,ve,_e,Oe,Ee,at)}qe!=null&&be&&Bd(qe,z&&z.ref,ve,U||z,!U)},y=(z,U,de,xe)=>{if(z==null)s(U.el=a(U.children),de,xe);else{const be=U.el=z.el;U.children!==z.children&&u(be,U.children)}},b=(z,U,de,xe)=>{z==null?s(U.el=l(U.children||""),de,xe):U.el=z.el},w=(z,U,de,xe)=>{[z.el,z.anchor]=f(z.children,U,de,xe,z.el,z.anchor)},C=({el:z,anchor:U},de,xe)=>{let be;for(;z&&z!==U;)be=d(z),s(z,de,xe),z=be;s(U,de,xe)},v=({el:z,anchor:U})=>{let de;for(;z&&z!==U;)de=d(z),r(z),z=de;r(U)},I=(z,U,de,xe,be,ve,_e,Oe,Ee)=>{U.type==="svg"?_e="svg":U.type==="math"&&(_e="mathml"),z==null?E(U,de,xe,be,ve,_e,Oe,Ee):D(z,U,be,ve,_e,Oe,Ee)},E=(z,U,de,xe,be,ve,_e,Oe)=>{let Ee,Ie;const{props:qe,shapeFlag:Pe,transition:Xe,dirs:st}=z;if(Ee=z.el=i(z.type,ve,qe&&qe.is,qe),Pe&8?c(Ee,z.children):Pe&16&&L(z.children,Ee,null,xe,be,ug(z,ve),_e,Oe),st&&Fi(z,null,xe,"created"),R(Ee,z,z.scopeId,_e,xe),qe){for(const ft in qe)ft!=="value"&&!su(ft)&&o(Ee,ft,null,qe[ft],ve,xe);"value"in qe&&o(Ee,"value",null,qe.value,ve),(Ie=qe.onVnodeBeforeMount)&&Rr(Ie,xe,z)}st&&Fi(z,null,xe,"beforeMount");const lt=tse(be,Xe);lt&&Xe.beforeEnter(Ee),s(Ee,U,de),((Ie=qe&&qe.onVnodeMounted)||lt||st)&&ys(()=>{Ie&&Rr(Ie,xe,z),lt&&Xe.enter(Ee),st&&Fi(z,null,xe,"mounted")},be)},R=(z,U,de,xe,be)=>{if(de&&p(z,de),xe)for(let ve=0;ve<xe.length;ve++)p(z,xe[ve]);if(be){let ve=be.subTree;if(U===ve||dE(ve.type)&&(ve.ssContent===U||ve.ssFallback===U)){const _e=be.vnode;R(z,_e,_e.scopeId,_e.slotScopeIds,be.parent)}}},L=(z,U,de,xe,be,ve,_e,Oe,Ee=0)=>{for(let Ie=Ee;Ie<z.length;Ie++){const qe=z[Ie]=Oe?Uo(z[Ie]):Mr(z[Ie]);g(null,qe,U,de,xe,be,ve,_e,Oe)}},D=(z,U,de,xe,be,ve,_e)=>{const Oe=U.el=z.el;let{patchFlag:Ee,dynamicChildren:Ie,dirs:qe}=U;Ee|=z.patchFlag&16;const Pe=z.props||Lt,Xe=U.props||Lt;let st;if(de&&Li(de,!1),(st=Xe.onVnodeBeforeUpdate)&&Rr(st,de,U,z),qe&&Fi(U,z,de,"beforeUpdate"),de&&Li(de,!0),(Pe.innerHTML&&Xe.innerHTML==null||Pe.textContent&&Xe.textContent==null)&&c(Oe,""),Ie?F(z.dynamicChildren,Ie,Oe,de,xe,ug(U,be),ve):_e||Q(z,U,Oe,null,de,xe,ug(U,be),ve,!1),Ee>0){if(Ee&16)T(Oe,Pe,Xe,de,be);else if(Ee&2&&Pe.class!==Xe.class&&o(Oe,"class",null,Xe.class,be),Ee&4&&o(Oe,"style",Pe.style,Xe.style,be),Ee&8){const lt=U.dynamicProps;for(let ft=0;ft<lt.length;ft++){const yt=lt[ft],qt=Pe[yt],cn=Xe[yt];(cn!==qt||yt==="value")&&o(Oe,yt,qt,cn,be,de)}}Ee&1&&z.children!==U.children&&c(Oe,U.children)}else!_e&&Ie==null&&T(Oe,Pe,Xe,de,be);((st=Xe.onVnodeUpdated)||qe)&&ys(()=>{st&&Rr(st,de,U,z),qe&&Fi(U,z,de,"updated")},xe)},F=(z,U,de,xe,be,ve,_e)=>{for(let Oe=0;Oe<U.length;Oe++){const Ee=z[Oe],Ie=U[Oe],qe=Ee.el&&(Ee.type===rn||!jl(Ee,Ie)||Ee.shapeFlag&198)?h(Ee.el):de;g(Ee,Ie,qe,null,xe,be,ve,_e,!0)}},T=(z,U,de,xe,be)=>{if(U!==de){if(U!==Lt)for(const ve in U)!su(ve)&&!(ve in de)&&o(z,ve,U[ve],null,be,xe);for(const ve in de){if(su(ve))continue;const _e=de[ve],Oe=U[ve];_e!==Oe&&ve!=="value"&&o(z,ve,Oe,_e,be,xe)}"value"in de&&o(z,"value",U.value,de.value,be)}},V=(z,U,de,xe,be,ve,_e,Oe,Ee)=>{const Ie=U.el=z?z.el:a(""),qe=U.anchor=z?z.anchor:a("");let{patchFlag:Pe,dynamicChildren:Xe,slotScopeIds:st}=U;st&&(Oe=Oe?Oe.concat(st):st),z==null?(s(Ie,de,xe),s(qe,de,xe),L(U.children||[],de,qe,be,ve,_e,Oe,Ee)):Pe>0&&Pe&64&&Xe&&z.dynamicChildren?(F(z.dynamicChildren,Xe,de,be,ve,_e,Oe),(U.key!=null||be&&U===be.subTree)&&Z0(z,U,!0)):Q(z,U,de,qe,be,ve,_e,Oe,Ee)},q=(z,U,de,xe,be,ve,_e,Oe,Ee)=>{U.slotScopeIds=Oe,z==null?U.shapeFlag&512?be.ctx.activate(U,de,xe,_e,Ee):se(U,de,xe,be,ve,_e,Ee):ee(z,U,Ee)},se=(z,U,de,xe,be,ve,_e)=>{const Oe=z.component=bse(z,xe,be);if(q2(z)&&(Oe.ctx.renderer=at),xse(Oe,!1,_e),Oe.asyncDep){if(be&&be.registerDep(Oe,te,_e),!z.el){const Ee=Oe.subTree=ur(hi);b(null,Ee,U,de)}}else te(Oe,z,U,de,be,ve,_e)},ee=(z,U,de)=>{const xe=U.component=z.component;if(cse(z,U,de))if(xe.asyncDep&&!xe.asyncResolved){le(xe,U,de);return}else xe.next=U,xe.update();else U.el=z.el,xe.vnode=U},te=(z,U,de,xe,be,ve,_e)=>{const Oe=()=>{if(z.isMounted){let{next:Pe,bu:Xe,u:st,parent:lt,vnode:ft}=z;{const wn=aE(z);if(wn){Pe&&(Pe.el=ft.el,le(z,Pe,_e)),wn.asyncDep.then(()=>{z.isUnmounted||Oe()});return}}let yt=Pe,qt;Li(z,!1),Pe?(Pe.el=ft.el,le(z,Pe,_e)):Pe=ft,Xe&&td(Xe),(qt=Pe.props&&Pe.props.onVnodeBeforeUpdate)&&Rr(qt,lt,Pe,ft),Li(z,!0);const cn=B1(z),_n=z.subTree;z.subTree=cn,g(_n,cn,h(_n.el),Ze(_n),z,be,ve),Pe.el=cn.el,yt===null&&hse(z,cn.el),st&&ys(st,be),(qt=Pe.props&&Pe.props.onVnodeUpdated)&&ys(()=>Rr(qt,lt,Pe,ft),be)}else{let Pe;const{el:Xe,props:st}=U,{bm:lt,m:ft,parent:yt,root:qt,type:cn}=z,_n=au(U);Li(z,!1),lt&&td(lt),!_n&&(Pe=st&&st.onVnodeBeforeMount)&&Rr(Pe,yt,U),Li(z,!0);{qt.ce&&qt.ce._injectChildStyle(cn);const wn=z.subTree=B1(z);g(null,wn,de,xe,z,be,ve),U.el=wn.el}if(ft&&ys(ft,be),!_n&&(Pe=st&&st.onVnodeMounted)){const wn=U;ys(()=>Rr(Pe,yt,wn),be)}(U.shapeFlag&256||yt&&au(yt.vnode)&&yt.vnode.shapeFlag&256)&&z.a&&ys(z.a,be),z.isMounted=!0,U=de=xe=null}};z.scope.on();const Ee=z.effect=new k2(Oe);z.scope.off();const Ie=z.update=Ee.run.bind(Ee),qe=z.job=Ee.runIfDirty.bind(Ee);qe.i=z,qe.id=z.uid,Ee.scheduler=()=>K0(qe),Li(z,!0),Ie()},le=(z,U,de)=>{U.component=z;const xe=z.vnode.props;z.vnode=U,z.next=null,qne(z,U.props,xe,de),Jne(z,U.children,de),Co(),A1(z),So()},Q=(z,U,de,xe,be,ve,_e,Oe,Ee=!1)=>{const Ie=z&&z.children,qe=z?z.shapeFlag:0,Pe=U.children,{patchFlag:Xe,shapeFlag:st}=U;if(Xe>0){if(Xe&128){ye(Ie,Pe,de,xe,be,ve,_e,Oe,Ee);return}else if(Xe&256){he(Ie,Pe,de,xe,be,ve,_e,Oe,Ee);return}}st&8?(qe&16&&Me(Ie,be,ve),Pe!==Ie&&c(de,Pe)):qe&16?st&16?ye(Ie,Pe,de,xe,be,ve,_e,Oe,Ee):Me(Ie,be,ve,!0):(qe&8&&c(de,""),st&16&&L(Pe,de,xe,be,ve,_e,Oe,Ee))},he=(z,U,de,xe,be,ve,_e,Oe,Ee)=>{z=z||Ha,U=U||Ha;const Ie=z.length,qe=U.length,Pe=Math.min(Ie,qe);let Xe;for(Xe=0;Xe<Pe;Xe++){const st=U[Xe]=Ee?Uo(U[Xe]):Mr(U[Xe]);g(z[Xe],st,de,null,be,ve,_e,Oe,Ee)}Ie>qe?Me(z,be,ve,!0,!1,Pe):L(U,de,xe,be,ve,_e,Oe,Ee,Pe)},ye=(z,U,de,xe,be,ve,_e,Oe,Ee)=>{let Ie=0;const qe=U.length;let Pe=z.length-1,Xe=qe-1;for(;Ie<=Pe&&Ie<=Xe;){const st=z[Ie],lt=U[Ie]=Ee?Uo(U[Ie]):Mr(U[Ie]);if(jl(st,lt))g(st,lt,de,null,be,ve,_e,Oe,Ee);else break;Ie++}for(;Ie<=Pe&&Ie<=Xe;){const st=z[Pe],lt=U[Xe]=Ee?Uo(U[Xe]):Mr(U[Xe]);if(jl(st,lt))g(st,lt,de,null,be,ve,_e,Oe,Ee);else break;Pe--,Xe--}if(Ie>Pe){if(Ie<=Xe){const st=Xe+1,lt=st<qe?U[st].el:xe;for(;Ie<=Xe;)g(null,U[Ie]=Ee?Uo(U[Ie]):Mr(U[Ie]),de,lt,be,ve,_e,Oe,Ee),Ie++}}else if(Ie>Xe)for(;Ie<=Pe;)Ce(z[Ie],be,ve,!0),Ie++;else{const st=Ie,lt=Ie,ft=new Map;for(Ie=lt;Ie<=Xe;Ie++){const en=U[Ie]=Ee?Uo(U[Ie]):Mr(U[Ie]);en.key!=null&&ft.set(en.key,Ie)}let yt,qt=0;const cn=Xe-lt+1;let _n=!1,wn=0;const fs=new Array(cn);for(Ie=0;Ie<cn;Ie++)fs[Ie]=0;for(Ie=st;Ie<=Pe;Ie++){const en=z[Ie];if(qt>=cn){Ce(en,be,ve,!0);continue}let Ye;if(en.key!=null)Ye=ft.get(en.key);else for(yt=lt;yt<=Xe;yt++)if(fs[yt-lt]===0&&jl(en,U[yt])){Ye=yt;break}Ye===void 0?Ce(en,be,ve,!0):(fs[Ye-lt]=Ie+1,Ye>=wn?wn=Ye:_n=!0,g(en,U[Ye],de,null,be,ve,_e,Oe,Ee),qt++)}const Ro=_n?nse(fs):Ha;for(yt=Ro.length-1,Ie=cn-1;Ie>=0;Ie--){const en=lt+Ie,Ye=U[en],Do=en+1<qe?U[en+1].el:xe;fs[Ie]===0?g(null,Ye,de,Do,be,ve,_e,Oe,Ee):_n&&(yt<0||Ie!==Ro[yt]?we(Ye,de,Do,2):yt--)}}},we=(z,U,de,xe,be=null)=>{const{el:ve,type:_e,transition:Oe,children:Ee,shapeFlag:Ie}=z;if(Ie&6){we(z.component.subTree,U,de,xe);return}if(Ie&128){z.suspense.move(U,de,xe);return}if(Ie&64){_e.move(z,U,de,at);return}if(_e===rn){s(ve,U,de);for(let Pe=0;Pe<Ee.length;Pe++)we(Ee[Pe],U,de,xe);s(z.anchor,U,de);return}if(_e===cg){C(z,U,de);return}if(xe!==2&&Ie&1&&Oe)if(xe===0)Oe.beforeEnter(ve),s(ve,U,de),ys(()=>Oe.enter(ve),be);else{const{leave:Pe,delayLeave:Xe,afterLeave:st}=Oe,lt=()=>{z.ctx.isUnmounted?r(ve):s(ve,U,de)},ft=()=>{Pe(ve,()=>{lt(),st&&st()})};Xe?Xe(ve,lt,ft):ft()}else s(ve,U,de)},Ce=(z,U,de,xe=!1,be=!1)=>{const{type:ve,props:_e,ref:Oe,children:Ee,dynamicChildren:Ie,shapeFlag:qe,patchFlag:Pe,dirs:Xe,cacheIndex:st}=z;if(Pe===-2&&(be=!1),Oe!=null&&(Co(),Bd(Oe,null,de,z,!0),So()),st!=null&&(U.renderCache[st]=void 0),qe&256){U.ctx.deactivate(z);return}const lt=qe&1&&Xe,ft=!au(z);let yt;if(ft&&(yt=_e&&_e.onVnodeBeforeUnmount)&&Rr(yt,U,z),qe&6)Ae(z.component,de,xe);else{if(qe&128){z.suspense.unmount(de,xe);return}lt&&Fi(z,null,U,"beforeUnmount"),qe&64?z.type.remove(z,U,de,at,xe):Ie&&!Ie.hasOnce&&(ve!==rn||Pe>0&&Pe&64)?Me(Ie,U,de,!1,!0):(ve===rn&&Pe&384||!be&&qe&16)&&Me(Ee,U,de),xe&&Se(z)}(ft&&(yt=_e&&_e.onVnodeUnmounted)||lt)&&ys(()=>{yt&&Rr(yt,U,z),lt&&Fi(z,null,U,"unmounted")},de)},Se=z=>{const{type:U,el:de,anchor:xe,transition:be}=z;if(U===rn){Le(de,xe);return}if(U===cg){v(z);return}const ve=()=>{r(de),be&&!be.persisted&&be.afterLeave&&be.afterLeave()};if(z.shapeFlag&1&&be&&!be.persisted){const{leave:_e,delayLeave:Oe}=be,Ee=()=>_e(de,ve);Oe?Oe(z.el,ve,Ee):Ee()}else ve()},Le=(z,U)=>{let de;for(;z!==U;)de=d(z),r(z),z=de;r(U)},Ae=(z,U,de)=>{const{bum:xe,scope:be,job:ve,subTree:_e,um:Oe,m:Ee,a:Ie,parent:qe,slots:{__:Pe}}=z;M1(Ee),M1(Ie),xe&&td(xe),qe&&ut(Pe)&&Pe.forEach(Xe=>{qe.renderCache[Xe]=void 0}),be.stop(),ve&&(ve.flags|=8,Ce(_e,z,U,de)),Oe&&ys(Oe,U),ys(()=>{z.isUnmounted=!0},U),U&&U.pendingBranch&&!U.isUnmounted&&z.asyncDep&&!z.asyncResolved&&z.suspenseId===U.pendingId&&(U.deps--,U.deps===0&&U.resolve())},Me=(z,U,de,xe=!1,be=!1,ve=0)=>{for(let _e=ve;_e<z.length;_e++)Ce(z[_e],U,de,xe,be)},Ze=z=>{if(z.shapeFlag&6)return Ze(z.component.subTree);if(z.shapeFlag&128)return z.suspense.next();const U=d(z.anchor||z.el),de=U&&U[G2];return de?d(de):U};let ot=!1;const $e=(z,U,de)=>{z==null?U._vnode&&Ce(U._vnode,null,null,!0):g(U._vnode||null,z,U,null,null,null,de),U._vnode=z,ot||(ot=!0,A1(),V2(),ot=!1)},at={p:g,um:Ce,m:we,r:Se,mt:se,mc:L,pc:Q,pbc:F,n:Ze,o:n};return{render:$e,hydrate:void 0,createApp:Hne($e)}}function ug({type:n,props:e},t){return t==="svg"&&n==="foreignObject"||t==="mathml"&&n==="annotation-xml"&&e&&e.encoding&&e.encoding.includes("html")?void 0:t}function Li({effect:n,job:e},t){t?(n.flags|=32,e.flags|=4):(n.flags&=-33,e.flags&=-5)}function tse(n,e){return(!n||n&&!n.pendingBranch)&&e&&!e.persisted}function Z0(n,e,t=!1){const s=n.children,r=e.children;if(ut(s)&&ut(r))for(let o=0;o<s.length;o++){const i=s[o];let a=r[o];a.shapeFlag&1&&!a.dynamicChildren&&((a.patchFlag<=0||a.patchFlag===32)&&(a=r[o]=Uo(r[o]),a.el=i.el),!t&&a.patchFlag!==-2&&Z0(i,a)),a.type===tm&&(a.el=i.el),a.type===hi&&!a.el&&(a.el=i.el)}}function nse(n){const e=n.slice(),t=[0];let s,r,o,i,a;const l=n.length;for(s=0;s<l;s++){const u=n[s];if(u!==0){if(r=t[t.length-1],n[r]<u){e[s]=r,t.push(s);continue}for(o=0,i=t.length-1;o<i;)a=o+i>>1,n[t[a]]<u?o=a+1:i=a;u<n[t[o]]&&(o>0&&(e[s]=t[o-1]),t[o]=s)}}for(o=t.length,i=t[o-1];o-- >0;)t[o]=i,i=e[i];return t}function aE(n){const e=n.subTree.component;if(e)return e.asyncDep&&!e.asyncResolved?e:aE(e)}function M1(n){if(n)for(let e=0;e<n.length;e++)n[e].flags|=8}const sse=Symbol.for("v-scx"),rse=()=>sd(sse);function J0(n,e){return Qf(n,null,e)}function ose(n,e){return Qf(n,null,{flush:"sync"})}function Xr(n,e,t){return Qf(n,e,t)}function Qf(n,e,t=Lt){const{immediate:s,deep:r,flush:o,once:i}=t,a=Yn({},t),l=e&&s||!e&&o!=="post";let u;if(_u){if(o==="sync"){const p=rse();u=p.__watcherHandles||(p.__watcherHandles=[])}else if(!l){const p=()=>{};return p.stop=Kr,p.resume=Kr,p.pause=Kr,p}}const c=ls;a.call=(p,f,g)=>eo(p,c,f,g);let h=!1;o==="post"?a.scheduler=p=>{ys(p,c&&c.suspense)}:o!=="sync"&&(h=!0,a.scheduler=(p,f)=>{f?p():K0(p)}),a.augmentJob=p=>{e&&(p.flags|=4),h&&(p.flags|=2,c&&(p.id=c.uid,p.i=c))};const d=bne(n,e,a);return _u&&(u?u.push(d):l&&d()),d}function ise(n,e,t){const s=this.proxy,r=xn(n)?n.includes(".")?lE(s,n):()=>s[n]:n.bind(s,s);let o;gt(e)?o=e:(o=e.handler,t=e);const i=eh(this),a=Qf(r,o.bind(s),t);return i(),a}function lE(n,e){const t=e.split(".");return()=>{let s=n;for(let r=0;r<t.length&&s;r++)s=s[t[r]];return s}}function uE(n,e,t=Lt){const s=ew(),r=ko(e),o=Si(e),i=cE(n,r),a=fne((l,u)=>{let c,h=Lt,d;return ose(()=>{const p=n[r];Es(c,p)&&(c=p,u())}),{get(){return l(),t.get?t.get(c):c},set(p){const f=t.set?t.set(p):p;if(!Es(f,c)&&!(h!==Lt&&Es(p,h)))return;const g=s.vnode.props;g&&(e in g||r in g||o in g)&&(`onUpdate:${e}`in g||`onUpdate:${r}`in g||`onUpdate:${o}`in g)||(c=p,u()),s.emit(`update:${e}`,f),Es(p,f)&&Es(p,h)&&!Es(f,d)&&u(),h=p,d=f}}});return a[Symbol.iterator]=()=>{let l=0;return{next(){return l<2?{value:l++?i||Lt:a,done:!1}:{done:!0}}}},a}const cE=(n,e)=>e==="modelValue"||e==="model-value"?n.modelModifiers:n[`${e}Modifiers`]||n[`${ko(e)}Modifiers`]||n[`${Si(e)}Modifiers`];function ase(n,e,...t){if(n.isUnmounted)return;const s=n.vnode.props||Lt;let r=t;const o=e.startsWith("update:"),i=o&&cE(s,e.slice(7));i&&(i.trim&&(r=t.map(c=>xn(c)?c.trim():c)),i.number&&(r=t.map(hy)));let a,l=s[a=sg(e)]||s[a=sg(ko(e))];!l&&o&&(l=s[a=sg(Si(e))]),l&&eo(l,n,6,r);const u=s[a+"Once"];if(u){if(!n.emitted)n.emitted={};else if(n.emitted[a])return;n.emitted[a]=!0,eo(u,n,6,r)}}function hE(n,e,t=!1){const s=e.emitsCache,r=s.get(n);if(r!==void 0)return r;const o=n.emits;let i={},a=!1;if(!gt(n)){const l=u=>{const c=hE(u,e,!0);c&&(a=!0,Yn(i,c))};!t&&e.mixins.length&&e.mixins.forEach(l),n.extends&&l(n.extends),n.mixins&&n.mixins.forEach(l)}return!o&&!a?(Qt(n)&&s.set(n,null),null):(ut(o)?o.forEach(l=>i[l]=null):Yn(i,o),Qt(n)&&s.set(n,i),i)}function em(n,e){return!n||!Wf(e)?!1:(e=e.slice(2).replace(/Once$/,""),Mt(n,e[0].toLowerCase()+e.slice(1))||Mt(n,Si(e))||Mt(n,e))}function B1(n){const{type:e,vnode:t,proxy:s,withProxy:r,propsOptions:[o],slots:i,attrs:a,emit:l,render:u,renderCache:c,props:h,data:d,setupState:p,ctx:f,inheritAttrs:g}=n,y=Md(n);let b,w;try{if(t.shapeFlag&4){const v=r||s,I=v;b=Mr(u.call(I,v,c,h,p,d,f)),w=a}else{const v=e;b=Mr(v.length>1?v(h,{attrs:a,slots:i,emit:l}):v(h,null)),w=e.props?a:lse(a)}}catch(v){uu.length=0,Xf(v,n,1),b=ur(hi)}let C=b;if(w&&g!==!1){const v=Object.keys(w),{shapeFlag:I}=C;v.length&&I&7&&(o&&v.some(P0)&&(w=use(w,o)),C=cl(C,w,!1,!0))}return t.dirs&&(C=cl(C,null,!1,!0),C.dirs=C.dirs?C.dirs.concat(t.dirs):t.dirs),t.transition&&q0(C,t.transition),b=C,Md(y),b}const lse=n=>{let e;for(const t in n)(t==="class"||t==="style"||Wf(t))&&((e||(e={}))[t]=n[t]);return e},use=(n,e)=>{const t={};for(const s in n)(!P0(s)||!(s.slice(9)in e))&&(t[s]=n[s]);return t};function cse(n,e,t){const{props:s,children:r,component:o}=n,{props:i,children:a,patchFlag:l}=e,u=o.emitsOptions;if(e.dirs||e.transition)return!0;if(t&&l>=0){if(l&1024)return!0;if(l&16)return s?V1(s,i,u):!!i;if(l&8){const c=e.dynamicProps;for(let h=0;h<c.length;h++){const d=c[h];if(i[d]!==s[d]&&!em(u,d))return!0}}}else return(r||a)&&(!a||!a.$stable)?!0:s===i?!1:s?i?V1(s,i,u):!0:!!i;return!1}function V1(n,e,t){const s=Object.keys(e);if(s.length!==Object.keys(n).length)return!0;for(let r=0;r<s.length;r++){const o=s[r];if(e[o]!==n[o]&&!em(t,o))return!0}return!1}function hse({vnode:n,parent:e},t){for(;e;){const s=e.subTree;if(s.suspense&&s.suspense.activeBranch===n&&(s.el=n.el),s===n)(n=e.vnode).el=t,e=e.parent;else break}}const dE=n=>n.__isSuspense;function dse(n,e){e&&e.pendingBranch?ut(n)?e.effects.push(...n):e.effects.push(n):vne(n)}const rn=Symbol.for("v-fgt"),tm=Symbol.for("v-txt"),hi=Symbol.for("v-cmt"),cg=Symbol.for("v-stc"),uu=[];let js=null;function dt(n=!1){uu.push(js=n?null:[])}function pse(){uu.pop(),js=uu[uu.length-1]||null}let Eu=1;function W1(n,e=!1){Eu+=n,n<0&&js&&e&&(js.hasOnce=!0)}function pE(n){return n.dynamicChildren=Eu>0?js||Ha:null,pse(),Eu>0&&js&&js.push(n),n}function St(n,e,t,s,r,o){return pE(Fe(n,e,t,s,r,o,!0))}function Go(n,e,t,s,r){return pE(ur(n,e,t,s,r,!0))}function fE(n){return n?n.__v_isVNode===!0:!1}function jl(n,e){return n.type===e.type&&n.key===e.key}const mE=({key:n})=>n??null,rd=({ref:n,ref_key:e,ref_for:t})=>(typeof n=="number"&&(n=""+n),n!=null?xn(n)||cs(n)||gt(n)?{i:Hs,r:n,k:e,f:!!t}:n:null);function Fe(n,e=null,t=null,s=0,r=null,o=n===rn?0:1,i=!1,a=!1){const l={__v_isVNode:!0,__v_skip:!0,type:n,props:e,key:e&&mE(e),ref:e&&rd(e),scopeId:U2,slotScopeIds:null,children:t,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetStart:null,targetAnchor:null,staticCount:0,shapeFlag:o,patchFlag:s,dynamicProps:r,dynamicChildren:null,appContext:null,ctx:Hs};return a?(Q0(l,t),o&128&&n.normalize(l)):t&&(l.shapeFlag|=xn(t)?8:16),Eu>0&&!i&&js&&(l.patchFlag>0||o&6)&&l.patchFlag!==32&&js.push(l),l}const ur=fse;function fse(n,e=null,t=null,s=0,r=null,o=!1){if((!n||n===Pne)&&(n=hi),fE(n)){const a=cl(n,e,!0);return t&&Q0(a,t),Eu>0&&!o&&js&&(a.shapeFlag&6?js[js.indexOf(n)]=a:js.push(a)),a.patchFlag=-2,a}if(Cse(n)&&(n=n.__vccOpts),e){e=mse(e);let{class:a,style:l}=e;a&&!xn(a)&&(e.class=Qo(a)),Qt(l)&&(j0(l)&&!ut(l)&&(l=Yn({},l)),e.style=jf(l))}const i=xn(n)?1:dE(n)?128:Cne(n)?64:Qt(n)?4:gt(n)?2:0;return Fe(n,e,t,s,r,i,o,!0)}function mse(n){return n?j0(n)||tE(n)?Yn({},n):n:null}function cl(n,e,t=!1,s=!1){const{props:r,ref:o,patchFlag:i,children:a,transition:l}=n,u=e?gE(r||{},e):r,c={__v_isVNode:!0,__v_skip:!0,type:n.type,props:u,key:u&&mE(u),ref:e&&e.ref?t&&o?ut(o)?o.concat(rd(e)):[o,rd(e)]:rd(e):o,scopeId:n.scopeId,slotScopeIds:n.slotScopeIds,children:a,target:n.target,targetStart:n.targetStart,targetAnchor:n.targetAnchor,staticCount:n.staticCount,shapeFlag:n.shapeFlag,patchFlag:e&&n.type!==rn?i===-1?16:i|16:i,dynamicProps:n.dynamicProps,dynamicChildren:n.dynamicChildren,appContext:n.appContext,dirs:n.dirs,transition:l,component:n.component,suspense:n.suspense,ssContent:n.ssContent&&cl(n.ssContent),ssFallback:n.ssFallback&&cl(n.ssFallback),el:n.el,anchor:n.anchor,ctx:n.ctx,ce:n.ce};return l&&s&&q0(c,l.clone(c)),c}function Ud(n=" ",e=0){return ur(tm,null,n,e)}function qi(n="",e=!1){return e?(dt(),Go(hi,null,n)):ur(hi,null,n)}function Mr(n){return n==null||typeof n=="boolean"?ur(hi):ut(n)?ur(rn,null,n.slice()):fE(n)?Uo(n):ur(tm,null,String(n))}function Uo(n){return n.el===null&&n.patchFlag!==-1||n.memo?n:cl(n)}function Q0(n,e){let t=0;const{shapeFlag:s}=n;if(e==null)e=null;else if(ut(e))t=16;else if(typeof e=="object")if(s&65){const r=e.default;r&&(r._c&&(r._d=!1),Q0(n,r()),r._c&&(r._d=!0));return}else{t=32;const r=e._;!r&&!tE(e)?e._ctx=Hs:r===3&&Hs&&(Hs.slots._===1?e._=1:(e._=2,n.patchFlag|=1024))}else gt(e)?(e={default:e,_ctx:Hs},t=32):(e=String(e),s&64?(t=16,e=[Ud(e)]):t=8);n.children=e,n.shapeFlag|=t}function gE(...n){const e={};for(let t=0;t<n.length;t++){const s=n[t];for(const r in s)if(r==="class")e.class!==s.class&&(e.class=Qo([e.class,s.class]));else if(r==="style")e.style=jf([e.style,s.style]);else if(Wf(r)){const o=e[r],i=s[r];i&&o!==i&&!(ut(o)&&o.includes(i))&&(e[r]=o?[].concat(o,i):i)}else r!==""&&(e[r]=s[r])}return e}function Rr(n,e,t,s=null){eo(n,e,7,[t,s])}const gse=J2();let yse=0;function bse(n,e,t){const s=n.type,r=(e?e.appContext:n.appContext)||gse,o={uid:yse++,vnode:n,type:s,parent:e,appContext:r,root:null,next:null,subTree:null,effect:null,update:null,job:null,scope:new Ute(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:e?e.provides:Object.create(r.provides),ids:e?e.ids:["",0,0],accessCache:null,renderCache:[],components:null,directives:null,propsOptions:sE(s,r),emitsOptions:hE(s,r),emit:null,emitted:null,propsDefaults:Lt,inheritAttrs:s.inheritAttrs,ctx:Lt,data:Lt,props:Lt,attrs:Lt,slots:Lt,refs:Lt,setupState:Lt,setupContext:null,suspense:t,suspenseId:t?t.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return o.ctx={_:o},o.root=e?e.root:o,o.emit=ase.bind(null,o),n.ce&&n.ce(o),o}let ls=null;const ew=()=>ls||Hs;let Gd,ky;{const n=Hf(),e=(t,s)=>{let r;return(r=n[t])||(r=n[t]=[]),r.push(s),o=>{r.length>1?r.forEach(i=>i(o)):r[0](o)}};Gd=e("__VUE_INSTANCE_SETTERS__",t=>ls=t),ky=e("__VUE_SSR_SETTERS__",t=>_u=t)}const eh=n=>{const e=ls;return Gd(n),n.scope.on(),()=>{n.scope.off(),Gd(e)}},U1=()=>{ls&&ls.scope.off(),Gd(null)};function yE(n){return n.vnode.shapeFlag&4}let _u=!1;function xse(n,e=!1,t=!1){e&&ky(e);const{props:s,children:r}=n.vnode,o=yE(n);Kne(n,s,o,e),Zne(n,r,t||e);const i=o?wse(n,e):void 0;return e&&ky(!1),i}function wse(n,e){const t=n.type;n.accessCache=Object.create(null),n.proxy=new Proxy(n.ctx,zne);const{setup:s}=t;if(s){Co();const r=n.setupContext=s.length>1?kse(n):null,o=eh(n),i=Qc(s,n,0,[n.props,r]),a=d2(i);if(So(),o(),(a||n.sp)&&!au(n)&&K2(n),a){if(i.then(U1,U1),e)return i.then(l=>{G1(n,l)}).catch(l=>{Xf(l,n,0)});n.asyncDep=i}else G1(n,i)}else bE(n)}function G1(n,e,t){gt(e)?n.type.__ssrInlineRender?n.ssrRender=e:n.render=e:Qt(e)&&(n.setupState=z2(e)),bE(n)}function bE(n,e,t){const s=n.type;n.render||(n.render=s.render||Kr);{const r=eh(n);Co();try{Mne(n)}finally{So(),r()}}}const vse={get(n,e){return is(n,"get",""),n[e]}};function kse(n){const e=t=>{n.exposed=t||{}};return{attrs:new Proxy(n.attrs,vse),slots:n.slots,emit:n.emit,expose:e}}function nm(n){return n.exposed?n.exposeProxy||(n.exposeProxy=new Proxy(z2(cne(n.exposed)),{get(e,t){if(t in e)return e[t];if(t in lu)return lu[t](n)},has(e,t){return t in e||t in lu}})):n.proxy}function Cse(n){return gt(n)&&"__vccOpts"in n}const Cs=(n,e)=>gne(n,e,_u),Sse="3.5.15";/**
* @vue/runtime-dom v3.5.15
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let Cy;const H1=typeof window<"u"&&window.trustedTypes;if(H1)try{Cy=H1.createPolicy("vue",{createHTML:n=>n})}catch{}const xE=Cy?n=>Cy.createHTML(n):n=>n,Ise="http://www.w3.org/2000/svg",$se="http://www.w3.org/1998/Math/MathML",io=typeof document<"u"?document:null,j1=io&&io.createElement("template"),Nse={insert:(n,e,t)=>{e.insertBefore(n,t||null)},remove:n=>{const e=n.parentNode;e&&e.removeChild(n)},createElement:(n,e,t,s)=>{const r=e==="svg"?io.createElementNS(Ise,n):e==="mathml"?io.createElementNS($se,n):t?io.createElement(n,{is:t}):io.createElement(n);return n==="select"&&s&&s.multiple!=null&&r.setAttribute("multiple",s.multiple),r},createText:n=>io.createTextNode(n),createComment:n=>io.createComment(n),setText:(n,e)=>{n.nodeValue=e},setElementText:(n,e)=>{n.textContent=e},parentNode:n=>n.parentNode,nextSibling:n=>n.nextSibling,querySelector:n=>io.querySelector(n),setScopeId(n,e){n.setAttribute(e,"")},insertStaticContent(n,e,t,s,r,o){const i=t?t.previousSibling:e.lastChild;if(r&&(r===o||r.nextSibling))for(;e.insertBefore(r.cloneNode(!0),t),!(r===o||!(r=r.nextSibling)););else{j1.innerHTML=xE(s==="svg"?`<svg>${n}</svg>`:s==="mathml"?`<math>${n}</math>`:n);const a=j1.content;if(s==="svg"||s==="mathml"){const l=a.firstChild;for(;l.firstChild;)a.appendChild(l.firstChild);a.removeChild(l)}e.insertBefore(a,t)}return[i?i.nextSibling:e.firstChild,t?t.previousSibling:e.lastChild]}},Tse=Symbol("_vtc");function Ese(n,e,t){const s=n[Tse];s&&(e=(e?[e,...s]:[...s]).join(" ")),e==null?n.removeAttribute("class"):t?n.setAttribute("class",e):n.className=e}const Hd=Symbol("_vod"),wE=Symbol("_vsh"),vE={beforeMount(n,{value:e},{transition:t}){n[Hd]=n.style.display==="none"?"":n.style.display,t&&e?t.beforeEnter(n):Kl(n,e)},mounted(n,{value:e},{transition:t}){t&&e&&t.enter(n)},updated(n,{value:e,oldValue:t},{transition:s}){!e!=!t&&(s?e?(s.beforeEnter(n),Kl(n,!0),s.enter(n)):s.leave(n,()=>{Kl(n,!1)}):Kl(n,e))},beforeUnmount(n,{value:e}){Kl(n,e)}};function Kl(n,e){n.style.display=e?n[Hd]:"none",n[wE]=!e}const _se=Symbol(""),Ase=/(^|;)\s*display\s*:/;function Rse(n,e,t){const s=n.style,r=xn(t);let o=!1;if(t&&!r){if(e)if(xn(e))for(const i of e.split(";")){const a=i.slice(0,i.indexOf(":")).trim();t[a]==null&&od(s,a,"")}else for(const i in e)t[i]==null&&od(s,i,"");for(const i in t)i==="display"&&(o=!0),od(s,i,t[i])}else if(r){if(e!==t){const i=s[_se];i&&(t+=";"+i),s.cssText=t,o=Ase.test(t)}}else e&&n.removeAttribute("style");Hd in n&&(n[Hd]=o?s.display:"",n[wE]&&(s.display="none"))}const K1=/\s*!important$/;function od(n,e,t){if(ut(t))t.forEach(s=>od(n,e,s));else if(t==null&&(t=""),e.startsWith("--"))n.setProperty(e,t);else{const s=Dse(n,e);K1.test(t)?n.setProperty(Si(s),t.replace(K1,""),"important"):n[s]=t}}const q1=["Webkit","Moz","ms"],hg={};function Dse(n,e){const t=hg[e];if(t)return t;let s=ko(e);if(s!=="filter"&&s in n)return hg[e]=s;s=m2(s);for(let r=0;r<q1.length;r++){const o=q1[r]+s;if(o in n)return hg[e]=o}return e}const X1="http://www.w3.org/1999/xlink";function Y1(n,e,t,s,r,o=Vte(e)){s&&e.startsWith("xlink:")?t==null?n.removeAttributeNS(X1,e.slice(6,e.length)):n.setAttributeNS(X1,e,t):t==null||o&&!y2(t)?n.removeAttribute(e):n.setAttribute(e,o?"":Qr(t)?String(t):t)}function Z1(n,e,t,s,r){if(e==="innerHTML"||e==="textContent"){t!=null&&(n[e]=e==="innerHTML"?xE(t):t);return}const o=n.tagName;if(e==="value"&&o!=="PROGRESS"&&!o.includes("-")){const a=o==="OPTION"?n.getAttribute("value")||"":n.value,l=t==null?n.type==="checkbox"?"on":"":String(t);(a!==l||!("_value"in n))&&(n.value=l),t==null&&n.removeAttribute(e),n._value=t;return}let i=!1;if(t===""||t==null){const a=typeof n[e];a==="boolean"?t=y2(t):t==null&&a==="string"?(t="",i=!0):a==="number"&&(t=0,i=!0)}try{n[e]=t}catch{}i&&n.removeAttribute(r||e)}function Ho(n,e,t,s){n.addEventListener(e,t,s)}function Ose(n,e,t,s){n.removeEventListener(e,t,s)}const J1=Symbol("_vei");function Fse(n,e,t,s,r=null){const o=n[J1]||(n[J1]={}),i=o[e];if(s&&i)i.value=s;else{const[a,l]=Lse(e);if(s){const u=o[e]=Mse(s,r);Ho(n,a,u,l)}else i&&(Ose(n,a,i,l),o[e]=void 0)}}const Q1=/(?:Once|Passive|Capture)$/;function Lse(n){let e;if(Q1.test(n)){e={};let s;for(;s=n.match(Q1);)n=n.slice(0,n.length-s[0].length),e[s[0].toLowerCase()]=!0}return[n[2]===":"?n.slice(3):Si(n.slice(2)),e]}let dg=0;const Pse=Promise.resolve(),zse=()=>dg||(Pse.then(()=>dg=0),dg=Date.now());function Mse(n,e){const t=s=>{if(!s._vts)s._vts=Date.now();else if(s._vts<=t.attached)return;eo(Bse(s,t.value),e,5,[s])};return t.value=n,t.attached=zse(),t}function Bse(n,e){if(ut(e)){const t=n.stopImmediatePropagation;return n.stopImmediatePropagation=()=>{t.call(n),n._stopped=!0},e.map(s=>r=>!r._stopped&&s&&s(r))}else return e}const ek=n=>n.charCodeAt(0)===111&&n.charCodeAt(1)===110&&n.charCodeAt(2)>96&&n.charCodeAt(2)<123,Vse=(n,e,t,s,r,o)=>{const i=r==="svg";e==="class"?Ese(n,s,i):e==="style"?Rse(n,t,s):Wf(e)?P0(e)||Fse(n,e,t,s,o):(e[0]==="."?(e=e.slice(1),!0):e[0]==="^"?(e=e.slice(1),!1):Wse(n,e,s,i))?(Z1(n,e,s),!n.tagName.includes("-")&&(e==="value"||e==="checked"||e==="selected")&&Y1(n,e,s,i,o,e!=="value")):n._isVueCE&&(/[A-Z]/.test(e)||!xn(s))?Z1(n,ko(e),s,o,e):(e==="true-value"?n._trueValue=s:e==="false-value"&&(n._falseValue=s),Y1(n,e,s,i))};function Wse(n,e,t,s){if(s)return!!(e==="innerHTML"||e==="textContent"||e in n&&ek(e)&&gt(t));if(e==="spellcheck"||e==="draggable"||e==="translate"||e==="autocorrect"||e==="form"||e==="list"&&n.tagName==="INPUT"||e==="type"&&n.tagName==="TEXTAREA")return!1;if(e==="width"||e==="height"){const r=n.tagName;if(r==="IMG"||r==="VIDEO"||r==="CANVAS"||r==="SOURCE")return!1}return ek(e)&&xn(t)?!1:e in n}const hl=n=>{const e=n.props["onUpdate:modelValue"]||!1;return ut(e)?t=>td(e,t):e};function Use(n){n.target.composing=!0}function tk(n){const e=n.target;e.composing&&(e.composing=!1,e.dispatchEvent(new Event("input")))}const yo=Symbol("_assign"),Ra={created(n,{modifiers:{lazy:e,trim:t,number:s}},r){n[yo]=hl(r);const o=s||r.props&&r.props.type==="number";Ho(n,e?"change":"input",i=>{if(i.target.composing)return;let a=n.value;t&&(a=a.trim()),o&&(a=hy(a)),n[yo](a)}),t&&Ho(n,"change",()=>{n.value=n.value.trim()}),e||(Ho(n,"compositionstart",Use),Ho(n,"compositionend",tk),Ho(n,"change",tk))},mounted(n,{value:e}){n.value=e??""},beforeUpdate(n,{value:e,oldValue:t,modifiers:{lazy:s,trim:r,number:o}},i){if(n[yo]=hl(i),n.composing)return;const a=(o||n.type==="number")&&!/^0\d/.test(n.value)?hy(n.value):n.value,l=e??"";a!==l&&(document.activeElement===n&&n.type!=="range"&&(s&&e===t||r&&n.value.trim()===l)||(n.value=l))}},Gse={deep:!0,created(n,e,t){n[yo]=hl(t),Ho(n,"change",()=>{const s=n._modelValue,r=kE(n),o=n.checked,i=n[yo];if(ut(s)){const a=b2(s,r),l=a!==-1;if(o&&!l)i(s.concat(r));else if(!o&&l){const u=[...s];u.splice(a,1),i(u)}}else if(Uf(s)){const a=new Set(s);o?a.add(r):a.delete(r),i(a)}else i(CE(n,o))})},mounted:nk,beforeUpdate(n,e,t){n[yo]=hl(t),nk(n,e,t)}};function nk(n,{value:e,oldValue:t},s){n._modelValue=e;let r;if(ut(e))r=b2(e,s.props.value)>-1;else if(Uf(e))r=e.has(s.props.value);else{if(e===t)return;r=ul(e,CE(n,!0))}n.checked!==r&&(n.checked=r)}const Hse={created(n,{value:e},t){n.checked=ul(e,t.props.value),n[yo]=hl(t),Ho(n,"change",()=>{n[yo](kE(n))})},beforeUpdate(n,{value:e,oldValue:t},s){n[yo]=hl(s),e!==t&&(n.checked=ul(e,s.props.value))}};function kE(n){return"_value"in n?n._value:n.value}function CE(n,e){const t=e?"_trueValue":"_falseValue";return t in n?n[t]:e}const jse=["ctrl","shift","alt","meta"],Kse={stop:n=>n.stopPropagation(),prevent:n=>n.preventDefault(),self:n=>n.target!==n.currentTarget,ctrl:n=>!n.ctrlKey,shift:n=>!n.shiftKey,alt:n=>!n.altKey,meta:n=>!n.metaKey,left:n=>"button"in n&&n.button!==0,middle:n=>"button"in n&&n.button!==1,right:n=>"button"in n&&n.button!==2,exact:(n,e)=>jse.some(t=>n[`${t}Key`]&&!e.includes(t))},qse=(n,e)=>{const t=n._withMods||(n._withMods={}),s=e.join(".");return t[s]||(t[s]=(r,...o)=>{for(let i=0;i<e.length;i++){const a=Kse[e[i]];if(a&&a(r,e))return}return n(r,...o)})},Xse=Yn({patchProp:Vse},Nse);let sk;function Yse(){return sk||(sk=Qne(Xse))}const Zse=(...n)=>{const e=Yse().createApp(...n),{mount:t}=e;return e.mount=s=>{const r=Qse(s);if(!r)return;const o=e._component;!gt(o)&&!o.render&&!o.template&&(o.template=r.innerHTML),r.nodeType===1&&(r.textContent="");const i=t(r,!1,Jse(r));return r instanceof Element&&(r.removeAttribute("v-cloak"),r.setAttribute("data-v-app","")),i},e};function Jse(n){if(n instanceof SVGElement)return"svg";if(typeof MathMLElement=="function"&&n instanceof MathMLElement)return"mathml"}function Qse(n){return xn(n)?document.querySelector(n):n}var ere=Object.defineProperty,tre=(n,e,t)=>e in n?ere(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,jn=(n,e,t)=>tre(n,typeof e!="symbol"?e+"":e,t);function sm(n){return v2()?(Gte(n),!0):!1}const nre=typeof window<"u"&&typeof document<"u";typeof WorkerGlobalScope<"u"&&globalThis instanceof WorkerGlobalScope;const sre=n=>n!=null,rre=Object.prototype.toString,ore=n=>rre.call(n)==="[object Object]",ire=()=>{};function cu(n){return Array.isArray(n)?n:[n]}function are(n){return ew()}function lre(n,e=!0,t){are()?_l(n,t):e?n():Yf(n)}function ure(n,e,t){return Xr(n,e,{...t,immediate:!0})}const Al=nre?window:void 0;function fo(n){var e;const t=qa(n);return(e=t==null?void 0:t.$el)!=null?e:t}function jd(...n){const e=[],t=()=>{e.forEach(a=>a()),e.length=0},s=(a,l,u,c)=>(a.addEventListener(l,u,c),()=>a.removeEventListener(l,u,c)),r=Cs(()=>{const a=cu(qa(n[0])).filter(l=>l!=null);return a.every(l=>typeof l!="string")?a:void 0}),o=ure(()=>{var a,l;return[(l=(a=r.value)==null?void 0:a.map(u=>fo(u)))!=null?l:[Al].filter(u=>u!=null),cu(qa(r.value?n[1]:n[0])),cu(Cr(r.value?n[2]:n[1])),qa(r.value?n[3]:n[2])]},([a,l,u,c])=>{if(t(),!(a!=null&&a.length)||!(l!=null&&l.length)||!(u!=null&&u.length))return;const h=ore(c)?{...c}:c;e.push(...a.flatMap(d=>l.flatMap(p=>u.map(f=>s(d,p,f,h)))))},{flush:"post"}),i=()=>{o(),t()};return sm(t),i}function cre(){const n=Ld(!1),e=ew();return e&&_l(()=>{n.value=!0},e),n}function SE(n){const e=cre();return Cs(()=>(e.value,!!n()))}function hre(n,e,t={}){const{window:s=Al,...r}=t;let o;const i=SE(()=>s&&"MutationObserver"in s),a=()=>{o&&(o.disconnect(),o=void 0)},l=Cs(()=>{const d=qa(n),p=cu(d).map(fo).filter(sre);return new Set(p)}),u=Xr(()=>l.value,d=>{a(),i.value&&d.size&&(o=new MutationObserver(e),d.forEach(p=>o.observe(p,r)))},{immediate:!0,flush:"post"}),c=()=>o==null?void 0:o.takeRecords(),h=()=>{u(),a()};return sm(h),{isSupported:i,stop:h,takeRecords:c}}function dre(n,e,t={}){const{window:s=Al,document:r=s==null?void 0:s.document,flush:o="sync"}=t;if(!s||!r)return ire;let i;const a=c=>{i==null||i(),i=c},l=J0(()=>{const c=fo(n);if(c){const{stop:h}=hre(r,d=>{d.map(p=>[...p.removedNodes]).flat().some(p=>p===c||p.contains(c))&&e(d)},{window:s,childList:!0,subtree:!0});a(h)}},{flush:o}),u=()=>{l(),a()};return sm(u),u}function pre(n={}){var e;const{window:t=Al,deep:s=!0,triggerOnRemoval:r=!1}=n,o=(e=n.document)!=null?e:t==null?void 0:t.document,i=()=>{var u;let c=o==null?void 0:o.activeElement;if(s)for(;c!=null&&c.shadowRoot;)c=(u=c==null?void 0:c.shadowRoot)==null?void 0:u.activeElement;return c},a=Ld(),l=()=>{a.value=i()};if(t){const u={capture:!0,passive:!0};jd(t,"blur",c=>{c.relatedTarget===null&&l()},u),jd(t,"focus",l,u)}return r&&dre(a,l,{document:o}),l(),a}function fre(n,e,t={}){const{window:s=Al,...r}=t;let o;const i=SE(()=>s&&"ResizeObserver"in s),a=()=>{o&&(o.disconnect(),o=void 0)},l=Cs(()=>{const h=qa(n);return Array.isArray(h)?h.map(d=>fo(d)):[fo(h)]}),u=Xr(l,h=>{if(a(),i.value&&s){o=new ResizeObserver(e);for(const d of h)d&&o.observe(d,r)}},{immediate:!0,flush:"post"}),c=()=>{a(),u()};return sm(c),{isSupported:i,stop:c}}function IE(n,e={width:0,height:0},t={}){const{window:s=Al,box:r="content-box"}=t,o=Cs(()=>{var h,d;return(d=(h=fo(n))==null?void 0:h.namespaceURI)==null?void 0:d.includes("svg")}),i=Ld(e.width),a=Ld(e.height),{stop:l}=fre(n,([h])=>{const d=r==="border-box"?h.borderBoxSize:r==="content-box"?h.contentBoxSize:h.devicePixelContentBoxSize;if(s&&o.value){const p=fo(n);if(p){const f=p.getBoundingClientRect();i.value=f.width,a.value=f.height}}else if(d){const p=cu(d);i.value=p.reduce((f,{inlineSize:g})=>f+g,0),a.value=p.reduce((f,{blockSize:g})=>f+g,0)}else i.value=h.contentRect.width,a.value=h.contentRect.height},t);lre(()=>{const h=fo(n);h&&(i.value="offsetWidth"in h?h.offsetWidth:e.width,a.value="offsetHeight"in h?h.offsetHeight:e.height)});const u=Xr(()=>fo(n),h=>{i.value=h?e.width:0,a.value=h?e.height:0});function c(){l(),u()}return{width:i,height:a,stop:c}}var mre=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function gre(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var Sy={exports:{}},yre=Sy.exports,rk;function bre(){return rk||(rk=1,function(n,e){(function(t,s){n.exports=s()})(yre,function(){var t=function(m,x){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(k,$){k.__proto__=$}||function(k,$){for(var N in $)Object.prototype.hasOwnProperty.call($,N)&&(k[N]=$[N])})(m,x)},s=function(){return(s=Object.assign||function(m){for(var x,k=1,$=arguments.length;k<$;k++)for(var N in x=arguments[k])Object.prototype.hasOwnProperty.call(x,N)&&(m[N]=x[N]);return m}).apply(this,arguments)};function r(m,x,k){for(var $,N=0,_=x.length;N<_;N++)!$&&N in x||(($=$||Array.prototype.slice.call(x,0,N))[N]=x[N]);return m.concat($||Array.prototype.slice.call(x))}var o=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:mre,i=Object.keys,a=Array.isArray;function l(m,x){return typeof x!="object"||i(x).forEach(function(k){m[k]=x[k]}),m}typeof Promise>"u"||o.Promise||(o.Promise=Promise);var u=Object.getPrototypeOf,c={}.hasOwnProperty;function h(m,x){return c.call(m,x)}function d(m,x){typeof x=="function"&&(x=x(u(m))),(typeof Reflect>"u"?i:Reflect.ownKeys)(x).forEach(function(k){f(m,k,x[k])})}var p=Object.defineProperty;function f(m,x,k,$){p(m,x,l(k&&h(k,"get")&&typeof k.get=="function"?{get:k.get,set:k.set,configurable:!0}:{value:k,configurable:!0,writable:!0},$))}function g(m){return{from:function(x){return m.prototype=Object.create(x.prototype),f(m.prototype,"constructor",m),{extend:d.bind(null,m.prototype)}}}}var y=Object.getOwnPropertyDescriptor,b=[].slice;function w(m,x,k){return b.call(m,x,k)}function C(m,x){return x(m)}function v(m){if(!m)throw new Error("Assertion Failed")}function I(m){o.setImmediate?setImmediate(m):setTimeout(m,0)}function E(m,x){if(typeof x=="string"&&h(m,x))return m[x];if(!x)return m;if(typeof x!="string"){for(var k=[],$=0,N=x.length;$<N;++$){var _=E(m,x[$]);k.push(_)}return k}var P=x.indexOf(".");if(P!==-1){var M=m[x.substr(0,P)];return M==null?void 0:E(M,x.substr(P+1))}}function R(m,x,k){if(m&&x!==void 0&&!("isFrozen"in Object&&Object.isFrozen(m)))if(typeof x!="string"&&"length"in x){v(typeof k!="string"&&"length"in k);for(var $=0,N=x.length;$<N;++$)R(m,x[$],k[$])}else{var _,P,M=x.indexOf(".");M!==-1?(_=x.substr(0,M),(P=x.substr(M+1))===""?k===void 0?a(m)&&!isNaN(parseInt(_))?m.splice(_,1):delete m[_]:m[_]=k:R(M=!(M=m[_])||!h(m,_)?m[_]={}:M,P,k)):k===void 0?a(m)&&!isNaN(parseInt(x))?m.splice(x,1):delete m[x]:m[x]=k}}function L(m){var x,k={};for(x in m)h(m,x)&&(k[x]=m[x]);return k}var D=[].concat;function F(m){return D.apply([],m)}var lt="BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(F([8,16,32,64].map(function(m){return["Int","Uint","Float"].map(function(x){return x+m+"Array"})}))).filter(function(m){return o[m]}),T=new Set(lt.map(function(m){return o[m]})),V=null;function q(m){return V=new WeakMap,m=function x(k){if(!k||typeof k!="object")return k;var $=V.get(k);if($)return $;if(a(k)){$=[],V.set(k,$);for(var N=0,_=k.length;N<_;++N)$.push(x(k[N]))}else if(T.has(k.constructor))$=k;else{var P,M=u(k);for(P in $=M===Object.prototype?{}:Object.create(M),V.set(k,$),k)h(k,P)&&($[P]=x(k[P]))}return $}(m),V=null,m}var se={}.toString;function ee(m){return se.call(m).slice(8,-1)}var te=typeof Symbol<"u"?Symbol.iterator:"@@iterator",le=typeof te=="symbol"?function(m){var x;return m!=null&&(x=m[te])&&x.apply(m)}:function(){return null};function Q(m,x){return x=m.indexOf(x),0<=x&&m.splice(x,1),0<=x}var he={};function ye(m){var x,k,$,N;if(arguments.length===1){if(a(m))return m.slice();if(this===he&&typeof m=="string")return[m];if(N=le(m)){for(k=[];!($=N.next()).done;)k.push($.value);return k}if(m==null)return[m];if(typeof(x=m.length)!="number")return[m];for(k=new Array(x);x--;)k[x]=m[x];return k}for(x=arguments.length,k=new Array(x);x--;)k[x]=arguments[x];return k}var we=typeof Symbol<"u"?function(m){return m[Symbol.toStringTag]==="AsyncFunction"}:function(){return!1},st=["Unknown","Constraint","Data","TransactionInactive","ReadOnly","Version","NotFound","InvalidState","InvalidAccess","Abort","Timeout","QuotaExceeded","Syntax","DataClone"],Zs=["Modify","Bulk","OpenFailed","VersionChange","Schema","Upgrade","InvalidTable","MissingAPI","NoSuchDatabase","InvalidArgument","SubTransaction","Unsupported","Internal","DatabaseClosed","PrematureCommit","ForeignAwait"].concat(st),Ce={VersionChanged:"Database version changed by other database connection",DatabaseClosed:"Database has been closed",Abort:"Transaction aborted",TransactionInactive:"Transaction has already completed or failed",MissingAPI:"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"};function Se(m,x){this.name=m,this.message=x}function Le(m,x){return m+". Errors: "+Object.keys(x).map(function(k){return x[k].toString()}).filter(function(k,$,N){return N.indexOf(k)===$}).join(`
`)}function Ae(m,x,k,$){this.failures=x,this.failedKeys=$,this.successCount=k,this.message=Le(m,x)}function Me(m,x){this.name="BulkError",this.failures=Object.keys(x).map(function(k){return x[k]}),this.failuresByPos=x,this.message=Le(m,this.failures)}g(Se).from(Error).extend({toString:function(){return this.name+": "+this.message}}),g(Ae).from(Se),g(Me).from(Se);var Ze=Zs.reduce(function(m,x){return m[x]=x+"Error",m},{}),ot=Se,$e=Zs.reduce(function(m,x){var k=x+"Error";function $(N,_){this.name=k,N?typeof N=="string"?(this.message="".concat(N).concat(_?`
 `+_:""),this.inner=_||null):typeof N=="object"&&(this.message="".concat(N.name," ").concat(N.message),this.inner=N):(this.message=Ce[x]||k,this.inner=null)}return g($).from(ot),m[x]=$,m},{});$e.Syntax=SyntaxError,$e.Type=TypeError,$e.Range=RangeError;var at=st.reduce(function(m,x){return m[x+"Error"]=$e[x],m},{}),ht=Zs.reduce(function(m,x){return["Syntax","Type","Range"].indexOf(x)===-1&&(m[x+"Error"]=$e[x]),m},{});function z(){}function U(m){return m}function de(m,x){return m==null||m===U?x:function(k){return x(m(k))}}function xe(m,x){return function(){m.apply(this,arguments),x.apply(this,arguments)}}function be(m,x){return m===z?x:function(){var k=m.apply(this,arguments);k!==void 0&&(arguments[0]=k);var $=this.onsuccess,N=this.onerror;this.onsuccess=null,this.onerror=null;var _=x.apply(this,arguments);return $&&(this.onsuccess=this.onsuccess?xe($,this.onsuccess):$),N&&(this.onerror=this.onerror?xe(N,this.onerror):N),_!==void 0?_:k}}function ve(m,x){return m===z?x:function(){m.apply(this,arguments);var k=this.onsuccess,$=this.onerror;this.onsuccess=this.onerror=null,x.apply(this,arguments),k&&(this.onsuccess=this.onsuccess?xe(k,this.onsuccess):k),$&&(this.onerror=this.onerror?xe($,this.onerror):$)}}function _e(m,x){return m===z?x:function(k){var $=m.apply(this,arguments);l(k,$);var N=this.onsuccess,_=this.onerror;return this.onsuccess=null,this.onerror=null,k=x.apply(this,arguments),N&&(this.onsuccess=this.onsuccess?xe(N,this.onsuccess):N),_&&(this.onerror=this.onerror?xe(_,this.onerror):_),$===void 0?k===void 0?void 0:k:l($,k)}}function Oe(m,x){return m===z?x:function(){return x.apply(this,arguments)!==!1&&m.apply(this,arguments)}}function Ee(m,x){return m===z?x:function(){var k=m.apply(this,arguments);if(k&&typeof k.then=="function"){for(var $=this,N=arguments.length,_=new Array(N);N--;)_[N]=arguments[N];return k.then(function(){return x.apply($,_)})}return x.apply(this,arguments)}}ht.ModifyError=Ae,ht.DexieError=Se,ht.BulkError=Me;var Ie=typeof location<"u"&&/^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);function qe(m){Ie=m}var Pe={},Xe=100,lt=typeof Promise>"u"?[]:function(){var m=Promise.resolve();if(typeof crypto>"u"||!crypto.subtle)return[m,u(m),m];var x=crypto.subtle.digest("SHA-512",new Uint8Array([0]));return[x,u(x),m]}(),st=lt[0],Zs=lt[1],lt=lt[2],Zs=Zs&&Zs.then,ft=st&&st.constructor,yt=!!lt,qt=function(m,x){Do.push([m,x]),_n&&(queueMicrotask(AE),_n=!1)},cn=!0,_n=!0,wn=[],fs=[],Ro=U,en={id:"global",global:!0,ref:0,unhandleds:[],onunhandled:z,pgp:!1,env:{},finalize:z},Ye=en,Do=[],Ii=0,th=[];function je(m){if(typeof this!="object")throw new TypeError("Promises must be constructed via new");this._listeners=[],this._lib=!1;var x=this._PSD=Ye;if(typeof m!="function"){if(m!==Pe)throw new TypeError("Not a function");return this._state=arguments[1],this._value=arguments[2],void(this._state===!1&&om(this,this._value))}this._state=null,this._value=null,++x.ref,function k($,N){try{N(function(_){if($._state===null){if(_===$)throw new TypeError("A promise cannot be resolved with itself.");var P=$._lib&&va();_&&typeof _.then=="function"?k($,function(M,X){_ instanceof je?_._then(M,X):_.then(M,X)}):($._state=!0,$._value=_,rw($)),P&&ka()}},om.bind(null,$))}catch(_){om($,_)}}(this,m)}var rm={get:function(){var m=Ye,x=oh;function k($,N){var _=this,P=!m.global&&(m!==Ye||x!==oh),M=P&&!Fo(),X=new je(function(Z,re){im(_,new sw(iw($,m,P,M),iw(N,m,P,M),Z,re,m))});return this._consoleTask&&(X._consoleTask=this._consoleTask),X}return k.prototype=Pe,k},set:function(m){f(this,"then",m&&m.prototype===Pe?rm:{get:function(){return m},set:rm.set})}};function sw(m,x,k,$,N){this.onFulfilled=typeof m=="function"?m:null,this.onRejected=typeof x=="function"?x:null,this.resolve=k,this.reject=$,this.psd=N}function om(m,x){var k,$;fs.push(x),m._state===null&&(k=m._lib&&va(),x=Ro(x),m._state=!1,m._value=x,$=m,wn.some(function(N){return N._value===$._value})||wn.push($),rw(m),k&&ka())}function rw(m){var x=m._listeners;m._listeners=[];for(var k=0,$=x.length;k<$;++k)im(m,x[k]);var N=m._PSD;--N.ref||N.finalize(),Ii===0&&(++Ii,qt(function(){--Ii==0&&am()},[]))}function im(m,x){if(m._state!==null){var k=m._state?x.onFulfilled:x.onRejected;if(k===null)return(m._state?x.resolve:x.reject)(m._value);++x.psd.ref,++Ii,qt(_E,[k,m,x])}else m._listeners.push(x)}function _E(m,x,k){try{var $,N=x._value;!x._state&&fs.length&&(fs=[]),$=Ie&&x._consoleTask?x._consoleTask.run(function(){return m(N)}):m(N),x._state||fs.indexOf(N)!==-1||function(_){for(var P=wn.length;P;)if(wn[--P]._value===_._value)return wn.splice(P,1)}(x),k.resolve($)}catch(_){k.reject(_)}finally{--Ii==0&&am(),--k.psd.ref||k.psd.finalize()}}function AE(){$i(en,function(){va()&&ka()})}function va(){var m=cn;return _n=cn=!1,m}function ka(){var m,x,k;do for(;0<Do.length;)for(m=Do,Do=[],k=m.length,x=0;x<k;++x){var $=m[x];$[0].apply(null,$[1])}while(0<Do.length);_n=cn=!0}function am(){var m=wn;wn=[],m.forEach(function($){$._PSD.onunhandled.call(null,$._value,$)});for(var x=th.slice(0),k=x.length;k;)x[--k]()}function nh(m){return new je(Pe,!1,m)}function tn(m,x){var k=Ye;return function(){var $=va(),N=Ye;try{return Lo(k,!0),m.apply(this,arguments)}catch(_){x&&x(_)}finally{Lo(N,!1),$&&ka()}}}d(je.prototype,{then:rm,_then:function(m,x){im(this,new sw(null,null,m,x,Ye))},catch:function(m){if(arguments.length===1)return this.then(null,m);var x=m,k=arguments[1];return typeof x=="function"?this.then(null,function($){return($ instanceof x?k:nh)($)}):this.then(null,function($){return($&&$.name===x?k:nh)($)})},finally:function(m){return this.then(function(x){return je.resolve(m()).then(function(){return x})},function(x){return je.resolve(m()).then(function(){return nh(x)})})},timeout:function(m,x){var k=this;return m<1/0?new je(function($,N){var _=setTimeout(function(){return N(new $e.Timeout(x))},m);k.then($,N).finally(clearTimeout.bind(null,_))}):this}}),typeof Symbol<"u"&&Symbol.toStringTag&&f(je.prototype,Symbol.toStringTag,"Dexie.Promise"),en.env=ow(),d(je,{all:function(){var m=ye.apply(null,arguments).map(ih);return new je(function(x,k){m.length===0&&x([]);var $=m.length;m.forEach(function(N,_){return je.resolve(N).then(function(P){m[_]=P,--$||x(m)},k)})})},resolve:function(m){return m instanceof je?m:m&&typeof m.then=="function"?new je(function(x,k){m.then(x,k)}):new je(Pe,!0,m)},reject:nh,race:function(){var m=ye.apply(null,arguments).map(ih);return new je(function(x,k){m.map(function($){return je.resolve($).then(x,k)})})},PSD:{get:function(){return Ye},set:function(m){return Ye=m}},totalEchoes:{get:function(){return oh}},newPSD:Oo,usePSD:$i,scheduler:{get:function(){return qt},set:function(m){qt=m}},rejectionMapper:{get:function(){return Ro},set:function(m){Ro=m}},follow:function(m,x){return new je(function(k,$){return Oo(function(N,_){var P=Ye;P.unhandleds=[],P.onunhandled=_,P.finalize=xe(function(){var M,X=this;M=function(){X.unhandleds.length===0?N():_(X.unhandleds[0])},th.push(function Z(){M(),th.splice(th.indexOf(Z),1)}),++Ii,qt(function(){--Ii==0&&am()},[])},P.finalize),m()},x,k,$)})}}),ft&&(ft.allSettled&&f(je,"allSettled",function(){var m=ye.apply(null,arguments).map(ih);return new je(function(x){m.length===0&&x([]);var k=m.length,$=new Array(k);m.forEach(function(N,_){return je.resolve(N).then(function(P){return $[_]={status:"fulfilled",value:P}},function(P){return $[_]={status:"rejected",reason:P}}).then(function(){return--k||x($)})})})}),ft.any&&typeof AggregateError<"u"&&f(je,"any",function(){var m=ye.apply(null,arguments).map(ih);return new je(function(x,k){m.length===0&&k(new AggregateError([]));var $=m.length,N=new Array($);m.forEach(function(_,P){return je.resolve(_).then(function(M){return x(M)},function(M){N[P]=M,--$||k(new AggregateError(N))})})})}),ft.withResolvers&&(je.withResolvers=ft.withResolvers));var Ln={awaits:0,echoes:0,id:0},RE=0,sh=[],rh=0,oh=0,DE=0;function Oo(m,x,k,$){var N=Ye,_=Object.create(N);return _.parent=N,_.ref=0,_.global=!1,_.id=++DE,en.env,_.env=yt?{Promise:je,PromiseProp:{value:je,configurable:!0,writable:!0},all:je.all,race:je.race,allSettled:je.allSettled,any:je.any,resolve:je.resolve,reject:je.reject}:{},x&&l(_,x),++N.ref,_.finalize=function(){--this.parent.ref||this.parent.finalize()},$=$i(_,m,k,$),_.ref===0&&_.finalize(),$}function Ca(){return Ln.id||(Ln.id=++RE),++Ln.awaits,Ln.echoes+=Xe,Ln.id}function Fo(){return!!Ln.awaits&&(--Ln.awaits==0&&(Ln.id=0),Ln.echoes=Ln.awaits*Xe,!0)}function ih(m){return Ln.echoes&&m&&m.constructor===ft?(Ca(),m.then(function(x){return Fo(),x},function(x){return Fo(),gn(x)})):m}function OE(){var m=sh[sh.length-1];sh.pop(),Lo(m,!1)}function Lo(m,x){var k,$=Ye;(x?!Ln.echoes||rh++&&m===Ye:!rh||--rh&&m===Ye)||queueMicrotask(x?(function(N){++oh,Ln.echoes&&--Ln.echoes!=0||(Ln.echoes=Ln.awaits=Ln.id=0),sh.push(Ye),Lo(N,!0)}).bind(null,m):OE),m!==Ye&&(Ye=m,$===en&&(en.env=ow()),yt&&(k=en.env.Promise,x=m.env,($.global||m.global)&&(Object.defineProperty(o,"Promise",x.PromiseProp),k.all=x.all,k.race=x.race,k.resolve=x.resolve,k.reject=x.reject,x.allSettled&&(k.allSettled=x.allSettled),x.any&&(k.any=x.any))))}function ow(){var m=o.Promise;return yt?{Promise:m,PromiseProp:Object.getOwnPropertyDescriptor(o,"Promise"),all:m.all,race:m.race,allSettled:m.allSettled,any:m.any,resolve:m.resolve,reject:m.reject}:{}}function $i(m,x,k,$,N){var _=Ye;try{return Lo(m,!0),x(k,$,N)}finally{Lo(_,!1)}}function iw(m,x,k,$){return typeof m!="function"?m:function(){var N=Ye;k&&Ca(),Lo(x,!0);try{return m.apply(this,arguments)}finally{Lo(N,!1),$&&queueMicrotask(Fo)}}}function lm(m){Promise===ft&&Ln.echoes===0?rh===0?m():enqueueNativeMicroTask(m):setTimeout(m,0)}(""+Zs).indexOf("[native code]")===-1&&(Ca=Fo=z);var gn=je.reject,Ni="",so="Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.",aw="String expected.",Sa=[],ah="__dbnames",um="readonly",cm="readwrite";function Ti(m,x){return m?x?function(){return m.apply(this,arguments)&&x.apply(this,arguments)}:m:x}var lw={type:3,lower:-1/0,lowerOpen:!1,upper:[[]],upperOpen:!1};function lh(m){return typeof m!="string"||/\./.test(m)?function(x){return x}:function(x){return x[m]===void 0&&m in x&&delete(x=q(x))[m],x}}function uw(){throw $e.Type()}function Rt(m,x){try{var k=cw(m),$=cw(x);if(k!==$)return k==="Array"?1:$==="Array"?-1:k==="binary"?1:$==="binary"?-1:k==="string"?1:$==="string"?-1:k==="Date"?1:$!=="Date"?NaN:-1;switch(k){case"number":case"Date":case"string":return x<m?1:m<x?-1:0;case"binary":return function(N,_){for(var P=N.length,M=_.length,X=P<M?P:M,Z=0;Z<X;++Z)if(N[Z]!==_[Z])return N[Z]<_[Z]?-1:1;return P===M?0:P<M?-1:1}(hw(m),hw(x));case"Array":return function(N,_){for(var P=N.length,M=_.length,X=P<M?P:M,Z=0;Z<X;++Z){var re=Rt(N[Z],_[Z]);if(re!==0)return re}return P===M?0:P<M?-1:1}(m,x)}}catch{}return NaN}function cw(m){var x=typeof m;return x!="object"?x:ArrayBuffer.isView(m)?"binary":(m=ee(m),m==="ArrayBuffer"?"binary":m)}function hw(m){return m instanceof Uint8Array?m:ArrayBuffer.isView(m)?new Uint8Array(m.buffer,m.byteOffset,m.byteLength):new Uint8Array(m)}var dw=(Xt.prototype._trans=function(m,x,k){var $=this._tx||Ye.trans,N=this.name,_=Ie&&typeof console<"u"&&console.createTask&&console.createTask("Dexie: ".concat(m==="readonly"?"read":"write"," ").concat(this.name));function P(Z,re,G){if(!G.schema[N])throw new $e.NotFound("Table "+N+" not part of transaction");return x(G.idbtrans,G)}var M=va();try{var X=$&&$.db._novip===this.db._novip?$===Ye.trans?$._promise(m,P,k):Oo(function(){return $._promise(m,P,k)},{trans:$,transless:Ye.transless||Ye}):function Z(re,G,ae,Y){if(re.idbdb&&(re._state.openComplete||Ye.letThrough||re._vip)){var ne=re._createTransaction(G,ae,re._dbSchema);try{ne.create(),re._state.PR1398_maxLoop=3}catch(ie){return ie.name===Ze.InvalidState&&re.isOpen()&&0<--re._state.PR1398_maxLoop?(console.warn("Dexie: Need to reopen db"),re.close({disableAutoOpen:!1}),re.open().then(function(){return Z(re,G,ae,Y)})):gn(ie)}return ne._promise(G,function(ie,J){return Oo(function(){return Ye.trans=ne,Y(ie,J,ne)})}).then(function(ie){if(G==="readwrite")try{ne.idbtrans.commit()}catch{}return G==="readonly"?ie:ne._completion.then(function(){return ie})})}if(re._state.openComplete)return gn(new $e.DatabaseClosed(re._state.dbOpenError));if(!re._state.isBeingOpened){if(!re._state.autoOpen)return gn(new $e.DatabaseClosed);re.open().catch(z)}return re._state.dbReadyPromise.then(function(){return Z(re,G,ae,Y)})}(this.db,m,[this.name],P);return _&&(X._consoleTask=_,X=X.catch(function(Z){return console.trace(Z),gn(Z)})),X}finally{M&&ka()}},Xt.prototype.get=function(m,x){var k=this;return m&&m.constructor===Object?this.where(m).first(x):m==null?gn(new $e.Type("Invalid argument to Table.get()")):this._trans("readonly",function($){return k.core.get({trans:$,key:m}).then(function(N){return k.hook.reading.fire(N)})}).then(x)},Xt.prototype.where=function(m){if(typeof m=="string")return new this.db.WhereClause(this,m);if(a(m))return new this.db.WhereClause(this,"[".concat(m.join("+"),"]"));var x=i(m);if(x.length===1)return this.where(x[0]).equals(m[x[0]]);var k=this.schema.indexes.concat(this.schema.primKey).filter(function(M){if(M.compound&&x.every(function(Z){return 0<=M.keyPath.indexOf(Z)})){for(var X=0;X<x.length;++X)if(x.indexOf(M.keyPath[X])===-1)return!1;return!0}return!1}).sort(function(M,X){return M.keyPath.length-X.keyPath.length})[0];if(k&&this.db._maxKey!==Ni){var _=k.keyPath.slice(0,x.length);return this.where(_).equals(_.map(function(X){return m[X]}))}!k&&Ie&&console.warn("The query ".concat(JSON.stringify(m)," on ").concat(this.name," would benefit from a ")+"compound index [".concat(x.join("+"),"]"));var $=this.schema.idxByName;function N(M,X){return Rt(M,X)===0}var P=x.reduce(function(G,X){var Z=G[0],re=G[1],G=$[X],ae=m[X];return[Z||G,Z||!G?Ti(re,G&&G.multi?function(Y){return Y=E(Y,X),a(Y)&&Y.some(function(ne){return N(ae,ne)})}:function(Y){return N(ae,E(Y,X))}):re]},[null,null]),_=P[0],P=P[1];return _?this.where(_.name).equals(m[_.keyPath]).filter(P):k?this.filter(P):this.where(x).equals("")},Xt.prototype.filter=function(m){return this.toCollection().and(m)},Xt.prototype.count=function(m){return this.toCollection().count(m)},Xt.prototype.offset=function(m){return this.toCollection().offset(m)},Xt.prototype.limit=function(m){return this.toCollection().limit(m)},Xt.prototype.each=function(m){return this.toCollection().each(m)},Xt.prototype.toArray=function(m){return this.toCollection().toArray(m)},Xt.prototype.toCollection=function(){return new this.db.Collection(new this.db.WhereClause(this))},Xt.prototype.orderBy=function(m){return new this.db.Collection(new this.db.WhereClause(this,a(m)?"[".concat(m.join("+"),"]"):m))},Xt.prototype.reverse=function(){return this.toCollection().reverse()},Xt.prototype.mapToClass=function(m){var x,k=this.db,$=this.name;function N(){return x!==null&&x.apply(this,arguments)||this}(this.schema.mappedClass=m).prototype instanceof uw&&(function(X,Z){if(typeof Z!="function"&&Z!==null)throw new TypeError("Class extends value "+String(Z)+" is not a constructor or null");function re(){this.constructor=X}t(X,Z),X.prototype=Z===null?Object.create(Z):(re.prototype=Z.prototype,new re)}(N,x=m),Object.defineProperty(N.prototype,"db",{get:function(){return k},enumerable:!1,configurable:!0}),N.prototype.table=function(){return $},m=N);for(var _=new Set,P=m.prototype;P;P=u(P))Object.getOwnPropertyNames(P).forEach(function(X){return _.add(X)});function M(X){if(!X)return X;var Z,re=Object.create(m.prototype);for(Z in X)if(!_.has(Z))try{re[Z]=X[Z]}catch{}return re}return this.schema.readHook&&this.hook.reading.unsubscribe(this.schema.readHook),this.schema.readHook=M,this.hook("reading",M),m},Xt.prototype.defineClass=function(){return this.mapToClass(function(m){l(this,m)})},Xt.prototype.add=function(m,x){var k=this,$=this.schema.primKey,N=$.auto,_=$.keyPath,P=m;return _&&N&&(P=lh(_)(m)),this._trans("readwrite",function(M){return k.core.mutate({trans:M,type:"add",keys:x!=null?[x]:null,values:[P]})}).then(function(M){return M.numFailures?je.reject(M.failures[0]):M.lastResult}).then(function(M){if(_)try{R(m,_,M)}catch{}return M})},Xt.prototype.update=function(m,x){return typeof m!="object"||a(m)?this.where(":id").equals(m).modify(x):(m=E(m,this.schema.primKey.keyPath),m===void 0?gn(new $e.InvalidArgument("Given object does not contain its primary key")):this.where(":id").equals(m).modify(x))},Xt.prototype.put=function(m,x){var k=this,$=this.schema.primKey,N=$.auto,_=$.keyPath,P=m;return _&&N&&(P=lh(_)(m)),this._trans("readwrite",function(M){return k.core.mutate({trans:M,type:"put",values:[P],keys:x!=null?[x]:null})}).then(function(M){return M.numFailures?je.reject(M.failures[0]):M.lastResult}).then(function(M){if(_)try{R(m,_,M)}catch{}return M})},Xt.prototype.delete=function(m){var x=this;return this._trans("readwrite",function(k){return x.core.mutate({trans:k,type:"delete",keys:[m]})}).then(function(k){return k.numFailures?je.reject(k.failures[0]):void 0})},Xt.prototype.clear=function(){var m=this;return this._trans("readwrite",function(x){return m.core.mutate({trans:x,type:"deleteRange",range:lw})}).then(function(x){return x.numFailures?je.reject(x.failures[0]):void 0})},Xt.prototype.bulkGet=function(m){var x=this;return this._trans("readonly",function(k){return x.core.getMany({keys:m,trans:k}).then(function($){return $.map(function(N){return x.hook.reading.fire(N)})})})},Xt.prototype.bulkAdd=function(m,x,k){var $=this,N=Array.isArray(x)?x:void 0,_=(k=k||(N?void 0:x))?k.allKeys:void 0;return this._trans("readwrite",function(P){var Z=$.schema.primKey,M=Z.auto,Z=Z.keyPath;if(Z&&N)throw new $e.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");if(N&&N.length!==m.length)throw new $e.InvalidArgument("Arguments objects and keys must have the same length");var X=m.length,Z=Z&&M?m.map(lh(Z)):m;return $.core.mutate({trans:P,type:"add",keys:N,values:Z,wantResults:_}).then(function(ne){var G=ne.numFailures,ae=ne.results,Y=ne.lastResult,ne=ne.failures;if(G===0)return _?ae:Y;throw new Me("".concat($.name,".bulkAdd(): ").concat(G," of ").concat(X," operations failed"),ne)})})},Xt.prototype.bulkPut=function(m,x,k){var $=this,N=Array.isArray(x)?x:void 0,_=(k=k||(N?void 0:x))?k.allKeys:void 0;return this._trans("readwrite",function(P){var Z=$.schema.primKey,M=Z.auto,Z=Z.keyPath;if(Z&&N)throw new $e.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");if(N&&N.length!==m.length)throw new $e.InvalidArgument("Arguments objects and keys must have the same length");var X=m.length,Z=Z&&M?m.map(lh(Z)):m;return $.core.mutate({trans:P,type:"put",keys:N,values:Z,wantResults:_}).then(function(ne){var G=ne.numFailures,ae=ne.results,Y=ne.lastResult,ne=ne.failures;if(G===0)return _?ae:Y;throw new Me("".concat($.name,".bulkPut(): ").concat(G," of ").concat(X," operations failed"),ne)})})},Xt.prototype.bulkUpdate=function(m){var x=this,k=this.core,$=m.map(function(P){return P.key}),N=m.map(function(P){return P.changes}),_=[];return this._trans("readwrite",function(P){return k.getMany({trans:P,keys:$,cache:"clone"}).then(function(M){var X=[],Z=[];m.forEach(function(G,ae){var Y=G.key,ne=G.changes,ie=M[ae];if(ie){for(var J=0,ce=Object.keys(ne);J<ce.length;J++){var fe=ce[J],me=ne[fe];if(fe===x.schema.primKey.keyPath){if(Rt(me,Y)!==0)throw new $e.Constraint("Cannot update primary key in bulkUpdate()")}else R(ie,fe,me)}_.push(ae),X.push(Y),Z.push(ie)}});var re=X.length;return k.mutate({trans:P,type:"put",keys:X,values:Z,updates:{keys:$,changeSpecs:N}}).then(function(G){var ae=G.numFailures,Y=G.failures;if(ae===0)return re;for(var ne=0,ie=Object.keys(Y);ne<ie.length;ne++){var J,ce=ie[ne],fe=_[Number(ce)];fe!=null&&(J=Y[ce],delete Y[ce],Y[fe]=J)}throw new Me("".concat(x.name,".bulkUpdate(): ").concat(ae," of ").concat(re," operations failed"),Y)})})})},Xt.prototype.bulkDelete=function(m){var x=this,k=m.length;return this._trans("readwrite",function($){return x.core.mutate({trans:$,type:"delete",keys:m})}).then(function(P){var N=P.numFailures,_=P.lastResult,P=P.failures;if(N===0)return _;throw new Me("".concat(x.name,".bulkDelete(): ").concat(N," of ").concat(k," operations failed"),P)})},Xt);function Xt(){}function Rl(m){function x(P,M){if(M){for(var X=arguments.length,Z=new Array(X-1);--X;)Z[X-1]=arguments[X];return k[P].subscribe.apply(null,Z),m}if(typeof P=="string")return k[P]}var k={};x.addEventType=_;for(var $=1,N=arguments.length;$<N;++$)_(arguments[$]);return x;function _(P,M,X){if(typeof P!="object"){var Z;M=M||Oe;var re={subscribers:[],fire:X=X||z,subscribe:function(G){re.subscribers.indexOf(G)===-1&&(re.subscribers.push(G),re.fire=M(re.fire,G))},unsubscribe:function(G){re.subscribers=re.subscribers.filter(function(ae){return ae!==G}),re.fire=re.subscribers.reduce(M,X)}};return k[P]=x[P]=re}i(Z=P).forEach(function(G){var ae=Z[G];if(a(ae))_(G,Z[G][0],Z[G][1]);else{if(ae!=="asap")throw new $e.InvalidArgument("Invalid event config");var Y=_(G,U,function(){for(var ne=arguments.length,ie=new Array(ne);ne--;)ie[ne]=arguments[ne];Y.subscribers.forEach(function(J){I(function(){J.apply(null,ie)})})})}})}}function Dl(m,x){return g(x).from({prototype:m}),x}function Ia(m,x){return!(m.filter||m.algorithm||m.or)&&(x?m.justLimit:!m.replayFilter)}function hm(m,x){m.filter=Ti(m.filter,x)}function dm(m,x,k){var $=m.replayFilter;m.replayFilter=$?function(){return Ti($(),x())}:x,m.justLimit=k&&!$}function uh(m,x){if(m.isPrimKey)return x.primaryKey;var k=x.getIndexByKeyPath(m.index);if(!k)throw new $e.Schema("KeyPath "+m.index+" on object store "+x.name+" is not indexed");return k}function pw(m,x,k){var $=uh(m,x.schema);return x.openCursor({trans:k,values:!m.keysOnly,reverse:m.dir==="prev",unique:!!m.unique,query:{index:$,range:m.range}})}function ch(m,x,k,$){var N=m.replayFilter?Ti(m.filter,m.replayFilter()):m.filter;if(m.or){var _={},P=function(M,X,Z){var re,G;N&&!N(X,Z,function(ae){return X.stop(ae)},function(ae){return X.fail(ae)})||((G=""+(re=X.primaryKey))=="[object ArrayBuffer]"&&(G=""+new Uint8Array(re)),h(_,G)||(_[G]=!0,x(M,X,Z)))};return Promise.all([m.or._iterate(P,k),fw(pw(m,$,k),m.algorithm,P,!m.keysOnly&&m.valueMapper)])}return fw(pw(m,$,k),Ti(m.algorithm,N),x,!m.keysOnly&&m.valueMapper)}function fw(m,x,k,$){var N=tn($?function(_,P,M){return k($(_),P,M)}:k);return m.then(function(_){if(_)return _.start(function(){var P=function(){return _.continue()};x&&!x(_,function(M){return P=M},function(M){_.stop(M),P=z},function(M){_.fail(M),P=z})||N(_.value,_,function(M){return P=M}),P()})})}var Ol=(mw.prototype.execute=function(m){var x=this["@@propmod"];if(x.add!==void 0){var k=x.add;if(a(k))return r(r([],a(m)?m:[],!0),k).sort();if(typeof k=="number")return(Number(m)||0)+k;if(typeof k=="bigint")try{return BigInt(m)+k}catch{return BigInt(0)+k}throw new TypeError("Invalid term ".concat(k))}if(x.remove!==void 0){var $=x.remove;if(a($))return a(m)?m.filter(function(N){return!$.includes(N)}).sort():[];if(typeof $=="number")return Number(m)-$;if(typeof $=="bigint")try{return BigInt(m)-$}catch{return BigInt(0)-$}throw new TypeError("Invalid subtrahend ".concat($))}return k=(k=x.replacePrefix)===null||k===void 0?void 0:k[0],k&&typeof m=="string"&&m.startsWith(k)?x.replacePrefix[1]+m.substring(k.length):m},mw);function mw(m){this["@@propmod"]=m}var FE=(Ft.prototype._read=function(m,x){var k=this._ctx;return k.error?k.table._trans(null,gn.bind(null,k.error)):k.table._trans("readonly",m).then(x)},Ft.prototype._write=function(m){var x=this._ctx;return x.error?x.table._trans(null,gn.bind(null,x.error)):x.table._trans("readwrite",m,"locked")},Ft.prototype._addAlgorithm=function(m){var x=this._ctx;x.algorithm=Ti(x.algorithm,m)},Ft.prototype._iterate=function(m,x){return ch(this._ctx,m,x,this._ctx.table.core)},Ft.prototype.clone=function(m){var x=Object.create(this.constructor.prototype),k=Object.create(this._ctx);return m&&l(k,m),x._ctx=k,x},Ft.prototype.raw=function(){return this._ctx.valueMapper=null,this},Ft.prototype.each=function(m){var x=this._ctx;return this._read(function(k){return ch(x,m,k,x.table.core)})},Ft.prototype.count=function(m){var x=this;return this._read(function(k){var $=x._ctx,N=$.table.core;if(Ia($,!0))return N.count({trans:k,query:{index:uh($,N.schema),range:$.range}}).then(function(P){return Math.min(P,$.limit)});var _=0;return ch($,function(){return++_,!1},k,N).then(function(){return _})}).then(m)},Ft.prototype.sortBy=function(m,x){var k=m.split(".").reverse(),$=k[0],N=k.length-1;function _(X,Z){return Z?_(X[k[Z]],Z-1):X[$]}var P=this._ctx.dir==="next"?1:-1;function M(X,Z){return Rt(_(X,N),_(Z,N))*P}return this.toArray(function(X){return X.sort(M)}).then(x)},Ft.prototype.toArray=function(m){var x=this;return this._read(function(k){var $=x._ctx;if($.dir==="next"&&Ia($,!0)&&0<$.limit){var N=$.valueMapper,_=uh($,$.table.core.schema);return $.table.core.query({trans:k,limit:$.limit,values:!0,query:{index:_,range:$.range}}).then(function(M){return M=M.result,N?M.map(N):M})}var P=[];return ch($,function(M){return P.push(M)},k,$.table.core).then(function(){return P})},m)},Ft.prototype.offset=function(m){var x=this._ctx;return m<=0||(x.offset+=m,Ia(x)?dm(x,function(){var k=m;return function($,N){return k===0||(k===1?--k:N(function(){$.advance(k),k=0}),!1)}}):dm(x,function(){var k=m;return function(){return--k<0}})),this},Ft.prototype.limit=function(m){return this._ctx.limit=Math.min(this._ctx.limit,m),dm(this._ctx,function(){var x=m;return function(k,$,N){return--x<=0&&$(N),0<=x}},!0),this},Ft.prototype.until=function(m,x){return hm(this._ctx,function(k,$,N){return!m(k.value)||($(N),x)}),this},Ft.prototype.first=function(m){return this.limit(1).toArray(function(x){return x[0]}).then(m)},Ft.prototype.last=function(m){return this.reverse().first(m)},Ft.prototype.filter=function(m){var x;return hm(this._ctx,function(k){return m(k.value)}),(x=this._ctx).isMatch=Ti(x.isMatch,m),this},Ft.prototype.and=function(m){return this.filter(m)},Ft.prototype.or=function(m){return new this.db.WhereClause(this._ctx.table,m,this)},Ft.prototype.reverse=function(){return this._ctx.dir=this._ctx.dir==="prev"?"next":"prev",this._ondirectionchange&&this._ondirectionchange(this._ctx.dir),this},Ft.prototype.desc=function(){return this.reverse()},Ft.prototype.eachKey=function(m){var x=this._ctx;return x.keysOnly=!x.isMatch,this.each(function(k,$){m($.key,$)})},Ft.prototype.eachUniqueKey=function(m){return this._ctx.unique="unique",this.eachKey(m)},Ft.prototype.eachPrimaryKey=function(m){var x=this._ctx;return x.keysOnly=!x.isMatch,this.each(function(k,$){m($.primaryKey,$)})},Ft.prototype.keys=function(m){var x=this._ctx;x.keysOnly=!x.isMatch;var k=[];return this.each(function($,N){k.push(N.key)}).then(function(){return k}).then(m)},Ft.prototype.primaryKeys=function(m){var x=this._ctx;if(x.dir==="next"&&Ia(x,!0)&&0<x.limit)return this._read(function($){var N=uh(x,x.table.core.schema);return x.table.core.query({trans:$,values:!1,limit:x.limit,query:{index:N,range:x.range}})}).then(function($){return $.result}).then(m);x.keysOnly=!x.isMatch;var k=[];return this.each(function($,N){k.push(N.primaryKey)}).then(function(){return k}).then(m)},Ft.prototype.uniqueKeys=function(m){return this._ctx.unique="unique",this.keys(m)},Ft.prototype.firstKey=function(m){return this.limit(1).keys(function(x){return x[0]}).then(m)},Ft.prototype.lastKey=function(m){return this.reverse().firstKey(m)},Ft.prototype.distinct=function(){var m=this._ctx,m=m.index&&m.table.schema.idxByName[m.index];if(!m||!m.multi)return this;var x={};return hm(this._ctx,function(N){var $=N.primaryKey.toString(),N=h(x,$);return x[$]=!0,!N}),this},Ft.prototype.modify=function(m){var x=this,k=this._ctx;return this._write(function($){var N,_,P;P=typeof m=="function"?m:(N=i(m),_=N.length,function(J){for(var ce=!1,fe=0;fe<_;++fe){var me=N[fe],ke=m[me],Re=E(J,me);ke instanceof Ol?(R(J,me,ke.execute(Re)),ce=!0):Re!==ke&&(R(J,me,ke),ce=!0)}return ce});var M=k.table.core,G=M.schema.primaryKey,X=G.outbound,Z=G.extractKey,re=200,G=x.db._options.modifyChunkSize;G&&(re=typeof G=="object"?G[M.name]||G["*"]||200:G);function ae(J,me){var fe=me.failures,me=me.numFailures;ne+=J-me;for(var ke=0,Re=i(fe);ke<Re.length;ke++){var Ve=Re[ke];Y.push(fe[Ve])}}var Y=[],ne=0,ie=[];return x.clone().primaryKeys().then(function(J){function ce(me){var ke=Math.min(re,J.length-me);return M.getMany({trans:$,keys:J.slice(me,me+ke),cache:"immutable"}).then(function(Re){for(var Ve=[],De=[],ze=X?[]:null,Ge=[],Be=0;Be<ke;++Be){var Je=Re[Be],bt={value:q(Je),primKey:J[me+Be]};P.call(bt,bt.value,bt)!==!1&&(bt.value==null?Ge.push(J[me+Be]):X||Rt(Z(Je),Z(bt.value))===0?(De.push(bt.value),X&&ze.push(J[me+Be])):(Ge.push(J[me+Be]),Ve.push(bt.value)))}return Promise.resolve(0<Ve.length&&M.mutate({trans:$,type:"add",values:Ve}).then(function($t){for(var Nt in $t.failures)Ge.splice(parseInt(Nt),1);ae(Ve.length,$t)})).then(function(){return(0<De.length||fe&&typeof m=="object")&&M.mutate({trans:$,type:"put",keys:ze,values:De,criteria:fe,changeSpec:typeof m!="function"&&m,isAdditionalChunk:0<me}).then(function($t){return ae(De.length,$t)})}).then(function(){return(0<Ge.length||fe&&m===pm)&&M.mutate({trans:$,type:"delete",keys:Ge,criteria:fe,isAdditionalChunk:0<me}).then(function($t){return ae(Ge.length,$t)})}).then(function(){return J.length>me+ke&&ce(me+re)})})}var fe=Ia(k)&&k.limit===1/0&&(typeof m!="function"||m===pm)&&{index:k.index,range:k.range};return ce(0).then(function(){if(0<Y.length)throw new Ae("Error modifying one or more objects",Y,ne,ie);return J.length})})})},Ft.prototype.delete=function(){var m=this._ctx,x=m.range;return Ia(m)&&(m.isPrimKey||x.type===3)?this._write(function(k){var $=m.table.core.schema.primaryKey,N=x;return m.table.core.count({trans:k,query:{index:$,range:N}}).then(function(_){return m.table.core.mutate({trans:k,type:"deleteRange",range:N}).then(function(P){var M=P.failures;if(P.lastResult,P.results,P=P.numFailures,P)throw new Ae("Could not delete some values",Object.keys(M).map(function(X){return M[X]}),_-P);return _-P})})}):this.modify(pm)},Ft);function Ft(){}var pm=function(m,x){return x.value=null};function LE(m,x){return m<x?-1:m===x?0:1}function PE(m,x){return x<m?-1:m===x?0:1}function Vs(m,x,k){return m=m instanceof yw?new m.Collection(m):m,m._ctx.error=new(k||TypeError)(x),m}function $a(m){return new m.Collection(m,function(){return gw("")}).limit(0)}function hh(m,x,k,$){var N,_,P,M,X,Z,re,G=k.length;if(!k.every(function(ne){return typeof ne=="string"}))return Vs(m,aw);function ae(ne){N=ne==="next"?function(J){return J.toUpperCase()}:function(J){return J.toLowerCase()},_=ne==="next"?function(J){return J.toLowerCase()}:function(J){return J.toUpperCase()},P=ne==="next"?LE:PE;var ie=k.map(function(J){return{lower:_(J),upper:N(J)}}).sort(function(J,ce){return P(J.lower,ce.lower)});M=ie.map(function(J){return J.upper}),X=ie.map(function(J){return J.lower}),re=(Z=ne)==="next"?"":$}ae("next"),m=new m.Collection(m,function(){return Po(M[0],X[G-1]+$)}),m._ondirectionchange=function(ne){ae(ne)};var Y=0;return m._addAlgorithm(function(ne,ie,J){var ce=ne.key;if(typeof ce!="string")return!1;var fe=_(ce);if(x(fe,X,Y))return!0;for(var me=null,ke=Y;ke<G;++ke){var Re=function(Ve,De,ze,Ge,Be,Je){for(var bt=Math.min(Ve.length,Ge.length),$t=-1,Nt=0;Nt<bt;++Nt){var Ws=De[Nt];if(Ws!==Ge[Nt])return Be(Ve[Nt],ze[Nt])<0?Ve.substr(0,Nt)+ze[Nt]+ze.substr(Nt+1):Be(Ve[Nt],Ge[Nt])<0?Ve.substr(0,Nt)+Ge[Nt]+ze.substr(Nt+1):0<=$t?Ve.substr(0,$t)+De[$t]+ze.substr($t+1):null;Be(Ve[Nt],Ws)<0&&($t=Nt)}return bt<Ge.length&&Je==="next"?Ve+ze.substr(Ve.length):bt<Ve.length&&Je==="prev"?Ve.substr(0,ze.length):$t<0?null:Ve.substr(0,$t)+Ge[$t]+ze.substr($t+1)}(ce,fe,M[ke],X[ke],P,Z);Re===null&&me===null?Y=ke+1:(me===null||0<P(me,Re))&&(me=Re)}return ie(me!==null?function(){ne.continue(me+re)}:J),!1}),m}function Po(m,x,k,$){return{type:2,lower:m,upper:x,lowerOpen:k,upperOpen:$}}function gw(m){return{type:1,lower:m,upper:m}}var yw=(Object.defineProperty(Pn.prototype,"Collection",{get:function(){return this._ctx.table.db.Collection},enumerable:!1,configurable:!0}),Pn.prototype.between=function(m,x,k,$){k=k!==!1,$=$===!0;try{return 0<this._cmp(m,x)||this._cmp(m,x)===0&&(k||$)&&(!k||!$)?$a(this):new this.Collection(this,function(){return Po(m,x,!k,!$)})}catch{return Vs(this,so)}},Pn.prototype.equals=function(m){return m==null?Vs(this,so):new this.Collection(this,function(){return gw(m)})},Pn.prototype.above=function(m){return m==null?Vs(this,so):new this.Collection(this,function(){return Po(m,void 0,!0)})},Pn.prototype.aboveOrEqual=function(m){return m==null?Vs(this,so):new this.Collection(this,function(){return Po(m,void 0,!1)})},Pn.prototype.below=function(m){return m==null?Vs(this,so):new this.Collection(this,function(){return Po(void 0,m,!1,!0)})},Pn.prototype.belowOrEqual=function(m){return m==null?Vs(this,so):new this.Collection(this,function(){return Po(void 0,m)})},Pn.prototype.startsWith=function(m){return typeof m!="string"?Vs(this,aw):this.between(m,m+Ni,!0,!0)},Pn.prototype.startsWithIgnoreCase=function(m){return m===""?this.startsWith(m):hh(this,function(x,k){return x.indexOf(k[0])===0},[m],Ni)},Pn.prototype.equalsIgnoreCase=function(m){return hh(this,function(x,k){return x===k[0]},[m],"")},Pn.prototype.anyOfIgnoreCase=function(){var m=ye.apply(he,arguments);return m.length===0?$a(this):hh(this,function(x,k){return k.indexOf(x)!==-1},m,"")},Pn.prototype.startsWithAnyOfIgnoreCase=function(){var m=ye.apply(he,arguments);return m.length===0?$a(this):hh(this,function(x,k){return k.some(function($){return x.indexOf($)===0})},m,Ni)},Pn.prototype.anyOf=function(){var m=this,x=ye.apply(he,arguments),k=this._cmp;try{x.sort(k)}catch{return Vs(this,so)}if(x.length===0)return $a(this);var $=new this.Collection(this,function(){return Po(x[0],x[x.length-1])});$._ondirectionchange=function(_){k=_==="next"?m._ascending:m._descending,x.sort(k)};var N=0;return $._addAlgorithm(function(_,P,M){for(var X=_.key;0<k(X,x[N]);)if(++N===x.length)return P(M),!1;return k(X,x[N])===0||(P(function(){_.continue(x[N])}),!1)}),$},Pn.prototype.notEqual=function(m){return this.inAnyRange([[-1/0,m],[m,this.db._maxKey]],{includeLowers:!1,includeUppers:!1})},Pn.prototype.noneOf=function(){var m=ye.apply(he,arguments);if(m.length===0)return new this.Collection(this);try{m.sort(this._ascending)}catch{return Vs(this,so)}var x=m.reduce(function(k,$){return k?k.concat([[k[k.length-1][1],$]]):[[-1/0,$]]},null);return x.push([m[m.length-1],this.db._maxKey]),this.inAnyRange(x,{includeLowers:!1,includeUppers:!1})},Pn.prototype.inAnyRange=function(ce,x){var k=this,$=this._cmp,N=this._ascending,_=this._descending,P=this._min,M=this._max;if(ce.length===0)return $a(this);if(!ce.every(function(fe){return fe[0]!==void 0&&fe[1]!==void 0&&N(fe[0],fe[1])<=0}))return Vs(this,"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower",$e.InvalidArgument);var X=!x||x.includeLowers!==!1,Z=x&&x.includeUppers===!0,re,G=N;function ae(fe,me){return G(fe[0],me[0])}try{(re=ce.reduce(function(fe,me){for(var ke=0,Re=fe.length;ke<Re;++ke){var Ve=fe[ke];if($(me[0],Ve[1])<0&&0<$(me[1],Ve[0])){Ve[0]=P(Ve[0],me[0]),Ve[1]=M(Ve[1],me[1]);break}}return ke===Re&&fe.push(me),fe},[])).sort(ae)}catch{return Vs(this,so)}var Y=0,ne=Z?function(fe){return 0<N(fe,re[Y][1])}:function(fe){return 0<=N(fe,re[Y][1])},ie=X?function(fe){return 0<_(fe,re[Y][0])}:function(fe){return 0<=_(fe,re[Y][0])},J=ne,ce=new this.Collection(this,function(){return Po(re[0][0],re[re.length-1][1],!X,!Z)});return ce._ondirectionchange=function(fe){G=fe==="next"?(J=ne,N):(J=ie,_),re.sort(ae)},ce._addAlgorithm(function(fe,me,ke){for(var Re,Ve=fe.key;J(Ve);)if(++Y===re.length)return me(ke),!1;return!ne(Re=Ve)&&!ie(Re)||(k._cmp(Ve,re[Y][1])===0||k._cmp(Ve,re[Y][0])===0||me(function(){G===N?fe.continue(re[Y][0]):fe.continue(re[Y][1])}),!1)}),ce},Pn.prototype.startsWithAnyOf=function(){var m=ye.apply(he,arguments);return m.every(function(x){return typeof x=="string"})?m.length===0?$a(this):this.inAnyRange(m.map(function(x){return[x,x+Ni]})):Vs(this,"startsWithAnyOf() only works with strings")},Pn);function Pn(){}function _r(m){return tn(function(x){return Fl(x),m(x.target.error),!1})}function Fl(m){m.stopPropagation&&m.stopPropagation(),m.preventDefault&&m.preventDefault()}var Ll="storagemutated",fm="x-storagemutated-1",zo=Rl(null,Ll),zE=(Ar.prototype._lock=function(){return v(!Ye.global),++this._reculock,this._reculock!==1||Ye.global||(Ye.lockOwnerFor=this),this},Ar.prototype._unlock=function(){if(v(!Ye.global),--this._reculock==0)for(Ye.global||(Ye.lockOwnerFor=null);0<this._blockedFuncs.length&&!this._locked();){var m=this._blockedFuncs.shift();try{$i(m[1],m[0])}catch{}}return this},Ar.prototype._locked=function(){return this._reculock&&Ye.lockOwnerFor!==this},Ar.prototype.create=function(m){var x=this;if(!this.mode)return this;var k=this.db.idbdb,$=this.db._state.dbOpenError;if(v(!this.idbtrans),!m&&!k)switch($&&$.name){case"DatabaseClosedError":throw new $e.DatabaseClosed($);case"MissingAPIError":throw new $e.MissingAPI($.message,$);default:throw new $e.OpenFailed($)}if(!this.active)throw new $e.TransactionInactive;return v(this._completion._state===null),(m=this.idbtrans=m||(this.db.core||k).transaction(this.storeNames,this.mode,{durability:this.chromeTransactionDurability})).onerror=tn(function(N){Fl(N),x._reject(m.error)}),m.onabort=tn(function(N){Fl(N),x.active&&x._reject(new $e.Abort(m.error)),x.active=!1,x.on("abort").fire(N)}),m.oncomplete=tn(function(){x.active=!1,x._resolve(),"mutatedParts"in m&&zo.storagemutated.fire(m.mutatedParts)}),this},Ar.prototype._promise=function(m,x,k){var $=this;if(m==="readwrite"&&this.mode!=="readwrite")return gn(new $e.ReadOnly("Transaction is readonly"));if(!this.active)return gn(new $e.TransactionInactive);if(this._locked())return new je(function(_,P){$._blockedFuncs.push([function(){$._promise(m,x,k).then(_,P)},Ye])});if(k)return Oo(function(){var _=new je(function(P,M){$._lock();var X=x(P,M,$);X&&X.then&&X.then(P,M)});return _.finally(function(){return $._unlock()}),_._lib=!0,_});var N=new je(function(_,P){var M=x(_,P,$);M&&M.then&&M.then(_,P)});return N._lib=!0,N},Ar.prototype._root=function(){return this.parent?this.parent._root():this},Ar.prototype.waitFor=function(m){var x,k=this._root(),$=je.resolve(m);k._waitingFor?k._waitingFor=k._waitingFor.then(function(){return $}):(k._waitingFor=$,k._waitingQueue=[],x=k.idbtrans.objectStore(k.storeNames[0]),function _(){for(++k._spinCount;k._waitingQueue.length;)k._waitingQueue.shift()();k._waitingFor&&(x.get(-1/0).onsuccess=_)}());var N=k._waitingFor;return new je(function(_,P){$.then(function(M){return k._waitingQueue.push(tn(_.bind(null,M)))},function(M){return k._waitingQueue.push(tn(P.bind(null,M)))}).finally(function(){k._waitingFor===N&&(k._waitingFor=null)})})},Ar.prototype.abort=function(){this.active&&(this.active=!1,this.idbtrans&&this.idbtrans.abort(),this._reject(new $e.Abort))},Ar.prototype.table=function(m){var x=this._memoizedTables||(this._memoizedTables={});if(h(x,m))return x[m];var k=this.schema[m];if(!k)throw new $e.NotFound("Table "+m+" not part of transaction");return k=new this.db.Table(m,k,this),k.core=this.db.core.table(m),x[m]=k},Ar);function Ar(){}function mm(m,x,k,$,N,_,P){return{name:m,keyPath:x,unique:k,multi:$,auto:N,compound:_,src:(k&&!P?"&":"")+($?"*":"")+(N?"++":"")+bw(x)}}function bw(m){return typeof m=="string"?m:m?"["+[].join.call(m,"+")+"]":""}function gm(m,x,k){return{name:m,primKey:x,indexes:k,mappedClass:null,idxByName:($=function(N){return[N.name,N]},k.reduce(function(N,_,P){return P=$(_,P),P&&(N[P[0]]=P[1]),N},{}))};var $}var Pl=function(m){try{return m.only([[]]),Pl=function(){return[[]]},[[]]}catch{return Pl=function(){return Ni},Ni}};function ym(m){return m==null?function(){}:typeof m=="string"?(x=m).split(".").length===1?function(k){return k[x]}:function(k){return E(k,x)}:function(k){return E(k,m)};var x}function xw(m){return[].slice.call(m)}var ME=0;function zl(m){return m==null?":id":typeof m=="string"?m:"[".concat(m.join("+"),"]")}function BE(m,x,X){function $(J){if(J.type===3)return null;if(J.type===4)throw new Error("Cannot convert never type to IDBKeyRange");var Y=J.lower,ne=J.upper,ie=J.lowerOpen,J=J.upperOpen;return Y===void 0?ne===void 0?null:x.upperBound(ne,!!J):ne===void 0?x.lowerBound(Y,!!ie):x.bound(Y,ne,!!ie,!!J)}function N(ae){var Y,ne=ae.name;return{name:ne,schema:ae,mutate:function(ie){var J=ie.trans,ce=ie.type,fe=ie.keys,me=ie.values,ke=ie.range;return new Promise(function(Re,Ve){Re=tn(Re);var De=J.objectStore(ne),ze=De.keyPath==null,Ge=ce==="put"||ce==="add";if(!Ge&&ce!=="delete"&&ce!=="deleteRange")throw new Error("Invalid operation type: "+ce);var Be,Je=(fe||me||{length:1}).length;if(fe&&me&&fe.length!==me.length)throw new Error("Given keys array must have same length as given values array.");if(Je===0)return Re({numFailures:0,failures:{},results:[],lastResult:void 0});function bt(ms){++Ws,Fl(ms)}var $t=[],Nt=[],Ws=0;if(ce==="deleteRange"){if(ke.type===4)return Re({numFailures:Ws,failures:Nt,results:[],lastResult:void 0});ke.type===3?$t.push(Be=De.clear()):$t.push(Be=De.delete($(ke)))}else{var ze=Ge?ze?[me,fe]:[me,null]:[fe,null],mt=ze[0],es=ze[1];if(Ge)for(var ts=0;ts<Je;++ts)$t.push(Be=es&&es[ts]!==void 0?De[ce](mt[ts],es[ts]):De[ce](mt[ts])),Be.onerror=bt;else for(ts=0;ts<Je;++ts)$t.push(Be=De[ce](mt[ts])),Be.onerror=bt}function Sh(ms){ms=ms.target.result,$t.forEach(function(Ai,Fm){return Ai.error!=null&&(Nt[Fm]=Ai.error)}),Re({numFailures:Ws,failures:Nt,results:ce==="delete"?fe:$t.map(function(Ai){return Ai.result}),lastResult:ms})}Be.onerror=function(ms){bt(ms),Sh(ms)},Be.onsuccess=Sh})},getMany:function(ie){var J=ie.trans,ce=ie.keys;return new Promise(function(fe,me){fe=tn(fe);for(var ke,Re=J.objectStore(ne),Ve=ce.length,De=new Array(Ve),ze=0,Ge=0,Be=function($t){$t=$t.target,De[$t._pos]=$t.result,++Ge===ze&&fe(De)},Je=_r(me),bt=0;bt<Ve;++bt)ce[bt]!=null&&((ke=Re.get(ce[bt]))._pos=bt,ke.onsuccess=Be,ke.onerror=Je,++ze);ze===0&&fe(De)})},get:function(ie){var J=ie.trans,ce=ie.key;return new Promise(function(fe,me){fe=tn(fe);var ke=J.objectStore(ne).get(ce);ke.onsuccess=function(Re){return fe(Re.target.result)},ke.onerror=_r(me)})},query:(Y=Z,function(ie){return new Promise(function(J,ce){J=tn(J);var fe,me,ke,ze=ie.trans,Re=ie.values,Ve=ie.limit,Be=ie.query,De=Ve===1/0?void 0:Ve,Ge=Be.index,Be=Be.range,ze=ze.objectStore(ne),Ge=Ge.isPrimaryKey?ze:ze.index(Ge.name),Be=$(Be);if(Ve===0)return J({result:[]});Y?((De=Re?Ge.getAll(Be,De):Ge.getAllKeys(Be,De)).onsuccess=function(Je){return J({result:Je.target.result})},De.onerror=_r(ce)):(fe=0,me=!Re&&"openKeyCursor"in Ge?Ge.openKeyCursor(Be):Ge.openCursor(Be),ke=[],me.onsuccess=function(Je){var bt=me.result;return bt?(ke.push(Re?bt.value:bt.primaryKey),++fe===Ve?J({result:ke}):void bt.continue()):J({result:ke})},me.onerror=_r(ce))})}),openCursor:function(ie){var J=ie.trans,ce=ie.values,fe=ie.query,me=ie.reverse,ke=ie.unique;return new Promise(function(Re,Ve){Re=tn(Re);var Ge=fe.index,De=fe.range,ze=J.objectStore(ne),ze=Ge.isPrimaryKey?ze:ze.index(Ge.name),Ge=me?ke?"prevunique":"prev":ke?"nextunique":"next",Be=!ce&&"openKeyCursor"in ze?ze.openKeyCursor($(De),Ge):ze.openCursor($(De),Ge);Be.onerror=_r(Ve),Be.onsuccess=tn(function(Je){var bt,$t,Nt,Ws,mt=Be.result;mt?(mt.___id=++ME,mt.done=!1,bt=mt.continue.bind(mt),$t=($t=mt.continuePrimaryKey)&&$t.bind(mt),Nt=mt.advance.bind(mt),Ws=function(){throw new Error("Cursor not stopped")},mt.trans=J,mt.stop=mt.continue=mt.continuePrimaryKey=mt.advance=function(){throw new Error("Cursor not started")},mt.fail=tn(Ve),mt.next=function(){var es=this,ts=1;return this.start(function(){return ts--?es.continue():es.stop()}).then(function(){return es})},mt.start=function(es){function ts(){if(Be.result)try{es()}catch(ms){mt.fail(ms)}else mt.done=!0,mt.start=function(){throw new Error("Cursor behind last entry")},mt.stop()}var Sh=new Promise(function(ms,Ai){ms=tn(ms),Be.onerror=_r(Ai),mt.fail=Ai,mt.stop=function(Fm){mt.stop=mt.continue=mt.continuePrimaryKey=mt.advance=Ws,ms(Fm)}});return Be.onsuccess=tn(function(ms){Be.onsuccess=ts,ts()}),mt.continue=bt,mt.continuePrimaryKey=$t,mt.advance=Nt,ts(),Sh},Re(mt)):Re(null)},Ve)})},count:function(ie){var J=ie.query,ce=ie.trans,fe=J.index,me=J.range;return new Promise(function(ke,Re){var Ve=ce.objectStore(ne),De=fe.isPrimaryKey?Ve:Ve.index(fe.name),Ve=$(me),De=Ve?De.count(Ve):De.count();De.onsuccess=tn(function(ze){return ke(ze.target.result)}),De.onerror=_r(Re)})}}}var _,P,M,re=(P=X,M=xw((_=m).objectStoreNames),{schema:{name:_.name,tables:M.map(function(ae){return P.objectStore(ae)}).map(function(ae){var Y=ae.keyPath,J=ae.autoIncrement,ne=a(Y),ie={},J={name:ae.name,primaryKey:{name:null,isPrimaryKey:!0,outbound:Y==null,compound:ne,keyPath:Y,autoIncrement:J,unique:!0,extractKey:ym(Y)},indexes:xw(ae.indexNames).map(function(ce){return ae.index(ce)}).map(function(ke){var fe=ke.name,me=ke.unique,Re=ke.multiEntry,ke=ke.keyPath,Re={name:fe,compound:a(ke),keyPath:ke,unique:me,multiEntry:Re,extractKey:ym(ke)};return ie[zl(ke)]=Re}),getIndexByKeyPath:function(ce){return ie[zl(ce)]}};return ie[":id"]=J.primaryKey,Y!=null&&(ie[zl(Y)]=J.primaryKey),J})},hasGetAll:0<M.length&&"getAll"in P.objectStore(M[0])&&!(typeof navigator<"u"&&/Safari/.test(navigator.userAgent)&&!/(Chrome\/|Edge\/)/.test(navigator.userAgent)&&[].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1]<604)}),X=re.schema,Z=re.hasGetAll,re=X.tables.map(N),G={};return re.forEach(function(ae){return G[ae.name]=ae}),{stack:"dbcore",transaction:m.transaction.bind(m),table:function(ae){if(!G[ae])throw new Error("Table '".concat(ae,"' not found"));return G[ae]},MIN_KEY:-1/0,MAX_KEY:Pl(x),schema:X}}function VE(m,x,k,$){var N=k.IDBKeyRange;return k.indexedDB,{dbcore:($=BE(x,N,$),m.dbcore.reduce(function(_,P){return P=P.create,s(s({},_),P(_))},$))}}function dh(m,$){var k=$.db,$=VE(m._middlewares,k,m._deps,$);m.core=$.dbcore,m.tables.forEach(function(N){var _=N.name;m.core.schema.tables.some(function(P){return P.name===_})&&(N.core=m.core.table(_),m[_]instanceof m.Table&&(m[_].core=N.core))})}function ph(m,x,k,$){k.forEach(function(N){var _=$[N];x.forEach(function(P){var M=function X(Z,re){return y(Z,re)||(Z=u(Z))&&X(Z,re)}(P,N);(!M||"value"in M&&M.value===void 0)&&(P===m.Transaction.prototype||P instanceof m.Transaction?f(P,N,{get:function(){return this.table(N)},set:function(X){p(this,N,{value:X,writable:!0,configurable:!0,enumerable:!0})}}):P[N]=new m.Table(N,_))})})}function bm(m,x){x.forEach(function(k){for(var $ in k)k[$]instanceof m.Table&&delete k[$]})}function WE(m,x){return m._cfg.version-x._cfg.version}function UE(m,x,k,$){var N=m._dbSchema;k.objectStoreNames.contains("$meta")&&!N.$meta&&(N.$meta=gm("$meta",vw("")[0],[]),m._storeNames.push("$meta"));var _=m._createTransaction("readwrite",m._storeNames,N);_.create(k),_._completion.catch($);var P=_._reject.bind(_),M=Ye.transless||Ye;Oo(function(){return Ye.trans=_,Ye.transless=M,x!==0?(dh(m,k),Z=x,((X=_).storeNames.includes("$meta")?X.table("$meta").get("version").then(function(re){return re??Z}):je.resolve(Z)).then(function(re){return ae=re,Y=_,ne=k,ie=[],re=(G=m)._versions,J=G._dbSchema=mh(0,G.idbdb,ne),(re=re.filter(function(ce){return ce._cfg.version>=ae})).length!==0?(re.forEach(function(ce){ie.push(function(){var fe=J,me=ce._cfg.dbschema;gh(G,fe,ne),gh(G,me,ne),J=G._dbSchema=me;var ke=xm(fe,me);ke.add.forEach(function(Ge){wm(ne,Ge[0],Ge[1].primKey,Ge[1].indexes)}),ke.change.forEach(function(Ge){if(Ge.recreate)throw new $e.Upgrade("Not yet support for changing primary key");var Be=ne.objectStore(Ge.name);Ge.add.forEach(function(Je){return fh(Be,Je)}),Ge.change.forEach(function(Je){Be.deleteIndex(Je.name),fh(Be,Je)}),Ge.del.forEach(function(Je){return Be.deleteIndex(Je)})});var Re=ce._cfg.contentUpgrade;if(Re&&ce._cfg.version>ae){dh(G,ne),Y._memoizedTables={};var Ve=L(me);ke.del.forEach(function(Ge){Ve[Ge]=fe[Ge]}),bm(G,[G.Transaction.prototype]),ph(G,[G.Transaction.prototype],i(Ve),Ve),Y.schema=Ve;var De,ze=we(Re);return ze&&Ca(),ke=je.follow(function(){var Ge;(De=Re(Y))&&ze&&(Ge=Fo.bind(null,null),De.then(Ge,Ge))}),De&&typeof De.then=="function"?je.resolve(De):ke.then(function(){return De})}}),ie.push(function(fe){var me,ke,Re=ce._cfg.dbschema;me=Re,ke=fe,[].slice.call(ke.db.objectStoreNames).forEach(function(Ve){return me[Ve]==null&&ke.db.deleteObjectStore(Ve)}),bm(G,[G.Transaction.prototype]),ph(G,[G.Transaction.prototype],G._storeNames,G._dbSchema),Y.schema=G._dbSchema}),ie.push(function(fe){G.idbdb.objectStoreNames.contains("$meta")&&(Math.ceil(G.idbdb.version/10)===ce._cfg.version?(G.idbdb.deleteObjectStore("$meta"),delete G._dbSchema.$meta,G._storeNames=G._storeNames.filter(function(me){return me!=="$meta"})):fe.objectStore("$meta").put(ce._cfg.version,"version"))})}),function ce(){return ie.length?je.resolve(ie.shift()(Y.idbtrans)).then(ce):je.resolve()}().then(function(){ww(J,ne)})):je.resolve();var G,ae,Y,ne,ie,J}).catch(P)):(i(N).forEach(function(re){wm(k,re,N[re].primKey,N[re].indexes)}),dh(m,k),void je.follow(function(){return m.on.populate.fire(_)}).catch(P));var X,Z})}function GE(m,x){ww(m._dbSchema,x),x.db.version%10!=0||x.objectStoreNames.contains("$meta")||x.db.createObjectStore("$meta").add(Math.ceil(x.db.version/10-1),"version");var k=mh(0,m.idbdb,x);gh(m,m._dbSchema,x);for(var $=0,N=xm(k,m._dbSchema).change;$<N.length;$++){var _=function(P){if(P.change.length||P.recreate)return console.warn("Unable to patch indexes of table ".concat(P.name," because it has changes on the type of index or primary key.")),{value:void 0};var M=x.objectStore(P.name);P.add.forEach(function(X){Ie&&console.debug("Dexie upgrade patch: Creating missing index ".concat(P.name,".").concat(X.src)),fh(M,X)})}(N[$]);if(typeof _=="object")return _.value}}function xm(m,x){var k,$={del:[],add:[],change:[]};for(k in m)x[k]||$.del.push(k);for(k in x){var N=m[k],_=x[k];if(N){var P={name:k,def:_,recreate:!1,del:[],add:[],change:[]};if(""+(N.primKey.keyPath||"")!=""+(_.primKey.keyPath||"")||N.primKey.auto!==_.primKey.auto)P.recreate=!0,$.change.push(P);else{var M=N.idxByName,X=_.idxByName,Z=void 0;for(Z in M)X[Z]||P.del.push(Z);for(Z in X){var re=M[Z],G=X[Z];re?re.src!==G.src&&P.change.push(G):P.add.push(G)}(0<P.del.length||0<P.add.length||0<P.change.length)&&$.change.push(P)}}else $.add.push([k,_])}return $}function wm(m,x,k,$){var N=m.db.createObjectStore(x,k.keyPath?{keyPath:k.keyPath,autoIncrement:k.auto}:{autoIncrement:k.auto});return $.forEach(function(_){return fh(N,_)}),N}function ww(m,x){i(m).forEach(function(k){x.db.objectStoreNames.contains(k)||(Ie&&console.debug("Dexie: Creating missing table",k),wm(x,k,m[k].primKey,m[k].indexes))})}function fh(m,x){m.createIndex(x.name,x.keyPath,{unique:x.unique,multiEntry:x.multi})}function mh(m,x,k){var $={};return w(x.objectStoreNames,0).forEach(function(N){for(var _=k.objectStore(N),P=mm(bw(Z=_.keyPath),Z||"",!0,!1,!!_.autoIncrement,Z&&typeof Z!="string",!0),M=[],X=0;X<_.indexNames.length;++X){var re=_.index(_.indexNames[X]),Z=re.keyPath,re=mm(re.name,Z,!!re.unique,!!re.multiEntry,!1,Z&&typeof Z!="string",!1);M.push(re)}$[N]=gm(N,P,M)}),$}function gh(m,x,k){for(var $=k.db.objectStoreNames,N=0;N<$.length;++N){var _=$[N],P=k.objectStore(_);m._hasGetAll="getAll"in P;for(var M=0;M<P.indexNames.length;++M){var X=P.indexNames[M],Z=P.index(X).keyPath,re=typeof Z=="string"?Z:"["+w(Z).join("+")+"]";!x[_]||(Z=x[_].idxByName[re])&&(Z.name=X,delete x[_].idxByName[re],x[_].idxByName[X]=Z)}}typeof navigator<"u"&&/Safari/.test(navigator.userAgent)&&!/(Chrome\/|Edge\/)/.test(navigator.userAgent)&&o.WorkerGlobalScope&&o instanceof o.WorkerGlobalScope&&[].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1]<604&&(m._hasGetAll=!1)}function vw(m){return m.split(",").map(function(x,k){var $=(x=x.trim()).replace(/([&*]|\+\+)/g,""),N=/^\[/.test($)?$.match(/^\[(.*)\]$/)[1].split("+"):$;return mm($,N||null,/\&/.test(x),/\*/.test(x),/\+\+/.test(x),a(N),k===0)})}var HE=(yh.prototype._parseStoresSpec=function(m,x){i(m).forEach(function(k){if(m[k]!==null){var $=vw(m[k]),N=$.shift();if(N.unique=!0,N.multi)throw new $e.Schema("Primary key cannot be multi-valued");$.forEach(function(_){if(_.auto)throw new $e.Schema("Only primary key can be marked as autoIncrement (++)");if(!_.keyPath)throw new $e.Schema("Index must have a name and cannot be an empty string")}),x[k]=gm(k,N,$)}})},yh.prototype.stores=function(k){var x=this.db;this._cfg.storesSource=this._cfg.storesSource?l(this._cfg.storesSource,k):k;var k=x._versions,$={},N={};return k.forEach(function(_){l($,_._cfg.storesSource),N=_._cfg.dbschema={},_._parseStoresSpec($,N)}),x._dbSchema=N,bm(x,[x._allTables,x,x.Transaction.prototype]),ph(x,[x._allTables,x,x.Transaction.prototype,this._cfg.tables],i(N),N),x._storeNames=i(N),this},yh.prototype.upgrade=function(m){return this._cfg.contentUpgrade=Ee(this._cfg.contentUpgrade||z,m),this},yh);function yh(){}function vm(m,x){var k=m._dbNamesDB;return k||(k=m._dbNamesDB=new ro(ah,{addons:[],indexedDB:m,IDBKeyRange:x})).version(1).stores({dbnames:"name"}),k.table("dbnames")}function km(m){return m&&typeof m.databases=="function"}function Cm(m){return Oo(function(){return Ye.letThrough=!0,m()})}function Sm(m){return!("from"in m)}var Qn=function(m,x){if(!this){var k=new Qn;return m&&"d"in m&&l(k,m),k}l(this,arguments.length?{d:1,from:m,to:1<arguments.length?x:m}:{d:0})};function Ml(m,x,k){var $=Rt(x,k);if(!isNaN($)){if(0<$)throw RangeError();if(Sm(m))return l(m,{from:x,to:k,d:1});var N=m.l,$=m.r;if(Rt(k,m.from)<0)return N?Ml(N,x,k):m.l={from:x,to:k,d:1,l:null,r:null},Cw(m);if(0<Rt(x,m.to))return $?Ml($,x,k):m.r={from:x,to:k,d:1,l:null,r:null},Cw(m);Rt(x,m.from)<0&&(m.from=x,m.l=null,m.d=$?$.d+1:1),0<Rt(k,m.to)&&(m.to=k,m.r=null,m.d=m.l?m.l.d+1:1),k=!m.r,N&&!m.l&&Bl(m,N),$&&k&&Bl(m,$)}}function Bl(m,x){Sm(x)||function k($,X){var _=X.from,P=X.to,M=X.l,X=X.r;Ml($,_,P),M&&k($,M),X&&k($,X)}(m,x)}function kw(m,x){var k=bh(x),$=k.next();if($.done)return!1;for(var N=$.value,_=bh(m),P=_.next(N.from),M=P.value;!$.done&&!P.done;){if(Rt(M.from,N.to)<=0&&0<=Rt(M.to,N.from))return!0;Rt(N.from,M.from)<0?N=($=k.next(M.from)).value:M=(P=_.next(N.from)).value}return!1}function bh(m){var x=Sm(m)?null:{s:0,n:m};return{next:function(k){for(var $=0<arguments.length;x;)switch(x.s){case 0:if(x.s=1,$)for(;x.n.l&&Rt(k,x.n.from)<0;)x={up:x,n:x.n.l,s:1};else for(;x.n.l;)x={up:x,n:x.n.l,s:1};case 1:if(x.s=2,!$||Rt(k,x.n.to)<=0)return{value:x.n,done:!1};case 2:if(x.n.r){x.s=3,x={up:x,n:x.n.r,s:0};continue}case 3:x=x.up}return{done:!0}}}}function Cw(m){var x,k,$=(((x=m.r)===null||x===void 0?void 0:x.d)||0)-(((k=m.l)===null||k===void 0?void 0:k.d)||0),N=1<$?"r":$<-1?"l":"";N&&(x=N=="r"?"l":"r",k=s({},m),$=m[N],m.from=$.from,m.to=$.to,m[N]=$[N],k[N]=$[x],(m[x]=k).d=Sw(k)),m.d=Sw(m)}function Sw(k){var x=k.r,k=k.l;return(x?k?Math.max(x.d,k.d):x.d:k?k.d:0)+1}function xh(m,x){return i(x).forEach(function(k){m[k]?Bl(m[k],x[k]):m[k]=function $(N){var _,P,M={};for(_ in N)h(N,_)&&(P=N[_],M[_]=!P||typeof P!="object"||T.has(P.constructor)?P:$(P));return M}(x[k])}),m}function Im(m,x){return m.all||x.all||Object.keys(m).some(function(k){return x[k]&&kw(x[k],m[k])})}d(Qn.prototype,((Zs={add:function(m){return Bl(this,m),this},addKey:function(m){return Ml(this,m,m),this},addKeys:function(m){var x=this;return m.forEach(function(k){return Ml(x,k,k)}),this},hasKey:function(m){var x=bh(this).next(m).value;return x&&Rt(x.from,m)<=0&&0<=Rt(x.to,m)}})[te]=function(){return bh(this)},Zs));var Ei={},$m={},Nm=!1;function wh(m){xh($m,m),Nm||(Nm=!0,setTimeout(function(){Nm=!1,Tm($m,!($m={}))},0))}function Tm(m,x){x===void 0&&(x=!1);var k=new Set;if(m.all)for(var $=0,N=Object.values(Ei);$<N.length;$++)Iw(P=N[$],m,k,x);else for(var _ in m){var P,M=/^idb\:\/\/(.*)\/(.*)\//.exec(_);M&&(_=M[1],M=M[2],(P=Ei["idb://".concat(_,"/").concat(M)])&&Iw(P,m,k,x))}k.forEach(function(X){return X()})}function Iw(m,x,k,$){for(var N=[],_=0,P=Object.entries(m.queries.query);_<P.length;_++){for(var M=P[_],X=M[0],Z=[],re=0,G=M[1];re<G.length;re++){var ae=G[re];Im(x,ae.obsSet)?ae.subscribers.forEach(function(J){return k.add(J)}):$&&Z.push(ae)}$&&N.push([X,Z])}if($)for(var Y=0,ne=N;Y<ne.length;Y++){var ie=ne[Y],X=ie[0],Z=ie[1];m.queries.query[X]=Z}}function jE(m){var x=m._state,k=m._deps.indexedDB;if(x.isBeingOpened||m.idbdb)return x.dbReadyPromise.then(function(){return x.dbOpenError?gn(x.dbOpenError):m});x.isBeingOpened=!0,x.dbOpenError=null,x.openComplete=!1;var $=x.openCanceller,N=Math.round(10*m.verno),_=!1;function P(){if(x.openCanceller!==$)throw new $e.DatabaseClosed("db.open() was cancelled")}function M(){return new je(function(ae,Y){if(P(),!k)throw new $e.MissingAPI;var ne=m.name,ie=x.autoSchema||!N?k.open(ne):k.open(ne,N);if(!ie)throw new $e.MissingAPI;ie.onerror=_r(Y),ie.onblocked=tn(m._fireOnBlocked),ie.onupgradeneeded=tn(function(J){var ce;re=ie.transaction,x.autoSchema&&!m._options.allowEmptyDB?(ie.onerror=Fl,re.abort(),ie.result.close(),(ce=k.deleteDatabase(ne)).onsuccess=ce.onerror=tn(function(){Y(new $e.NoSuchDatabase("Database ".concat(ne," doesnt exist")))})):(re.onerror=_r(Y),J=J.oldVersion>Math.pow(2,62)?0:J.oldVersion,G=J<1,m.idbdb=ie.result,_&&GE(m,re),UE(m,J/10,re,Y))},Y),ie.onsuccess=tn(function(){re=null;var J,ce,fe,me,ke,Re=m.idbdb=ie.result,Ve=w(Re.objectStoreNames);if(0<Ve.length)try{var De=Re.transaction((me=Ve).length===1?me[0]:me,"readonly");if(x.autoSchema)ce=Re,fe=De,(J=m).verno=ce.version/10,fe=J._dbSchema=mh(0,ce,fe),J._storeNames=w(ce.objectStoreNames,0),ph(J,[J._allTables],i(fe),fe);else if(gh(m,m._dbSchema,De),((ke=xm(mh(0,(ke=m).idbdb,De),ke._dbSchema)).add.length||ke.change.some(function(ze){return ze.add.length||ze.change.length}))&&!_)return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."),Re.close(),N=Re.version+1,_=!0,ae(M());dh(m,De)}catch{}Sa.push(m),Re.onversionchange=tn(function(ze){x.vcFired=!0,m.on("versionchange").fire(ze)}),Re.onclose=tn(function(ze){m.on("close").fire(ze)}),G&&(ke=m._deps,De=ne,Re=ke.indexedDB,ke=ke.IDBKeyRange,km(Re)||De===ah||vm(Re,ke).put({name:De}).catch(z)),ae()},Y)}).catch(function(ae){switch(ae==null?void 0:ae.name){case"UnknownError":if(0<x.PR1398_maxLoop)return x.PR1398_maxLoop--,console.warn("Dexie: Workaround for Chrome UnknownError on open()"),M();break;case"VersionError":if(0<N)return N=0,M()}return je.reject(ae)})}var X,Z=x.dbReadyResolve,re=null,G=!1;return je.race([$,(typeof navigator>"u"?je.resolve():!navigator.userAgentData&&/Safari\//.test(navigator.userAgent)&&!/Chrom(e|ium)\//.test(navigator.userAgent)&&indexedDB.databases?new Promise(function(ae){function Y(){return indexedDB.databases().finally(ae)}X=setInterval(Y,100),Y()}).finally(function(){return clearInterval(X)}):Promise.resolve()).then(M)]).then(function(){return P(),x.onReadyBeingFired=[],je.resolve(Cm(function(){return m.on.ready.fire(m.vip)})).then(function ae(){if(0<x.onReadyBeingFired.length){var Y=x.onReadyBeingFired.reduce(Ee,z);return x.onReadyBeingFired=[],je.resolve(Cm(function(){return Y(m.vip)})).then(ae)}})}).finally(function(){x.openCanceller===$&&(x.onReadyBeingFired=null,x.isBeingOpened=!1)}).catch(function(ae){x.dbOpenError=ae;try{re&&re.abort()}catch{}return $===x.openCanceller&&m._close(),gn(ae)}).finally(function(){x.openComplete=!0,Z()}).then(function(){var ae;return G&&(ae={},m.tables.forEach(function(Y){Y.schema.indexes.forEach(function(ne){ne.name&&(ae["idb://".concat(m.name,"/").concat(Y.name,"/").concat(ne.name)]=new Qn(-1/0,[[[]]]))}),ae["idb://".concat(m.name,"/").concat(Y.name,"/")]=ae["idb://".concat(m.name,"/").concat(Y.name,"/:dels")]=new Qn(-1/0,[[[]]])}),zo(Ll).fire(ae),Tm(ae,!0)),m})}function Em(m){function x(_){return m.next(_)}var k=N(x),$=N(function(_){return m.throw(_)});function N(_){return function(X){var M=_(X),X=M.value;return M.done?X:X&&typeof X.then=="function"?X.then(k,$):a(X)?Promise.all(X).then(k,$):k(X)}}return N(x)()}function vh(m,x,k){for(var $=a(m)?m.slice():[m],N=0;N<k;++N)$.push(x);return $}var KE={stack:"dbcore",name:"VirtualIndexMiddleware",level:1,create:function(m){return s(s({},m),{table:function(x){var k=m.table(x),$=k.schema,N={},_=[];function P(G,ae,Y){var ne=zl(G),ie=N[ne]=N[ne]||[],J=G==null?0:typeof G=="string"?1:G.length,ce=0<ae,ce=s(s({},Y),{name:ce?"".concat(ne,"(virtual-from:").concat(Y.name,")"):Y.name,lowLevelIndex:Y,isVirtual:ce,keyTail:ae,keyLength:J,extractKey:ym(G),unique:!ce&&Y.unique});return ie.push(ce),ce.isPrimaryKey||_.push(ce),1<J&&P(J===2?G[0]:G.slice(0,J-1),ae+1,Y),ie.sort(function(fe,me){return fe.keyTail-me.keyTail}),ce}x=P($.primaryKey.keyPath,0,$.primaryKey),N[":id"]=[x];for(var M=0,X=$.indexes;M<X.length;M++){var Z=X[M];P(Z.keyPath,0,Z)}function re(G){var ae,Y=G.query.index;return Y.isVirtual?s(s({},G),{query:{index:Y.lowLevelIndex,range:(ae=G.query.range,Y=Y.keyTail,{type:ae.type===1?2:ae.type,lower:vh(ae.lower,ae.lowerOpen?m.MAX_KEY:m.MIN_KEY,Y),lowerOpen:!0,upper:vh(ae.upper,ae.upperOpen?m.MIN_KEY:m.MAX_KEY,Y),upperOpen:!0})}}):G}return s(s({},k),{schema:s(s({},$),{primaryKey:x,indexes:_,getIndexByKeyPath:function(G){return(G=N[zl(G)])&&G[0]}}),count:function(G){return k.count(re(G))},query:function(G){return k.query(re(G))},openCursor:function(G){var ae=G.query.index,Y=ae.keyTail,ne=ae.isVirtual,ie=ae.keyLength;return ne?k.openCursor(re(G)).then(function(ce){return ce&&J(ce)}):k.openCursor(G);function J(ce){return Object.create(ce,{continue:{value:function(fe){fe!=null?ce.continue(vh(fe,G.reverse?m.MAX_KEY:m.MIN_KEY,Y)):G.unique?ce.continue(ce.key.slice(0,ie).concat(G.reverse?m.MIN_KEY:m.MAX_KEY,Y)):ce.continue()}},continuePrimaryKey:{value:function(fe,me){ce.continuePrimaryKey(vh(fe,m.MAX_KEY,Y),me)}},primaryKey:{get:function(){return ce.primaryKey}},key:{get:function(){var fe=ce.key;return ie===1?fe[0]:fe.slice(0,ie)}},value:{get:function(){return ce.value}}})}}})}})}};function _m(m,x,k,$){return k=k||{},$=$||"",i(m).forEach(function(N){var _,P,M;h(x,N)?(_=m[N],P=x[N],typeof _=="object"&&typeof P=="object"&&_&&P?(M=ee(_))!==ee(P)?k[$+N]=x[N]:M==="Object"?_m(_,P,k,$+N+"."):_!==P&&(k[$+N]=x[N]):_!==P&&(k[$+N]=x[N])):k[$+N]=void 0}),i(x).forEach(function(N){h(m,N)||(k[$+N]=x[N])}),k}function Am(m,x){return x.type==="delete"?x.keys:x.keys||x.values.map(m.extractKey)}var qE={stack:"dbcore",name:"HooksMiddleware",level:2,create:function(m){return s(s({},m),{table:function(x){var k=m.table(x),$=k.schema.primaryKey;return s(s({},k),{mutate:function(N){var _=Ye.trans,P=_.table(x).hook,M=P.deleting,X=P.creating,Z=P.updating;switch(N.type){case"add":if(X.fire===z)break;return _._promise("readwrite",function(){return re(N)},!0);case"put":if(X.fire===z&&Z.fire===z)break;return _._promise("readwrite",function(){return re(N)},!0);case"delete":if(M.fire===z)break;return _._promise("readwrite",function(){return re(N)},!0);case"deleteRange":if(M.fire===z)break;return _._promise("readwrite",function(){return function G(ae,Y,ne){return k.query({trans:ae,values:!1,query:{index:$,range:Y},limit:ne}).then(function(ie){var J=ie.result;return re({type:"delete",keys:J,trans:ae}).then(function(ce){return 0<ce.numFailures?Promise.reject(ce.failures[0]):J.length<ne?{failures:[],numFailures:0,lastResult:void 0}:G(ae,s(s({},Y),{lower:J[J.length-1],lowerOpen:!0}),ne)})})}(N.trans,N.range,1e4)},!0)}return k.mutate(N);function re(G){var ae,Y,ne,ie=Ye.trans,J=G.keys||Am($,G);if(!J)throw new Error("Keys missing");return(G=G.type==="add"||G.type==="put"?s(s({},G),{keys:J}):s({},G)).type!=="delete"&&(G.values=r([],G.values)),G.keys&&(G.keys=r([],G.keys)),ae=k,ne=J,((Y=G).type==="add"?Promise.resolve([]):ae.getMany({trans:Y.trans,keys:ne,cache:"immutable"})).then(function(ce){var fe=J.map(function(me,ke){var Re,Ve,De,ze=ce[ke],Ge={onerror:null,onsuccess:null};return G.type==="delete"?M.fire.call(Ge,me,ze,ie):G.type==="add"||ze===void 0?(Re=X.fire.call(Ge,me,G.values[ke],ie),me==null&&Re!=null&&(G.keys[ke]=me=Re,$.outbound||R(G.values[ke],$.keyPath,me))):(Re=_m(ze,G.values[ke]),(Ve=Z.fire.call(Ge,Re,me,ze,ie))&&(De=G.values[ke],Object.keys(Ve).forEach(function(Be){h(De,Be)?De[Be]=Ve[Be]:R(De,Be,Ve[Be])}))),Ge});return k.mutate(G).then(function(me){for(var ke=me.failures,Re=me.results,Ve=me.numFailures,me=me.lastResult,De=0;De<J.length;++De){var ze=(Re||J)[De],Ge=fe[De];ze==null?Ge.onerror&&Ge.onerror(ke[De]):Ge.onsuccess&&Ge.onsuccess(G.type==="put"&&ce[De]?G.values[De]:ze)}return{failures:ke,results:Re,numFailures:Ve,lastResult:me}}).catch(function(me){return fe.forEach(function(ke){return ke.onerror&&ke.onerror(me)}),Promise.reject(me)})})}}})}})}};function $w(m,x,k){try{if(!x||x.keys.length<m.length)return null;for(var $=[],N=0,_=0;N<x.keys.length&&_<m.length;++N)Rt(x.keys[N],m[_])===0&&($.push(k?q(x.values[N]):x.values[N]),++_);return $.length===m.length?$:null}catch{return null}}var XE={stack:"dbcore",level:-1,create:function(m){return{table:function(x){var k=m.table(x);return s(s({},k),{getMany:function($){if(!$.cache)return k.getMany($);var N=$w($.keys,$.trans._cache,$.cache==="clone");return N?je.resolve(N):k.getMany($).then(function(_){return $.trans._cache={keys:$.keys,values:$.cache==="clone"?q(_):_},_})},mutate:function($){return $.type!=="add"&&($.trans._cache=null),k.mutate($)}})}}}};function Nw(m,x){return m.trans.mode==="readonly"&&!!m.subscr&&!m.trans.explicit&&m.trans.db._options.cache!=="disabled"&&!x.schema.primaryKey.outbound}function Tw(m,x){switch(m){case"query":return x.values&&!x.unique;case"get":case"getMany":case"count":case"openCursor":return!1}}var YE={stack:"dbcore",level:0,name:"Observability",create:function(m){var x=m.schema.name,k=new Qn(m.MIN_KEY,m.MAX_KEY);return s(s({},m),{transaction:function($,N,_){if(Ye.subscr&&N!=="readonly")throw new $e.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(Ye.querier));return m.transaction($,N,_)},table:function($){var N=m.table($),_=N.schema,P=_.primaryKey,G=_.indexes,M=P.extractKey,X=P.outbound,Z=P.autoIncrement&&G.filter(function(Y){return Y.compound&&Y.keyPath.includes(P.keyPath)}),re=s(s({},N),{mutate:function(Y){function ne(Be){return Be="idb://".concat(x,"/").concat($,"/").concat(Be),me[Be]||(me[Be]=new Qn)}var ie,J,ce,fe=Y.trans,me=Y.mutatedParts||(Y.mutatedParts={}),ke=ne(""),Re=ne(":dels"),Ve=Y.type,Ge=Y.type==="deleteRange"?[Y.range]:Y.type==="delete"?[Y.keys]:Y.values.length<50?[Am(P,Y).filter(function(Be){return Be}),Y.values]:[],De=Ge[0],ze=Ge[1],Ge=Y.trans._cache;return a(De)?(ke.addKeys(De),(Ge=Ve==="delete"||De.length===ze.length?$w(De,Ge):null)||Re.addKeys(De),(Ge||ze)&&(ie=ne,J=Ge,ce=ze,_.indexes.forEach(function(Be){var Je=ie(Be.name||"");function bt(Nt){return Nt!=null?Be.extractKey(Nt):null}function $t(Nt){return Be.multiEntry&&a(Nt)?Nt.forEach(function(Ws){return Je.addKey(Ws)}):Je.addKey(Nt)}(J||ce).forEach(function(Nt,es){var mt=J&&bt(J[es]),es=ce&&bt(ce[es]);Rt(mt,es)!==0&&(mt!=null&&$t(mt),es!=null&&$t(es))})}))):De?(ze={from:(ze=De.lower)!==null&&ze!==void 0?ze:m.MIN_KEY,to:(ze=De.upper)!==null&&ze!==void 0?ze:m.MAX_KEY},Re.add(ze),ke.add(ze)):(ke.add(k),Re.add(k),_.indexes.forEach(function(Be){return ne(Be.name).add(k)})),N.mutate(Y).then(function(Be){return!De||Y.type!=="add"&&Y.type!=="put"||(ke.addKeys(Be.results),Z&&Z.forEach(function(Je){for(var bt=Y.values.map(function(mt){return Je.extractKey(mt)}),$t=Je.keyPath.findIndex(function(mt){return mt===P.keyPath}),Nt=0,Ws=Be.results.length;Nt<Ws;++Nt)bt[Nt][$t]=Be.results[Nt];ne(Je.name).addKeys(bt)})),fe.mutatedParts=xh(fe.mutatedParts||{},me),Be})}}),G=function(ne){var ie=ne.query,ne=ie.index,ie=ie.range;return[ne,new Qn((ne=ie.lower)!==null&&ne!==void 0?ne:m.MIN_KEY,(ie=ie.upper)!==null&&ie!==void 0?ie:m.MAX_KEY)]},ae={get:function(Y){return[P,new Qn(Y.key)]},getMany:function(Y){return[P,new Qn().addKeys(Y.keys)]},count:G,query:G,openCursor:G};return i(ae).forEach(function(Y){re[Y]=function(ne){var ie=Ye.subscr,J=!!ie,ce=Nw(Ye,N)&&Tw(Y,ne)?ne.obsSet={}:ie;if(J){var fe=function(ze){return ze="idb://".concat(x,"/").concat($,"/").concat(ze),ce[ze]||(ce[ze]=new Qn)},me=fe(""),ke=fe(":dels"),ie=ae[Y](ne),J=ie[0],ie=ie[1];if((Y==="query"&&J.isPrimaryKey&&!ne.values?ke:fe(J.name||"")).add(ie),!J.isPrimaryKey){if(Y!=="count"){var Re=Y==="query"&&X&&ne.values&&N.query(s(s({},ne),{values:!1}));return N[Y].apply(this,arguments).then(function(ze){if(Y==="query"){if(X&&ne.values)return Re.then(function(bt){return bt=bt.result,me.addKeys(bt),ze});var Ge=ne.values?ze.result.map(M):ze.result;(ne.values?me:ke).addKeys(Ge)}else if(Y==="openCursor"){var Be=ze,Je=ne.values;return Be&&Object.create(Be,{key:{get:function(){return ke.addKey(Be.primaryKey),Be.key}},primaryKey:{get:function(){var bt=Be.primaryKey;return ke.addKey(bt),bt}},value:{get:function(){return Je&&me.addKey(Be.primaryKey),Be.value}}})}return ze})}ke.add(k)}}return N[Y].apply(this,arguments)}}),re}})}};function Ew(m,x,k){if(k.numFailures===0)return x;if(x.type==="deleteRange")return null;var $=x.keys?x.keys.length:"values"in x&&x.values?x.values.length:1;return k.numFailures===$?null:(x=s({},x),a(x.keys)&&(x.keys=x.keys.filter(function(N,_){return!(_ in k.failures)})),"values"in x&&a(x.values)&&(x.values=x.values.filter(function(N,_){return!(_ in k.failures)})),x)}function Rm(m,x){return k=m,(($=x).lower===void 0||($.lowerOpen?0<Rt(k,$.lower):0<=Rt(k,$.lower)))&&(m=m,(x=x).upper===void 0||(x.upperOpen?Rt(m,x.upper)<0:Rt(m,x.upper)<=0));var k,$}function _w(m,x,ae,$,N,_){if(!ae||ae.length===0)return m;var P=x.query.index,M=P.multiEntry,X=x.query.range,Z=$.schema.primaryKey.extractKey,re=P.extractKey,G=(P.lowLevelIndex||P).extractKey,ae=ae.reduce(function(Y,ne){var ie=Y,J=[];if(ne.type==="add"||ne.type==="put")for(var ce=new Qn,fe=ne.values.length-1;0<=fe;--fe){var me,ke=ne.values[fe],Re=Z(ke);ce.hasKey(Re)||(me=re(ke),(M&&a(me)?me.some(function(Be){return Rm(Be,X)}):Rm(me,X))&&(ce.addKey(Re),J.push(ke)))}switch(ne.type){case"add":var Ve=new Qn().addKeys(x.values?Y.map(function(Je){return Z(Je)}):Y),ie=Y.concat(x.values?J.filter(function(Je){return Je=Z(Je),!Ve.hasKey(Je)&&(Ve.addKey(Je),!0)}):J.map(function(Je){return Z(Je)}).filter(function(Je){return!Ve.hasKey(Je)&&(Ve.addKey(Je),!0)}));break;case"put":var De=new Qn().addKeys(ne.values.map(function(Je){return Z(Je)}));ie=Y.filter(function(Je){return!De.hasKey(x.values?Z(Je):Je)}).concat(x.values?J:J.map(function(Je){return Z(Je)}));break;case"delete":var ze=new Qn().addKeys(ne.keys);ie=Y.filter(function(Je){return!ze.hasKey(x.values?Z(Je):Je)});break;case"deleteRange":var Ge=ne.range;ie=Y.filter(function(Je){return!Rm(Z(Je),Ge)})}return ie},m);return ae===m?m:(ae.sort(function(Y,ne){return Rt(G(Y),G(ne))||Rt(Z(Y),Z(ne))}),x.limit&&x.limit<1/0&&(ae.length>x.limit?ae.length=x.limit:m.length===x.limit&&ae.length<x.limit&&(N.dirty=!0)),_?Object.freeze(ae):ae)}function Aw(m,x){return Rt(m.lower,x.lower)===0&&Rt(m.upper,x.upper)===0&&!!m.lowerOpen==!!x.lowerOpen&&!!m.upperOpen==!!x.upperOpen}function ZE(m,x){return function(k,$,N,_){if(k===void 0)return $!==void 0?-1:0;if($===void 0)return 1;if(($=Rt(k,$))===0){if(N&&_)return 0;if(N)return 1;if(_)return-1}return $}(m.lower,x.lower,m.lowerOpen,x.lowerOpen)<=0&&0<=function(k,$,N,_){if(k===void 0)return $!==void 0?1:0;if($===void 0)return-1;if(($=Rt(k,$))===0){if(N&&_)return 0;if(N)return-1;if(_)return 1}return $}(m.upper,x.upper,m.upperOpen,x.upperOpen)}function JE(m,x,k,$){m.subscribers.add(k),$.addEventListener("abort",function(){var N,_;m.subscribers.delete(k),m.subscribers.size===0&&(N=m,_=x,setTimeout(function(){N.subscribers.size===0&&Q(_,N)},3e3))})}var QE={stack:"dbcore",level:0,name:"Cache",create:function(m){var x=m.schema.name;return s(s({},m),{transaction:function(k,$,N){var _,P,M=m.transaction(k,$,N);return $==="readwrite"&&(P=(_=new AbortController).signal,N=function(X){return function(){if(_.abort(),$==="readwrite"){for(var Z=new Set,re=0,G=k;re<G.length;re++){var ae=G[re],Y=Ei["idb://".concat(x,"/").concat(ae)];if(Y){var ne=m.table(ae),ie=Y.optimisticOps.filter(function(Je){return Je.trans===M});if(M._explicit&&X&&M.mutatedParts)for(var J=0,ce=Object.values(Y.queries.query);J<ce.length;J++)for(var fe=0,me=(Ve=ce[J]).slice();fe<me.length;fe++)Im((De=me[fe]).obsSet,M.mutatedParts)&&(Q(Ve,De),De.subscribers.forEach(function(Je){return Z.add(Je)}));else if(0<ie.length){Y.optimisticOps=Y.optimisticOps.filter(function(Je){return Je.trans!==M});for(var ke=0,Re=Object.values(Y.queries.query);ke<Re.length;ke++)for(var Ve,De,ze,Ge=0,Be=(Ve=Re[ke]).slice();Ge<Be.length;Ge++)(De=Be[Ge]).res!=null&&M.mutatedParts&&(X&&!De.dirty?(ze=Object.isFrozen(De.res),ze=_w(De.res,De.req,ie,ne,De,ze),De.dirty?(Q(Ve,De),De.subscribers.forEach(function(Je){return Z.add(Je)})):ze!==De.res&&(De.res=ze,De.promise=je.resolve({result:ze}))):(De.dirty&&Q(Ve,De),De.subscribers.forEach(function(Je){return Z.add(Je)})))}}}Z.forEach(function(Je){return Je()})}}},M.addEventListener("abort",N(!1),{signal:P}),M.addEventListener("error",N(!1),{signal:P}),M.addEventListener("complete",N(!0),{signal:P})),M},table:function(k){var $=m.table(k),N=$.schema.primaryKey;return s(s({},$),{mutate:function(_){var P=Ye.trans;if(N.outbound||P.db._options.cache==="disabled"||P.explicit||P.idbtrans.mode!=="readwrite")return $.mutate(_);var M=Ei["idb://".concat(x,"/").concat(k)];return M?(P=$.mutate(_),_.type!=="add"&&_.type!=="put"||!(50<=_.values.length||Am(N,_).some(function(X){return X==null}))?(M.optimisticOps.push(_),_.mutatedParts&&wh(_.mutatedParts),P.then(function(X){0<X.numFailures&&(Q(M.optimisticOps,_),(X=Ew(0,_,X))&&M.optimisticOps.push(X),_.mutatedParts&&wh(_.mutatedParts))}),P.catch(function(){Q(M.optimisticOps,_),_.mutatedParts&&wh(_.mutatedParts)})):P.then(function(X){var Z=Ew(0,s(s({},_),{values:_.values.map(function(re,G){var ae;return X.failures[G]||(re=(ae=N.keyPath)!==null&&ae!==void 0&&ae.includes(".")?q(re):s({},re),R(re,N.keyPath,X.results[G])),re})}),X);M.optimisticOps.push(Z),queueMicrotask(function(){return _.mutatedParts&&wh(_.mutatedParts)})}),P):$.mutate(_)},query:function(_){if(!Nw(Ye,$)||!Tw("query",_))return $.query(_);var P=((Z=Ye.trans)===null||Z===void 0?void 0:Z.db._options.cache)==="immutable",G=Ye,M=G.requery,X=G.signal,Z=function(ne,ie,J,ce){var fe=Ei["idb://".concat(ne,"/").concat(ie)];if(!fe)return[];if(!(ie=fe.queries[J]))return[null,!1,fe,null];var me=ie[(ce.query?ce.query.index.name:null)||""];if(!me)return[null,!1,fe,null];switch(J){case"query":var ke=me.find(function(Re){return Re.req.limit===ce.limit&&Re.req.values===ce.values&&Aw(Re.req.query.range,ce.query.range)});return ke?[ke,!0,fe,me]:[me.find(function(Re){return("limit"in Re.req?Re.req.limit:1/0)>=ce.limit&&(!ce.values||Re.req.values)&&ZE(Re.req.query.range,ce.query.range)}),!1,fe,me];case"count":return ke=me.find(function(Re){return Aw(Re.req.query.range,ce.query.range)}),[ke,!!ke,fe,me]}}(x,k,"query",_),re=Z[0],G=Z[1],ae=Z[2],Y=Z[3];return re&&G?re.obsSet=_.obsSet:(G=$.query(_).then(function(ne){var ie=ne.result;if(re&&(re.res=ie),P){for(var J=0,ce=ie.length;J<ce;++J)Object.freeze(ie[J]);Object.freeze(ie)}else ne.result=q(ie);return ne}).catch(function(ne){return Y&&re&&Q(Y,re),Promise.reject(ne)}),re={obsSet:_.obsSet,promise:G,subscribers:new Set,type:"query",req:_,dirty:!1},Y?Y.push(re):(Y=[re],(ae=ae||(Ei["idb://".concat(x,"/").concat(k)]={queries:{query:{},count:{}},objs:new Map,optimisticOps:[],unsignaledParts:{}})).queries.query[_.query.index.name||""]=Y)),JE(re,Y,M,X),re.promise.then(function(ne){return{result:_w(ne.result,_,ae==null?void 0:ae.optimisticOps,$,re,P)}})}})}})}};function kh(m,x){return new Proxy(m,{get:function(k,$,N){return $==="db"?x:Reflect.get(k,$,N)}})}var ro=(yn.prototype.version=function(m){if(isNaN(m)||m<.1)throw new $e.Type("Given version is not a positive number");if(m=Math.round(10*m)/10,this.idbdb||this._state.isBeingOpened)throw new $e.Schema("Cannot add version when database is open");this.verno=Math.max(this.verno,m);var x=this._versions,k=x.filter(function($){return $._cfg.version===m})[0];return k||(k=new this.Version(m),x.push(k),x.sort(WE),k.stores({}),this._state.autoSchema=!1,k)},yn.prototype._whenReady=function(m){var x=this;return this.idbdb&&(this._state.openComplete||Ye.letThrough||this._vip)?m():new je(function(k,$){if(x._state.openComplete)return $(new $e.DatabaseClosed(x._state.dbOpenError));if(!x._state.isBeingOpened){if(!x._state.autoOpen)return void $(new $e.DatabaseClosed);x.open().catch(z)}x._state.dbReadyPromise.then(k,$)}).then(m)},yn.prototype.use=function(m){var x=m.stack,k=m.create,$=m.level,N=m.name;return N&&this.unuse({stack:x,name:N}),m=this._middlewares[x]||(this._middlewares[x]=[]),m.push({stack:x,create:k,level:$??10,name:N}),m.sort(function(_,P){return _.level-P.level}),this},yn.prototype.unuse=function(m){var x=m.stack,k=m.name,$=m.create;return x&&this._middlewares[x]&&(this._middlewares[x]=this._middlewares[x].filter(function(N){return $?N.create!==$:!!k&&N.name!==k})),this},yn.prototype.open=function(){var m=this;return $i(en,function(){return jE(m)})},yn.prototype._close=function(){var m=this._state,x=Sa.indexOf(this);if(0<=x&&Sa.splice(x,1),this.idbdb){try{this.idbdb.close()}catch{}this.idbdb=null}m.isBeingOpened||(m.dbReadyPromise=new je(function(k){m.dbReadyResolve=k}),m.openCanceller=new je(function(k,$){m.cancelOpen=$}))},yn.prototype.close=function(k){var x=(k===void 0?{disableAutoOpen:!0}:k).disableAutoOpen,k=this._state;x?(k.isBeingOpened&&k.cancelOpen(new $e.DatabaseClosed),this._close(),k.autoOpen=!1,k.dbOpenError=new $e.DatabaseClosed):(this._close(),k.autoOpen=this._options.autoOpen||k.isBeingOpened,k.openComplete=!1,k.dbOpenError=null)},yn.prototype.delete=function(m){var x=this;m===void 0&&(m={disableAutoOpen:!0});var k=0<arguments.length&&typeof arguments[0]!="object",$=this._state;return new je(function(N,_){function P(){x.close(m);var M=x._deps.indexedDB.deleteDatabase(x.name);M.onsuccess=tn(function(){var X,Z,re;X=x._deps,Z=x.name,re=X.indexedDB,X=X.IDBKeyRange,km(re)||Z===ah||vm(re,X).delete(Z).catch(z),N()}),M.onerror=_r(_),M.onblocked=x._fireOnBlocked}if(k)throw new $e.InvalidArgument("Invalid closeOptions argument to db.delete()");$.isBeingOpened?$.dbReadyPromise.then(P):P()})},yn.prototype.backendDB=function(){return this.idbdb},yn.prototype.isOpen=function(){return this.idbdb!==null},yn.prototype.hasBeenClosed=function(){var m=this._state.dbOpenError;return m&&m.name==="DatabaseClosed"},yn.prototype.hasFailed=function(){return this._state.dbOpenError!==null},yn.prototype.dynamicallyOpened=function(){return this._state.autoSchema},Object.defineProperty(yn.prototype,"tables",{get:function(){var m=this;return i(this._allTables).map(function(x){return m._allTables[x]})},enumerable:!1,configurable:!0}),yn.prototype.transaction=function(){var m=(function(x,k,$){var N=arguments.length;if(N<2)throw new $e.InvalidArgument("Too few arguments");for(var _=new Array(N-1);--N;)_[N-1]=arguments[N];return $=_.pop(),[x,F(_),$]}).apply(this,arguments);return this._transaction.apply(this,m)},yn.prototype._transaction=function(m,x,k){var $=this,N=Ye.trans;N&&N.db===this&&m.indexOf("!")===-1||(N=null);var _,P,M=m.indexOf("?")!==-1;m=m.replace("!","").replace("?","");try{if(P=x.map(function(Z){if(Z=Z instanceof $.Table?Z.name:Z,typeof Z!="string")throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");return Z}),m=="r"||m===um)_=um;else{if(m!="rw"&&m!=cm)throw new $e.InvalidArgument("Invalid transaction mode: "+m);_=cm}if(N){if(N.mode===um&&_===cm){if(!M)throw new $e.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");N=null}N&&P.forEach(function(Z){if(N&&N.storeNames.indexOf(Z)===-1){if(!M)throw new $e.SubTransaction("Table "+Z+" not included in parent transaction.");N=null}}),M&&N&&!N.active&&(N=null)}}catch(Z){return N?N._promise(null,function(re,G){G(Z)}):gn(Z)}var X=(function Z(re,G,ae,Y,ne){return je.resolve().then(function(){var ie=Ye.transless||Ye,J=re._createTransaction(G,ae,re._dbSchema,Y);if(J.explicit=!0,ie={trans:J,transless:ie},Y)J.idbtrans=Y.idbtrans;else try{J.create(),J.idbtrans._explicit=!0,re._state.PR1398_maxLoop=3}catch(me){return me.name===Ze.InvalidState&&re.isOpen()&&0<--re._state.PR1398_maxLoop?(console.warn("Dexie: Need to reopen db"),re.close({disableAutoOpen:!1}),re.open().then(function(){return Z(re,G,ae,null,ne)})):gn(me)}var ce,fe=we(ne);return fe&&Ca(),ie=je.follow(function(){var me;(ce=ne.call(J,J))&&(fe?(me=Fo.bind(null,null),ce.then(me,me)):typeof ce.next=="function"&&typeof ce.throw=="function"&&(ce=Em(ce)))},ie),(ce&&typeof ce.then=="function"?je.resolve(ce).then(function(me){return J.active?me:gn(new $e.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))}):ie.then(function(){return ce})).then(function(me){return Y&&J._resolve(),J._completion.then(function(){return me})}).catch(function(me){return J._reject(me),gn(me)})})}).bind(null,this,_,P,N,k);return N?N._promise(_,X,"lock"):Ye.trans?$i(Ye.transless,function(){return $._whenReady(X)}):this._whenReady(X)},yn.prototype.table=function(m){if(!h(this._allTables,m))throw new $e.InvalidTable("Table ".concat(m," does not exist"));return this._allTables[m]},yn);function yn(m,x){var k=this;this._middlewares={},this.verno=0;var $=yn.dependencies;this._options=x=s({addons:yn.addons,autoOpen:!0,indexedDB:$.indexedDB,IDBKeyRange:$.IDBKeyRange,cache:"cloned"},x),this._deps={indexedDB:x.indexedDB,IDBKeyRange:x.IDBKeyRange},$=x.addons,this._dbSchema={},this._versions=[],this._storeNames=[],this._allTables={},this.idbdb=null,this._novip=this;var N,_,P,M,X,Z={dbOpenError:null,isBeingOpened:!1,onReadyBeingFired:null,openComplete:!1,dbReadyResolve:z,dbReadyPromise:null,cancelOpen:z,openCanceller:null,autoSchema:!0,PR1398_maxLoop:3,autoOpen:x.autoOpen};Z.dbReadyPromise=new je(function(G){Z.dbReadyResolve=G}),Z.openCanceller=new je(function(G,ae){Z.cancelOpen=ae}),this._state=Z,this.name=m,this.on=Rl(this,"populate","blocked","versionchange","close",{ready:[Ee,z]}),this.on.ready.subscribe=C(this.on.ready.subscribe,function(G){return function(ae,Y){yn.vip(function(){var ne,ie=k._state;ie.openComplete?(ie.dbOpenError||je.resolve().then(ae),Y&&G(ae)):ie.onReadyBeingFired?(ie.onReadyBeingFired.push(ae),Y&&G(ae)):(G(ae),ne=k,Y||G(function J(){ne.on.ready.unsubscribe(ae),ne.on.ready.unsubscribe(J)}))})}}),this.Collection=(N=this,Dl(FE.prototype,function(ce,J){this.db=N;var Y=lw,ne=null;if(J)try{Y=J()}catch(fe){ne=fe}var ie=ce._ctx,J=ie.table,ce=J.hook.reading.fire;this._ctx={table:J,index:ie.index,isPrimKey:!ie.index||J.schema.primKey.keyPath&&ie.index===J.schema.primKey.name,range:Y,keysOnly:!1,dir:"next",unique:"",algorithm:null,filter:null,replayFilter:null,justLimit:!0,isMatch:null,offset:0,limit:1/0,error:ne,or:ie.or,valueMapper:ce!==U?ce:null}})),this.Table=(_=this,Dl(dw.prototype,function(G,ae,Y){this.db=_,this._tx=Y,this.name=G,this.schema=ae,this.hook=_._allTables[G]?_._allTables[G].hook:Rl(null,{creating:[be,z],reading:[de,U],updating:[_e,z],deleting:[ve,z]})})),this.Transaction=(P=this,Dl(zE.prototype,function(G,ae,Y,ne,ie){var J=this;this.db=P,this.mode=G,this.storeNames=ae,this.schema=Y,this.chromeTransactionDurability=ne,this.idbtrans=null,this.on=Rl(this,"complete","error","abort"),this.parent=ie||null,this.active=!0,this._reculock=0,this._blockedFuncs=[],this._resolve=null,this._reject=null,this._waitingFor=null,this._waitingQueue=null,this._spinCount=0,this._completion=new je(function(ce,fe){J._resolve=ce,J._reject=fe}),this._completion.then(function(){J.active=!1,J.on.complete.fire()},function(ce){var fe=J.active;return J.active=!1,J.on.error.fire(ce),J.parent?J.parent._reject(ce):fe&&J.idbtrans&&J.idbtrans.abort(),gn(ce)})})),this.Version=(M=this,Dl(HE.prototype,function(G){this.db=M,this._cfg={version:G,storesSource:null,dbschema:{},tables:{},contentUpgrade:null}})),this.WhereClause=(X=this,Dl(yw.prototype,function(G,ae,Y){if(this.db=X,this._ctx={table:G,index:ae===":id"?null:ae,or:Y},this._cmp=this._ascending=Rt,this._descending=function(ne,ie){return Rt(ie,ne)},this._max=function(ne,ie){return 0<Rt(ne,ie)?ne:ie},this._min=function(ne,ie){return Rt(ne,ie)<0?ne:ie},this._IDBKeyRange=X._deps.IDBKeyRange,!this._IDBKeyRange)throw new $e.MissingAPI})),this.on("versionchange",function(G){0<G.newVersion?console.warn("Another connection wants to upgrade database '".concat(k.name,"'. Closing db now to resume the upgrade.")):console.warn("Another connection wants to delete database '".concat(k.name,"'. Closing db now to resume the delete request.")),k.close({disableAutoOpen:!1})}),this.on("blocked",function(G){!G.newVersion||G.newVersion<G.oldVersion?console.warn("Dexie.delete('".concat(k.name,"') was blocked")):console.warn("Upgrade '".concat(k.name,"' blocked by other connection holding version ").concat(G.oldVersion/10))}),this._maxKey=Pl(x.IDBKeyRange),this._createTransaction=function(G,ae,Y,ne){return new k.Transaction(G,ae,Y,k._options.chromeTransactionDurability,ne)},this._fireOnBlocked=function(G){k.on("blocked").fire(G),Sa.filter(function(ae){return ae.name===k.name&&ae!==k&&!ae._state.vcFired}).map(function(ae){return ae.on("versionchange").fire(G)})},this.use(XE),this.use(QE),this.use(YE),this.use(KE),this.use(qE);var re=new Proxy(this,{get:function(G,ae,Y){if(ae==="_vip")return!0;if(ae==="table")return function(ie){return kh(k.table(ie),re)};var ne=Reflect.get(G,ae,Y);return ne instanceof dw?kh(ne,re):ae==="tables"?ne.map(function(ie){return kh(ie,re)}):ae==="_createTransaction"?function(){return kh(ne.apply(this,arguments),re)}:ne}});this.vip=re,$.forEach(function(G){return G(k)})}var Ch,Zs=typeof Symbol<"u"&&"observable"in Symbol?Symbol.observable:"@@observable",e_=(Dm.prototype.subscribe=function(m,x,k){return this._subscribe(m&&typeof m!="function"?m:{next:m,error:x,complete:k})},Dm.prototype[Zs]=function(){return this},Dm);function Dm(m){this._subscribe=m}try{Ch={indexedDB:o.indexedDB||o.mozIndexedDB||o.webkitIndexedDB||o.msIndexedDB,IDBKeyRange:o.IDBKeyRange||o.webkitIDBKeyRange}}catch{Ch={indexedDB:null,IDBKeyRange:null}}function Rw(m){var x,k=!1,$=new e_(function(N){var _=we(m),P,M=!1,X={},Z={},re={get closed(){return M},unsubscribe:function(){M||(M=!0,P&&P.abort(),G&&zo.storagemutated.unsubscribe(Y))}};N.start&&N.start(re);var G=!1,ae=function(){return lm(ne)},Y=function(ie){xh(X,ie),Im(Z,X)&&ae()},ne=function(){var ie,J,ce;!M&&Ch.indexedDB&&(X={},ie={},P&&P.abort(),P=new AbortController,ce=function(fe){var me=va();try{_&&Ca();var ke=Oo(m,fe);return ke=_?ke.finally(Fo):ke}finally{me&&ka()}}(J={subscr:ie,signal:P.signal,requery:ae,querier:m,trans:null}),Promise.resolve(ce).then(function(fe){k=!0,x=fe,M||J.signal.aborted||(X={},function(me){for(var ke in me)if(h(me,ke))return;return 1}(Z=ie)||G||(zo(Ll,Y),G=!0),lm(function(){return!M&&N.next&&N.next(fe)}))},function(fe){k=!1,["DatabaseClosedError","AbortError"].includes(fe==null?void 0:fe.name)||M||lm(function(){M||N.error&&N.error(fe)})}))};return setTimeout(ae,0),re});return $.hasValue=function(){return k},$.getValue=function(){return x},$}var _i=ro;function Om(m){var x=Mo;try{Mo=!0,zo.storagemutated.fire(m),Tm(m,!0)}finally{Mo=x}}d(_i,s(s({},ht),{delete:function(m){return new _i(m,{addons:[]}).delete()},exists:function(m){return new _i(m,{addons:[]}).open().then(function(x){return x.close(),!0}).catch("NoSuchDatabaseError",function(){return!1})},getDatabaseNames:function(m){try{return x=_i.dependencies,k=x.indexedDB,x=x.IDBKeyRange,(km(k)?Promise.resolve(k.databases()).then(function($){return $.map(function(N){return N.name}).filter(function(N){return N!==ah})}):vm(k,x).toCollection().primaryKeys()).then(m)}catch{return gn(new $e.MissingAPI)}var x,k},defineClass:function(){return function(m){l(this,m)}},ignoreTransaction:function(m){return Ye.trans?$i(Ye.transless,m):m()},vip:Cm,async:function(m){return function(){try{var x=Em(m.apply(this,arguments));return x&&typeof x.then=="function"?x:je.resolve(x)}catch(k){return gn(k)}}},spawn:function(m,x,k){try{var $=Em(m.apply(k,x||[]));return $&&typeof $.then=="function"?$:je.resolve($)}catch(N){return gn(N)}},currentTransaction:{get:function(){return Ye.trans||null}},waitFor:function(m,x){return x=je.resolve(typeof m=="function"?_i.ignoreTransaction(m):m).timeout(x||6e4),Ye.trans?Ye.trans.waitFor(x):x},Promise:je,debug:{get:function(){return Ie},set:function(m){qe(m)}},derive:g,extend:l,props:d,override:C,Events:Rl,on:zo,liveQuery:Rw,extendObservabilitySet:xh,getByKeyPath:E,setByKeyPath:R,delByKeyPath:function(m,x){typeof x=="string"?R(m,x,void 0):"length"in x&&[].map.call(x,function(k){R(m,k,void 0)})},shallowClone:L,deepClone:q,getObjectDiff:_m,cmp:Rt,asap:I,minKey:-1/0,addons:[],connections:Sa,errnames:Ze,dependencies:Ch,cache:Ei,semVer:"4.0.11",version:"4.0.11".split(".").map(function(m){return parseInt(m)}).reduce(function(m,x,k){return m+x/Math.pow(10,2*k)})})),_i.maxKey=Pl(_i.dependencies.IDBKeyRange),typeof dispatchEvent<"u"&&typeof addEventListener<"u"&&(zo(Ll,function(m){Mo||(m=new CustomEvent(fm,{detail:m}),Mo=!0,dispatchEvent(m),Mo=!1)}),addEventListener(fm,function(m){m=m.detail,Mo||Om(m)}));var Na,Mo=!1,Dw=function(){};return typeof BroadcastChannel<"u"&&((Dw=function(){(Na=new BroadcastChannel(fm)).onmessage=function(m){return m.data&&Om(m.data)}})(),typeof Na.unref=="function"&&Na.unref(),zo(Ll,function(m){Mo||Na.postMessage(m)})),typeof addEventListener<"u"&&(addEventListener("pagehide",function(m){if(!ro.disableBfCache&&m.persisted){Ie&&console.debug("Dexie: handling persisted pagehide"),Na!=null&&Na.close();for(var x=0,k=Sa;x<k.length;x++)k[x].close({disableAutoOpen:!1})}}),addEventListener("pageshow",function(m){!ro.disableBfCache&&m.persisted&&(Ie&&console.debug("Dexie: handling persisted pageshow"),Dw(),Om({all:new Qn(-1/0,[[]])}))})),je.rejectionMapper=function(m,x){return!m||m instanceof Se||m instanceof TypeError||m instanceof SyntaxError||!m.name||!at[m.name]?m:(x=new at[m.name](x||m.message,m),"stack"in m&&f(x,"stack",{get:function(){return this.inner.stack}}),x)},qe(Ie),s(ro,Object.freeze({__proto__:null,Dexie:ro,liveQuery:Rw,Entity:uw,cmp:Rt,PropModification:Ol,replacePrefix:function(m,x){return new Ol({replacePrefix:[m,x]})},add:function(m){return new Ol({add:m})},remove:function(m){return new Ol({remove:m})},default:ro,RangeSet:Qn,mergeRanges:Bl,rangesOverlap:kw}),{default:ro}),ro})}(Sy)),Sy.exports}var xre=bre();const Iy=gre(xre),ok=Symbol.for("Dexie"),Kd=globalThis[ok]||(globalThis[ok]=Iy);if(Iy.semVer!==Kd.semVer)throw new Error(`Two different versions of Dexie loaded in the same app: ${Iy.semVer} and ${Kd.semVer}`);const{liveQuery:Epe,mergeRanges:_pe,rangesOverlap:Ape,RangeSet:Rpe,cmp:Dpe,Entity:Ope,PropModification:Fpe,replacePrefix:Lpe,add:Ppe,remove:zpe}=Kd;var wre="",vre="",kre="",Cre="",Sre="",Ire="",$re="",Nre="",Tre="",Ere="",_re="",Are="",Rre="",Dre="",Ore="",Fre="",Lre="",Pre="",zre="",Mre="",Bre="",Vre="",Wre="",Ure="",Gre="",Hre="",jre="",Kre="",qre="",Xre="",Yre="",Zre="",Jre="",Qre="",eoe="",toe="",noe="",soe="",roe="",ooe="",ioe="",aoe="",loe="",uoe="",coe="",hoe="",doe="",poe="",foe="",moe="",goe="",yoe="",boe="",xoe="",woe="",voe="",koe="",Coe="",Soe="",Ioe="",$oe="",Noe="",Toe="",Eoe="",_oe="",Aoe="",Roe="",Doe="",Ooe="",Foe="",Loe="",Poe="",zoe="",Moe="",Boe="",Voe="",Woe="",Uoe="",Goe="",Hoe="",joe="",Koe="",qoe="",Xoe="",Yoe="",Zoe="",Joe="",Qoe="",eie="",tie="",nie="",sie="",rie="",oie="",iie="",aie="",lie="",uie="",cie="",hie="",die="",pie="",fie="",mie="",gie="",yie="",bie="",xie="",wie="",vie="",kie="",Cie="",Sie="",Iie="",$ie="",Nie="",Tie="",Eie="",_ie="",Aie="",Rie="",Die="",Oie="",Fie="",Lie="",Pie="",zie="",Mie="",Bie="",Vie="",Wie="",Uie="",Gie="",Hie="",jie="",Kie="",qie="",Xie="",Yie="",Zie="",Jie="",Qie="",eae="",tae="",nae="",sae="",rae="",oae="",iae="",aae="",lae="",uae="",cae="",hae="",dae="",pae="",fae="",mae="",gae="",yae="",bae="",xae="",wae="",vae="",kae="",Cae="",Sae="",Iae="",$ae="",Nae="",Tae="",Eae="",_ae="",Aae="",Rae="",Dae="",Oae="",Fae="",Lae="",Pae="",zae="",Mae="",Bae="",Vae="",Wae="",Uae="",Gae="",Hae="",jae="",Kae="",qae="",Xae="",Yae="",Zae="",Jae="",Qae="",ele="",tle="",nle="",sle="",rle="",ole="",ile="",ale="",lle="",ule="",cle="",hle="",dle="",ple="",fle="",mle="",gle="",yle="",ble="",xle="",wle="",vle="",kle="",Cle="",Sle="",Ile="",$le="",Nle="",Tle="",Ele="",_le="",Ale="",Rle="",Dle="",Ole="",Fle="",Lle="",Ple="",zle="",Mle="",Ble="",Vle="",Wle="",Ule="",Gle="",Hle="",jle="",Kle="",qle="",Xle="",Yle="",Zle="",Jle="",Qle="",eue="",tue="",nue="",sue="",rue="",oue="",iue="",aue="",lue="",uue="",cue="",hue="",due="",pue="",fue="",mue="",gue="",yue="",bue="",xue="",wue="",vue="",kue="",Cue="",Sue="",Iue="",$ue="",Nue="",Tue="",Eue="",_ue="",Aue="",Rue="",Due="",Oue="",Fue="",Lue="",Pue="",zue="",Mue="",Bue="",Vue="",Wue="",Uue="",Gue="",Hue="",jue="",Kue="",que="",Xue="",Yue="",Zue="",Jue="",Que="",ece="",tce="",nce="",sce="",rce="",oce="",ice="",ace="",lce="",uce="",cce="",hce="",dce="",pce="",fce="",mce="",gce="",yce="",bce="",xce="",wce="",vce="",kce="",Cce="",Sce="",Ice="",$ce="",Nce="",Tce="",Ece="",_ce="",Ace="",Rce="",Dce="",Oce="",Fce="",Lce="",Pce="",zce="",Mce="",Bce="",Vce="",Wce="",Uce="",Gce="",Hce="",jce="",Kce="",qce="",Xce="",Yce="",Zce="",Jce="",Qce="",ehe="",the="",nhe="",she="",rhe="",ohe="",ihe="",ahe="",lhe="",uhe="",che="",hhe="",dhe="",phe="",fhe="",mhe="",ghe="",yhe="",bhe="",xhe="",whe="",vhe="",khe="",Che="",She="",Ihe="",$he="",Nhe="",The="",Ehe="",_he="",Ahe="",Rhe="",Dhe="",Ohe="",Fhe="",Lhe="",Phe="",zhe="",Mhe="",Bhe="",Vhe="",Whe="",Uhe="",Ghe="",Hhe="",jhe={a:wre,e:vre,ai:kre,ei:Cre,xi:Sre,yi:Ire,an:$re,han:Nre,ang:Tre,ao:Ere,wa:_re,yu:Are,niu:Rre,o:Dre,ba:Ore,pa:Fre,pi:Lre,bi:Pre,bai:zre,bo:Mre,bei:Bre,ban:Vre,pan:Wre,bin:Ure,bang:Gre,pang:Hre,beng:jre,bao:Kre,bu:qre,pu:Xre,mian:Yre,po:Zre,fan:Jre,fu:Qre,ben:eoe,feng:toe,bian:noe,pian:soe,zhen:roe,biao:ooe,piao:ioe,huo:aoe,bie:loe,min:uoe,fen:coe,bing:hoe,geng:doe,fang:poe,xian:foe,fou:moe,ca:goe,cha:yoe,cai:boe,can:xoe,shen:woe,cen:voe,san:koe,cang:Coe,zang:Soe,chen:Ioe,cao:$oe,ce:Noe,ze:Toe,zhai:Eoe,dao:_oe,ceng:Aoe,zha:Roe,chai:Doe,ci:Ooe,zi:Foe,cuo:Loe,chan:Poe,shan:zoe,zhan:Moe,xin:Boe,lian:Voe,chang:Woe,zhang:Uoe,chao:Goe,zhao:Hoe,zhou:joe,che:Koe,ju:qoe,cheng:Xoe,rong:Yoe,sheng:Zoe,deng:Joe,zhi:Qoe,zheng:eie,tang:tie,chi:nie,shi:sie,qi:rie,chuai:oie,tuo:iie,duo:aie,xue:lie,chong:uie,chou:cie,qiu:hie,xiu:die,chu:pie,tuan:fie,zhui:mie,chuan:gie,zhuan:yie,yuan:bie,cuan:xie,chuang:wie,zhuang:vie,chui:kie,chun:Cie,zhun:Sie,cu:Iie,dun:$ie,qu:Nie,xu:Tie,chuo:Eie,zu:_ie,ji:Aie,cong:Rie,zong:Die,cou:Oie,cui:Fie,wei:Lie,cun:Pie,zuo:zie,zuan:Mie,da:Bie,dai:Vie,tai:Wie,ta:Uie,dan:Gie,lu:Hie,tan:jie,ren:Kie,jie:qie,yan:Xie,dang:Yie,tao:Zie,tiao:Jie,te:Qie,de:eae,dei:tae,di:nae,ti:sae,tui:rae,you:oae,dian:iae,tian:aae,zhu:lae,nian:uae,diao:cae,yao:hae,die:dae,she:pae,ye:fae,xie:mae,zhe:gae,ding:yae,diu:bae,ting:xae,dong:wae,tong:vae,zhong:kae,dou:Cae,du:Sae,duan:Iae,dui:$ae,rui:Nae,yue:Tae,tun:Eae,hui:_ae,wu:Aae,ya:Rae,he:Dae,wo:Oae,en:Fae,n:Lae,er:Pae,fa:zae,quan:Mae,fei:Bae,pei:Vae,ping:Wae,fo:Uae,hu:Gae,ga:Hae,ge:jae,ha:Kae,xia:qae,gai:Xae,hai:Yae,gan:Zae,gang:Jae,jiang:Qae,hang:ele,gong:tle,hong:nle,guang:sle,qiong:rle,gao:ole,hao:ile,li:ale,jia:lle,luo:ule,ke:cle,qia:hle,gei:dle,gen:ple,hen:fle,gou:mle,kou:gle,gu:yle,pai:ble,gua:xle,tou:wle,guai:vle,kuai:kle,guan:Cle,wan:Sle,ne:Ile,gui:$le,jun:Nle,jiong:Tle,jue:Ele,gun:_le,hun:Ale,guo:Rle,hei:Dle,kan:Ole,heng:Fle,mo:Lle,peng:Ple,hou:zle,hua:Mle,huai:Ble,huan:Vle,xun:Wle,huang:Ule,nai:Gle,luan:Hle,qie:jle,jian:Kle,nan:qle,qian:Xle,qiang:Yle,xiang:Zle,jiao:Jle,zhuo:Qle,qiao:eue,xiao:tue,si:nue,kai:sue,jin:rue,qin:oue,jing:iue,ying:aue,jiu:lue,zui:uue,juan:cue,suan:hue,yun:due,qun:pue,ka:fue,kang:mue,keng:gue,kao:yue,ken:bue,yin:xue,kong:wue,ku:vue,kua:kue,kui:Cue,kuan:Sue,kuang:Iue,que:$ue,kun:Nue,kuo:Tue,la:Eue,lai:_ue,lan:Aue,lin:Rue,lang:Due,liang:Oue,lao:Fue,mu:Lue,le:Pue,lei:zue,sui:Mue,lie:Bue,leng:Vue,ling:Wue,lia:Uue,liao:Gue,liu:Hue,lun:jue,lv:Kue,lou:que,mao:Xue,long:Yue,nong:Zue,shuang:Jue,shu:Que,shuai:ece,lve:tce,ma:nce,me:sce,mai:rce,man:oce,mi:ice,men:ace,mang:lce,meng:uce,miao:cce,mou:hce,miu:dce,mei:pce,wen:fce,mie:mce,ming:gce,na:yce,nei:bce,nuo:xce,ruo:wce,nang:vce,nao:kce,ni:Cce,nen:Sce,neng:Ice,nin:$ce,niao:Nce,nie:Tce,niang:Ece,ning:_ce,nu:Ace,nv:Rce,ru:Dce,nuan:Oce,nve:Fce,re:Lce,ou:Pce,pao:zce,pou:Mce,pen:Bce,pie:Vce,pin:Wce,se:Uce,qing:Gce,zan:Hce,shao:jce,sao:Kce,sha:qce,xuan:Xce,ran:Yce,rang:Zce,rao:Jce,reng:Qce,ri:ehe,rou:the,ruan:nhe,run:she,sa:rhe,suo:ohe,sai:ihe,shui:ahe,sang:lhe,sen:uhe,seng:che,shai:hhe,shang:dhe,xing:phe,shou:fhe,shuo:mhe,su:ghe,shua:yhe,shuan:bhe,shun:xhe,song:whe,sou:vhe,sun:khe,teng:Che,tie:She,tu:Ihe,wai:$he,wang:Nhe,weng:The,zhua:Ehe,yang:_he,xiong:Ahe,yo:Rhe,yong:Dhe,za:Ohe,zai:Fhe,zao:Lhe,zei:Phe,zen:zhe,zeng:Mhe,zhei:Bhe,zou:Vhe,zhuai:Whe,zun:Uhe,dia:Ghe,nou:Hhe};const Khe=5;var qhe=class{constructor(){jn(this,"currentInput",""),jn(this,"candidates",[]),jn(this,"db"),jn(this,"pinyinDict",jhe),jn(this,"pinyinCharTable"),jn(this,"initializationPromise"),this.db=new Kd("PinyinCharDB"),this.db.version(1).stores({pinyinCharEntries:"++id, &[pinyin+char], pinyin, char, weight"}),this.pinyinCharTable=this.db.table("pinyinCharEntries"),this.initializationPromise=this.initializeDatabase()}async initializeDatabase(){try{if(await this.pinyinCharTable.count()===0){const n=[];for(const[e,t]of Object.entries(this.pinyinDict))for(const s of t.split(""))n.push({pinyin:e,char:s,weight:1});await this.pinyinCharTable.bulkAdd(n)}}catch(n){throw console.error(" PinyinCharDB :",n),n}}async processInput(n){if(await this.initializationPromise,this.currentInput=n.toLowerCase(),this.candidates=[],!this.currentInput)return[];const e=await this.pinyinCharTable.where("pinyin").startsWith(this.currentInput).toArray(),t=(s,r)=>{const o=s.pinyin===r,i=s.weight>1;return o&&i?1:!o&&i?2:o&&!i?3:!o&&!i?4:5};return e.sort((s,r)=>{const o=t(s,this.currentInput),i=t(r,this.currentInput);return o!==i?o-i:r.weight!==s.weight?r.weight-s.weight:s.id-r.id}),this.candidates=e.map(s=>s.char),this.candidates=[...new Set(this.candidates)],this.candidates}async selectCandidate(n){var e,t,s;if(await this.initializationPromise,!this.currentInput)return;let r=this.currentInput;for(const i of Object.keys(this.pinyinDict))if(i.startsWith(this.currentInput)&&this.pinyinDict[i].includes(n))if(i.length>r.length||i===this.currentInput){if(r=i,(e=this.pinyinDict[this.currentInput])!=null&&e.includes(n)&&this.currentInput===i)break}else r===this.currentInput&&(t=this.pinyinDict[i])!=null&&t.includes(n)&&(r=i);if(!((s=this.pinyinDict[r])!=null&&s.includes(n))){for(const i of Object.keys(this.pinyinDict))if(this.pinyinDict[i].includes(n)){if(i.startsWith(this.currentInput)){r=i;break}r===this.currentInput&&(r=i)}}const o=await this.pinyinCharTable.where({pinyin:r,char:n}).first();if(o&&o.id!==void 0){const i=Math.min((o.weight||0)+1,Khe);await this.pinyinCharTable.update(o.id,{weight:i})}else this.pinyinDict[r]?await this.pinyinCharTable.add({pinyin:r,char:n,weight:1}):console.warn(` ${n}  ${r} `);this.clear()}clear(){this.currentInput="",this.candidates=[]}getCurrentInput(){return this.currentInput}getCandidates(){return this.candidates}},Xhe=class{constructor(n,e={}){jn(this,"canvas"),jn(this,"ctx"),jn(this,"lastX",0),jn(this,"lastY",0),jn(this,"strokeData",[]),jn(this,"clearTimerId",null),jn(this,"isDrawing",!1),jn(this,"options"),jn(this,"handleStart",s=>{s.preventDefault(),this.isDrawing=!0;const{offsetX:r,offsetY:o}=this.getEventCoordinates(s);this.startDrawing(r,o),this.resetClearTimer()}),jn(this,"handleMove",s=>{if(!this.isDrawing)return;s.preventDefault();const{offsetX:r,offsetY:o}=this.getEventCoordinates(s);this.draw(r,o),this.resetClearTimer()}),jn(this,"handleEnd",s=>{this.isDrawing&&(s.preventDefault(),this.isDrawing=!1,this.endStroke(),this.startClearTimer(),this.options.onDrawEnd&&this.options.onDrawEnd())}),this.canvas=n,this.options={clearDelay:1e3,...e};const t=this.canvas.getContext("2d");if(!t)throw new Error("Failed to get 2D rendering context");this.ctx=t,this.setupCanvas(),this.attachEvents()}setupCanvas(){this.ctx.lineJoin="round",this.ctx.lineCap="round",this.ctx.lineWidth=3,this.ctx.strokeStyle="#000",this.clearCanvas(),this.drawGrid()}drawGrid(){const n=this.canvas.width,e=this.canvas.height;this.ctx.save(),this.ctx.strokeStyle="#ddd",this.ctx.lineWidth=1,this.ctx.setLineDash([3,3]),this.ctx.beginPath(),this.ctx.moveTo(0,e/2),this.ctx.lineTo(n,e/2),this.ctx.moveTo(n/2,0),this.ctx.lineTo(n/2,e),this.ctx.stroke(),this.ctx.setLineDash([]),this.ctx.beginPath(),this.ctx.rect(0,0,n,e),this.ctx.stroke(),this.ctx.restore()}clearCanvas(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),this.drawGrid(),this.strokeData=[],this.resetClearTimer()}startDrawing(n,e){this.lastX=n,this.lastY=e,this.ctx.strokeStyle="#000",this.ctx.lineWidth=3,this.ctx.setLineDash([]),this.strokeData.push(n,e,0)}draw(n,e){this.ctx.beginPath(),this.ctx.moveTo(this.lastX,this.lastY),this.ctx.lineTo(n,e),this.ctx.stroke(),this.lastX=n,this.lastY=e,this.strokeData.push(n,e,0)}endStroke(){this.strokeData.length>=3&&(this.strokeData[this.strokeData.length-1]=1)}getStrokeData(){return this.strokeData}resetClearTimer(){this.clearTimerId&&(window.clearTimeout(this.clearTimerId),this.clearTimerId=null)}startClearTimer(){this.resetClearTimer(),this.clearTimerId=window.setTimeout(()=>{this.clearCanvas(),this.clearTimerId=null},this.options.clearDelay)}getEventCoordinates(n){if(n instanceof MouseEvent)return{offsetX:n.offsetX,offsetY:n.offsetY};{const e=n.touches[0]||n.changedTouches[0],t=n.target.getBoundingClientRect();return{offsetX:e.clientX-t.left,offsetY:e.clientY-t.top}}}attachEvents(){this.canvas.addEventListener("mousedown",this.handleStart),this.canvas.addEventListener("mousemove",this.handleMove),this.canvas.addEventListener("mouseup",this.handleEnd),this.canvas.addEventListener("mouseleave",this.handleEnd),this.canvas.addEventListener("touchstart",this.handleStart,{passive:!1}),this.canvas.addEventListener("touchmove",this.handleMove,{passive:!1}),this.canvas.addEventListener("touchend",this.handleEnd),this.canvas.addEventListener("touchcancel",this.handleEnd)}detachEvents(){this.canvas.removeEventListener("mousedown",this.handleStart),this.canvas.removeEventListener("mousemove",this.handleMove),this.canvas.removeEventListener("mouseup",this.handleEnd),this.canvas.removeEventListener("mouseleave",this.handleEnd),this.canvas.removeEventListener("touchstart",this.handleStart),this.canvas.removeEventListener("touchmove",this.handleMove),this.canvas.removeEventListener("touchend",this.handleEnd),this.canvas.removeEventListener("touchcancel",this.handleEnd)}destroy(){this.detachEvents(),this.resetClearTimer()}getCanvas(){return this.canvas}getContext(){return this.ctx}};function Yhe(n,e,t){if(!n||!e||t==="static")return null;let s,r;if(t==="bottom")s=window.innerHeight-e.offsetHeight,r=0;else{const o=n.getBoundingClientRect(),i=e.offsetWidth;s=o.bottom+window.scrollY,r=o.left+window.scrollX+o.width/2-i/2;const a=window.innerWidth;r+i>a&&(r=a-i-10),r<10&&(r=10)}return{top:`${s}px`,left:`${r}px`}}function ik(n){if(!n)return!1;if(n.tagName==="TEXTAREA")return!0;if(n.tagName==="INPUT"){const e=(n.type||"text").toLowerCase();return!["checkbox","radio","button","submit","reset","file","image","range","color","hidden","date","datetime-local","month","week","time"].includes(e)}return!1}function Zhe(n,e,t){n.value=e,tde(n,t),n.dispatchEvent(new Event("input",{bubbles:!0}))}function Jhe(n,e,t,s=""){return n.slice(0,e)+s+n.slice(e+t)}function $E(n,e=""){const t=Number(n.getAttribute("maxlength"));let s=n.selectionStart??0;const r=n.selectionEnd??s;let o;if(e.length>0)o=r-s;else{const l=r-s;if(l>0)o=l;else if(s>0)o=1,s--;else return}if(e.length>0&&t&&n.value.length-o+e.length>t)return;const i=Jhe(n.value,s,o,e),a=s+e.length;Zhe(n,i,a)}function Qhe(n,e){$E(n,e)}function ede(n){$E(n)}function tde(n,e){n.selectionStart=e,n.selectionEnd=e}let NE=null;function nde(n){NE=n}function $y(){return NE}function sde(n=!1){const e=Yt(!1);async function t(){const r=$y();if(r)try{e.value=await r.initialize()}catch(o){console.error(":",o),e.value=!1}else console.warn(""),e.value=!1}async function s(){const r=$y();if(r&&e.value)try{await r.close(),e.value=!1}catch(o){console.error(":",o)}}return _l(()=>{n&&t()}),Jf(()=>{s()}),{recognizerInitialized:e}}const tw="data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%3e%3cpath%20d='M21,11H6.83L10.41,7.41L9,6L3,12L9,18L10.41,16.58L6.83,13H21V11Z'%20/%3e%3c/svg%3e",nw="data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%3e%3cpath%20d='M19,7V11H5.83L9.41,7.41L8,6L2,12L8,18L9.41,16.58L5.83,13H21V7H19Z'%20/%3e%3c/svg%3e",rde={class:"zhk-candidate-list"},ode=["onClick"],TE=_o({__name:"CandidateList",props:{candidates:{}},emits:["select"],setup(n,{emit:e}){const t=e;function s(r){t("select",r)}return(r,o)=>(dt(),St("div",rde,[(dt(!0),St(rn,null,qr(r.candidates,(i,a)=>(dt(),St("button",{key:`candidate-${a}`,class:"zhk-candidate-list__item",onClick:l=>s(i)},ks(i),9,ode))),128))]))}}),ide={class:"handwriting-input"},ade={class:"handwriting-buttons"},lde={class:"handwriting-canvas-container"},ude=["width","height"],cde={class:"handwriting-buttons"},hde=_o({__name:"HandwritingInput",emits:["key","exit"],setup(n,{emit:e}){const t=e,s=Yt(null),r=Yt(null);let o=null;const i=Yt(!1),{height:a}=IE(r);function l(){o&&o.clearCanvas()}function u(){s.value&&(o&&o.destroy(),o=new Xhe(s.value,{onDrawEnd:h}))}const c=Yt([]);async function h(){if(!o||o.getStrokeData().length===0||i.value)return;const p=$y();if(p){i.value=!0;try{const f=[...o.getStrokeData()],g=await p.recognize(f);c.value=g}catch(f){console.error(":",f)}finally{i.value=!1}}else console.warn("")}Jf(()=>{o&&o.destroy()}),Xr(a,()=>{s.value&&Yf(()=>{u()})}),_l(()=>{u()});function d(p){t("key",{key:p}),c.value=[],l()}return(p,f)=>(dt(),St("div",ide,[ur(TE,{candidates:c.value,onSelect:d},null,8,["candidates"]),Fe("div",{ref_key:"containerRef",ref:r,class:"handwriting-content"},[Fe("div",ade,[Fe("button",{class:"handwriting-btn handwriting-btn--function",onClick:f[0]||(f[0]=g=>t("key",{key:""}))},"  "),Fe("button",{class:"handwriting-btn handwriting-btn--function",onClick:f[1]||(f[1]=g=>t("key",{key:""}))},"  "),Fe("button",{class:"handwriting-btn handwriting-btn--function",onClick:f[2]||(f[2]=g=>t("key",{key:""}))},"  "),Fe("button",{class:"handwriting-btn handwriting-btn--function",onClick:f[3]||(f[3]=g=>t("key",{key:""}))},"  ")]),Fe("div",lde,[Fe("canvas",{ref_key:"canvasRef",ref:s,class:"handwriting-canvas",width:Cr(a),height:Cr(a)},null,8,ude)]),Fe("div",cde,[Fe("button",{class:"handwriting-btn handwriting-btn--function",onClick:f[4]||(f[4]=g=>t("key",{key:"delete",isControl:!0}))},f[8]||(f[8]=[Fe("img",{src:tw,alt:""},null,-1)])),Fe("button",{class:"handwriting-btn handwriting-btn--function",onClick:f[5]||(f[5]=g=>t("exit"))},"  "),Fe("button",{class:"handwriting-btn handwriting-btn--function",onClick:f[6]||(f[6]=g=>t("key",{key:""}))},"  "),Fe("button",{class:"handwriting-btn handwriting-btn--function",onClick:f[7]||(f[7]=g=>t("key",{key:"enter",isControl:!0}))},f[9]||(f[9]=[Fe("img",{src:nw,alt:""},null,-1)]))])],512)]))}}),dde="data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%3e%3cpath%20d='M6,18H18V16H6M12,8.41L16.59,13L18,11.58L12,5.58L6,11.58L7.41,13L12,8.41Z'%20/%3e%3c/svg%3e",EE="data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%3e%3cpath%20d='M3%2015H5V19H19V15H21V19C21%2020.1%2020.1%2021%2019%2021H5C3.9%2021%203%2020.1%203%2019V15Z'%20/%3e%3c/svg%3e",pde="data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%3e%3cpath%20d='M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z'%20/%3e%3c/svg%3e",fde={class:"zhk-selection"},mde={class:"zhk-selection__list"},gde=["onClick"],yde=_o({__name:"CandidateSelection",props:{candidates:{}},emits:["select","close"],setup(n,{emit:e}){const t=e;function s(o){t("select",o)}function r(){t("close")}return(o,i)=>(dt(),St("div",fde,[Fe("div",mde,[(dt(!0),St(rn,null,qr(o.candidates,(a,l)=>(dt(),St("div",{key:l,class:"zhk-selection__text",onClick:u=>s(a)},ks(a),9,gde))),128))]),Fe("div",{class:"zhk-selection__func"},[Fe("button",{class:"zhk-selection__func-btn",onClick:r},"  ")])]))}}),bde={class:"zhk-candidate"},xde={class:"zhk-candidate__container"},wde={key:0,class:"zhk-candidate__pinyin"},vde={class:"zhk-candidate__bottom-container"},kde=_o({__name:"CandidateBar",props:{modelValue:{required:!0},modelModifiers:{}},emits:by(["key","input"],["update:modelValue"]),setup(n,{emit:e}){const t=e,s=uE(n,"modelValue"),r=new qhe,o=Yt([]);J0(async()=>{o.value=await r.processInput(s.value)});const i=Cs(()=>o.value.slice(0,30)),a=Yt(!1);function l(u){r.selectCandidate(u),t("input",u),s.value="",a.value=!1}return(u,c)=>(dt(),St("div",bde,[Fe("div",xde,[s.value?(dt(),St("div",wde,ks(s.value),1)):qi("",!0),Fe("div",vde,[o.value.length>0?(dt(),Go(TE,{key:0,candidates:i.value,onSelect:l},null,8,["candidates"])):qi("",!0),o.value.length>0?(dt(),St("button",{key:1,class:"zhk-candidate__more",onClick:c[0]||(c[0]=h=>a.value=!0)},c[2]||(c[2]=[Fe("img",{src:pde,alt:""},null,-1)]))):qi("",!0)])]),Fr(ur(yde,{candidates:o.value,onSelect:l,onClose:c[1]||(c[1]=h=>a.value=!1)},null,8,["candidates"]),[[vE,a.value]])]))}}),Cde={class:"zhk-base"},Sde={class:"zhk-base__row"},Ide=["onClick"],$de=["disabled"],Nde={key:1,src:dde,class:"zhk-base__key-icon",alt:"Shift"},Tde=["onClick"],Ede={class:"zhk-base__row"},_de={class:"zhk-base__toggle-main"},Ade={class:"zhk-base__toggle-sub"},Rde=_o({__name:"KeyboardBase",props:by({recognizerInitialized:{type:Boolean},enableHandwriting:{type:Boolean}},{modelValue:{default:"en"},modelModifiers:{}}),emits:by(["key"],["update:modelValue"]),setup(n,{emit:e}){const t=n,s=e,r=uE(n,"modelValue"),o=Yt(!1),i=Cs(()=>r.value==="zh"),a=Cs(()=>i.value?!0:o.value);function l(v,I=!1){s("key",{key:v,isControl:I})}function u(){i.value?r.value="hand":o.value=!o.value}function c(){r.value="num"}function h(){r.value="symbol"}const d=["1","2","3","4","5","6","7","8","9","0"],p=[["q","w","e","r","t","y","u","i","o","p"],["a","s","d","f","g","h","j","k","l"],["z","x","c","v","b","n","m"]],f=Yt("");function g(){if(r.value==="zh"&&f.value){f.value=f.value.slice(0,-1);return}l("delete",!0)}function y(v){if(r.value==="zh"){f.value+=v;return}const I=o.value?v.toUpperCase():v;l(I)}function b(){r.value=r.value==="zh"?"en":"zh"}const w=Cs(()=>t.enableHandwriting?t.recognizerInitialized?"":"...":"-"),C=Cs(()=>!t.enableHandwriting||!t.recognizerInitialized);return(v,I)=>(dt(),St("div",Cde,[Fe("div",Sde,[r.value==="zh"?(dt(),Go(kde,{key:0,modelValue:f.value,"onUpdate:modelValue":I[0]||(I[0]=E=>f.value=E),onInput:I[1]||(I[1]=E=>l(E,!1))},null,8,["modelValue"])):(dt(),St(rn,{key:1},qr(d,(E,R)=>Fe("button",{key:`number-${R}`,class:"zhk-base__key zhk-base__key--letter",onClick:L=>y(E)},ks(E),9,Ide)),64))]),(dt(),St(rn,null,qr(p,(E,R)=>Fe("div",{key:`row-${R}`,class:"zhk-base__row"},[R===2?(dt(),St("button",{key:0,class:Qo(["zhk-base__key zhk-base__key--function zhk-base__key--shift",{"zhk-base__key--active":!i.value&&o.value,"zhk-base__key--disabled":i.value&&C.value}]),disabled:i.value&&C.value,onClick:u},[i.value?(dt(),St(rn,{key:0},[Ud(ks(w.value),1)],64)):(dt(),St("img",Nde))],10,$de)):qi("",!0),(dt(!0),St(rn,null,qr(E,(L,D)=>(dt(),St("button",{key:`key-${R}-${D}`,class:"zhk-base__key zhk-base__key--letter",onClick:F=>y(L)},ks(a.value?L.toUpperCase():L),9,Tde))),128)),R===2?(dt(),St("button",{key:1,class:"zhk-base__key zhk-base__key--function zhk-base__key--delete",onClick:I[2]||(I[2]=()=>g())},I[7]||(I[7]=[Fe("img",{src:tw,class:"zhk-base__key-icon",alt:"Delete"},null,-1)]))):qi("",!0)])),64)),Fe("div",Ede,[Fe("button",{class:"zhk-base__key zhk-base__key--function",onClick:h},"  "),Fe("button",{class:"zhk-base__key zhk-base__key--function",onClick:c}," 123 "),Fe("button",{class:"zhk-base__key",onClick:I[3]||(I[3]=()=>l(","))},"  "),Fe("button",{class:"zhk-base__key zhk-base__key--space",onClick:I[4]||(I[4]=()=>l(" "))},I[8]||(I[8]=[Fe("img",{src:EE,class:"zhk-base__key-icon",alt:"Space"},null,-1)])),Fe("button",{class:"zhk-base__key",onClick:I[5]||(I[5]=()=>l(""))},"  "),Fe("button",{class:"zhk-base__key zhk-base__key--function",onClick:b},[Fe("span",_de,ks(r.value==="zh"?"":""),1),Fe("span",Ade,"/"+ks(r.value==="zh"?"":""),1)]),Fe("button",{class:"zhk-base__key zhk-base__key--function",onClick:I[6]||(I[6]=()=>l("enter",!0))},I[9]||(I[9]=[Fe("img",{src:nw,class:"zhk-base__key-icon",alt:"Enter"},null,-1)]))])]))}}),Dde={class:"num-keyboard"},Ode={class:"num-keyboard__container"},Fde={class:"num-keyboard__left"},Lde={class:"num-keyboard__rows"},Pde=["onClick"],zde={key:1,src:EE,class:"zhk-base__key-icon",alt:"Space"},Mde={class:"num-keyboard__right"},Bde=["onClick"],Vde=["src","alt"],Wde={key:1},Ude=_o({__name:"NumericKeyboard",emits:["key","exit"],setup(n,{emit:e}){const t=e,s=[["1","2","3"],["4","5","6"],["7","8","9"],["back","0","space"]],r=[{key:"delete",icon:tw,text:"",alt:"Delete"},{key:".",icon:"",text:".",alt:"."},{key:"@",icon:"",text:"@",alt:"@"},{key:"enter",icon:nw,text:"",alt:"Enter"}];function o(l){t("key",{key:l})}function i(l,u=!0){t("key",{key:l,isControl:u})}function a(){t("exit")}return(l,u)=>(dt(),St("div",Dde,[Fe("div",Ode,[Fe("div",Fde,[Fe("div",Lde,[(dt(),St(rn,null,qr(s,(c,h)=>Fe("div",{key:`row-${h}`,class:"num-keyboard__row"},[(dt(!0),St(rn,null,qr(c,(d,p)=>(dt(),St("button",{key:`key-${h}-${p}`,class:Qo(["num-keyboard__key",{"num-keyboard__key--back":d==="back","num-keyboard__key--space":d==="space"}]),onClick:f=>d==="back"?a():o(d==="space"?" ":d)},[d==="back"?(dt(),St(rn,{key:0},[Ud("  ")],64)):d==="space"?(dt(),St("img",zde)):(dt(),St(rn,{key:2},[Ud(ks(d),1)],64))],10,Pde))),128))])),64))])]),Fe("div",Mde,[(dt(),St(rn,null,qr(r,(c,h)=>Fe("button",{key:`func-${h}`,class:"num-keyboard__key num-keyboard__key--function",onClick:d=>c.key==="."||c.key==="@"?o(c.key):i(c.key)},[c.icon?(dt(),St("img",{key:0,src:c.icon,class:"num-keyboard__key-icon",alt:c.alt},null,8,Vde)):(dt(),St("span",Wde,ks(c.text),1))],8,Bde)),64))])])]))}}),Gde="data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%3e%3cpath%20d='M18,20V10H6V20H18M18,8A2,2%200%200,1%2020,10V20A2,2%200%200,1%2018,22H6C4.89,22%204,21.1%204,20V10A2,2%200%200,1%206,8H15V6A3,3%200%200,0%2012,3A3,3%200%200,0%209,6H7A5,5%200%200,1%2012,1A5,5%200%200,1%2017,6V8H18M12,17A2,2%200%200,1%2010,15A2,2%200%200,1%2012,13A2,2%200%200,1%2014,15A2,2%200%200,1%2012,17Z'%20/%3e%3c/svg%3e",Hde="data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%3e%3cpath%20d='M12,17C10.89,17%2010,16.1%2010,15C10,13.89%2010.89,13%2012,13A2,2%200%200,1%2014,15A2,2%200%200,1%2012,17M18,20V10H6V20H18M18,8A2,2%200%200,1%2020,10V20A2,2%200%200,1%2018,22H6C4.89,22%204,21.1%204,20V10C4,8.89%204.89,8%206,8H7V6A5,5%200%200,1%2012,1A5,5%200%200,1%2017,6V8H18M12,3A3,3%200%200,0%209,6V8H15V6A3,3%200%200,0%2012,3Z'%20/%3e%3c/svg%3e",jde={class:"symbol-keyboard"},Kde={class:"symbol-keyboard__content"},qde={class:"symbol-keyboard__functions"},Xde={class:"symbol-keyboard__lang-selector"},Yde={class:"symbol-keyboard__control-group"},Zde=["src"],Jde=["src"],Qde={class:"symbol-keyboard__symbols-container"},epe={class:"symbol-keyboard__symbols-grid"},tpe=["onClick"],npe="!@#$%^&*(){}[]<>/\\|:;\"',.,?+-=_~`",spe="",rpe=_o({__name:"SymbolKeyboard",emits:["key","exit"],setup(n,{emit:e}){const t=e,s=Yt("en"),r=Cs(()=>s.value==="zh"?spe:npe),o=Yt(!1);function i(c){t("key",{key:c}),o.value||t("exit")}function a(){t("exit")}function l(c){s.value=c}function u(){o.value=!o.value}return(c,h)=>(dt(),St("div",jde,[Fe("div",Kde,[Fe("div",qde,[Fe("div",Xde,[Fe("button",{class:Qo(["symbol-keyboard__lang-btn",{"symbol-keyboard__lang-btn--active":s.value==="zh"}]),onClick:h[0]||(h[0]=d=>l("zh"))},"  ",2),Fe("button",{class:Qo(["symbol-keyboard__lang-btn",{"symbol-keyboard__lang-btn--active":s.value==="en"}]),onClick:h[1]||(h[1]=d=>l("en"))},"  ",2)]),Fe("div",Yde,[Fe("button",{class:Qo(["symbol-keyboard__key symbol-keyboard__key--function symbol-keyboard__key--lock",{"symbol-keyboard__key--locked":o.value}]),onClick:u},[o.value?(dt(),St("img",{key:1,src:Cr(Hde),alt:"Lock closed"},null,8,Jde)):(dt(),St("img",{key:0,src:Cr(Gde),alt:"Lock open"},null,8,Zde))],2),Fe("button",{class:"symbol-keyboard__key symbol-keyboard__key--function symbol-keyboard__key--back",onClick:a},"  ")])]),Fe("div",Qde,[Fe("div",epe,[(dt(!0),St(rn,null,qr(r.value,(d,p)=>(dt(),St("button",{key:`key-${p}`,class:"symbol-keyboard__key",onClick:f=>i(d)},ks(d),9,tpe))),128))])])])]))}}),ope={key:0,class:"zhk__disabled-overlay"},ipe=_o({__name:"ZhKeyboard",props:{defaultMode:{default:"en"},enableHandwriting:{type:Boolean,default:!1},position:{default:"static"},disableWhenNoFocus:{type:Boolean,default:!0}},emits:["key"],setup(n,{emit:e}){const t=n,s=e,r=Yt(t.defaultMode||"en"),o=Yt(t.defaultMode||"en"),i=Yt([]),a=Yt(!1),l=Yt(null),u=Yt(null),{recognizerInitialized:c}=sde(t.enableHandwriting);Xr(r,(I,E)=>{I!==E&&(o.value=E)});const h=pre(),d=Cs(()=>h.value&&ik(h.value)?h.value:null),p=Cs(()=>t.position==="static"||!!(h.value&&ik(h.value))),{height:f}=IE(u);J0(()=>{if(d.value){const I=d.value.dataset.inputmode;I&&(r.value=I)}}),Xr([p,f,d],()=>{p.value&&f.value&&Yf(()=>{y()})});const g=Cs(()=>t.disableWhenNoFocus===!1?!1:!d.value);function y(){if(!f.value)return;const I=Yhe(d.value,u.value,t.position);l.value=I}jd(window,"scroll",y,{passive:!0}),jd(window,"resize",y,{passive:!0});function b(I){if(I.isControl){switch(I.key){case"delete":ede(d.value);break;case"more":a.value=!0;break}return}else w(I.key);s("key",I)}function w(I){Qhe(d.value,I)}function C(){r.value=o.value}function v(I){i.value=I}return(I,E)=>(dt(),Go(Ine,{to:"body",disabled:I.position==="static"},[Fr(Fe("div",gE(I.$attrs,{ref_key:"keyboardRef",ref:u,class:["zhk",{"zhk--floating":I.position==="float","zhk--bottom":I.position==="bottom","zhk--disabled":g.value}],style:{"--keyboard-height":`${Cr(f)}px`,...l.value},onMousedown:E[1]||(E[1]=qse(()=>{},["prevent"]))}),[g.value||!p.value||!Cr(f)?(dt(),St("div",ope,E[2]||(E[2]=[Fe("span",null,"",-1)]))):(dt(),St(rn,{key:1},[r.value==="hand"?(dt(),Go(hde,{key:0,onKey:b,onExit:C,onRecognize:v})):r.value==="num"?(dt(),Go(Ude,{key:1,onKey:b,onExit:C})):r.value==="symbol"?(dt(),Go(rpe,{key:2,onKey:b,onExit:C})):r.value==="en"||r.value==="zh"?(dt(),Go(Rde,{key:3,modelValue:r.value,"onUpdate:modelValue":E[0]||(E[0]=R=>r.value=R),"recognizer-initialized":Cr(c),"enable-handwriting":I.enableHandwriting,onKey:b},null,8,["modelValue","recognizer-initialized","enable-handwriting"])):qi("",!0)],64))],16),[[vE,p.value]])],8,["disabled"]))}}),ape={class:"root-container"},lpe={class:"container"},upe={class:"input-grid"},cpe={class:"input-container"},hpe={class:"input-container"},dpe={class:"input-container"},ppe={class:"input-container"},fpe={class:"controls"},mpe={class:"checkbox-container"},gpe={class:"checkbox-item"},ype={class:"position-container"},bpe={class:"radio-group"},xpe=["id","value"],wpe=["for"],vpe={class:"keyboard-wrapper"},kpe=_o({__name:"App",setup(n){const e=Yt(""),t=Yt(""),s=Yt(""),r=Yt(""),o=Yt(400),i=Yt(300),a=Yt("float"),l=Yt(!0),u={static:"",float:"",bottom:""};return _l(()=>{window.innerWidth<960&&(a.value="bottom")}),(c,h)=>(dt(),St("div",ape,[Fe("div",lpe,[h[14]||(h[14]=Fe("div",{class:"header"},[Fe("h1",null,"")],-1)),Fe("div",upe,[Fe("div",cpe,[h[8]||(h[8]=Fe("label",null,":",-1)),Fr(Fe("input",{"onUpdate:modelValue":h[0]||(h[0]=d=>e.value=d),type:"text","data-inputmode":"en",inputmode:"none",placeholder:""},null,512),[[Ra,e.value]])]),Fe("div",hpe,[h[9]||(h[9]=Fe("label",null,":",-1)),Fr(Fe("input",{"onUpdate:modelValue":h[1]||(h[1]=d=>t.value=d),type:"text","data-inputmode":"zh",inputmode:"none",placeholder:""},null,512),[[Ra,t.value]])]),Fe("div",dpe,[h[10]||(h[10]=Fe("label",null,":",-1)),Fr(Fe("input",{"onUpdate:modelValue":h[2]||(h[2]=d=>s.value=d),type:"text","data-inputmode":"hand",inputmode:"none",placeholder:""},null,512),[[Ra,s.value]])]),Fe("div",ppe,[h[11]||(h[11]=Fe("label",null,":",-1)),Fr(Fe("input",{"onUpdate:modelValue":h[3]||(h[3]=d=>r.value=d),type:"text","data-inputmode":"num",inputmode:"none",placeholder:""},null,512),[[Ra,r.value]])])]),Fe("div",fpe,[a.value!=="bottom"?(dt(),St(rn,{key:0},[Fe("label",null,": "+ks(o.value)+"px",1),Fr(Fe("input",{"onUpdate:modelValue":h[4]||(h[4]=d=>o.value=d),type:"range",min:"400",max:"1080",step:"10",class:"width-slider"},null,512),[[Ra,o.value]]),Fe("label",null,": "+ks(i.value)+"px",1),Fr(Fe("input",{"onUpdate:modelValue":h[5]||(h[5]=d=>i.value=d),type:"range",min:"300",max:"1000",step:"10",class:"width-slider"},null,512),[[Ra,i.value]])],64)):qi("",!0),Fe("div",mpe,[Fe("div",gpe,[Fr(Fe("input",{id:"disable-when-no-focus","onUpdate:modelValue":h[6]||(h[6]=d=>l.value=d),type:"checkbox"},null,512),[[Gse,l.value]]),h[12]||(h[12]=Fe("label",{for:"disable-when-no-focus"},"",-1))])]),Fe("div",ype,[h[13]||(h[13]=Fe("label",null,":",-1)),Fe("div",bpe,[(dt(),St(rn,null,qr(u,(d,p)=>Fe("div",{key:p,class:"radio-item"},[Fr(Fe("input",{id:`pos-${p}`,"onUpdate:modelValue":h[7]||(h[7]=f=>a.value=f),type:"radio",value:p,name:"position"},null,8,xpe),[[Hse,a.value]]),Fe("label",{for:`pos-${p}`},ks(d),9,wpe)])),64))])])])]),Fe("div",vpe,[ur(Cr(ipe),{position:a.value,style:jf(a.value==="bottom"?{width:"100%",height:"auto"}:{width:`${o.value}px`,height:`${i.value}px`}),"enable-handwriting":"","disable-when-no-focus":l.value},null,8,["position","style","disable-when-no-focus"])])]))}});nde(new _te({modelPath:"/models/handwrite/model.json",dictPath:"/models/dict.txt"}));Zse(kpe).mount("#app");
